Some
thoughts
about
tsearch
David
Anderson
Updated
February
Updated
June
fixing
a
typo
and
regularizing
line
lengths
Tsearch
was
defined
and
implemented
fairly
early
in
the
history
of
UNIX
but
I
don
t
know
exactly
when
The
earliest
documentation
I
have
is
from
the
edition
of
UNIX
System
V
Release
Programmer
s
Reference
Manual
It
is
useful
because
it
enables
one
to
make
a
searchable
tree
of
well
any
data
one
might
have
need
to
search
Tsearch
never
needs
to
understand
the
format
of
the
data
The
functions
defined
there
are
tsearch
tfind
tdelete
and
twalk
It
requires
careful
attention
to
understand
it
Note
the
difference
between
void
root
and
void
rootp
The
confusion
is
partly
due
to
the
interface
definition
Until
the
late
century
only
limited
attention
was
given
to
interface
design
By
the
late
century
it
seems
clear
that
any
newly
designed
tsearch
like
functionality
would
have
a
significantly
different
interface
An
example
of
an
improved
interface
is
the
GNU
Linux
function
hsearch_r
Making
the
return
value
a
small
integer
defining
what
the
function
actually
did
and
using
other
arguments
to
return
additional
values
as
necessary
significantly
simplifies
the
discussion
Here
though
we
are
talking
about
the
old
and
standard
interface
We
attempt
to
clarify
the
messy
parts
See
the
examples
provided
for
actual
code
The
functions
and
tables
of
tsearch
are
not
thread
safe
Nor
thread
aware
Any
access
to
one
of
tables
at
the
same
time
the
table
is
being
updated
will
lead
to
chaos
eventually
Any
table
tsearch
maintains
consists
of
records
of
undefined
meaning
the
definition
is
local
to
the
internals
content
each
record
of
which
contains
as
one
element
a
copy
of
a
KEY
pointer
In
the
following
I
freely
use
tsearch
for
dwarf_tsearch
etc
The
functionality
and
interfaces
are
identical
Further
reading
The
canonical
reference
for
binary
trees
and
the
algorithm
reference
for
most
of
the
tsearch
code
is
Donald
E
Knuth
The
Art
of
Computer
Programming
Volume
Second
Edition
Section
Binary
Tree
Searching
page
Chapter
Balanced
Trees
page
Algorithms
Fourth
Edition
Robert
Sedgewick
and
Kevin
Wayne
is
the
basis
for
the
red
black
tree
coding
Wikipedia
has
quite
a
few
entries
of
interest
http
en
wikipedia
org
wiki
Self
balancing_binary_search_tree
http
en
wikipedia
org
wiki
Tree_traversal
http
en
wikipedia
org
wiki
Redâ€“black_tree
are
just
a
few
After
implementing
tsearch
I
looked
briefly
at
some
other
projects
but
these
references
may
be
out
of
date
freecode
net
See
the
GNU
libavl
project
The
libavl
libary
is
a
GNU
project
in
C
with
each
tree
type
having
a
uniquely
named
but
consistent
set
of
interfaces
The
interface
design
is
much
more
sensible
than
Unix
TSEARCH
You
will
probably
find
it
in
most
any
Linux
distribution
The
tarfile
source
has
no
configure
step
and
the
Makefile
failed
for
me
ftp
ftp
gnu
org
pub
gnu
avl
avl
tar
gz
is
rather
old
but
shows
internal
evidence
of
last
being
updated
in
pdf
and
other
file
timestamps
in
the
tar
file
The
Makefile
fails
for
me
doing
plain
make
Doing
make
program
to
just
build
the
source
works
fine
The
interface
definitions
are
more
sensible
than
tsearch
rb_delete
returns
the
deleted
item
when
it
succeeds
for
example
freecode
net
See
the
libredblack
project
This
project
tarfile
was
last
updated
in
It
is
on
sourceforge
at
http
sourceforge
net
projects
redblacktree
Implemented
in
C
Configure
worked
version
but
the
make
step
failed
running
the
python
app
rbgen
due
to
the
presence
of
the
string
prefix
on
line
of
rbgen
Removing
that
one
line
of
python
commentary
from
Eric
Raymond
fixed
the
build
There
is
a
good
amount
of
C
define
magic
making
it
harder
to
read
the
source
than
one
might
expect
The
interface
definitions
are
more
sensible
than
tsearch
rb_delete
returns
the
deleted
item
when
it
succeeds
for
example
freecode
net
See
the
project
Template
based
B
Tree
Is
in
C
and
can
be
used
for
searches
which
are
file
or
memory
based
through
use
of
C
templates
by
the
implemenation
Have
not
attempted
to
build
it
tsearch
void
tsearch
const
void
key
void
rootp
int
compar
const
void
l
const
void
r
Our
terminology
comes
from
the
above
declaration
tsearch
returns
a
pointer
If
tsearch
fails
due
to
an
out
of
memory
or
internal
error
it
returns
NULL
Otherwise
it
returns
a
non
null
pointer
see
Return
value
below
KEY
First
we
will
define
KEY
as
it
is
ordinarily
used
KEY
is
a
pointer
to
an
object
you
define
and
initialize
The
object
must
remain
in
stable
storage
for
as
long
as
the
table
has
a
copy
of
the
KEY
pointing
to
the
object
Example
struct
mystruct
key_a
malloc
sizeof
struct
mystruct
initialize
key_a
my
data
to
fill
in
struct
void
r
tsearch
key_a
comparfunc
ROOTP
This
must
be
the
address
of
a
void
datum
Before
the
first
call
of
tsearch
the
value
of
rootp
must
be
NULL
set
by
you
somehow
The
contents
are
maintained
by
tsearch
thereafter
COMPAR
A
function
you
write
whose
argments
when
tsearch
internals
call
it
are
KEY
pointers
from
two
records
your
records
The
function
should
return
if
the
record
KEY
l
points
to
is
considered
less
than
the
recorda
KEY
r
points
to
Return
zero
if
the
values
are
considered
to
match
Return
otherwise
Example
int
comparefunc
const
void
l
const
void
r
struct
mystruct
lp
l
struct
mystruct
rp
r
if
lp
myv
rp
myv
return
if
lp
myv
rp
myv
return
return
Of
course
the
comparison
need
not
be
of
simple
values
it
could
involve
anything
This
is
just
a
simple
sketch
Return
value
If
tsearch
returns
NULL
something
went
wrong
There
was
insufficient
memory
or
an
internal
error
of
some
kind
Lets
call
the
KEY
passed
in
KEYa
Otherwise
tsearch
returns
a
pointer
to
a
KEY
for
this
object
Dereference
to
get
an
actual
KEY
a
pointer
to
your
object
Lets
call
this
dereferenced
KEY
key_deref
struct
mystruct
key_deref
struct
mystruct
r
if
KEYa
key_deref
then
KEYa
was
added
to
the
tree
Hence
the
tree
now
has
a
copy
of
the
value
of
key_a
so
we
must
not
free
it
else
KEYa
matched
a
record
in
the
tree
and
did
nothing
so
you
need
to
free
any
space
you
allocated
to
build
the
KEYa
for
this
tsearch
call
In
our
example
free
key_a
I
hope
the
above
clarifies
the
use
of
tsearch
somewhat
Tfind
void
find
const
void
key
void
rootp
int
compar
const
void
l
const
void
r
The
interfaces
are
the
same
but
the
return
value
is
in
contrast
with
tsearch
reasonably
clear
A
non
null
return
is
a
key
pointer
It
never
adds
a
new
record
it
just
tries
to
find
a
record
A
NULL
return
means
either
that
the
search
ed
for
record
did
not
exist
or
that
something
internal
went
wrong
or
perhaps
that
something
incorrect
was
detected
at
runtime
in
the
arguments
passed
in
On
return
you
must
free
the
key
you
passed
in
Tdelete
void
tdelete
const
void
key
void
rootp
int
compar
const
void
l
const
void
r
The
arguments
are
the
same
as
tsearch
tfind
but
the
return
value
is
a
bit
odd
If
something
goes
wrong
or
if
the
record
does
not
exist
it
returns
NULL
That
is
straightforward
If
the
record
is
deleted
tdelete
is
supposed
to
return
a
pointer
to
the
parent
of
the
deleted
record
The
content
of
the
deleted
record
is
NOT
deleted
The
assumption
implicit
here
is
that
key
is
the
real
record
as
found
by
tfind
for
example
so
by
freeing
key
you
complete
the
deletion
A
fake
key
that
matches
a
real
key
might
return
a
value
but
you
have
no
way
to
know
what
the
node
pointer
of
the
real
key
is
so
cannot
possibly
free
it
If
the
record
deleted
was
the
last
record
in
the
tree
a
NULL
is
returned
and
rootp
is
set
to
NULL
Thus
restoring
initial
conditions
of
an
empty
tree
If
the
record
deleted
was
the
root
of
the
records
in
the
tree
as
of
the
call
then
what
is
this
supposed
to
return?
No
available
documentation
suggests
an
answer
The
current
dwarf_tdelete
implementations
return
some
record
or
other
in
this
case
In
the
case
of
dwarf_tdelete
for
a
hash
tree
if
the
node
was
the
last
in
a
hash
chain
then
NULL
is
returned
ugly
but
it
is
difficult
to
figure
out
what
else
to
do
All
this
means
that
it
is
a
waste
of
time
to
inspect
the
return
value
from
tdelete
So
to
do
a
tdelete
and
do
any
necessary
memory
free
do
key
xxxx
t
tfind
key
compar_func
if
t
tdelete
t
compar_func
free
key
free
t
where
what
free
key
means
is
to
free
whatever
key
xxxx
allocated
Which
means
do
the
same
for
free
r
Of
course
if
your
keys
point
into
to
a
static
array
of
data
then
free
is
unnecessary
but
how
often
will
the
data
be
in
static
memory?
And
if
it
is
in
static
storage
why
do
any
free
at
all?
Tdestroy
void
tdestroy
void
root
void
free_node
void
key
This
frees
all
memory
the
tree
system
has
and
along
the
way
it
calls
free_node
for
each
node
in
the
tree
It
empties
the
tree
but
oddly
the
root
argument
is
a
simple
pointer
to
the
root
not
a
pointer
to
pointer
Hence
this
routine
can
free
the
tree
but
cannot
assign
a
NULL
to
the
root
So
you
should
do
root
after
calling
tdestroy
Twalk
void
twalk
const
void
root
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
On
each
visit
to
a
node
the
action
function
is
called
with
a
pointer
to
a
node
a
visit
code
of
preorder
postorder
endorder
or
leaf
and
a
depth
in
the
tree
Interior
nodes
will
be
visited
up
to
three
times
Tdump
void
tdump
const
void
rootp
char
keyprint
const
void
key
const
char
msg
This
is
unique
to
the
dwarf_tsearch
library
It
prints
to
stdout
a
representation
of
the
tree
The
output
is
indented
one
space
per
level
and
ordered
such
that
turning
the
output
degrees
clockwise
shows
a
kind
of
picture
of
the
tree
structure
in
the
way
trees
are
normally
shown
in
books
It
may
be
of
slight
interest
for
debugging
trees
if
the
trees
are
not
too
large
The
msg
argument
is
just
a
character
string
of
interest
to
you
something
identifying
the
output
It
is
printed
once
and
otherwise
ignored
The
keyprint
argument
is
a
pointer
to
a
function
you
write
The
function
is
called
for
each
node
in
turn
It
should
return
a
pointer
to
a
string
with
whatever
data
from
the
passed
in
by
tdump
key
you
wish
to
show
Normally
the
pointer
returned
from
keyprint
should
be
pointing
to
a
static
area
so
there
is
no
issue
with
memory
leakage
to
worry
about
tdump
will
print
the
returned
string
immediately
and
will
not
refer
to
it
again
tsearch
use
using
pointers
declarations
left
out
The
struct
here
is
entirely
ours
tsearch
neither
knows
nor
cares
how
it
is
laid
out
mt
struct
example_tentry
mt
struct
example_tentry
calloc
sizeof
struct
example_tentry
mt
mt_key
keyvalue
mt
mt_data
datavalue
errno
tsearch
adds
an
entry
if
its
not
present
already
retval
dwarf_tsearch
mt
tree
mt_compare_func
if
retval
printf
FAIL
ENOMEM
in
search
on
d
give
up
insertrecsbypointer
n
i
exit
else
struct
example_tentry
re
re
struct
example_tentry
retval
if
re
mt
found
existing
entry
mt_free_func
mt
else
New
entry
mt
was
added
In
this
case
the
mt_compare_func
might
if
using
a
struct
look
like
int
mt_compare_func
const
void
l
const
void
r
const
struct
example_tentry
ml
l
const
struct
example_tentry
mr
r
If
the
key
were
a
string
one
could
use
strcmp
instead
of
the
comparisons
here
if
ml
mt_key
mr
mt_key
return
if
ml
mt_key
mr
mt_key
return
return
tsearch
use
using
values
declarations
left
out
void
mt
void
key
errno
tsearch
adds
an
entry
if
its
not
present
already
retval
dwarf_tsearch
mt
tree
value_compare_func
if
retval
printf
FAIL
ENOMEM
in
search
on
d
give
up
insertrecsbypointer
n
i
exit
else
successful
search
mt
might
have
been
added
by
the
call
or
maybe
it
was
already
in
the
tree
It
is
impossible
to
tell
which
in
this
special
use
of
mt
value
In
this
case
the
value_compare_func
might
look
like
int
value_compare_func
const
void
l
const
void
r
VALTYPE
lp
VALTYPE
l
VALTYPE
rp
VALTYPE
r
if
lp
rp
return
if
lp
rp
return
return
In
this
case
the
free_node
function
would
look
like
void
free_node
Do
nothing
In
this
case
there
is
never
any
free
calls
you
need
to
make
as
the
key
is
not
a
pointer
to
anything
If
I
were
designing
the
interfaces
in
I
might
do
as
follows
I
think
the
GNU
hsearch_r
interfaces
are
a
fine
approach
and
could
be
extended
to
tsearch
But
I
propose
something
slightly
different
define
TSE_OK
define
TSE_MEM
define
TSE_ERR
define
TSE_NOTFOUND
define
TSE_DUPLICATE
define
TSE_STOP
struct
tsearch_base
opaque
struct
content
defined
by
the
search
code
content
not
made
public
you
define
comparison
function
int
compare_func
void
l
void
r
you
define
free
function
int
free_func
void
n
None
of
the
proposed
interfaces
touch
errno
All
functions
return
TSE_OK
or
some
other
TSE
value
depending
on
the
call
Here
we
present
the
compare
func
and
free_func
just
once
quite
unlike
normal
tsearch
and
maybe
not
the
best
idea
int
tcreate
struct
tsearch_base
base
compare_func
free_func
allocate
a
struct_tsearch_base
record
and
puts
a
pointer
to
it
in
base
Records
the
compare
and
free_func
pointers
A
call
on
this
by
uses
is
a
requirement
returns
TSE_MEM
if
out
of
memory
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_OK
if
the
base
was
created
allocated
int
tsearch
void
key
struct
tsearch_base
base
returns
TSE_MEM
if
out
of
memory
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_DUPLICATE
if
new
record
not
added
that
key
in
tree
already
TSE_OK
if
new
record
added
int
tfind
void
key
struct
tsearch_base
base
void
foundrec
returns
TSE_OK
if
record
returned
in
foundrec
up
to
you
to
free
key
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_NOTFOUND
if
not
found
up
to
you
to
free
key
int
tdelete
void
key
struct
tsearch_base
base
void
keyout
If
successful
tdelete
deletes
the
record
key
identifies
and
returns
that
record
s
recorded
key
through
keyout
So
if
a
free
or
other
action
is
required
you
can
take
that
action
You
must
free
key
The
base
struct
tsearch_base
record
is
NOT
freed
it
remains
whether
the
tree
has
any
records
left
or
not
returns
TSE_NOTFOUND
if
key
not
found
TSE_OK
if
key
found
and
the
found
key
is
returned
via
keyout
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
int
twalk
struct
tsearch_base
base
int
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
The
action
function
returns
TSE_OK
normally
TSE_ERR
if
something
is
wrong
stop
the
walk
and
return
TSE_ERR
Or
TSE_STOP
a
soon
as
an
action
function
returns
TSE_STOP
twalk
returns
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_OK
if
all
is
well
TSE_STOP
if
an
action
function
call
returned
TSE_STOP
int
tsize
struct
tsearch_base
base
unsigned
long
count_out
Stores
a
count
of
the
records
currently
recorded
in
the
tree
in
count_out
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_OK
if
all
is
well
int
tdestroy
struct
tsearch_base
base
A
call
is
a
requirement
on
users
to
free
up
the
tree
space
Calls
free_func
on
each
node
in
the
tree
and
frees
all
tree
memory
and
does
base
NULL
to
reset
your
tree
pointer
returns
TSE_ERR
if
something
wrong
with
an
argument
or
an
internal
problem
TSE_OK
if
the
the
tree
is
destroyed
base
is
zeroed
the
following
line
may
be
removed
if
the
ff
ligature
works
on
your
machine
lg
set
up
heading
formats
ds
HF
ds
HP
nr
Hs
nr
Hb
Increment
body
point
size
S
Put
current
date
in
the
following
at
each
rev
ds
vE
Rev
June
ds
ds
ds
if
t
ds
Cw
f
CW
if
n
ds
Cw
fB
de
Cf
Place
every
other
arg
in
Cw
font
beginning
with
first
if
n
Cw
fP
if
n
Cw
fP
if
n
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
Cw
nr
Cl
set
P
one
lower
than
desired
start
of
printed
page
number
of
real
content
to
get
pdf
and
printed
numbers
to
agree
nr
P
SA
TL
A
Consumer
Library
Interface
to
DWARF
AF
AU
David
Anderson
PF
vE
nP
AS
This
document
describes
an
interface
to
a
library
of
functions
to
access
DWARF
debugging
information
entries
DWARF
line
number
information
and
other
DWARF2
information
P
There
are
a
few
sections
which
are
SGI
specific
those
are
clearly
identified
in
the
document
P
Starting
December
we
rearrange
the
pdf
that
GNU
groff
mm
gives
us
mm
is
not
exceptionally
flexible
using
tools
pdftotext
pdfseparate
and
pdfunite
from
the
poppler
utils
package
for
debian
ubuntu
We
hope
the
new
arrangement
with
the
table
of
contents
following
this
page
followed
by
the
library
documentation
itself
makes
the
document
easier
to
navigate
P
vE
AE
MT
H
INTRODUCTION
This
document
describes
an
interface
to
fIlibdwarf
fP
a
library
of
functions
to
provide
access
to
DWARF
debugging
information
records
DWARF
line
number
information
DWARF
address
range
and
global
names
information
weak
names
information
DWARF
frame
description
information
DWARF
static
function
names
DWARF
static
variables
and
DWARF
type
information
P
The
document
has
long
mentioned
the
Unix
International
Programming
Languages
Special
Interest
Group
PLSIG
under
whose
auspices
the
DWARF
committee
was
formed
around
Unix
International
was
disbanded
in
the
and
no
longer
exists
P
The
DWARF
committee
published
DWARF2
July
P
In
the
mid
this
document
and
the
library
it
describes
which
the
committee
never
endorsed
having
decided
not
to
endorse
or
approve
any
particular
library
interface
was
made
available
on
the
internet
by
Silicon
Graphics
Inc
P
In
the
DWARF
committee
began
an
affiliation
with
FreeStandards
org
In
FreeStandards
org
merged
with
The
Linux
Foundation
The
DWARF
committee
dropped
its
affiliation
with
FreeStandards
org
in
and
established
the
dwarfstd
org
website
See
http
www
dwarfstd
org
for
current
information
on
standardization
activities
and
a
copy
of
the
standard
H
Copyright
Copyright
Silicon
Graphics
Inc
Copyright
David
Anderson
Permission
is
hereby
granted
to
copy
or
republish
or
use
any
or
all
of
this
document
without
restriction
except
that
when
publishing
more
than
a
small
amount
of
the
document
please
acknowledge
Silicon
Graphics
Inc
and
David
Anderson
This
document
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
H
Purpose
and
Scope
The
purpose
of
this
document
is
to
document
a
library
of
functions
to
access
DWARF
debugging
information
There
is
no
effort
made
in
this
document
to
address
the
creation
of
these
records
as
those
issues
are
addressed
separately
see
A
Producer
Library
Interface
to
DWARF
P
Additionally
the
focus
of
this
document
is
the
functional
interface
and
as
such
implementation
as
well
as
optimization
issues
are
intentionally
ignored
H
Document
History
P
A
document
was
written
about
which
had
similar
layout
and
interfaces
Written
by
people
from
Hal
Corporation
That
document
described
a
library
for
reading
DWARF1
The
authors
distributed
paper
copies
to
the
committee
with
the
clearly
expressed
intent
to
propose
the
document
as
a
supported
interface
definition
The
committee
decided
not
to
pursue
a
library
definition
P
SGI
wrote
the
document
you
are
now
reading
in
with
a
similar
layout
and
content
and
organization
but
it
was
complete
document
rewrite
with
the
intent
to
read
DWARF2
the
DWARF
version
then
in
existence
The
intent
was
and
is
to
also
cover
future
revisions
of
DWARF
All
the
function
interfaces
were
changed
in
to
uniformly
return
a
simple
integer
success
code
see
DW_DLV_OK
etc
generally
following
the
recommendations
in
the
chapter
titled
Candy
Machine
Interfaces
of
Writing
Solid
Code
a
book
by
Steve
Maguire
published
by
Microsoft
Press
H
Definitions
DWARF
debugging
information
entries
DIEs
are
the
segments
of
information
placed
in
the
f
CW
debug_
fP
sections
by
compilers
assemblers
and
linkage
editors
that
in
conjunction
with
line
number
entries
are
necessary
for
symbolic
source
level
debugging
Refer
to
the
latest
fIDWARF
Debugging
Information
Format
fP
from
www
dwarfstd
org
for
a
more
complete
description
of
these
entries
P
This
document
adopts
all
the
terms
and
definitions
in
fIDWARF
Debugging
Information
Format
fP
versions
and
It
originally
focused
on
the
implementation
at
Silicon
Graphics
Inc
but
now
attempts
to
be
more
generally
useful
H
Overview
The
remaining
sections
of
this
document
describe
the
proposed
interface
to
f
CWlibdwarf
fP
first
by
describing
the
purpose
of
additional
types
defined
by
the
interface
followed
by
descriptions
of
the
available
operations
This
document
assumes
you
are
thoroughly
familiar
with
the
information
contained
in
the
fIDWARF
Debugging
Information
Format
fP
document
P
We
separate
the
functions
into
several
categories
to
emphasize
that
not
all
consumers
want
to
use
all
the
functions
We
call
the
categories
Debugger
Internal
level
High
level
and
Miscellaneous
not
because
one
is
more
important
than
another
but
as
a
way
of
making
the
rather
large
set
of
function
calls
easier
to
understand
P
Unless
otherwise
specified
all
functions
and
structures
should
be
taken
as
being
designed
for
Debugger
consumers
P
The
Debugger
Interface
of
this
library
is
intended
to
be
used
by
debuggers
The
interface
is
low
level
close
to
dwarf
but
suppresses
irrelevant
detail
A
debugger
will
want
to
absorb
all
of
some
sections
at
startup
and
will
want
to
see
little
or
nothing
of
some
sections
except
at
need
And
even
then
will
probably
want
to
absorb
only
the
information
in
a
single
compilation
unit
at
a
time
A
debugger
does
not
care
about
implementation
details
of
the
library
P
The
Internal
level
Interface
is
for
a
DWARF
prettyprinter
and
checker
A
thorough
prettyprinter
will
want
to
know
all
kinds
of
internal
things
like
actual
FORM
numbers
and
actual
offsets
so
it
can
check
for
appropriate
structure
in
the
DWARF
data
and
print
on
request
all
that
internal
information
for
human
users
and
libdwarf
authors
and
compiler
writers
Calls
in
this
interface
provide
data
a
debugger
does
not
normally
care
about
P
The
High
level
Interface
is
for
higher
level
access
it
is
not
really
a
high
level
interface
Programs
such
as
disassemblers
will
want
to
be
able
to
display
relevant
information
about
functions
and
line
numbers
without
having
to
invest
too
much
effort
in
looking
at
DWARF
P
The
miscellaneous
interface
is
just
what
is
left
over
the
error
handler
functions
P
The
following
is
a
brief
mention
of
the
changes
in
this
libdwarf
from
the
libdwarf
draft
for
DWARF
Version
and
recent
changes
H
Items
Changed
P
June
The
DW_DLC_READ
macro
as
well
as
the
other
DW_DLC
macros
has
been
deleted
from
libdwarf
h
the
access
argument
has
been
deleted
P
Many
obsolete
functions
deleted
June
P
If
dwarf_formudata
encounters
a
signed
form
it
checks
the
value
If
the
value
is
non
negative
it
returns
the
non
negative
value
otherwise
it
returns
an
error
This
means
success
calling
dwarf_formudata
does
not
prove
the
form
is
not
DW_FORM_sdata
June
P
Added
dwarf_get_FORM_CLASS_name
so
library
uses
can
print
a
form
class
value
usefully
February
P
Added
dwarf_decode_leb128
and
dwarf_decode_signed_leb128
so
library
users
can
access
these
library
internal
functions
P
Added
dwarf_macro_context_total_length
because
callers
of
dwarf_get_macro_context
_by_offset
sometimes
want
to
know
the
length
of
ops
header
P
The
description
of
dwarf_srcfiles
now
reflects
the
difference
in
line
table
handling
between
DWARF5
and
other
line
table
versions
If
using
dwarf_srcfiles
do
read
its
documentation
here
Section
page
in
this
version
P
Added
functions
dwarf_crc32
and
dwarf_basic_crc32
so
libdwarf
can
check
debuglink
build
id
CRC
values
P
Added
dwarf_get_ranges_b
so
clients
reading
DWARF4
split
dwarf
a
GNU
extension
can
get
the
final
offset
of
the
ranges
September
P
All
the
dwarf_init
and
dwarf_elf_init
calls
have
always
been
able
to
return
DW_DLV_ERROR
with
a
Dwarf_Error
pointer
returned
too
We
now
update
the
advice
on
dealing
with
this
situation
unifying
with
the
rest
of
libdwarf
errors
September
P
The
documentation
of
dwarf_init_path
was
basically
correct
but
omitted
meaningful
mention
of
the
dbg
argument
and
a
little
wrongly
described
the
error
argument
July
P
Added
dwarf_get_debug_sup
to
retrived
the
DWARF5
section
debug_sup
content
July
P
Added
new
functions
for
reading
debug_gnu_pubtypes
and
debug_gnu_pubnames
dwarf_get_gnu_index_head
dwarf_gnu_index_dealloc
dwarf_get_gnu_index_block
dwarf_get_gnu_index_block_entry
July
P
Added
new
functions
for
full
debug_loclists
access
dwarf_get_locdesc_entry_d
dwarf_get_loclist_head_basics
dwarf_get_loclist_head_kind
and
dwarf_loc_head_c_dealloc
For
accessing
certain
DWARF5
new
location
operators
for
example
DW_OP_const_type
as
well
as
all
other
operators
we
add
dwarf_get_location_op_value_d
Added
functions
allowing
simple
reporting
of
debug_loclists
without
involving
other
sections
dwarf_load_loclists
dwarf_get_loclist_context_basics
dwarf_get_loclist_lle
dwarf_get_loclist_offset_index_value
and
dwarf_get_loclist_raw_entry_detail
June
P
Added
new
functions
for
full
debug_rnglists
support
and
fixed
issues
with
DWARF5
debug_addr
index
FORMs
New
functions
for
general
use
dwarf_addr_form_is_indexed
dwarf_get_rnglists_entry_fields_a
dwarf_rnglists_get_rle_head
dwarf_dealloc_rnglists_head
New
functions
for
a
complete
listing
of
the
debug_rnglists
section
dwarf_load_rnglists
dwarf_get_rnglist_offset_index_value
dwarf_get_rnglist_context
dwarf_get_rnglist_head_basics
dwarf_get_rnglist_context_basics
dwarf_get_rnglist_rle
Also
added
new
functions
dwarf_dealloc_die
dwarf_dealloc_error
and
dwarf_dealloc_attribute
to
provide
type
safe
calls
for
deallocation
of
the
specific
data
types
May
P
What
was
historically
called
length_size
in
libdwarf
and
dwarfdump
is
actually
the
size
of
an
offset
or
in
DWARF2
and
For
readability
all
instances
of
length_size
are
being
converted
as
time
permits
to
offset_size
May
P
Added
a
new
function
dwarf_set_de_alloc_flag
which
allows
turning
off
of
libdwarf
internal
allocation
tracking
to
improve
libdwarf
performance
a
few
percent
which
only
really
matters
with
giant
DWARF
sections
The
downside
of
turning
off
the
flag
is
consumer
code
must
do
all
the
dwarf_dealloc
calls
itself
to
avoid
memory
leaks
March
P
Corrected
the
documentation
of
dwarf_diename
It
was
never
appropriate
to
use
dwarf_dealloc
on
the
string
pointer
returned
but
Up
till
now
this
document
said
such
a
call
was
required
March
P
Now
we
document
here
that
if
one
uses
dwarf_init_b
or
dwarf_init_path
that
the
function
dwarf_get_elf
cannot
succeed
as
there
is
no
longer
any
Elf
pointer
from
libelf
to
return
November
P
New
function
dwarf_gnu_debuglink
allow
callers
to
access
fields
that
GNU
compilers
create
and
use
to
link
an
executable
to
its
separate
DWARF
debugging
content
object
file
September
updated
October
P
dwarf_next_cu_header_d
and
the
other
earlier
versions
of
this
now
allow
a
null
in
place
of
a
pointer
for
next_cu_offset
dwarf_hipc_b
now
allows
a
null
in
place
of
the
return_form
and
or
return_class
arguments
Unless
you
know
a
sufficiently
recent
libdwarf
is
to
be
used
it
is
not
safe
to
pass
those
arguments
as
null
pointers
This
allowance
of
null
is
because
we
ve
become
aware
that
the
relevant
NetBSD
man
pages
on
these
functions
incorrectly
specified
that
null
was
allowed
April
P
The
new
non
libelf
reader
code
checks
elf
header
values
more
thoroughly
than
libelf
and
detects
corrupted
Elf
earlier
and
in
more
cases
than
libelf
Since
the
reports
of
elf
corruption
from
libdwarf
dwarfdump
are
not
detailed
we
suggest
one
use
an
object
dumper
to
check
the
object
file
in
question
Two
useful
object
dumpers
are
GNU
readelf
part
of
GNU
binutils
and
readelfobj
part
of
the
readelfobj
project
on
sourceforge
net
readelfobj
uses
essentially
the
same
algorithms
as
libdwarf
does
and
should
report
something
meaningful
April
P
Added
support
for
MacOS
dSYM
objects
and
PE
object
files
as
well
as
an
initialization
function
allowing
a
path
instead
of
a
Posix
Unix
fd
or
a
libelf
Elf
January
P
Added
a
libdwarf
interface
dwarf_errmsg_by_number
so
that
places
in
the
code
that
can
have
errors
but
do
not
want
the
Dwarf_Error
complexities
can
report
more
details
than
just
an
error
number
December
P
Now
Mach
o
dSYM
files
containing
dwarf
are
readable
by
libdwarf
and
their
DWARF
dumped
by
dwarfdump
There
are
no
new
options
or
choices
libdwarf
and
dwarfdump
notice
which
kind
of
object
they
are
processing
New
functions
added
to
libdwarf
h
dwarf_init_path_dSYM
dwarf_object_detector_path_b
and
dwarf_object_detector_fd
modified
June
P
P
Older
entries
removed
as
no
longer
very
relevant
H
Items
Removed
P
Dwarf_Type
was
removed
since
types
are
no
longer
special
P
dwarf_typeof
was
removed
since
types
are
no
longer
special
P
Dwarf_Ellist
was
removed
since
element
lists
no
longer
are
a
special
format
P
Dwarf_Bounds
was
removed
since
bounds
have
been
generalized
P
dwarf_nextdie
was
replaced
by
dwarf_next_cu_header
to
reflect
the
real
way
DWARF
is
organized
The
dwarf_nextdie
was
only
useful
for
getting
to
compilation
unit
beginnings
so
it
does
not
seem
harmful
to
remove
it
in
favor
of
a
more
direct
function
P
dwarf_childcnt
is
removed
on
grounds
that
no
good
use
was
apparent
P
dwarf_prevline
and
dwarf_nextline
were
removed
on
grounds
this
is
better
left
to
a
debugger
to
do
Similarly
dwarf_dieline
was
removed
P
dwarf_is1stline
was
removed
as
it
was
not
meaningful
for
the
revised
DWARF
line
operations
P
Any
libdwarf
implementation
might
well
decide
to
support
all
the
removed
functionality
and
to
retain
the
DWARF
Version
meanings
of
that
functionality
This
would
be
difficult
because
the
original
libdwarf
draft
specification
used
traditional
C
library
interfaces
which
confuse
the
values
returned
by
successful
calls
with
exceptional
conditions
like
failures
and
no
more
data
indications
H
Revision
History
VL
LI
June
Old
interfaces
have
been
removed
from
the
API
in
favor
of
new
ones
present
in
the
library
for
years
with
improved
functionality
The
new
ones
will
have
the
same
name
but
with
a
trailing
_a
or
_b
or
the
like
LI
September
A
new
approach
simpler
more
uniform
to
deal
with
a
failure
of
a
dwarf_init
or
dwarf_elf_init
call
is
described
in
Chapter
Improved
support
for
split
dwarf
Added
dwarf_get_ranges_b
LI
May
Adding
support
for
DWARF5
sections
debug_rnglists
and
debug_loclists
LI
March
Added
dwarf_set_de_alloc_flag
so
consumers
get
a
little
better
performance
from
libdwarf
At
a
price
See
the
description
a
bit
later
here
LI
January
Added
support
for
reading
DWARF
in
PE
object
files
LI
October
Added
support
for
reading
MacOS
dSYM
object
files
LI
Added
support
for
nearly
all
of
DWARF5
LI
July
Added
support
for
the
gdb_index
section
and
started
support
for
the
debug_cu_index
and
debug_tu_index
sections
LI
October
DWARF4
support
for
reading
debug_types
added
LI
March
Work
on
DWARF2
SGI
draft
begins
LI
June
The
function
returns
are
changed
to
return
an
error
success
code
only
LI
April
Support
for
DWARF3
consumer
operations
is
close
to
completion
LI
November
Added
various
new
functions
and
improved
error
checking
LI
March
Adding
support
for
DWARF5
split
dwarf
LE
H
Types
Definitions
H
General
Description
The
fIlibdwarf
h
fP
header
file
contains
typedefs
and
preprocessor
definitions
of
types
and
symbolic
names
used
to
reference
objects
of
fIlibdwarf
fP
The
types
defined
by
typedefs
contained
in
fIlibdwarf
h
fP
all
use
the
convention
of
adding
f
CWDwarf_
fP
as
a
prefix
and
can
be
placed
in
three
categories
BL
LI
Scalar
types
The
scalar
types
defined
in
fIlibdwarf
h
fP
are
defined
primarily
for
notational
convenience
and
identification
Depending
on
the
individual
definition
they
are
interpreted
as
a
value
a
pointer
or
as
a
flag
LI
Aggregate
types
Some
values
can
not
be
represented
by
a
single
scalar
type
they
must
be
represented
by
a
collection
of
or
as
a
union
of
scalar
and
or
aggregate
types
LI
Opaque
types
The
complete
definition
of
these
types
is
intentionally
omitted
their
use
is
as
handles
for
query
operations
which
will
yield
either
an
instance
of
another
opaque
type
to
be
used
in
another
query
or
an
instance
of
a
scalar
or
aggregate
type
which
is
the
actual
result
P
H
Scalar
Types
The
following
are
the
defined
by
fIlibdwarf
h
fP
DS
f
CW
typedef
int
Dwarf_Bool
typedef
unsigned
long
long
Dwarf_Off
typedef
unsigned
long
long
Dwarf_Unsigned
typedef
unsigned
short
Dwarf_Half
typedef
unsigned
char
Dwarf_Small
typedef
signed
long
long
Dwarf_Signed
typedef
unsigned
long
long
Dwarf_Addr
typedef
void
Dwarf_Ptr
typedef
void
Dwarf_Handler
Dwarf_Error
error
Dwarf_Ptr
errarg
DE
nr
aX
n
Fg
Dwarf_Ptr
is
an
address
for
use
by
the
host
program
calling
the
library
not
for
representing
pc
values
addresses
within
the
target
object
file
Dwarf_Addr
is
for
pc
values
within
the
target
object
file
The
sample
scalar
type
assignments
above
are
for
a
fIlibdwarf
h
fP
that
can
read
and
write
bit
or
bit
binaries
on
a
bit
or
bit
host
machine
The
types
must
be
defined
appropriately
for
each
implementation
of
libdwarf
A
description
of
these
scalar
types
in
the
SGI
MIPS
environment
is
given
in
Figure
n
aX
DS
TS
center
box
tab
lfB
lfB
lfB
lfB
l
c
c
l
NAME
SIZE
ALIGNMENT
PURPOSE
_
Dwarf_Bool
Boolean
states
Dwarf_Off
Unsigned
file
offset
Dwarf_Unsigned
Unsigned
large
integer
Dwarf_Half
Unsigned
medium
integer
Dwarf_Small
Unsigned
small
integer
Dwarf_Signed
Signed
large
integer
Dwarf_Addr
Program
address
target
program
Dwarf_Ptr
Dwarf
section
pointer
host
program
Dwarf_Handler
Pointer
to
error
handler
function
TE
FG
Scalar
Types
DE
H
Aggregate
Types
The
following
aggregate
types
are
defined
by
fIlibdwarf
h
fP
f
CWDwarf_Loc
fP
f
CWDwarf_Locdesc
fP
f
CWDwarf_Block
fP
f
CWDwarf_Frame_Op
fP
f
CWDwarf_Regtable
fP
f
CWDwarf_Regtable3
fP
While
most
of
f
CWlibdwarf
fP
acts
on
or
returns
simple
values
or
opaque
pointer
types
this
small
set
of
structures
seems
useful
Yet
at
the
same
time
these
public
structures
are
inflexible
as
any
change
in
format
or
content
breaks
binary
and
possibly
source
in
some
cases
compatibility
H
Location
Record
The
f
CWDwarf_Loc
fP
type
identifies
a
single
atom
of
a
location
description
or
a
location
expression
This
is
obsolete
and
should
not
be
used
though
it
works
adequately
for
DWARF2
DS
f
CWtypedef
struct
Dwarf_Small
lr_atom
Dwarf_Unsigned
lr_number
Dwarf_Unsigned
lr_number2
Dwarf_Unsigned
lr_offset
Dwarf_Loc
fP
DE
The
f
CWlr_atom
fP
identifies
the
atom
corresponding
to
the
f
CWDW_OP_
fP
definition
in
fIdwarf
h
fP
and
it
represents
the
operation
to
be
performed
in
order
to
locate
the
item
in
question
P
The
f
CWlr_number
fP
field
is
the
operand
to
be
used
in
the
calculation
specified
by
the
f
CWlr_atom
fP
field
not
all
atoms
use
this
field
Some
atom
operations
imply
signed
numbers
so
it
is
necessary
to
cast
this
to
a
f
CWDwarf_Signed
fP
type
for
those
operations
P
The
f
CWlr_number2
fP
field
is
the
second
operand
specified
by
the
f
CWlr_atom
fP
field
only
f
CWDW_OP_BREGX
fP
has
this
field
Some
atom
operations
imply
signed
numbers
so
it
may
be
necessary
to
cast
this
to
a
f
CWDwarf_Signed
fP
type
for
those
operations
P
For
a
f
CWDW_OP_implicit_value
fP
operator
the
f
CWlr_number2
fP
field
is
a
pointer
to
the
bytes
of
the
value
The
field
pointed
to
is
f
CWlr_number
fP
bytes
long
There
is
no
explicit
terminator
Do
not
attempt
to
f
CWfree
fP
the
bytes
which
f
CWlr_number2
fP
points
at
and
do
not
alter
those
bytes
The
pointer
value
remains
valid
till
the
open
Dwarf_Debug
is
closed
This
is
a
rather
ugly
use
of
a
host
integer
to
hold
a
pointer
You
will
normally
have
to
do
a
cast
operation
to
use
the
value
P
For
a
f
CWDW_OP_GNU_const_type
fP
operator
the
f
CWlr_number2
fP
field
is
a
pointer
to
a
block
with
an
initial
unsigned
byte
giving
the
number
of
bytes
following
followed
immediately
that
number
of
const
value
bytes
There
is
no
explicit
terminator
Do
not
attempt
to
f
CWfree
fP
the
bytes
which
f
CWlr_number2
fP
points
at
and
do
not
alter
those
bytes
The
pointer
value
remains
valid
till
the
open
Dwarf_Debug
is
closed
This
is
a
rather
ugly
use
of
a
host
integer
to
hold
a
pointer
You
will
normally
have
to
do
a
cast
operation
to
use
the
value
P
The
f
CWlr_offset
fP
field
is
the
byte
offset
within
the
block
the
location
record
came
from
of
the
atom
specified
by
the
f
CWlr_atom
fP
field
This
is
set
on
all
atoms
This
is
useful
for
operations
f
CWDW_OP_SKIP
fP
and
f
CWDW_OP_BRA
fP
H
Location
Description
This
is
obsolete
and
should
not
be
used
though
it
works
ok
for
DWARF2
The
f
CWDwarf_Locdesc
fP
type
represents
an
ordered
list
of
f
CWDwarf_Loc
fP
records
used
in
the
calculation
to
locate
an
item
Note
that
in
many
cases
the
location
can
only
be
calculated
at
runtime
of
the
associated
program
DS
f
CWtypedef
struct
Dwarf_Addr
ld_lopc
Dwarf_Addr
ld_hipc
Dwarf_Unsigned
ld_cents
Dwarf_Loc
ld_s
Dwarf_Locdesc
fP
DE
The
f
CWld_lopc
fP
and
f
CWld_hipc
fP
fields
provide
an
address
range
for
which
this
location
descriptor
is
valid
Both
of
these
fields
are
set
to
fIzero
fP
if
the
location
descriptor
is
valid
throughout
the
scope
of
the
item
it
is
associated
with
These
addresses
are
virtual
memory
addresses
not
offsets
from
something
The
virtual
memory
addresses
do
not
account
for
dso
movement
none
of
the
pc
values
from
libdwarf
do
that
it
is
up
to
the
consumer
to
do
that
P
The
f
CWld_cents
fP
field
contains
a
count
of
the
number
of
f
CWDwarf_Loc
fP
entries
pointed
to
by
the
f
CWld_s
fP
field
P
The
f
CWld_s
fP
field
points
to
an
array
of
f
CWDwarf_Loc
fP
records
H
Data
Block
SP
This
is
obsolete
and
should
not
be
used
though
it
works
ok
for
DWARF2
The
f
CWDwarf_Block
fP
type
is
used
to
contain
the
value
of
an
attribute
whose
form
is
either
f
CWDW_FORM_block1
fP
f
CWDW_FORM_block2
fP
f
CWDW_FORM_block4
fP
f
CWDW_FORM_block8
fP
or
f
CWDW_FORM_block
fP
Its
intended
use
is
to
deliver
the
value
for
an
attribute
of
any
of
these
forms
DS
f
CWtypedef
struct
Dwarf_Unsigned
bl_len
Dwarf_Ptr
bl_data
Dwarf_Small
bl_from_loclist
Dwarf_Unsigned
bl_section_offset
Dwarf_Block
fP
DE
P
The
f
CWbl_len
fP
field
contains
the
length
in
bytes
of
the
data
pointed
to
by
the
f
CWbl_data
fP
field
P
The
f
CWbl_data
fP
field
contains
a
pointer
to
the
uninterpreted
data
Since
we
use
a
f
CWDwarf_Ptr
fP
here
one
must
copy
the
pointer
to
some
other
type
typically
an
f
CWunsigned
char
fP
so
one
can
add
increments
to
index
through
the
data
The
data
pointed
to
by
f
CWbl_data
fP
is
not
necessarily
at
any
useful
alignment
H
Frame
Operation
Codes
DWARF
This
interface
is
adequate
for
DWARF2
but
not
entirely
suitable
for
DWARF3
or
later
A
new
functional
interface
is
needed
This
DWARF2
interface
is
not
sufficient
but
at
present
is
the
only
available
interface
P
See
also
the
section
Low
Level
Frame
Operations
below
P
The
DWARF2
f
CWDwarf_Frame_Op
fP
type
is
used
to
contain
the
data
of
a
single
instruction
of
an
instruction
sequence
of
low
level
information
from
the
section
containing
frame
information
This
is
ordinarily
used
by
Internal
level
Consumers
trying
to
print
everything
in
detail
DS
f
CWtypedef
struct
Dwarf_Small
fp_base_op
Dwarf_Small
fp_extended_op
Dwarf_Half
fp_register
Dwarf_Signed
fp_offset
Dwarf_Offset
fp_instr_offset
Dwarf_Frame_Op
DE
f
CWfp_base_op
fP
is
the
bit
basic
op
code
f
CWfp_extended_op
fP
is
the
bit
extended
opcode
if
f
CWfp_base_op
fP
indicated
there
was
an
extended
op
code
and
is
zero
otherwise
P
f
CWfp_register
fP
is
any
or
the
first
register
value
as
defined
in
the
f
CWCall
frame
instruction
encodings
fP
in
the
f
CWdwarf
fP
document
in
DWARF3
see
Figure
in
DWARF5
see
table
If
not
used
with
the
operation
it
is
P
f
CWfp_offset
fP
is
the
address
delta
offset
or
second
register
as
defined
in
the
f
CWCall
frame
instruction
encodings
fP
documentation
If
this
is
an
f
CWaddress
fP
then
the
value
should
be
cast
to
f
CW
Dwarf_Addr
fP
before
being
used
In
any
implementation
this
field
must
be
as
large
as
the
largest
of
Dwarf_Ptr
Dwarf_Signed
and
Dwarf_Addr
for
this
to
work
properly
If
not
used
with
the
op
it
is
If
the
fp_extended_op
is
f
CWDW_CFA_def_cfa
fP
or
f
CWDW_CFA_val_expression
fP
or
f
CWDW_CFA_expression
fP
then
f
CWfp_offset
fP
is
a
pointer
to
an
expression
block
in
the
in
memory
copy
of
the
frame
section
P
f
CWfp_instr_offset
fP
is
the
byte_offset
within
the
instruction
stream
of
the
frame
instructions
of
this
operation
It
starts
at
for
a
given
frame
descriptor
H
Frame
Regtable
DWARF
This
interface
is
adequate
for
DWARF2
and
MIPS
but
not
for
DWARF3
or
later
A
separate
and
preferred
interface
usable
for
DWARF3
and
for
DWARF2
is
described
below
See
also
the
section
Low
Level
Frame
Operations
below
P
The
f
CWDwarf_Regtable
fP
type
is
used
to
contain
the
register
restore
information
for
all
registers
at
a
given
PC
value
Normally
used
by
debuggers
If
you
wish
to
default
to
this
interface
and
to
the
use
of
DW_FRAME_CFA_COL
specify
enable_oldframecol
at
libdwarf
configure
time
Or
add
a
call
dwarf_set_frame_cfa_value
dbg
DW_FRAME_CFA_COL
after
your
dwarf_init_b
call
this
call
replaces
the
default
libdwarf
compile
time
value
with
DW_FRAME_CFA_COL
DS
DW_REG_TABLE_SIZE
must
reflect
the
number
of
registers
DW_FRAME_LAST_REG_NUM
as
defined
in
dwarf
h
define
DW_REG_TABLE_SIZE
fill
in
size
here
for
MIPS
IRIX
f
CWtypedef
struct
struct
Dwarf_Small
dw_offset_relevant
Dwarf_Half
dw_regnum
Dwarf_Addr
dw_offset
rules
DW_REG_TABLE_SIZE
Dwarf_Regtable
fP
DE
P
The
array
is
indexed
by
register
number
The
field
values
for
each
index
are
described
next
For
clarity
we
describe
the
field
values
for
index
rules
M
M
being
any
legal
array
element
index
P
f
CWdw_offset_relevant
fP
is
non
zero
to
indicate
the
f
CWdw_offset
fP
field
is
meaningful
If
zero
then
the
f
CWdw_offset
fP
is
zero
and
should
be
ignored
P
f
CWdw_regnum
fPis
the
register
number
applicable
If
f
CWdw_offset_relevant
fP
is
zero
then
this
is
the
register
number
of
the
register
containing
the
value
for
register
M
If
f
CWdw_offset_relevant
fP
is
non
zero
then
this
is
the
register
number
of
the
register
to
use
as
a
base
M
may
be
DW_FRAME_CFA_COL
for
example
and
the
f
CWdw_offset
fP
value
applies
The
value
of
register
M
is
therefore
the
value
of
register
f
CWdw_regnum
fP
P
f
CWdw_offset
fP
should
be
ignored
if
f
CWdw_offset_relevant
fP
is
zero
If
f
CWdw_offset_relevant
fP
is
non
zero
then
the
consumer
code
should
add
the
value
to
the
value
of
the
register
f
CWdw_regnum
fP
to
produce
the
value
H
Frame
Operation
Codes
DWARF
for
DWARF2
and
later
This
interface
was
intended
to
be
adequate
for
DWARF3
and
for
DWARF2
and
DWARF4
but
was
never
implemented
H
Frame
Regtable
DWARF
for
DWARF2
and
later
This
interface
is
adequate
for
DWARF2
and
later
versions
It
is
new
in
libdwarf
as
of
April
The
default
configure
of
libdwarf
inserts
DW_FRAME_CFA_COL3
as
the
default
CFA
column
Or
add
a
call
dwarf_set_frame_cfa_value
dbg
DW_FRAME_CFA_COL3
after
your
dwarf_init_b
call
this
call
replaces
the
default
libdwarf
compile
time
value
with
DW_FRAME_CFA_COL3
P
The
f
CWDwarf_Regtable3
fP
type
is
used
to
contain
the
register
restore
information
for
all
registers
at
a
given
PC
value
Normally
used
by
debuggers
DS
f
CWtypedef
struct
Dwarf_Regtable_Entry3_s
Dwarf_Small
dw_offset_relevant
Dwarf_Small
dw_value_type
Dwarf_Half
dw_regnum
Dwarf_Unsigned
dw_offset_or_block_len
Dwarf_Ptr
dw_block_ptr
Dwarf_Regtable_Entry3
typedef
struct
Dwarf_Regtable3_s
struct
Dwarf_Regtable_Entry3_s
rt3_cfa_rule
Dwarf_Half
rt3_reg_table_size
struct
Dwarf_Regtable_Entry3_s
rt3_rules
Dwarf_Regtable3
fP
DE
P
The
array
is
indexed
by
register
number
The
field
values
for
each
index
are
described
next
For
clarity
we
describe
the
field
values
for
index
rules
M
M
being
any
legal
array
element
index
DW_FRAME_CFA_COL3
DW_FRAME_SAME_VAL
DW_FRAME_UNDEFINED_VAL
are
not
legal
array
indexes
nor
is
any
index
or
rt3_reg_table_size
The
caller
of
routines
using
this
struct
must
create
data
space
for
rt3_reg_table_size
entries
of
struct
Dwarf_Regtable_Entry3_s
and
arrange
that
rt3_rules
points
to
that
space
and
that
rt3_reg_table_size
is
set
correctly
The
caller
need
not
but
may
initialize
the
contents
of
the
rt3_cfa_rule
or
the
rt3_rules
array
The
following
applies
to
each
rt3_rules
rule
M
P
in
f
CWdw_regnum
fP
is
the
register
number
applicable
If
f
CWdw_regnum
fP
is
DW_FRAME_UNDEFINED_VAL
then
the
register
I
has
undefined
value
If
f
CWdw_regnum
fP
is
DW_FRAME_SAME_VAL
then
the
register
I
has
the
same
value
as
in
the
previous
frame
P
If
f
CWdw_regnum
fP
is
neither
of
these
two
then
the
following
apply
P
P
f
CWdw_value_type
fP
determines
the
meaning
of
the
other
fields
It
is
one
of
DW_EXPR_OFFSET
DW_EXPR_VAL_OFFSET
DW_EXPR_EXPRESSION
or
DW_EXPR_VAL_EXPRESSION
P
If
f
CWdw_value_type
fP
is
DW_EXPR_OFFSET
then
this
is
as
in
DWARF2
and
the
offset
N
rule
or
the
register
R
rule
of
the
DWARF3
and
DWARF2
document
applies
The
value
is
either
in
If
f
CWdw_offset_relevant
fP
is
non
zero
then
f
CWdw_regnum
fP
is
effectively
ignored
but
must
be
identical
to
DW_FRAME_CFA_COL3
and
the
f
CWdw_offset
fP
value
applies
The
value
of
register
M
is
therefore
the
value
of
CFA
plus
the
value
of
f
CWdw_offset
fP
The
result
of
the
calculation
is
the
address
in
memory
where
the
value
of
register
M
resides
This
is
the
offset
N
rule
of
the
DWARF2
and
DWARF3
documents
P
f
CWdw_offset_relevant
fP
is
zero
it
indicates
the
f
CWdw_offset
fP
field
is
not
meaningful
The
value
of
register
M
is
the
value
currently
in
register
f
CWdw_regnum
fP
the
value
DW_FRAME_CFA_COL3
must
not
appear
only
real
registers
This
is
the
register
R
rule
of
the
DWARF3
spec
in
P
If
f
CWdw_value_type
fP
is
DW_EXPR_OFFSET
then
this
is
the
the
val_offset
N
rule
of
the
DWARF3
spec
applies
The
calculation
is
identical
to
that
of
DW_EXPR_OFFSET
but
the
value
is
interpreted
as
the
value
of
register
M
rather
than
the
address
where
register
M
s
value
is
stored
P
If
f
CWdw_value_type
fP
is
DW_EXPR_EXPRESSION
then
this
is
the
the
expression
E
rule
of
the
DWARF3
document
P
in
f
CWdw_offset_or_block_len
fP
is
the
length
in
bytes
of
the
in
memory
block
pointed
at
by
f
CWdw_block_ptr
fP
f
CWdw_block_ptr
fP
is
a
DWARF
expression
Evaluate
that
expression
and
the
result
is
the
address
where
the
previous
value
of
register
M
is
found
in
P
If
f
CWdw_value_type
fP
is
DW_EXPR_VAL_EXPRESSION
then
this
is
the
the
val_expression
E
rule
of
the
DWARF3
spec
P
in
f
CWdw_offset_or_block_len
fP
is
the
length
in
bytes
of
the
in
memory
block
pointed
at
by
f
CWdw_block_ptr
fP
f
CWdw_block_ptr
fP
is
a
DWARF
expression
Evaluate
that
expression
and
the
result
is
the
previous
value
of
register
M
in
P
The
rule
f
CWrt3_cfa_rule
fP
is
the
current
value
of
the
CFA
It
is
interpreted
exactly
like
any
register
M
rule
as
described
just
above
except
that
f
CWdw_regnum
fP
cannot
be
CW_FRAME_CFA_REG3
or
DW_FRAME_UNDEFINED_VAL
or
DW_FRAME_SAME_VAL
but
must
be
a
real
register
number
in
H
Macro
Details
Record
The
f
CWDwarf_Macro_Details
fP
type
gives
information
about
a
single
entry
in
the
debug
macinfo
section
DWARF2
DWARF3
and
DWARF4
It
is
not
useful
for
DWARF
debug_macro
section
data
DS
f
CWstruct
Dwarf_Macro_Details_s
Dwarf_Off
dmd_offset
Dwarf_Small
dmd_type
Dwarf_Signed
dmd_lineno
Dwarf_Signed
dmd_fileindex
char
dmd_macro
typedef
struct
Dwarf_Macro_Details_s
Dwarf_Macro_Details
DE
P
f
CWdmd_offset
fP
is
the
byte
offset
within
the
debug_macinfo
section
of
this
macro
information
P
f
CWdmd_type
fP
is
the
type
code
of
this
macro
info
entry
or
the
type
code
indicating
that
this
is
the
end
of
macro
information
entries
for
a
compilation
unit
See
f
CWDW_MACINFO_define
fP
etc
in
the
DWARF
document
P
f
CWdmd_lineno
fP
is
the
line
number
where
this
entry
was
found
or
if
there
is
no
applicable
line
number
P
f
CWdmd_fileindex
fP
is
the
file
index
of
the
file
involved
This
is
only
guaranteed
meaningful
on
a
f
CWDW_MACINFO_start_file
fP
f
CWdmd_type
fP
Set
to
if
unknown
see
the
functional
interface
for
more
details
P
f
CWdmd_macro
fP
is
the
applicable
string
For
a
f
CWDW_MACINFO_define
fP
this
is
the
macro
name
and
value
For
a
f
CWDW_MACINFO_undef
fP
or
this
is
the
macro
name
For
a
f
CWDW_MACINFO_vendor_ext
fP
this
is
the
vendor
defined
string
value
For
other
f
CWdmd_type
fPs
this
is
H
Opaque
Types
The
opaque
types
declared
in
fIlibdwarf
h
fP
are
used
as
descriptors
for
queries
against
DWARF
information
stored
in
various
debugging
sections
Each
time
an
instance
of
an
opaque
type
is
returned
as
a
result
of
a
fIlibdwarf
fP
operation
f
CWDwarf_Debug
fP
excepted
it
should
be
freed
using
f
CWdwarf_dealloc
fP
when
it
is
no
longer
of
use
read
the
following
documentation
for
details
as
in
at
least
one
case
there
is
a
special
routine
provided
for
deallocation
and
f
CWdwarf_dealloc
fP
is
not
directly
called
see
f
CWdwarf_srclines_b
fP
Some
functions
return
a
number
of
instances
of
an
opaque
type
in
a
block
by
means
of
a
pointer
to
the
block
and
a
count
of
the
number
of
opaque
descriptors
in
the
block
see
the
function
description
for
deallocation
rules
for
such
functions
The
list
of
opaque
types
defined
in
fIlibdwarf
h
fP
that
are
pertinent
to
the
Consumer
Library
and
their
intended
use
is
described
below
This
is
not
a
full
list
of
the
opaque
types
see
libdwarf
h
for
the
full
list
DS
f
CWtypedef
struct
Dwarf_Debug_s
Dwarf_Debug
fP
DE
An
instance
of
the
f
CWDwarf_Debug
fP
type
is
created
as
a
result
of
a
successful
call
to
f
CWdwarf_init_b
fP
or
f
CWdwarf_elf_init_b
fP
and
is
used
as
a
descriptor
for
subsequent
access
to
most
f
CWlibdwarf
fP
functions
on
that
object
The
storage
pointed
to
by
this
descriptor
should
be
not
be
freed
using
the
f
CWdwarf_dealloc
fP
function
Instead
free
it
with
f
CWdwarf_finish
fP
P
DS
f
CWtypedef
struct
Dwarf_Die_s
Dwarf_Die
fP
DE
An
instance
of
a
f
CWDwarf_Die
fP
type
is
returned
from
a
successful
call
to
the
f
CWdwarf_siblingof
fP
f
CWdwarf_child
fP
or
f
CWdwarf_offdie_b
fP
function
and
is
used
as
a
descriptor
for
queries
about
information
related
to
that
DIE
The
storage
pointed
to
by
this
descriptor
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_DIE
fP
when
no
longer
needed
or
preferably
call
f
CWdwarf_dealloc_die
fP
instead
DS
f
CWtypedef
struct
Dwarf_Line_s
Dwarf_Line
fP
DE
Instances
of
f
CWDwarf_Line
fP
type
are
returned
from
a
successful
call
to
the
f
CWdwarf_srclines_from_linecontext
fP
function
and
are
used
as
descriptors
for
queries
about
source
lines
The
storage
pointed
to
by
these
descriptors
should
be
freed
using
f
CWdwarf_srclines_dealloc_b
line_context
error
fP
when
no
longer
needed
DS
f
CWtypedef
struct
Dwarf_Global_s
Dwarf_Global
fP
DE
Instances
of
f
CWDwarf_Global
fP
type
are
returned
from
a
successful
call
to
the
f
CWdwarf_get_globals
fP
function
and
are
used
as
descriptors
for
queries
about
global
names
pubnames
DS
f
CWtypedef
struct
Dwarf_Weak_s
Dwarf_Weak
fP
DE
Instances
of
f
CWDwarf_Weak
fP
type
are
returned
from
a
successful
call
to
the
SGI
specific
f
CWdwarf_get_weaks
fP
function
and
are
used
as
descriptors
for
queries
about
weak
names
The
storage
pointed
to
by
these
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_WEAK_CONTEXT
fP
or
f
CWDW_DLA_WEAK
fP
an
older
name
supported
for
compatibility
when
no
longer
needed
DS
f
CWtypedef
struct
Dwarf_Func_s
Dwarf_Func
fP
DE
Instances
of
f
CWDwarf_Func
fP
type
are
returned
from
a
successful
call
to
the
SGI
specific
f
CWdwarf_get_funcs
fP
function
and
are
used
as
descriptors
for
queries
about
static
function
names
DS
f
CWtypedef
struct
Dwarf_Type_s
Dwarf_Type
fP
DE
Instances
of
f
CWDwarf_Type
fP
type
are
returned
from
a
successful
call
to
the
SGI
specific
f
CWdwarf_get_types
fP
function
and
are
used
as
descriptors
for
queries
about
user
defined
types
DS
f
CWtypedef
struct
Dwarf_Var_s
Dwarf_Var
fP
DE
Instances
of
f
CWDwarf_Var
fP
type
are
returned
from
a
successful
call
to
the
SGI
specific
f
CWdwarf_get_vars
fP
function
and
are
used
as
descriptors
for
queries
about
static
variables
DS
f
CWtypedef
struct
Dwarf_Error_s
Dwarf_Error
fP
DE
This
descriptor
points
to
a
structure
that
provides
detailed
information
about
errors
detected
by
f
CWlibdwarf
fP
Users
typically
provide
a
location
for
f
CWlibdwarf
fP
to
store
this
descriptor
for
the
user
to
obtain
more
information
about
the
error
The
storage
pointed
to
by
this
descriptor
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ERROR
fP
when
no
longer
needed
or
preferably
call
f
CWdwarf_dealloc_error
fP
instead
DS
f
CWtypedef
struct
Dwarf_Attribute_s
Dwarf_Attribute
fP
DE
Instances
of
f
CWDwarf_Attribute
fP
type
are
returned
from
a
successful
call
to
the
f
CWdwarf_attrlist
fP
or
f
CWdwarf_attr
fP
functions
and
are
used
as
descriptors
for
queries
about
attribute
values
The
storage
pointed
to
by
this
descriptor
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ATTR
fP
when
no
longer
needed
or
call
f
CWdwarf_dealloc_attribute
fP
instead
DS
f
CWtypedef
struct
Dwarf_Abbrev_s
Dwarf_Abbrev
fP
DE
An
instance
of
a
f
CWDwarf_Abbrev
fP
type
is
returned
from
a
successful
call
to
f
CWdwarf_get_abbrev
fP
and
is
used
as
a
descriptor
for
queries
about
abbreviations
in
the
debug_abbrev
section
The
storage
pointed
to
by
this
descriptor
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ABBREV
fP
when
no
longer
needed
DS
f
CWtypedef
struct
Dwarf_Fde_s
Dwarf_Fde
fP
DE
Instances
of
f
CWDwarf_Fde
fP
type
are
returned
from
a
successful
call
to
the
f
CWdwarf_get_fde_list
fP
f
CWdwarf_get_fde_for_die
fP
or
f
CWdwarf_get_fde_at_pc
fP
functions
and
are
used
as
descriptors
for
queries
about
frames
descriptors
DS
f
CWtypedef
struct
Dwarf_Cie_s
Dwarf_Cie
fP
DE
Instances
of
f
CWDwarf_Cie
fP
type
are
returned
from
a
successful
call
to
the
f
CWdwarf_get_fde_list
fP
function
and
are
used
as
descriptors
for
queries
about
information
that
is
common
to
several
frames
DS
f
CWtypedef
struct
Dwarf_Arange_s
Dwarf_Arange
fP
DE
Instances
of
f
CWDwarf_Arange
fP
type
are
returned
from
successful
calls
to
the
f
CWdwarf_get_aranges
fP
or
f
CWdwarf_get_arange
fP
functions
and
are
used
as
descriptors
for
queries
about
address
ranges
The
storage
pointed
to
by
this
descriptor
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ARANGE
fP
when
no
longer
needed
DS
f
CWtypedef
struct
Dwarf_Gdbindex_s
Dwarf_Gdbindex
fP
DE
Instances
of
f
CWDwarf_Gdbindex
fP
type
are
returned
from
successful
calls
to
the
f
CWdwarf_gdbindex_header
fP
function
and
are
used
to
extract
information
from
a
gdb_index
section
This
section
is
a
gcc
gdb
extension
and
is
designed
to
allow
a
debugger
fast
access
to
data
in
debug_info
The
storage
pointed
to
by
this
descriptor
should
be
freed
using
a
call
to
f
CWdwarf_gdbindex_free
fP
with
a
valid
f
CWDwarf_Gdbindex
fP
pointer
as
the
argument
DS
f
CWtypedef
struct
Dwarf_Xu_Index_Header_s
Dwarf_Xu_Index_header
fP
DE
Instances
of
f
CWDwarf_Xu_Index_Header_s
fP
type
are
returned
from
successful
calls
to
the
f
CWdwarf_get_xu_index_header
fP
function
and
are
used
to
extract
information
from
a
debug_cu_index
or
debug_tu_index
section
These
sections
are
used
to
make
possible
access
to
dwo
sections
gathered
into
a
dwp
object
as
part
of
the
DebugFission
ie
Split
Dwarf
project
allowing
separation
of
an
executable
from
most
of
its
DWARF
debugging
information
As
of
May
these
sections
are
accepted
into
DWARF5
but
the
standard
has
not
been
released
The
storage
pointed
to
by
this
descriptor
should
be
freed
using
a
call
to
f
CWdwarf_xh_header_free
fP
with
a
valid
f
CWDwarf_XuIndexHeader
fP
pointer
as
the
argument
DS
f
CWtypedef
struct
Dwarf_Line_Context_s
Dwarf_Line_Context
fP
DE
f
CWdwarf_srclines_b
fP
returns
a
Dwarf_Line_Context
through
an
argument
and
the
new
structure
pointer
lets
us
access
line
header
information
conveniently
DS
f
CWtypedef
struct
Dwarf_Locdesc_c_s
Dwarf_Locdesc_c
fP
f
CWtypedef
struct
Dwarf_Loc_Head_c_s
Dwarf_Loc_Head_c
fP
DE
f
CWDwarf_Loc
fP
are
involved
in
the
DWARF5
interfaces
to
location
lists
The
new
interfaces
are
all
functional
and
contents
of
the
above
types
are
not
exposed
DS
f
CWtypedef
struct
Dwarf_Macro_Context_s
Dwarf_Macro_Context
fP
DE
f
CWdwarf_get_macro_context
fP
and
f
CWdwarf_get_macro_context_by_offset
fP
return
a
Dwarf_Line_Context
through
an
argument
and
the
new
structure
pointer
lets
us
access
macro
data
from
the
debug_macro
section
DS
f
CWtypedef
struct
Dwarf_Dsc_Head_s
Dwarf_Dsc_Head
fP
DE
f
CWdwarf_discr_list
fP
returns
a
Dwarf_Dsc_Head
through
an
argument
and
the
new
structure
pointer
lets
us
access
macro
data
from
a
f
CWDW_AT_discr_list
fP
attribute
H
UTF
strings
fIlibdwarf
fP
is
defined
at
various
points
to
return
string
pointers
or
to
copy
strings
into
string
areas
you
define
DWARF
allows
the
use
of
f
CWDW_AT_use_UTF8
fP
DWARF3
and
later
f
CWDW_ATE_UTF
fP
DWARF4
and
later
to
specify
that
the
strings
returned
are
actually
in
UTF
format
What
this
means
is
that
if
UTF
is
specified
on
a
particular
object
it
is
up
to
callers
that
wish
to
print
all
the
characters
properly
to
use
language
appropriate
functions
to
print
Unicode
strings
appropriately
All
ASCII
characters
in
the
strings
will
print
properly
whether
printed
as
wide
characters
or
not
The
methods
to
convert
UTF
strings
so
they
will
print
correctly
for
all
such
strings
is
beyond
the
scope
of
this
document
P
If
UTF
is
not
specified
then
one
is
probably
safe
in
assuming
the
strings
are
iso_8859
and
normal
C
printf
will
work
fine
P
In
either
case
one
should
be
wary
of
corrupted
accidentally
or
intentionally
strings
with
ASCII
control
characters
in
the
text
Such
can
cause
bad
effects
if
simply
printed
to
a
device
such
as
a
terminal
H
Error
Handling
The
method
for
detection
and
disposition
of
error
conditions
that
arise
during
access
of
debugging
information
via
fIlibdwarf
fP
is
consistent
across
all
fIlibdwarf
fP
functions
that
are
capable
of
producing
an
error
This
section
describes
the
method
used
by
fIlibdwarf
fP
in
notifying
client
programs
of
error
conditions
P
Most
functions
within
fIlibdwarf
fP
accept
as
an
argument
a
pointer
to
a
f
CWDwarf_Error
fP
descriptor
where
a
f
CWDwarf_Error
fP
descriptor
is
stored
if
an
error
is
detected
by
the
function
Routines
in
the
client
program
that
provide
this
argument
can
query
the
f
CWDwarf_Error
fP
descriptor
to
determine
the
nature
of
the
error
and
perform
appropriate
processing
The
intent
is
that
clients
do
the
appropriate
processing
immediately
on
encountering
an
error
and
then
the
client
calls
f
CWdwarf_dealloc_error
fP
to
free
the
Dwarf_Error
descriptor
at
which
point
the
client
should
zero
that
descriptor
as
the
non
zero
value
is
stale
P
We
think
the
following
is
appropriate
as
a
general
outline
See
dwarfdump
source
for
many
examples
of
both
of
the
following
incomplete
examples
The
very
few
functions
not
following
this
general
call
return
plan
are
specifically
documented
in
DS
f
CW
int
example_codea
Dwarf_Debug
dbg
Dwarf_Die
indie
int
is_info
Dwarf_Die
sibdie
Dwarf_Error
err
int
res
const
char
secname
res
dwarf_siblingof_b
dbg
indie
is_info
sibdie
err
if
res
DW_DLV_ERROR
return
res
Let
higher
level
decide
what
to
do
and
it
will
eventually
need
to
do
dwarf_dealloc_error
appropriately
the
sibdie
argument
is
not
touched
or
used
by
the
called
function
else
if
res
DW_DLV_NO_ENTRY
return
res
No
sibdie
created
Nothing
done
the
sibdie
argument
is
not
touched
or
used
by
the
called
function
sibdie
created
The
function
stored
a
DIE
pointer
pointing
to
a
created
DIE
record
through
the
sibdie
pointer
Caller
should
eventually
do
dwarf_dealloc_die
appropriately
return
DW_DLV_OK
fP
DE
in
P
In
a
case
where
it
is
ok
to
suppress
the
error
as
being
unimporant
this
is
an
outline
not
a
useful
function
in
DS
f
CW
int
example_codeb
Dwarf_Debug
dbg
const
char
sec_name
int
is_info
Dwarf_Error
e
int
res
res
dwarf_get_die_section_name
dbg
is_info
sec_name
if
res
DW_DLV_ERROR
dwarf_dealloc_error
e
e
return
res
let
higher
level
decide
what
to
do
Nothing
allocated
in
the
call
still
exists
if
res
DW_DLV_NO_ENTRY
fP
DE
in
P
In
the
rare
case
where
the
malloc
arena
is
exhausted
when
trying
to
create
a
Dwarf_Error
descriptor
a
pointer
to
a
statically
allocated
descriptor
will
be
returned
This
static
descriptor
is
new
in
December
A
call
to
f
CWdwarf_dealloc
fP
to
free
the
statically
allocated
descriptor
is
harmless
it
sets
the
error
value
in
the
descriptor
to
DW_DLE_FAILSAFE_ERRVAL
The
possible
conflation
of
errors
when
the
arena
is
exhausted
and
a
dwarf_error
descriptor
is
saved
past
the
next
reader
call
in
any
thread
is
considered
better
than
having
fIlibdwarf
fP
call
f
CWabort
fP
as
earlier
fIlibdwarf
fP
did
P
We
strongly
suggest
most
applications
calling
fIlibdwarf
fP
follow
the
suggestion
above
passing
a
valid
Dwarf_Error
address
in
the
last
argument
when
calling
fIlibdwarf
fP
where
there
are
such
Dwarf_Error
arguments
there
are
other
approaches
described
just
below
that
might
be
worth
considering
in
small
simple
applications
as
they
reduce
the
Dwarf_Error
argument
to
just
passing
null
pointer
P
The
cases
that
arise
when
passing
a
null
for
the
Dwarf_Error
and
where
there
is
an
error
detected
are
A
with
an
error
handler
function
libdwarf
will
call
that
function
and
on
return
to
fIlibdwarf
fP
fIlibdwarf
fP
will
return
f
CWDW_DLV_ERROR
fP
to
the
original
client
call
or
B
with
no
error
handler
function
see
below
libdwarf
will
print
an
error
and
call
f
CWabort
fP
P
AL
A
LI
For
the
error
handler
case
a
client
program
can
specify
a
function
to
be
invoked
upon
detection
of
an
error
at
the
time
the
library
is
initialized
see
f
CWdwarf_init_b
fP
or
f
CWdwarf_init_path
fP
for
example
When
a
fIlibdwarf
fP
routine
detects
an
error
this
function
is
called
with
two
arguments
a
code
indicating
the
nature
of
the
error
and
a
pointer
provided
by
the
client
at
initialization
again
see
f
CWdwarf_init_b
fP
or
f
CWdwarf_init_path
fP
This
pointer
argument
can
be
used
to
relay
information
between
the
error
handler
and
other
routines
of
the
client
program
A
client
program
can
specify
or
change
both
the
error
handling
function
and
the
pointer
argument
after
initialization
using
f
CWdwarf_seterrhand
fP
and
f
CWdwarf_seterrarg
fP
When
the
client
error
function
returns
libdwarf
returns
f
CWDW_DLV_ERROR
fP
P
If
the
client
passed
in
a
non
null
f
CWerror
fP
argument
in
the
libdwarf
call
finding
an
error
the
f
CWdwarf_seterrhand
fP
function
invocation
mentioned
here
does
not
happen
P
LI
In
the
final
case
where
fIlibdwarf
fP
functions
are
not
provided
a
pointer
to
a
f
CWDwarf_Error
fP
descriptor
and
no
error
handling
function
was
provided
at
initialization
fIlibdwarf
fP
functions
print
a
short
message
to
f
CWstdout
fP
and
terminate
execution
with
f
CWabort
fP
P
Before
March
fIlibdwarf
fP
gave
up
when
there
was
no
error
handling
by
emitting
a
short
message
on
f
CWstderr
fP
and
calling
f
CWabort
fP
LE
P
The
following
lists
the
processing
steps
taken
upon
detection
of
an
error
AL
LI
Check
the
f
CWerror
fP
argument
if
not
a
fINULL
fP
pointer
allocate
and
initialize
a
f
CWDwarf_Error
fP
descriptor
with
information
describing
the
error
place
this
descriptor
in
the
area
pointed
to
by
f
CWerror
fP
and
return
a
value
indicating
an
error
condition
LI
If
an
f
CWerrhand
fP
argument
was
provided
to
f
CWdwarf_init_b
fP
at
initialization
call
f
CWerrhand
fP
passing
it
the
error
descriptor
and
the
value
of
the
f
CWerrarg
fP
argument
provided
to
f
CWdwarf_init_b
fP
If
the
error
handling
function
returns
return
f
CWDW_DLV_ERROR
fP
indicating
an
error
condition
LI
If
neither
the
f
CWerror
fP
argument
nor
an
f
CWerrhand
fP
argument
was
provided
Terminate
program
execution
by
calling
f
CWabort
fP
LE
SP
In
all
cases
it
is
clear
from
the
value
returned
from
a
function
that
an
error
occurred
in
executing
the
function
since
DW_DLV_ERROR
is
returned
P
As
can
be
seen
from
the
above
steps
the
client
program
can
provide
an
error
handler
at
initialization
and
still
provide
an
f
CWerror
fP
argument
to
fIlibdwarf
fP
functions
when
it
is
not
desired
to
have
the
error
handler
invoked
P
If
a
f
CWlibdwarf
fP
function
is
called
with
invalid
arguments
the
behavior
is
undefined
In
particular
supplying
a
f
CWNULL
fP
pointer
to
a
f
CWlibdwarf
fP
function
except
where
explicitly
permitted
or
pointers
to
invalid
addresses
or
uninitialized
data
causes
undefined
behavior
the
return
value
in
such
cases
is
undefined
and
the
function
may
fail
to
invoke
the
caller
supplied
error
handler
or
to
return
a
meaningful
error
number
Implementations
also
may
abort
execution
for
such
cases
P
Some
errors
are
so
inconsequential
that
it
does
not
warrant
rejecting
an
object
or
returning
an
error
Examples
would
be
a
frame
length
not
being
a
multiple
of
an
address
size
an
arange
in
debug_aranges
has
some
padding
bytes
or
a
relocation
could
not
be
completed
To
make
it
possible
for
a
client
to
report
such
errors
the
function
f
CWdwarf_get_harmless_error_list
fP
returns
strings
with
error
text
in
them
This
function
may
be
ignored
if
client
code
does
not
want
to
bother
with
such
error
reporting
P
H
Returned
values
in
the
functional
interface
Values
returned
by
f
CWlibdwarf
fP
functions
to
indicate
success
and
errors
nr
aX
n
Fg
are
enumerated
in
Figure
n
aX
The
f
CWDW_DLV_NO_ENTRY
fP
case
is
useful
for
functions
need
to
indicate
that
while
there
was
no
data
to
return
there
was
no
error
either
For
example
f
CWdwarf_siblingof
fP
may
return
f
CWDW_DLV_NO_ENTRY
fP
to
indicate
that
that
there
was
no
sibling
to
return
DS
TS
center
box
tab
lfB
cfB
lfB
l
c
l
SYMBOLIC
NAME
VALUE
MEANING
_
DW_DLV_ERROR
Error
DW_DLV_OK
Successful
call
DW_DLV_NO_ENTRY
No
applicable
value
TE
FG
Error
Indications
DE
P
Each
function
in
the
interface
that
returns
a
value
returns
one
of
the
integers
in
the
above
figure
P
If
f
CWDW_DLV_ERROR
fP
is
returned
and
a
pointer
to
a
f
CWDwarf_Error
fP
pointer
is
passed
to
the
function
then
a
Dwarf_Error
handle
is
returned
through
the
pointer
No
other
pointer
value
in
the
interface
returns
a
value
After
the
f
CWDwarf_Error
fP
is
no
longer
of
interest
a
f
CWdwarf_dealloc
dbg
dw_err
DW_DLA_ERROR
fP
on
the
error
pointer
is
appropriate
to
free
any
space
used
by
the
error
information
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
no
pointer
value
in
the
interface
returns
a
value
P
If
f
CWDW_DLV_OK
fP
is
returned
the
f
CWDwarf_Error
fP
pointer
if
supplied
is
not
touched
but
any
other
values
to
be
returned
through
pointers
are
returned
In
this
case
calls
depending
on
the
exact
function
returning
the
error
to
f
CWdwarf_dealloc
fP
may
be
appropriate
once
the
particular
pointer
returned
is
no
longer
of
interest
P
Pointers
passed
to
allow
values
to
be
returned
through
them
are
uniformly
the
last
pointers
in
each
argument
list
P
All
the
interface
functions
are
defined
from
the
point
of
view
of
the
writer
of
the
library
as
is
traditional
for
UN
X
library
documentation
not
from
the
point
of
view
of
the
user
of
the
library
The
caller
might
code
P
DS
f
CWDwarf_Line
line
Dwarf_Unsigned
ret_loff
Dwarf_Error
err
int
retval
dwarf_lineoff_b
line
fP
DE
for
the
function
defined
as
P
DS
f
CWint
dwarf_lineoff_b
Dwarf_Line
line
Dwarf_Unsigned
return_lineoff
Dwarf_Error
err
fP
DE
and
this
document
refers
to
the
function
as
returning
the
value
through
err
or
return_lineoff
or
uses
the
phrase
returns
in
the
location
pointed
to
by
err
Sometimes
other
similar
phrases
are
used
H
Memory
Management
Several
of
the
functions
that
comprise
fIlibdwarf
fP
return
pointers
opaque
descriptors
to
structures
that
have
been
dynamically
allocated
by
the
library
To
manage
dynamic
memory
the
function
f
CWdwarf_dealloc
fP
is
provided
to
free
storage
allocated
as
a
result
of
a
call
to
a
fIlibdwarf
fP
function
Some
additional
functions
described
later
are
provided
to
free
storage
in
particular
circumstances
This
section
describes
the
general
strategy
that
should
be
taken
by
a
client
program
in
managing
dynamic
storage
P
By
default
f
CWlibdwarf
fP
tracks
its
allocations
and
f
CWdwarf_finish
fP
cleans
up
allocations
where
f
CWdwarf_dealloc
fP
was
not
called
See
f
CWdwarf_set_de_alloc_flag
fP
below
H
Read
only
Properties
All
pointers
opaque
descriptors
returned
by
or
as
a
result
of
a
fIlibdwarf
Consumer
Library
fP
call
should
be
assumed
to
point
to
read
only
memory
The
results
are
undefined
for
fIlibdwarf
fP
clients
that
attempt
to
write
to
a
region
pointed
to
by
a
value
returned
by
a
fIlibdwarf
Consumer
Library
fP
call
H
Storage
Deallocation
See
the
section
Returned
values
in
the
functional
interface
above
for
the
general
rules
where
calls
to
f
CWdwarf_dealloc
fP
are
appropriate
P
As
of
May
there
are
additional
dealloc
calls
which
enable
type
checking
the
calls
f
CWdwarf_dealloc_error
fP
f
CWdwarf_dealloc_die
fP
and
f
CWdwarf_dealloc_attribute
fP
P
H
dwarf_dealloc
The
first
prototype
is
the
generic
one
that
can
dealloc
any
of
the
libdwarf
types
such
as
DW_DLA_DIE
etc
This
has
the
disadvantages
that
the
f
CWspace_to_dealloc
fP
argument
cannot
be
type
checked
and
the
f
CWappropriate_dla_name
fP
is
a
simple
integer
hence
not
meaningfully
checkable
either
P
Whenever
possible
use
a
type
safe
deallocation
call
for
several
types
that
is
the
only
documented
deallocation
call
and
for
f
CWDwarf_Die
fP
f
CWDwarf_Attribute
fP
or
f
CWDwarf_Error
fP
use
the
following
dealloc
functions
instead
of
this
one
The
use
of
this
form
remains
fully
supported
P
DS
f
CWvoid
dwarf_dealloc
Dwarf_Debug
dbg
void
space_to_dealloc
int
appropriate_dla_name
fP
DE
in
DS
FG
Example_dwarf_dealloc
f
CW
void
exampledealloc
Dwarf_Debug
dbg
Dwarf_Die
somedie
dwarf_dealloc
dbg
somedie
DW_DLA_DIE
fP
DE
in
H
dwarf_dealloc_die
The
second
prototype
is
only
to
dealloc
a
Dwarf_Die
Any
call
to
this
is
typechecked
P
DS
f
CWvoid
dwarf_dealloc_die
Dwarf_Die
mydie
fP
DE
in
DS
FG
Example_dwarf_dealloc_die
f
CW
void
exampledeallocdie
Dwarf_Die
somedie
dwarf_dealloc_die
somedie
fP
DE
in
H
dwarf_dealloc_attribute
The
second
prototype
is
only
to
dealloc
a
Dwarf_Attribute
These
arise
from
calls
from
f
CWdwarf_attrlist
fP
Any
call
to
this
is
typechecked
P
DS
f
CWvoid
dwarf_dealloc_error
Dwarf_Debug
dbg
Dwarf_Die
mydie
fP
DE
in
DS
FG
Example_dwarf_dealloc_attribute
f
CW
void
exampledeallocattr
Dwarf_Attribute
attr
dwarf_dealloc_attribute
attr
fP
DE
in
H
dwarf_dealloc_error
The
second
prototype
is
only
to
dealloc
a
Dwarf_Error
These
arise
when
some
libdwarf
call
returns
DW_DLV_ERROR
Any
call
to
this
is
typechecked
P
DS
f
CWvoid
dwarf_dealloc_error
Dwarf_Debug
dbg
Dwarf_Die
mydie
fP
DE
in
DS
FG
Example_dwarf_dealloc_error
f
CW
void
exampledeallocerror
Dwarf_Debug
dbg
Dwarf_Error
err
dwarf_dealloc_error
dbg
err
fP
DE
in
P
See
also
f
CWErrors
Returned
from
dwarf_init
calls
fP
below
In
some
cases
the
pointers
returned
by
a
fIlibdwarf
fP
call
are
pointers
to
data
which
is
not
freeable
The
library
knows
from
the
allocation
type
provided
to
it
whether
the
space
is
freeable
or
not
and
will
not
free
inappropriately
when
f
CWdwarf_dealloc
fP
is
called
So
it
is
vital
that
f
CWdwarf_dealloc
fP
be
called
with
the
proper
allocation
type
P
For
all
storage
allocated
by
fIlibdwarf
fP
the
client
can
free
the
storage
for
reuse
by
calling
f
CWdwarf_dealloc
fP
providing
it
with
the
f
CWDwarf_Debug
fP
descriptor
specifying
the
object
for
which
the
storage
was
allocated
a
pointer
to
the
area
to
be
free
ed
and
an
identifier
that
specifies
what
the
pointer
points
to
the
allocation
type
For
example
to
free
a
f
CWDwarf_Die
die
fP
belonging
the
the
object
represented
by
f
CWDwarf_Debug
dbg
fP
allocated
by
a
call
to
f
CWdwarf_siblingof
fP
the
call
to
f
CWdwarf_dealloc
fP
would
be
DS
f
CWdwarf_dealloc
dbg
die
DW_DLA_DIE
fP
or
preferably
f
CWdwarf_dealloc_die
die
fP
DE
To
free
storage
allocated
in
the
form
of
a
list
of
pointers
opaque
descriptors
each
member
of
the
list
should
be
deallocated
followed
by
deallocation
of
the
actual
list
itself
The
following
code
fragment
uses
an
invocation
of
f
CWdwarf_attrlist
fP
as
an
example
to
illustrate
a
technique
that
can
be
used
to
free
storage
from
any
fIlibdwarf
fP
routine
that
returns
a
list
in
DS
FG
Example1
dwarf_attrlist
f
CW
void
example1
Dwarf_Debug
dbg
Dwarf_Die
somedie
Dwarf_Signed
atcount
Dwarf_Attribute
atlist
Dwarf_Error
error
Dwarf_Signed
i
int
errv
errv
dwarf_attrlist
somedie
if
errv
DW_DLV_OK
for
i
i
atcount
i
use
atlist
i
dwarf_dealloc_attribute
atlist
i
This
original
form
still
works
dwarf_dealloc
dbg
atlist
i
DW_DLA_ATTR
dwarf_dealloc
dbg
atlist
DW_DLA_LIST
fP
DE
in
f
CWdwarf_finish
fP
will
deallocate
all
dynamic
storage
associated
with
an
instance
of
a
f
CWDwarf_Debug
fP
type
In
particular
it
will
deallocate
all
dynamically
allocated
space
associated
with
the
f
CWDwarf_Debug
fP
descriptor
and
finally
make
the
descriptor
invalid
H
Errors
Returned
from
dwarf_init
calls
These
errors
are
almost
always
due
to
fuzzing
objects
injecting
random
values
into
objects
Rarely
seen
in
any
valid
object
file
See
https
en
wikipedia
org
wiki
Fuzzing
P
A
f
CWDwarf_Error
fP
returned
from
any
f
CWdwarf_init
fP
should
be
dealt
with
like
any
other
error
We
start
with
an
example
of
how
to
deal
with
this
class
of
errors
See
just
below
the
example
for
a
further
discussion
in
DS
void
exampleinitfail
const
char
path
char
true_pathbuf
unsigned
tpathlen
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Error
error
Dwarf_Debug
dbg
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
int
res
res
dwarf_init_path
path
true_pathbuf
tpathlen
groupnumber
errhand
errarg
reserved1
reserved2
Preferred
version
if
res
DW_DLV_ERROR
Valid
call
even
though
dbg
is
null
dwarf_dealloc
dbg
error
DW_DLA_ERROR
Simpler
newer
form
in
this
comment
but
use
the
older
form
above
for
compatibility
with
older
libdwarf
dwarf_dealloc_error
dbg
error
With
libdwarf
before
September
these
dealloc
calls
will
leave
a
few
bytes
allocated
The
orginal
recommendation
to
call
free
error
in
this
case
is
still
valid
though
it
will
not
necessarily
free
every
byte
allocated
with
September
and
later
libdwarf
Horrible
messy
alternative
best
effort
if
dwarf_package_version
exists
function
created
in
October
package
version
if
res
DW_DLV_ERROR
const
char
ver
dwarf_package_version
int
cmpres
cmpres
strcmp
ver
if
cmpres
dwarf_dealloc_error
dbg
error
else
free
error
DE
in
P
If
your
application
needs
to
be
absolutely
sure
not
even
a
single
byte
leaks
from
a
failed
libdwarf
init
function
call
the
only
sure
approach
is
to
ensure
you
use
a
September
version
or
later
libdwarf
Versions
between
and
have
no
available
function
that
will
guarantee
freeing
these
last
few
bytes
P
If
your
application
does
not
care
if
a
failed
libdwarf
init
function
leaks
a
few
bytes
then
the
September
advice
of
calling
dwarf_dealloc
dbg
error
DW_DLA_ERROR
is
best
as
though
leaks
a
few
bytes
with
libdwarf
before
September
P
If
your
application
is
using
or
earlier
libdwarf
the
choice
of
free
error
will
avoid
a
leak
from
a
failed
dwarf
init
call
though
changing
to
a
more
recent
libdwarf
will
then
make
a
few
bytes
leak
quite
possible
until
the
application
is
changed
to
use
the
dwarf_dealloc
call
H
Error
DW_DLA
error
free
types
The
codes
that
identify
the
storage
pointed
to
in
calls
to
nr
aX
n
Fg
f
CWdwarf_dealloc
fP
are
described
in
figure
n
aX
DS
TS
center
box
tab
lfB
lfB
l
l
IDENTIFIER
USED
TO
FREE
_
DW_DLA_STRING
char
DW_DLA_LOC
Dwarf_Loc
DW_DLA_LOCDESC
Dwarf_Locdesc
DW_DLA_ELLIST
Dwarf_Ellist
not
used
DW_DLA_BOUNDS
Dwarf_Bounds
not
used
DW_DLA_BLOCK
Dwarf_Block
DW_DLA_DEBUG
Dwarf_Debug
do
not
use
DW_DLA_DIE
Dwarf_Die
DW_DLA_LINE
Dwarf_Line
DW_DLA_ATTR
Dwarf_Attribute
DW_DLA_TYPE
Dwarf_Type
not
used
DW_DLA_SUBSCR
Dwarf_Subscr
not
used
DW_DLA_GLOBAL
Dwarf_Global
DW_DLA_ERROR
Dwarf_Error
DW_DLA_LIST
a
list
of
opaque
descriptors
DW_DLA_LINEBUF
Dwarf_Line
not
used
DW_DLA_ARANGE
Dwarf_Arange
DW_DLA_ABBREV
Dwarf_Abbrev
DW_DLA_FRAME_OP
Dwarf_Frame_Op
DW_DLA_CIE
Dwarf_Cie
DW_DLA_FDE
Dwarf_Fde
DW_DLA_LOC_BLOCK
Dwarf_Loc
Block
DW_DLA_FRAME_BLOCK
Dwarf_Frame
Block
not
used
DW_DLA_FUNC
Dwarf_Func
DW_DLA_TYPENAME
Dwarf_Type
DW_DLA_VAR
Dwarf_Var
DW_DLA_WEAK
Dwarf_Weak
DW_DLA_ADDR
Dwarf_Addr
DW_DLA_RANGES
Dwarf_Ranges
DW_DLA_GNU_INDEX_HEAD
debug_gnu_type
pubnames
DW_DLA_RNGLISTS_HEAD
debug_rnglists
DW_DLA_DGBINDEX
Dwarf_Gdbindex
DW_DLA_XU_INDEX
Dwarf_Xu_Index_Header
DW_DLA_LOC_BLOCK_C
Dwarf_Loc_c
DW_DLA_LOCDESC_C
Dwarf_Locdesc_c
DW_DLA_LOC_HEAD_C
Dwarf_Loc_Head_c
DW_DLA_MACRO_CONTEXT
Dwarf_Macro_Context
DW_DLA_DSC_HEAD
Dwarf_Dsc_Head
DW_DLA_DNAMES_HEAD
Dwarf_Dnames_Head
DW_DLA_STR_OFFSETS
Dwarf_Str_Offsets_Table
TE
FG
Allocation
Deallocation
Identifiers
DE
P
H
Functional
Interface
This
section
describes
the
functions
available
in
the
fIlibdwarf
fP
library
Each
function
description
includes
its
definition
followed
by
one
or
more
paragraph
describing
the
function
s
operation
P
The
following
sections
describe
these
functions
H
Initialization
Operations
These
functions
are
concerned
with
preparing
an
object
file
for
subsequent
access
by
the
functions
in
fIlibdwarf
fP
and
with
releasing
allocated
resources
when
access
is
complete
f
CWdwarf_init_path
fP
or
f
CWdwarf_init_path_dl
fP
are
the
initialization
functions
to
use
if
one
actually
has
a
path
if
you
just
have
an
open
fd
or
open
libelf
handle
you
cannot
use
the
_path_
versions
that
s
fine
These
both
allow
libdwarf
to
attempt
to
follow
f
CWGNU
debuglink
fP
hints
in
a
specially
produced
executable
shared
object
to
find
the
object
file
with
the
DWARF
sections
to
match
tne
executable
or
shared
object
For
non
debuglink
executables
these
two
functions
behave
identically
P
f
CWGNU
debuglink
fP
is
completely
different
than
and
separate
from
Split
Dwarf
and
MacOS
dSYM
it
would
seem
unlikely
that
these
could
be
combined
in
any
single
executable
shared
object
All
are
intended
to
have
DWARF
fully
available
but
not
taking
space
in
the
executable
shared
object
See
https
sourceware
org
gdb
onlinedocs
gdb
Separate
Debug
Files
html
for
information
on
debuglink
and
the
related
build
id
P
f
CWdwarf_init_path
fP
provides
no
way
to
add
extra
global
paths
to
debuglink
searches
But
f
CWdwarf_init_path_dl
fP
has
extra
arguments
to
make
adding
extra
paths
easy
P
libdwarf
lets
one
access
the
executable
s
section
eh_frame
with
frame
backtrace
information
by
turning
off
recognition
of
f
CWGNU
debuglink
fP
in
the
Dwarf_Debug
being
opened
by
passing
in
f
CWtrue_path_out_buffer
fP
f
CWtrue_path_bufferlen
fP
as
zero
H
dwarf_init_path
DS
f
CWint
dwarf_init_path
const
char
path
char
true_path_out_buffer
unsigned
true_path_bufferlen
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Error
error
DE
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
returns
a
pointer
to
an
initialized
Dwarf_Debug
through
the
dbg
argument
All
this
work
identically
across
all
supported
object
file
types
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
there
is
no
such
file
and
nothing
else
is
done
or
returned
P
If
f
CWDW_DLV_ERROR
fP
is
returned
a
Dwarf_Error
is
returned
through
the
error
pointer
and
nothing
else
is
done
or
returned
P
Now
we
turn
to
the
arguments
P
Pass
in
the
name
of
the
object
file
via
the
f
CWpath
fP
argument
P
For
MacOS
pass
in
a
pointer
to
f
CWtrue_path_out_buffer
fP
big
pointing
to
a
buffer
large
enough
to
hold
the
passed
in
path
if
that
were
doubled
plus
adding
characters
Then
pass
that
length
in
the
f
CWtrue_path_bufferlen
fP
argument
If
a
file
is
found
the
dSYM
path
or
if
not
that
the
original
path
the
final
path
is
copied
into
f
CWtrue_path_out_buffer
fP
In
any
case
This
is
harmless
with
non
MacOS
executables
but
for
non
MacOS
non
f
CWGNU_debuglink
fP
objects
f
CWtrue_path_out_buffer
fP
will
just
match
f
CWpath
fP
P
For
Elf
executables
shared
objects
using
f
CWGNU_debuglink
fP
The
same
considerations
apply
pass
in
a
pointer
to
f
CWtrue_path_out_buffer
fP
big
pointing
to
a
buffer
large
enough
to
hold
the
passed
in
path
if
that
were
doubled
plus
adding
characters
a
heuristic
the
is
arbitrary
f
CWGNU_debuglink
fP
paths
can
be
long
but
not
likely
longer
than
this
suggested
size
P
When
you
know
you
won
t
be
reading
MacOS
executables
and
won
t
be
accessing
f
CWGNU_debuglink
fP
executables
special
treatment
by
passing
as
arguments
to
f
CWtrue_path_out_buffer
fP
and
f
CWtrue_path_bufferlen
fP
If
those
are
zero
the
f
CWMacOS
fP
f
CWGNU_debuglink
fP
special
processing
will
not
occur
P
Pass
in
zero
with
the
f
CWaccess
fP
f
CW
fP
argument
The
f
CWDW_DLC_READ
fP
flag
which
only
ever
applied
to
libelf
is
zero
P
The
f
CWgroupnumber
fP
argument
indicates
which
group
is
to
be
accessed
Group
one
is
normal
dwarf
sections
such
as
f
CW
debug_info
fP
Group
two
is
DWARF5
dwo
split
dwarf
dwarf
sections
such
as
debug_info
dwo
Groups
three
and
higher
are
for
COMDAT
groups
If
an
object
file
has
only
sections
from
one
of
the
groups
then
passing
zero
will
access
that
group
Otherwise
passing
zero
will
access
only
group
one
See
f
CWdwarf_sec_group_sizes
fP
and
f
CWdwarf_sec_group_map
fP
for
more
group
information
Typically
pass
in
DW_GROUPNUMBER_ANY
to
f
CWgroupnumber
fP
Non
elf
objects
do
not
use
this
field
P
The
f
CWerrhand
fP
argument
is
a
pointer
to
a
function
that
will
be
invoked
whenever
an
error
is
detected
as
a
result
of
a
fIlibdwarf
fP
operation
The
f
CWerrarg
fP
argument
is
passed
as
an
argument
to
the
f
CWerrhand
fP
function
P
f
CWdbg
fP
is
used
to
return
an
initialized
Dwarf_Debug
pointer
P
f
CWreserved1
fP
f
CWreserved2
fP
and
f
CWreserved3
fP
are
currently
unused
pass
in
to
all
three
P
Pass
in
a
pointer
to
a
Dwarf_Error
to
the
f
CWerror
fP
argument
if
you
wish
libdwarf
to
return
an
error
code
H
dwarf_init_path_dl
DS
f
CWint
dwarf_init_path_dl
const
char
path
char
true_path_out_buffer
unsigned
true_path_bufferlen
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
char
global_paths
unsigned
int
global_paths_count
Dwarf_Debug
dbg
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Error
error
fP
DE
This
function
is
identical
to
f
CWdwarf_init_path
fP
in
every
respect
except
if
you
know
that
you
must
use
special
paths
to
find
the
f
CWGNU
debuglink
fP
target
file
with
DWARF
information
P
f
CWglobal_paths
fP
allows
you
to
specify
such
paths
Pass
in
f
CWglobal_paths
fP
as
a
pointer
to
an
array
of
pointer
to
char
each
pointing
to
a
global
path
string
Pass
in
f
CWglobal_paths_count
fP
with
the
number
of
entries
in
the
pointer
array
Pass
both
as
zero
if
there
are
no
debuglink
global
paths
other
than
the
default
standard
f
CW
usr
lib
debug
fP
P
for
the
f
CWaccess
fP
argument
pass
in
There
is
no
DW_DLC_READ
macro
now
H
dwarf_init_b
DS
f
CWint
dwarf_init_b
int
fd
unsigned
group_number
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
fP
DE
When
it
returns
f
CWDW_DLV_OK
fP
the
function
f
CWdwarf_init_b
fP
returns
through
f
CWdbg
fP
a
f
CWDwarf_Debug
fP
descriptor
that
represents
a
handle
for
accessing
debugging
records
associated
with
the
open
file
descriptor
f
CWfd
fP
f
CWDW_DLV_NO_ENTRY
fP
is
returned
if
the
object
does
not
contain
DWARF
debugging
information
f
CWDW_DLV_ERROR
fP
is
returned
if
an
error
occurred
P
for
the
f
CWaccess
fP
argument
pass
in
There
is
no
DW_DLC_READ
macro
now
P
The
f
CWgroupnumber
fP
argument
indicates
which
group
is
to
be
accessed
Group
one
is
normal
dwarf
sections
such
as
f
CW
debug_info
fP
Group
two
is
DWARF5
dwo
split
dwarf
dwarf
sections
such
as
debug_info
dwo
If
you
don
t
know
specific
value
use
DW_GROUPNUMBER_ANY
and
it
will
work
for
you
in
almost
all
cases
Groups
three
and
higher
are
for
COMDAT
groups
If
an
object
file
has
only
sections
from
one
of
the
groups
then
passing
zero
will
access
that
group
Otherwise
passing
zero
will
access
only
group
one
See
f
CWdwarf_sec_group_sizes
fP
and
f
CWdwarf_sec_group_map
fP
for
more
group
information
P
The
f
CWerrhand
fP
argument
is
a
pointer
to
a
function
that
will
be
invoked
whenever
an
error
is
detected
as
a
result
of
a
fIlibdwarf
fP
operation
The
f
CWerrarg
fP
argument
is
passed
as
an
argument
to
the
f
CWerrhand
fP
function
P
The
file
descriptor
associated
with
the
f
CWfd
fP
argument
must
refer
to
an
ordinary
file
i
e
not
a
pipe
socket
device
proc
entry
etc
be
opened
with
the
at
least
as
much
permission
as
specified
by
the
f
CWaccess
fP
argument
and
cannot
be
closed
or
used
as
an
argument
to
any
system
calls
by
the
client
until
after
f
CWdwarf_finish
fP
is
called
The
seek
position
of
the
file
associated
with
f
CWfd
fP
is
undefined
upon
return
of
f
CWdwarf_init_b
fP
P
Historical
Note
With
SGI
IRIX
by
default
it
was
allowed
that
the
app
f
CWclose
fP
f
CWfd
fP
immediately
after
calling
f
CWdwarf_init_b
fP
but
that
is
not
a
portable
approach
that
it
worked
was
an
accidental
side
effect
of
the
fact
that
SGI
IRIX
used
f
CWELF_C_READ_MMAP
fP
in
its
hidden
internals
The
portable
approach
is
to
consider
that
f
CWfd
fP
must
be
left
open
till
after
the
corresponding
dwarf_finish
call
has
returned
P
Since
f
CWdwarf_init_b
fP
uses
the
same
error
handling
processing
as
other
fIlibdwarf
fP
functions
see
fIError
Handling
fP
above
client
programs
will
generally
supply
an
f
CWerror
fP
parameter
to
bypass
the
default
actions
during
initialization
unless
the
default
actions
are
appropriate
H
dwarf_set_de_alloc_flag
DS
f
CWint
dwarf_set_de_alloc_flag
int
v
fP
DE
f
CWdwarf_set_de_alloc_flag
fP
sets
and
returns
a
flag
value
applying
to
the
current
running
instance
of
f
CWlibdwarf
fP
It
s
action
sets
an
internal
value
and
that
value
should
be
set
changed
if
you
wish
to
do
that
before
any
other
f
CWlibdwarf
fP
calls
P
By
default
f
CWlibdwarf
fP
keeps
track
of
all
its
internal
allocations
So
if
the
documentation
here
says
you
should
do
f
CWdwarf_dealloc
fP
calls
or
other
calls
documented
here
for
specific
functions
and
you
omit
some
or
all
of
them
then
calling
f
CWdwarf_finish
fP
will
clean
up
all
those
allocations
left
undone
P
If
you
call
f
CWdwarf_set_de_alloc_flag
fP
then
libdwarf
will
not
keep
track
of
allocations
so
your
code
must
do
all
f
CWdwarf_dealloc
fP
calls
as
defined
below
P
If
you
call
f
CWdwarf_set_de_alloc_flag
fP
that
sets
restores
the
setting
to
its
default
value
so
from
that
point
all
new
internal
allocations
will
be
tracked
and
f
CWdwarf_finish
fP
can
clean
the
new
ones
up
P
The
return
value
of
f
CWdwarf_set_de_alloc_flag
fP
is
the
previous
value
of
the
internal
flag
One
is
the
default
meaning
record
allocations
Zero
is
the
other
possible
value
meaning
do
not
record
f
CWlibdwarf
fP
allocations
P
It
is
best
to
ignore
this
call
unless
you
have
gigantic
DWARF
sections
and
you
need
whatever
percent
speed
improvement
from
f
CWlibdwarf
fP
that
you
can
get
If
you
do
use
it
then
by
all
means
use
tools
such
as
cc
fsanitize
or
valgrind
to
ensure
there
are
no
leaks
in
your
application
at
least
given
your
test
cases
P
The
function
name
echos
the
spelling
of
a
f
CWlibdwarf
fP
internal
field
in
f
CWstruct
Dwarf_Debug_s
fP
named
f
CWde_alloc_tree
fP
H
Dwarf_Handler
function
This
is
an
example
of
a
valid
error
handler
function
A
pointer
to
this
or
another
like
it
may
be
passed
to
f
CWdwarf_elf_init_b
fP
or
f
CWdwarf_init_b
fP
DS
f
CWstatic
void
simple_error_handler
Dwarf_Error
error
Dwarf_Ptr
errarg
printf
libdwarf
error
d
s
n
dwarf_errno
error
dwarf_errmsg
error
exit
fP
DE
P
This
will
only
be
called
if
an
error
is
detected
inside
libdwarf
and
the
Dwarf_Error
argument
passed
to
libdwarf
is
NULL
A
Dwarf_Error
will
be
created
with
the
error
number
assigned
by
the
library
and
passed
to
the
error
handler
P
The
second
argument
is
a
copy
of
the
value
passed
in
to
f
CWdwarf_elf_init_b
fP
as
the
f
CWerrarg
fP
argument
Typically
the
init
function
would
be
passed
a
pointer
to
an
application
created
struct
containing
the
data
the
application
needs
to
do
what
it
wants
to
do
in
the
error
handler
P
In
a
language
with
exceptions
or
exception
like
features
an
exception
could
be
thrown
here
Or
the
application
could
simply
give
up
and
call
f
CWexit
fP
as
in
the
sample
given
above
H
dwarf_set_tied_dbg
DS
f
CWint
dwarf_set_tied_dbg
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_set_tied_dbg
fP
enables
cross
object
access
of
DWARF
data
If
a
DWARF5
Package
object
has
f
CWDW_FORM_addrx
fP
or
f
CWDW_FORM_GNU_addr_index
fP
or
one
of
the
other
indexed
forms
in
DWARF5
in
an
address
attribute
one
needs
both
the
Package
file
and
the
executable
to
extract
the
actual
address
with
f
CWdwarf_formaddr
fP
The
utility
function
f
CWdwarf_addr_form_is_indexed
form
fP
is
a
handy
way
to
know
if
an
address
form
is
indexed
One
does
a
normal
f
CWdwarf_init_b
fP
on
each
object
and
then
tie
the
two
together
with
a
call
such
as
in
DS
FG
Example2
dwarf_set_died_dbg
f
CW
void
example2
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg
Dwarf_Error
error
int
res
Do
the
dwarf_init_b
calls
to
set
dbg
tieddbg
at
this
point
Then
res
dwarf_set_tied_dbg
dbg
tieddbg
if
res
DW_DLV_OK
Something
went
wrong
fP
DE
in
When
done
with
both
dbg
and
tieddbg
do
the
normal
finishing
operations
on
both
in
any
order
It
is
possible
to
undo
the
tieing
operation
with
in
FG
Example3
dwarf_set_tied_dbg
obsolete
DS
f
CW
void
example3
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
res
dwarf_set_tied_dbg
dbg
NULL
if
res
DW_DLV_OK
Something
went
wrong
fP
DE
in
P
It
is
not
necessary
to
undo
the
tieing
operation
before
finishing
on
the
dbg
and
tieddbg
H
dwarf_get_tied_dbg
DS
f
CWint
dwarf_get_tied_dbg
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg_out
Dwarf_Error
error
fP
DE
f
CWdwarf_get_tied_dbg
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWtieddbg_out
fP
to
the
pointer
to
the
tied
Dwarf_Debug
If
there
is
no
tied
object
f
CWtieddbg_out
fP
is
set
to
NULL
P
On
error
it
returns
f
CWDW_DLV_ERROR
fP
P
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_finish
DS
f
CWint
dwarf_finish
Dwarf_Debug
dbg
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_finish
fP
releases
all
fILibdwarf
fP
internal
resources
associated
with
the
descriptor
f
CWdbg
fP
and
invalidates
f
CWdbg
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
during
the
finishing
operation
It
returns
f
CWDW_DLV_OK
fP
for
a
successful
operation
H
dwarf_set_stringcheck
DS
f
CWint
dwarf_set_stringcheck
int
stringcheck
fP
DE
The
function
f
CWint
dwarf_set_stringcheck
fP
sets
a
global
flag
and
returns
the
previous
value
of
the
global
flag
If
the
stringcheck
global
flag
is
zero
the
default
libdwarf
does
string
length
validity
checks
the
checks
do
slow
libdwarf
down
very
slightly
If
the
stringcheck
global
flag
is
non
zero
libdwarf
does
not
do
string
length
validity
checks
The
global
flag
is
really
just
bits
long
upperbits
are
not
noticed
or
recorded
H
dwarf_set_reloc_application
DS
f
CWint
dwarf_set_reloc_application
int
apply
fP
DE
The
function
f
CWint
dwarf_set_reloc_application
fP
sets
a
global
flag
and
returns
the
previous
value
of
the
global
flag
If
the
reloc_application
global
flag
is
non
zero
the
default
then
the
applicable
rela
section
if
one
exists
will
be
processed
and
applied
to
any
DWARF
section
when
it
is
read
in
If
the
reloc_application
global
flag
is
zero
no
such
relocation
application
is
attempted
Not
all
machine
types
elf
header
e_machine
or
all
relocations
are
supported
but
then
very
few
relocation
types
apply
to
DWARF
debug
sections
The
global
flag
is
really
just
bits
long
upperbits
are
not
noticed
or
recorded
It
seems
unlikely
anyone
will
need
to
call
this
function
H
dwarf_record_cmdline_options
DS
f
CWint
dwarf_record_cmdline_options
Dwarf_Cmdline_Options
options
fP
DE
The
function
f
CWint
dwarf_record_cmdline_options
fP
copies
a
Dwarf_Cmdline_Options
structure
from
consumer
code
to
libdwarf
The
structure
is
defined
in
f
CWlibdwarf
h
fP
The
initial
version
of
this
structure
has
a
single
field
f
CWcheck_verbose_mode
fP
which
if
non
zero
tells
libdwarf
to
print
some
detailed
messages
to
f
CWstdout
fP
in
case
certain
errors
are
detected
The
default
for
this
value
is
FALSE
so
the
extra
messages
are
off
by
default
H
dwarf_object_init_b
DS
f
CWint
dwarf_object_init_b
Dwarf_Obj_Access_Interface
obj
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
unsigned
groupnumber
Dwarf_Debug
dbg
Dwarf_Error
error
fP
DE
The
function
f
CWint
dwarf_object_init_b
fP
enables
access
to
non
Elf
object
files
by
allowing
the
caller
to
then
provide
function
pointers
to
code
user
written
not
part
of
libdwarf
that
will
look
to
libdwarf
as
if
libdwarf
was
reading
Elf
P
See
f
CWint
dwarf_init_b
fP
for
additional
information
on
the
arguments
passed
in
the
f
CWobj
fP
argument
here
is
a
set
of
function
pointers
and
describing
how
to
access
non
Elf
files
is
beyond
the
scope
of
this
document
P
As
a
hint
note
that
the
source
files
with
dwarf_elf_init_file_ownership
dwarf_original_elf_init
c
and
dwarf_elf_object_access_init
dwarf_elf_access
c
are
the
only
sources
that
would
need
replacement
for
a
different
object
format
The
replacement
would
need
to
emulate
certain
conventions
of
Elf
objects
mainly
that
section
index
is
an
empty
section
but
the
rest
of
libdwarf
uses
what
these
two
source
files
set
up
without
knowing
how
to
operate
on
Elf
P
Writing
the
functions
needed
to
support
non
Elf
will
require
study
of
Elf
and
of
the
object
format
involved
The
topic
is
beyond
the
scope
of
this
document
H
dwarf_get_real_section_name
DS
f
CWint
dwarf_get_real_section_name
Dwarf_Debug
dbg
const
char
std_section_name
const
char
actual_sec_name_out
Dwarf_Small
marked_compressed
Dwarf_Small
marked_zlib_compressed
Dwarf_Small
marked_shf_compressed
Dwarf_Unsigned
compressed_length
Dwarf_Unsigned
uncompressed_length
Dwarf_Error
error
DE
Elf
sections
are
sometimes
compressed
to
reduce
the
disk
footprint
of
the
sections
It
s
sometimes
interesting
to
library
users
what
the
real
name
was
in
the
object
file
and
whether
it
was
compressed
Libdwarf
uncompresses
such
sections
automatically
It
s
not
usually
necessary
to
know
the
true
name
or
anything
about
compression
P
f
CW
fP
The
caller
passes
in
a
f
CWDwarf_Debug
fP
pointer
and
a
standard
section
name
such
as
debug_info
On
success
the
function
returns
through
the
other
arguments
the
true
section
name
and
a
flag
which
if
non
zero
means
the
section
was
compressed
and
a
flag
which
if
non
zero
means
the
section
had
the
Elf
section
flag
SHF_COMPRESSED
set
The
caller
must
ensure
that
the
memory
pointed
to
by
f
CWactual_sec_name_out
fP
f
CWmarked_zcompressed
fP
and
f
CWmarked_zlib_compressed
fP
f
CWmarked_shf_compressed
fP
f
CWcompressed_length
fP
f
CWuncompressed_length
fP
is
zero
at
the
point
of
call
P
The
flag
f
CW
marked_compressed
fP
if
non
zero
means
the
section
name
started
with
zdebug
indicating
compression
was
done
P
The
flag
f
CWmarked_zlib_compressed
fP
if
non
zero
means
the
initial
bytes
of
the
section
starte
with
the
ASCII
characters
ZLIB
and
the
section
was
compressed
P
The
flag
f
CWmarked_shf_compressed
fP
if
non
zero
means
the
Elf
section
sh_flag
SHF_COMPRESSED
is
set
and
the
section
was
compressed
The
flag
value
in
an
elf
section
header
is
P
The
value
f
CWcompressed_length
fP
is
passed
back
through
the
pointer
if
and
only
if
the
section
is
compressed
and
the
pointer
is
non
null
P
The
value
f
CWuncompressed_length
fP
is
passed
back
through
the
pointer
if
and
only
if
the
section
is
compressed
and
the
pointer
is
non
null
P
If
the
section
name
passed
in
is
not
used
by
libdwarf
for
this
object
file
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
P
On
error
the
function
returns
f
CWDW_DLV_ERROR
fP
P
The
string
pointed
to
by
f
CW
actual_sec_name_out
fP
must
not
be
free
d
H
dwarf_package_version
DS
f
CWconst
char
dwarf_package_version
void
fP
DE
The
package
version
is
set
in
config
h
from
its
value
in
configure
ac
and
in
CMakeLists
txt
in
the
source
tree
at
the
build
time
of
the
library
A
pointer
to
a
static
string
is
returned
by
this
function
The
format
is
standard
ISO
date
format
For
example
It
s
not
entirely
clear
how
this
actually
helps
But
there
is
a
request
for
this
and
we
provide
it
as
of
October
H
Object
Type
Detectors
These
are
used
by
f
CWlibdwarf
fP
and
may
be
of
use
generally
They
have
no
connection
to
any
Dwarf_Debug
data
as
you
see
from
the
arguments
passed
in
H
dwarf_object_detector_path_b
This
returns
basic
object
file
information
and
make
it
possible
to
resolve
GNU
debuglink
paths
to
a
file
with
DWARF
DS
f
CWint
dwarf_object_detector_path_b
const
char
path
char
outpath
unsigned
long
outpath_len
char
gl_pathnames
unsigned
gl_pathcount
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
fP
DE
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
returns
various
data
through
the
arguments
described
just
below
This
works
identically
across
all
supported
object
file
types
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
there
is
no
such
file
and
nothing
else
is
done
or
returned
P
If
f
CWDW_DLV_ERROR
fP
is
returned
a
Dwarf_Error
is
returned
through
the
error
pointer
and
nothing
else
is
done
or
returned
P
Now
we
turn
to
the
arguments
P
The
required
arguments
are
f
CWpath
fP
f
CWftype
fP
f
CWendian
fP
f
CWoffsetsize
fP
and
f
CWfilesize
fP
All
others
should
be
passed
as
unless
GNU
debuglink
processing
is
needed
See
below
P
Pass
in
the
name
of
the
object
file
via
the
f
CWpath
fP
argument
P
For
f
CWftype
fP
f
CWendian
fP
and
f
CWfilesize
fP
pass
pointers
f
CWftype
fP
will
be
returned
as
one
of
the
DW_TYPE
values
see
libdwarf
h
f
CWendian
fP
will
be
returned
as
one
of
the
DW_ENDIAN
values
see
libdwarf
h
f
CWoffsetsize
fP
will
be
returned
as
or
as
found
in
the
object
file
header
s
The
meaning
of
f
CWoffsetsize
fP
may
differ
depending
on
the
particular
object
format
f
CWfilesize
fP
will
be
returned
as
the
size
of
the
file
found
in
bytes
P
Now
we
turn
to
the
arguments
involved
in
GNU
debuglink
processing
f
CWoutpath
fP
f
CWoutpath_len
fP
f
CWgl_pathnames
fP
f
CWgl_pathcount
fP
and
f
CWpathsource
fP
Usually
one
will
pass
all
these
as
and
avoid
special
processing
P
To
f
CWoutpath
fP
pass
in
a
pointer
big
enough
to
hold
the
passed
in
path
if
that
were
doubled
plus
adding
characters
that
is
a
rather
arbitrary
size
request
a
larger
value
might
be
better
in
some
circumstances
Then
pass
that
length
in
the
f
CWoutpath_len
fP
argument
The
path
will
be
copied
to
outpath
If
a
GNU
debuglink
file
is
found
the
path
to
that
file
will
be
copied
to
f
CWoutpath
fP
P
To
f
CWpathsource
fP
pass
in
a
pointer
to
an
f
CWunsigned
char
fP
containing
the
value
f
CWDW_PATHSOURCE_basic
fP
If
a
debuglink
file
is
found
f
CWoutpath
fP
will
be
set
to
the
debuglink
target
file
and
f
CW
pathsource
fP
will
be
set
to
f
CWDW_PATHSOURCE_debuglink
fP
P
The
f
CWftype
fP
pointer
argument
returns
f
CWDW_FTYPE_ELF
fP
f
CWDW_FTYPE_MACH_O
fP
f
CWDW_FTYPE_PE
fP
f
CWDW_FTYPE_ARCHIVE
fP
or
f
CWDW_FTYPE_UNKNOWN
fP
to
the
caller
The
f
CWDW_FTYPE_ARCHIVE
fP
value
says
nothing
whatever
about
the
contents
of
the
archive
P
The
f
CWendian
fP
pointer
argument
returns
f
CWDW_ENDIAN_BIG
fP
f
CWDW_ENDIAN_LITTLE
fP
f
CWDW_ENDIAN_SAME
fP
f
CWDW_ENDIAN_OPPOSITE
fP
or
f
CWDW_ENDIAN_UNKNOWN
fP
to
the
caller
P
The
f
CWoffsetsize
fP
pointer
argument
returns
a
size
value
from
the
object
file
If
the
object
file
uses
bit
offsets
it
returns
and
if
bit
offsets
it
returns
Each
object
type
uses
such
values
but
the
meanings
vary
between
object
types
P
The
f
CWfilesize
fP
pointer
argument
returns
the
size
in
bytes
of
the
object
file
This
is
essentially
useless
for
f
CWDW_FTYPE_ARCHIVE
fP
files
one
thinks
P
f
CW
fP
The
f
CWgl_pathnames
fP
and
f
CWgl_pathcount
fP
arguments
provide
a
way
to
give
the
GNU
debuglink
logic
additional
directories
beyond
the
standard
location
to
search
for
object
files
f
CWgl_pathnames
fP
must
if
non
zero
point
to
an
array
of
pointers
to
character
strings
with
file
paths
to
search
f
CWgl_pathcount
fP
must
contain
the
number
of
such
paths
in
the
pathname
array
P
The
f
CWerrcode
fP
pointer
argument
returns
if
and
only
if
DW_DLV_ERROR
is
returned
by
the
function
an
integer
error
code
At
this
time
there
is
no
handy
function
to
turn
that
error
code
into
a
string
In
the
libdwarf
source
you
will
find
that
code
in
the
DW_DLE_
error
list
H
dwarf_object_detector_path_dSYM
This
returns
basic
object
file
data
and
makes
it
possible
to
resolve
MacOS
paths
and
return
the
path
to
the
MacOS
dSYM
object
file
with
DWARF
if
one
exists
DS
f
CWint
dwarf_object_detector_path_dSYM
const
char
path
char
outpath
unsigned
long
outpath_len
char
gl_pathnames
unsigned
gl_pathcount
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
fP
DE
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
returns
various
data
through
the
arguments
described
just
below
This
works
identically
across
all
supported
object
file
types
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
there
is
no
such
file
and
nothing
else
is
done
or
returned
P
If
f
CWDW_DLV_ERROR
fP
is
returned
a
Dwarf_Error
is
returned
through
the
error
pointer
and
nothing
else
is
done
or
returned
P
Now
we
turn
to
the
arguments
P
The
required
arguments
are
f
CWpath
fP
f
CWftype
fP
f
CWendian
fP
f
CWoffsetsize
fP
and
f
CWfilesize
fP
All
others
should
be
passed
as
unless
MacOS
dSYM
processing
is
needed
See
below
P
Pass
in
the
name
of
the
object
file
via
the
f
CWpath
fP
argument
P
For
f
CWftype
fP
f
CWendian
fP
f
CWoffsetsize
fP
and
f
CWfilesize
fP
pass
pointers
f
CWftype
fP
will
be
returned
as
one
of
the
DW_TYPE
values
see
libdwarf
h
f
CWendian
fP
will
be
returned
as
one
of
the
DW_ENDIAN
values
see
libdwarf
h
f
CWfilesize
fP
will
be
returned
as
the
size
of
the
file
found
in
bytes
f
CWoffsetsize
fP
will
be
returned
as
the
a
value
of
or
as
defined
by
the
object
format
but
the
meaning
may
vary
by
object
format
P
Now
we
turn
to
the
arguments
involved
in
MacOS
dSYM
processing
f
CWoutpath
fP
f
CWoutpath_len
fP
f
CWgl_pathnames
fP
f
CWgl_pathcount
fP
and
f
CWpathsource
fP
Usually
one
will
pass
all
these
as
and
avoid
special
processing
P
P
For
MacOS
dSym
processing
the
f
CWgl_pathnames
fP
and
f
CWgl_pathcount
fP
are
not
used
so
pass
them
as
P
To
f
CWoutpath
fP
pass
in
a
pointer
big
enough
to
hold
the
passed
in
path
if
that
were
doubled
plus
adding
characters
Then
pass
that
length
in
the
f
CWoutpath_len
fP
argument
The
path
will
be
copied
to
outpath
For
MacOS
dSYM
object
files
the
final
outpath
of
the
dSYM
file
with
MacOS
conventional
directories
added
is
copied
into
f
CWoutpath
fP
Where
the
MacOS
local
directory
tree
is
missing
or
incomplete
f
CWoutpath
fP
will
be
left
as
a
zero
length
string
P
The
f
CWerrcode
fP
pointer
argument
returns
if
and
only
if
DW_DLV_ERROR
is
returned
by
the
function
an
integer
error
code
At
this
time
there
is
no
handy
function
to
turn
that
error
code
into
a
string
In
the
libdwarf
source
you
will
find
that
code
in
the
DW_DLE_
error
list
H
dwarf_object_detector_fd
DS
f
CWint
dwarf_object_detector_fd
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
errcode
fP
DE
f
CWdwarf_object_detector_fd
fP
is
the
same
as
f
CWdwarf_object_detector_path
fP
except
that
no
path
strings
apply
to
f
CWdwarf_object_detector_fd
fP
H
Section
Group
Operations
The
section
group
data
is
essential
information
when
processing
an
object
with
COMDAT
section
group
DWARF
sections
or
with
both
split
dwarf
dwo
sections
and
non
split
dwarf
sections
P
It
relies
on
Elf
section
groups
whereas
some
compilers
rely
instead
on
relocation
information
to
identify
section
groups
These
relocation
specified
groupings
are
not
understood
at
this
time
P
A
standard
DWARF2
or
DWARF3
or
DWARF4
object
Old
Standard
Object
or
OSO
will
not
contain
any
of
those
new
sections
The
DWARF4
standard
Appendix
E
Using
Compilation
Units
offers
an
overview
of
COMDAT
section
groups
f
CWlibdwarf
fP
assigns
the
group
number
one
to
OSO
DWARF
Any
sections
that
are
split
dwarf
section
name
ending
in
dwo
or
one
of
the
two
special
DWP
index
sections
are
assigned
group
number
two
by
libdwarf
COMDAT
section
groups
are
assigned
groups
numbers
and
higher
as
needed
P
The
COMDAT
section
group
uses
are
not
well
defined
but
popular
compilations
systems
are
using
such
sections
There
is
no
meaningful
documentation
that
we
can
find
so
far
on
how
the
COMDAT
section
groups
are
used
so
f
CWlibdwarf
fP
is
based
on
observations
of
what
compilers
generate
H
dwarf_sec_group_sizes
DS
f
CW
int
dwarf_dwarf_sec_group_sizes
Dwarf_Debug
dbg
Dwarf_Unsigned
section_count_out
Dwarf_Unsigned
group_count_out
Dwarf_Unsigned
selected_group_out
Dwarf_Unsigned
map_entry_count_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_sec_group_sizes
fP
may
be
called
on
any
open
f
CWDwarf_Debug
fP
It
returns
f
CWDW_DLV_OK
fP
on
success
and
returns
values
via
the
pointer
arguments
P
Once
the
f
CWDwarf_Debug
fP
is
open
the
group
information
is
set
and
it
will
not
change
for
the
life
of
this
f
CWDwarf_Debug
fP
P
The
f
CW
section_count_out
fP
is
set
to
the
number
of
sections
in
the
object
Many
of
the
sections
will
be
irrelevant
to
f
CWlibdwarf
fP
P
The
f
CW
group_count_out
fP
is
set
to
the
number
of
groups
in
the
object
as
f
CWlibdwarf
fP
counts
them
An
OSO
will
have
exactly
one
group
A
DWP
object
will
have
exactly
one
group
If
is
more
than
one
group
consumer
code
will
likely
want
to
open
additional
f
CWDwarf_Debug
fP
objects
and
request
relevant
information
to
process
the
DWARF
contents
An
executable
or
a
DWP
object
will
always
have
a
f
CW
group_count_out
fP
of
one
An
executable
or
a
shared
library
cannot
have
any
COMDAT
section
groups
as
the
linker
will
have
dealt
with
them
P
The
f
CW
selected_group_out
fP
is
set
to
the
group
number
that
this
f
CWDwarf_Debug
fP
will
focus
on
See
f
CWdwarf_sec_group_map
fP
for
additional
details
on
how
f
CW
selected_group_out
fP
is
interpreted
P
The
f
CW
map_entry_count_out
fP
is
set
to
the
number
of
entries
in
the
map
See
f
CWdwarf_sec_group_map
fP
P
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
P
The
initial
implementation
never
returns
f
CWDW_DLV_ERROR
fP
or
f
CWDW_DLV_NO_ENTRY
fP
but
callers
should
allow
for
that
possibility
H
dwarf_sec_group_map
DS
f
CW
int
dwarf_sec_group_map
Dwarf_Debug
dbg
Dwarf_Unsigned
map_entry_count
Dwarf_Unsigned
group_numbers_array
Dwarf_Unsigned
section_numbers_array
const
char
sec_names_array
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_sec_group_map
fP
may
be
called
on
any
open
f
CWDwarf_Debug
fP
P
The
caller
must
allocate
f
CWmap_entry_count
fP
arrays
used
in
the
following
three
arguments
the
and
pass
the
appropriate
pointer
into
the
function
as
well
as
passing
in
f
CWmap_entry_count
fP
itself
P
The
map
entries
returned
cover
all
the
DWARF
related
sections
in
the
object
though
the
f
CWselected_group
fP
value
will
dictate
which
of
the
sections
in
the
f
CWDwarf_Debug
fP
will
actually
be
accessed
via
the
usual
f
CWlibdwarf
fP
functions
That
is
only
sections
in
the
selected
group
may
be
directly
accessed
though
libdwarf
may
indirectly
access
sections
in
section
group
one
so
relevant
details
can
be
accessed
such
as
abbreviation
tables
etc
Describing
the
details
of
this
access
outside
the
current
f
CWselected_group
fP
goes
beyond
what
this
document
covers
as
of
this
writing
P
It
returns
f
CWDW_DLV_OK
fP
on
success
and
sets
values
into
the
user
allocated
array
elements
sorted
by
section
number
in
DS
f
CW
group_numbers_array
group_numbers_array
map_entry_count
section_numbers_array
section_numbers_array
map_entry_count
sec_names_array
sec_names_array
map_entry_count
fP
DE
in
P
f
CWgroup_numbers_array
fP
for
example
is
set
to
a
group
number
One
or
two
or
if
there
are
COMDAT
groups
it
will
be
three
or
higher
P
f
CWsection_numbers_array
fP
for
example
is
set
to
a
valid
Elf
section
number
relevant
to
f
CWDWARF
fP
each
section
number
shown
will
be
greater
than
zero
P
f
CWsec_names_array
fP
for
example
is
set
to
a
pointer
to
a
string
containing
the
Elf
section
name
of
the
Elf
section
number
in
f
CWsections_number_array
fP
P
On
error
the
function
will
return
f
CWDW_DLV_ERROR
fP
or
f
CWDW_DLV_NO_ENTRY
fP
which
indicates
a
serious
problem
with
this
object
P
Here
is
an
example
of
use
of
these
functions
in
DS
f
CW
void
examplesecgroup
Dwarf_Debug
dbg
int
res
Dwarf_Unsigned
section_count
Dwarf_Unsigned
group_count
Dwarf_Unsigned
selected_group
Dwarf_Unsigned
group_map_entry_count
Dwarf_Unsigned
sec_nums
Dwarf_Unsigned
group_nums
const
char
sec_names
Dwarf_Error
error
Dwarf_Unsigned
i
res
dwarf_sec_group_sizes
dbg
if
res
DW_DLV_OK
Something
is
badly
wrong
return
In
an
object
without
split
dwarf
sections
or
COMDAT
sections
we
now
have
selected_group
sec_nums
calloc
group_map_entry_count
sizeof
Dwarf_Unsigned
if
sec_nums
FAIL
out
of
memory
return
group_nums
calloc
group_map_entry_count
sizeof
Dwarf_Unsigned
if
group_nums
free
group_nums
FAIL
out
of
memory
return
sec_names
calloc
group_map_entry_count
sizeof
char
if
sec_names
free
group_nums
free
sec_nums
FAIL
out
of
memory
return
res
dwarf_sec_group_map
dbg
group_map_entry_count
group_nums
sec_nums
sec_names
if
res
DW_DLV_OK
FAIL
Something
badly
wrong
for
i
i
group_map_entry_count
i
Now
do
something
with
group_nums
i
sec_nums
i
sec_names
i
free
group_nums
free
sec_nums
The
strings
are
in
Elf
data
Do
not
free
the
strings
themselves
free
sec_names
fP
DE
in
H
Section
size
operations
P
These
operations
are
informative
but
not
normally
needed
H
dwarf_get_section_max_offsets_d
DS
f
CWint
dwarf_get_section_max_offsets_d
Dwarf_debug
dbg
Dwarf_Unsigned
debug_info_size
Dwarf_Unsigned
debug_abbrev_size
Dwarf_Unsigned
debug_line_size
Dwarf_Unsigned
debug_loc_size
Dwarf_Unsigned
debug_aranges_size
Dwarf_Unsigned
debug_macinfo_size
Dwarf_Unsigned
debug_pubnames_size
Dwarf_Unsigned
debug_str_size
Dwarf_Unsigned
debug_frame_size
Dwarf_Unsigned
debug_ranges_size
Dwarf_Unsigned
debug_typenames_size
Dwarf_Unsigned
debug_types_size
Dwarf_Unsigned
debug_macro_size
Dwarf_Unsigned
debug_str_offsets_size
Dwarf_Unsigned
debug_sup_size
Dwarf_Unsigned
debug_cu_index_size
Dwarf_Unsigned
debug_tu_index_size
Dwarf_Unsigned
debug_names_size
Dwarf_Unsigned
debug_loclists_size
Dwarf_Unsigned
debug_rnglists_size
DE
P
The
function
f
CWdwarf_get_section_max_offsets_b
fP
an
open
Dwarf_Dbg
and
reports
on
the
section
sizes
by
pushing
section
size
values
back
through
the
pointers
Null
arguments
are
safe
to
pass
in
H
Printf
Callbacks
P
This
is
new
in
August
P
The
f
CWdwarf_print_lines
fP
function
is
intended
as
a
helper
to
programs
like
f
CWdwarfdump
fP
and
show
some
line
internal
details
in
a
way
only
the
internals
of
libdwarf
can
show
them
But
using
printf
directly
in
libdwarf
means
the
caller
has
limited
control
of
where
the
output
appears
So
now
the
printf
output
is
passed
back
to
the
caller
through
a
callback
function
whose
implementation
is
provided
by
the
caller
P
Any
code
calling
libdwarf
can
ignore
the
functions
described
in
this
section
completely
If
the
functions
are
ignored
the
messages
if
any
from
libdwarf
will
simply
not
appear
anywhere
P
The
f
CWlibdwarf
h
fP
header
file
defines
f
CWstruct
Dwarf_Printf_Callback_Info_s
fP
and
f
CWdwarf_register_printf_callback
fP
for
those
libdwarf
callers
wishing
to
implement
the
callback
In
this
section
we
describe
how
one
uses
that
interface
The
applications
f
CWdwarfdump
fP
and
f
CWdwarfdump2
fP
are
examples
of
how
these
may
be
used
H
dwarf_register_printf_callback
DS
f
CWstruct
Dwarf_Printf_Callback_Info_s
dwarf_register_printf_callback
Dwarf_Debug
dbg
struct
Dwarf_Printf_Callback_Info_s
newvalues
DE
P
The
f
CWdwarf_register_printf_callback
fP
function
can
only
be
called
after
the
Dwarf_Debug
instance
has
been
initialized
the
call
makes
no
sense
at
other
times
The
function
returns
the
current
value
of
the
structure
If
f
CWnewvalues
fP
is
non
null
then
the
passed
in
values
are
used
to
initialize
the
libdwarf
internal
callback
data
the
values
returned
are
the
values
before
the
f
CWnewvalues
fP
are
recorded
If
f
CWnewvalues
fP
is
null
no
change
is
made
to
the
libdwarf
internal
callback
data
H
Dwarf_Printf_Callback_Info_s
DS
f
CWstruct
Dwarf_Printf_Callback_Info_s
void
dp_user_pointer
dwarf_printf_callback_function_type
dp_fptr
char
dp_buffer
unsigned
int
dp_buffer_len
int
dp_buffer_user_provided
void
dp_reserved
DE
P
First
we
describe
the
fields
as
applicable
in
setting
up
for
a
call
to
f
CWdwarf_register_printf_callback
fP
P
The
field
f
CWdp_user_pointer
fP
is
remembered
by
libdwarf
and
passed
back
in
any
call
libdwarf
makes
to
the
user
s
callback
function
It
is
otherwise
ignored
by
libdwarf
P
The
field
f
CWdp_fptr
fP
is
either
NULL
or
a
pointer
to
a
user
implemented
function
P
If
the
field
f
CWdp_buffer_user_provided
fP
is
non
zero
then
f
CWdp_buffer_len
fP
and
f
CWdp_buffer
fP
must
be
set
by
the
user
and
libdwarf
will
use
that
buffer
without
doing
any
malloc
of
space
If
the
field
f
CWdp_buffer_user_provided
fP
is
zero
then
the
input
fields
f
CWdp_buffer_len
fP
and
f
CWdp_buffer
fP
are
ignored
by
libdwarf
and
space
is
malloc
d
as
needed
P
The
field
f
CWdp_reserved
fP
is
ignored
it
is
reserved
for
future
use
P
When
the
structure
is
returned
by
f
CWdwarf_register_printf_callback
fP
the
values
of
the
fields
before
the
f
CWdwarf_register_printf_callback
fP
call
are
returned
H
dwarf_printf_callback_function_type
DS
f
CWtypedef
void
dwarf_printf_callback_function_type
void
user_pointer
const
char
linecontent
DE
P
Any
application
using
the
callbacks
needs
to
use
the
function
f
CWdwarf_register_printf_callback
fP
and
supply
a
function
matching
the
above
function
prototype
from
libdwarf
h
H
Example
of
printf
callback
use
in
a
C
application
using
libdwarf
DS
f
CWstruct
Dwarf_Printf_Callback_Info_s
printfcallbackdata
memset
sizeof
printfcallbackdata
printfcallbackdata
dp_fptr
printf_callback_for_libdwarf
dwarf_register_printf_callback
dbg
Assuming
the
user
implements
something
like
the
following
function
in
her
application
void
printf_callback_for_libdwarf
void
userdata
const
char
data
cout
data
DE
P
It
is
crucial
that
the
user
s
callback
function
copies
or
prints
the
data
immediately
Once
the
user
callback
function
returns
the
f
CWdata
fP
pointer
may
change
or
become
stale
without
warning
H
Debugging
Information
Entry
Delivery
Operations
These
functions
are
concerned
with
accessing
debugging
information
entries
whether
from
a
debug_info
debug_types
debug_info
dwo
or
debug_types
dwo
P
Since
all
such
sections
use
similar
formats
one
set
of
functions
suffices
H
dwarf_get_die_section_name
DS
int
dwarf_get_die_section_name
Dwarf_Debug
dbg
Dwarf_Bool
is_info
const
char
sec_name
Dwarf_Error
error
DE
f
CWdwarf_get_die_section_name
fP
lets
consumers
access
the
object
section
name
when
no
specific
DIE
is
at
hand
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
See
also
f
CWdwarf_get_die_section_name_b
fP
P
The
function
f
CWdwarf_get_die_section_name
fP
operates
on
the
either
the
debug_info
dwo
section
if
f
CWis_info
fP
is
non
zero
or
debug_types
dwo
section
if
f
CWis_info
fP
is
zero
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_die_section_name_b
DS
int
dwarf_get_die_section_name_b
Dwarf_Die
die
const
char
sec_name
Dwarf_Error
error
DE
f
CWdwarf_get_die_section_name_b
fP
lets
consumers
access
the
object
section
name
when
one
has
a
DIE
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
See
also
f
CWdwarf_get_die_section_name
fP
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_next_cu_header_d
DS
f
CWint
dwarf_next_cu_header_d
Dwarf_debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_header
Dwarf_Half
header_cu_type
Dwarf_Error
error
DE
The
function
f
CWdwarf_next_cu_header_d
fP
operates
on
the
either
the
debug_info
section
if
f
CWis_info
fP
is
non
zero
or
debug_types
section
if
f
CWis_info
fP
is
zero
Only
DWARF4
allows
a
debug_types
section
The
function
returns
f
CWDW_DLV_ERROR
fP
if
it
fails
and
f
CWDW_DLV_OK
fP
if
it
succeeds
It
returns
f
CWDW_DLV_NO_ENTRY
fP
when
there
are
no
more
compilation
units
in
the
object
file
P
If
it
succeeds
f
CW
next_cu_header
fP
is
set
to
the
offset
in
the
debug_info
section
of
the
next
compilation
unit
header
if
it
succeeds
On
reading
the
last
compilation
unit
header
in
the
debug_info
section
it
contains
the
size
of
the
debug_info
or
debug_types
section
P
Beginning
April
f
CWnext_cu_header
fP
and
indeed
all
the
arguments
following
f
CWis_info
fP
may
be
passed
as
NULL
if
one
is
not
interested
in
the
value
P
The
next
call
to
f
CWdwarf_next_cu_header_d
fP
returns
f
CWDW_DLV_NO_ENTRY
fP
without
reading
a
compilation
unit
or
setting
f
CW
next_cu_header
fP
Subsequent
calls
to
f
CWdwarf_next_cu_header
fP
repeat
the
cycle
by
reading
the
first
compilation
unit
and
so
on
P
The
other
values
returned
through
pointers
are
the
values
in
the
compilation
unit
header
P
f
CWcu_header_length
fP
returns
the
length
in
bytes
of
the
compilation
unit
header
P
f
CWversion_stamp
fP
returns
the
section
version
which
would
be
for
debug_info
for
DWARF2
for
DWARF3
for
DWARF4
or
for
DWARF5
P
f
CWabbrev_offset
fP
returns
the
debug_abbrev
section
offset
of
the
abbreviations
for
this
compilation
unit
P
f
CWaddress_size
fP
returns
the
size
of
an
address
in
this
compilation
unit
Which
is
usually
or
P
f
CWoffset_size
fP
returns
the
size
in
bytes
of
an
offset
for
the
compilation
unit
The
offset
size
is
for
dwarf
and
for
dwarf
This
is
the
offset
size
in
dwarf
data
not
the
address
size
inside
the
executable
code
The
offset
size
can
be
even
if
embedded
in
a
elf
file
which
is
normal
for
elf
and
can
be
even
in
a
elf
file
which
probably
will
never
be
seen
in
practice
P
The
f
CWextension_size
fP
pointer
is
only
relevant
if
the
f
CWoffset_size
fP
pointer
returns
The
value
is
not
normally
useful
but
is
returned
through
the
pointer
for
completeness
The
pointer
f
CWextension_size
fP
returns
if
the
CU
is
MIPS
IRIX
non
standard
dwarf
MIPS
IRIX
dwarf
was
created
years
before
DWARF3
defined
dwarf
and
returns
if
the
dwarf
uses
the
standard
extension
the
is
the
size
in
bytes
of
the
in
the
initial
length
field
which
indicates
the
following
bytes
in
the
debug_info
section
are
the
real
length
See
the
DWARF3
or
DWARF4
standard
section
P
The
f
CWsignature
fP
pointer
is
only
relevant
if
the
CU
has
a
type
signature
and
if
relevant
the
byte
type
signature
of
the
debug_types
CU
header
is
assigned
through
the
pointer
P
The
f
CWtypeoffset
fP
pointer
is
only
relevant
the
CU
has
a
type
signature
if
relevant
the
local
offset
within
the
CU
of
the
the
type
offset
the
debug_types
entry
represents
is
assigned
through
the
pointer
The
f
CWtypeoffset
fP
matters
because
a
DW_AT_type
referencing
the
type
unit
may
reference
an
inner
type
such
as
a
C
class
in
a
C
namespace
but
the
type
itself
has
the
enclosing
namespace
in
the
debug_type
type_unit
P
The
f
CWheader_cu_type
fP
pointer
is
applicable
to
all
CU
headers
The
value
returned
through
the
pointer
is
either
f
CWDW_UT_compile
fP
f
CWDW_UT_partial
fP
f
CWDW_UT_type
fP
and
identifies
the
header
type
of
this
CU
In
f
CWDWARF4
fP
a
f
CWDW_UT_type
fP
will
be
in
f
CW
debug_types
fP
but
in
f
CWDWARF5
fP
these
compilation
units
are
in
f
CW
debug_info
fP
and
the
Debug
Fission
ie
Split
Dwarf
f
CW
debug_info
dwo
fP
sections
H
dwarf_next_cu_header_c
DS
f
CWint
dwarf_next_cu_header_c
Dwarf_debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_header
Dwarf_Error
error
DE
The
function
f
CWdwarf_next_cu_header_c
fP
operates
on
the
either
the
debug_info
section
if
f
CWis_info
fP
is
non
zero
or
debug_types
section
if
f
CWis_info
fP
is
zero
P
It
operates
exactly
like
f
CWdwarf_next_cu_header_d
fP
but
is
missing
the
f
CWheader_type
fP
field
This
is
kept
for
compatibility
All
code
using
this
should
be
changed
to
use
f
CWdwarf_next_cu_header_d
fP
H
dwarf_next_cu_header_b
DS
f
CWint
dwarf_next_cu_header_b
Dwarf_debug
dbg
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Unsigned
next_cu_header
Dwarf_Error
error
DE
P
This
is
obsolete
as
of
October
though
supported
P
The
function
f
CWdwarf_next_cu_header_b
fP
operates
on
the
debug_info
section
It
operates
exactly
like
f
CWdwarf_next_cu_header_c
fP
but
is
missing
the
f
CWsignature
fP
and
f
CWtypeoffset
fP
fields
This
is
kept
for
compatibility
All
code
using
this
should
be
changed
to
use
f
CWdwarf_next_cu_header_c
fP
H
dwarf_next_cu_header
P
The
following
is
the
original
form
missing
the
f
CWoffset_size
fP
f
CWextension_size
fP
f
CWsignature
fP
and
f
CWtypeoffset
fP
fields
in
f
CWdwarf_next_cu_header_c
fP
This
is
kept
for
compatibility
All
code
using
this
should
be
changed
to
use
f
CWdwarf_next_cu_header_c
fP
DS
f
CWint
dwarf_next_cu_header
Dwarf_debug
dbg
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Unsigned
next_cu_header
Dwarf_Error
error
DE
H
dwarf_siblingof_b
DS
f
CWint
dwarf_siblingof_b
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Bool
is_info
Dwarf_Die
return_sib
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_siblingof_b
fP
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CWerror
fP
pointer
on
error
If
there
is
no
sibling
it
returns
f
CWDW_DLV_NO_ENTRY
fP
When
it
succeeds
f
CWdwarf_siblingof_b
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_sib
fP
to
the
f
CWDwarf_Die
fP
descriptor
of
the
sibling
of
f
CWdie
fP
If
f
CWis_info
fP
is
non
zero
then
the
f
CWdie
fP
is
assumed
to
refer
to
a
debug_info
DIE
If
f
CWis_info
fP
is
zero
then
the
f
CWdie
fP
is
assumed
to
refer
to
a
debug_types
DIE
Note
that
the
first
call
the
call
that
gets
the
compilation
unit
DIE
in
a
compilation
unit
passes
in
a
NULL
f
CWdie
fP
so
having
the
caller
pass
in
f
CWis_info
fP
is
essential
And
if
f
CWdie
fP
is
non
NULL
it
is
still
essential
for
the
call
to
pass
in
f
CWis_info
fP
set
properly
to
reflect
the
section
the
DIE
came
from
The
function
f
CWdwarf_get_die_infotypes_flag
fP
is
of
interest
as
it
returns
the
proper
is_info
value
from
any
non
NULL
f
CWdie
fP
pointer
If
f
CWdie
fP
is
fINULL
fP
the
f
CWDwarf_Die
fP
descriptor
of
the
first
die
in
the
compilation
unit
is
returned
This
die
has
the
f
CWDW_TAG_compile_unit
fP
f
CWDW_TAG_partial_unit
fP
or
f
CWDW_TAG_type_unit
fP
tag
in
FG
Example4
dwarf_siblingof_b
DS
f
CW
void
example4
Dwarf_Debug
dbg
Dwarf_Die
in_die
Dwarf_Bool
is_info
Dwarf_Die
return_sib
Dwarf_Error
error
int
res
in_die
might
be
NULL
or
a
valid
Dwarf_Die
res
dwarf_siblingof_b
dbg
in_die
is_info
if
res
DW_DLV_OK
Use
return_sib
here
dwarf_dealloc_die
return_sib
This
original
form
still
works
dwarf_dealloc
dbg
return_sib
DW_DLA_DIE
return_sib
is
no
longer
usable
for
anything
we
ensure
we
do
not
use
it
accidentally
with
return_sib
fP
DE
in
H
dwarf_child
DS
f
CWint
dwarf_child
Dwarf_Die
die
Dwarf_Die
return_kid
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_child
fP
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CWerror
fP
die
on
error
If
there
is
no
child
it
returns
f
CWDW_DLV_NO_ENTRY
fP
When
it
succeeds
f
CWdwarf_child
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_kid
fP
to
the
f
CWDwarf_Die
fP
descriptor
of
the
first
child
of
f
CWdie
fP
The
function
f
CWdwarf_siblingof
fP
can
be
used
with
the
return
value
of
f
CWdwarf_child
fP
to
access
the
other
children
of
f
CWdie
fP
in
FG
Example5
dwarf_child
DS
f
CW
void
example5
Dwarf_Die
in_die
Dwarf_Die
return_kid
Dwarf_Error
error
int
res
res
dwarf_child
in_die
if
res
DW_DLV_OK
Use
return_kid
here
dwarf_dealloc_die
return_kid
The
original
form
of
dealloc
still
works
dwarf_dealloc
dbg
return_kid
DW_DLA_DIE
return_die
is
no
longer
usable
for
anything
we
ensure
we
do
not
use
it
accidentally
with
return_kid
fP
DE
in
H
dwarf_offdie_b
DS
f
CWint
dwarf_offdie_b
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Die
return_die
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_offdie_b
fP
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CWerror
fP
die
on
error
When
it
succeeds
f
CWdwarf_offdie_b
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_die
fP
to
the
the
f
CWDwarf_Die
fP
descriptor
of
the
debugging
information
entry
at
f
CWoffset
fP
in
the
section
containing
debugging
information
entries
i
e
the
debug_info
section
A
return
of
f
CWDW_DLV_NO_ENTRY
fP
means
that
the
f
CWoffset
fP
in
the
section
is
of
a
byte
containing
all
bits
indicating
that
there
is
no
abbreviation
code
Meaning
this
die
offset
is
not
the
offset
of
a
real
die
but
is
instead
an
offset
of
a
null
die
a
padding
die
or
of
some
random
zero
byte
this
should
not
be
returned
in
normal
use
P
It
is
the
user
s
responsibility
to
make
sure
that
f
CWoffset
fP
is
the
start
of
a
valid
debugging
information
entry
The
result
of
passing
it
an
invalid
offset
could
be
chaos
P
If
f
CWis_info
fP
is
non
zero
the
f
CWoffset
fP
must
refer
to
a
debug_info
section
offset
If
f
CWis_info
fP
zero
the
f
CWoffset
fP
must
refer
to
a
debug_types
section
offset
Error
returns
or
misleading
values
may
result
if
the
f
CWis_info
fP
flag
or
the
f
CWoffset
fP
value
are
incorrect
in
FG
Example6
dwarf_offdie_b
DS
f
CW
void
example6
Dwarf_Debug
dbg
Dwarf_Off
die_offset
Dwarf_Bool
is_info
Dwarf_Error
error
Dwarf_Die
return_die
int
res
res
dwarf_offdie_b
dbg
die_offset
is_info
if
res
DW_DLV_OK
Use
return_die
here
dwarf_dealloc_die
return_die
The
original
form
still
works
dwarf_dealloc
dbg
return_die
DW_DLA_DIE
return_die
is
no
longer
usable
for
anything
we
ensure
we
do
not
use
it
accidentally
with
return_die
else
res
could
be
NO
ENTRY
or
ERROR
so
no
dealloc
necessary
fP
DE
in
H
dwarf_validate_die_sibling
DS
f
CWint
validate_die_sibling
Dwarf_Die
sibling
Dwarf_Off
offset
fP
DE
When
used
correctly
in
a
depth
first
walk
of
a
DIE
tree
this
function
validates
that
any
DW_AT_sibling
attribute
gives
the
same
offset
as
the
direct
tree
walk
That
is
the
only
purpose
of
this
function
The
function
f
CWdwarf_validate_die_sibling
fP
returns
f
CWDW_DLV_OK
fP
if
the
last
die
processed
in
a
depth
first
DIE
tree
walk
was
the
same
offset
as
generated
by
a
call
to
f
CWdwarf_siblingof
fP
Meaning
that
the
DW_AT_sibling
attribute
value
if
any
was
correct
If
the
conditions
are
not
met
then
DW_DLV_ERROR
is
returned
and
f
CW
offset
fP
is
set
to
the
offset
in
the
debug_info
section
of
the
last
DIE
processed
If
the
application
prints
the
offset
a
knowledgeable
user
may
be
able
to
figure
out
what
the
compiler
did
wrong
H
Debugging
Information
Entry
Query
Operations
These
queries
return
specific
information
about
debugging
information
entries
or
a
descriptor
that
can
be
used
on
subsequent
queries
when
given
a
f
CWDwarf_Die
fP
descriptor
Note
that
some
operations
are
specific
to
debugging
information
entries
that
are
represented
by
a
f
CWDwarf_Die
fP
descriptor
of
a
specific
type
For
example
not
all
debugging
information
entries
contain
an
attribute
having
a
name
so
consequently
a
call
to
f
CWdwarf_diename
fP
using
a
f
CWDwarf_Die
fP
descriptor
that
does
not
have
a
name
attribute
will
return
f
CWDW_DLV_NO_ENTRY
fP
This
is
not
an
error
i
e
calling
a
function
that
needs
a
specific
attribute
is
not
an
error
for
a
die
that
does
not
contain
that
specific
attribute
P
There
are
several
methods
that
can
be
used
to
obtain
the
value
of
an
attribute
in
a
given
die
AL
LI
Call
f
CWdwarf_hasattr
fP
to
determine
if
the
debugging
information
entry
has
the
attribute
of
interest
prior
to
issuing
the
query
for
information
about
the
attribute
LI
Supply
an
f
CWerror
fP
argument
and
check
its
value
after
the
call
to
a
query
indicates
an
unsuccessful
return
to
determine
the
nature
of
the
problem
The
f
CWerror
fP
argument
will
indicate
whether
an
error
occurred
or
the
specific
attribute
needed
was
missing
in
that
die
LI
Arrange
to
have
an
error
handling
function
invoked
upon
detection
of
an
error
see
f
CWdwarf_init_b
fP
LI
Call
f
CWdwarf_attrlist
fP
and
iterate
through
the
returned
list
of
attributes
dealing
with
each
one
as
appropriate
LE
P
H
dwarf_get_die_infotypes_flag
DS
f
CWDwarf_Bool
dwarf_get_die_infotypes_flag
Dwarf_Die
die
fP
DE
P
The
function
f
CWdwarf_get_die_infotypes_flag
fP
returns
the
section
flag
indicating
which
section
the
DIE
originates
from
If
the
returned
value
is
non
zero
the
DIE
originates
from
the
debug_info
section
If
the
returned
value
is
zero
the
DIE
originates
from
the
debug_types
section
H
dwarf_cu_header_basics
DS
f
CWint
dwarf_cu_header_basics
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Bool
is_info
Dwarf_Bool
is_dwo
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Off
offset_of_length
Dwarf_Unsigned
total_byte_length
Dwarf_Error
error
fP
DE
P
On
success
the
function
f
CWcu_header_basics
fP
various
data
items
from
the
CU
header
and
the
CU
die
passed
in
Any
return
value
pointer
may
be
passed
in
as
NULL
indicating
that
the
value
is
not
needed
P
Summing
f
CWoffset_size
fP
and
f
CWextension_size
fP
gives
the
length
of
the
CU
length
field
which
is
immediately
followed
by
the
CU
header
P
f
CWis_dwo
fP
field
will
surely
always
be
as
dwo
dwp
debug_info
cannot
be
skeleton
CUs
P
The
f
CWsignature
fP
value
is
returned
if
there
a
signature
in
the
DWARF5
CU
header
or
the
CU
die
P
The
f
CWoffset_of_length
fP
returned
is
the
offset
of
the
first
byte
of
the
length
field
of
the
CU
P
The
f
CWtotal_byte_Length
fP
returned
is
the
length
of
data
in
the
CU
counting
from
the
first
byte
at
f
CWoffset_of_length
fP
H
dwarf_tag
DS
f
CWint
dwarf_tag
Dwarf_Die
die
Dwarf_Half
tagval
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_tag
fP
returns
the
f
CWtag
fP
of
f
CWdie
fP
through
the
pointer
f
CWtagval
fP
if
it
succeeds
It
returns
f
CWDW_DLV_OK
fP
if
it
succeeds
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_dieoffset
DS
f
CWint
dwarf_dieoffset
Dwarf_Die
die
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
When
it
succeeds
the
function
f
CWdwarf_dieoffset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
position
of
f
CWdie
fP
in
the
section
containing
debugging
information
entries
the
f
CWreturn_offset
fP
is
a
section
relative
offset
In
other
words
it
sets
f
CWreturn_offset
fP
to
the
offset
of
the
start
of
the
debugging
information
entry
described
by
f
CWdie
fP
in
the
section
containing
dies
i
e
debug_info
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_addr_form_is_indexed
f
CWdwarf_addr_form_is_indexed
form
fP
is
a
utility
function
to
make
it
simple
to
determine
if
a
form
is
one
of
the
indexed
forms
there
are
several
such
in
DWARF5
See
DWARF5
section
f
CWClasses
and
Forms
fP
for
more
information
DS
int
dwarf_addr_form_is_indexed
Dwarf_Half
form
DE
It
returns
TRUE
if
the
form
is
one
of
the
indexed
address
forms
such
as
DW_FORM_addrx1
and
FALSE
otherwise
H
dwarf_debug_addr_index_to_addr
DS
int
dwarf_debug_addr_index_to_addr
Dwarf_Die
die
Dwarf_Unsigned
index
Dwarf_Addr
return_addr
Dwarf_Error
error
DE
Attributes
with
form
DW_FORM_addrx
the
operation
DW_OP_addrx
or
certain
of
the
split
dwarf
location
list
entries
give
an
index
value
to
a
machine
address
in
the
debug_addr
section
which
is
always
in
debug_addr
even
when
the
form
operation
are
in
a
split
dwarf
dwo
section
P
On
successful
return
this
function
turns
such
an
index
into
a
target
address
value
through
the
pointer
f
CWreturn_addr
fP
P
If
there
is
an
error
this
may
return
DW_
f
CWDW_DLV_ERROR
fP
and
it
will
have
returned
an
error
through
f
CW
error
fP
P
If
there
is
no
available
debug_addr
section
this
may
return
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_die_CU_offset
DS
f
CWint
dwarf_die_CU_offset
Dwarf_Die
die
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_die_CU_offset
fP
is
similar
to
f
CWdwarf_dieoffset
fP
except
that
it
puts
the
offset
of
the
DIE
represented
by
the
f
CWDwarf_Die
fP
f
CWdie
fP
from
the
start
of
the
compilation
unit
that
it
belongs
to
rather
than
the
start
of
debug_info
the
f
CWreturn_offset
fP
is
a
CU
relative
offset
H
dwarf_die_offsets
DS
f
CWint
dwarf_die_offsets
Dwarf_Die
die
Dwarf_Off
global_off
Dwarf_Off
cu_off
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_die_offsets
fP
is
a
combination
of
f
CWdwarf_dieoffset
fP
and
f
CWdwarf_die_cu_offset
fP
in
that
it
returns
both
the
global
debug_info
offset
and
the
CU
relative
offset
of
the
f
CWdie
fP
in
a
single
call
H
dwarf_ptr_CU_offset
DS
f
CWint
dwarf_ptr_CU_offset
Dwarf_CU_Context
cu_context
Dwarf_Byte_ptr
di_ptr
Dwarf_Off
cu_off
fP
DE
Given
a
valid
CU
context
pointer
and
a
pointer
into
that
CU
context
the
function
f
CWdwarf_ptr_CU_offset
fP
returns
DW_DLV_OK
and
sets
f
CW
cu_off
fP
to
the
CU
relative
local
offset
in
that
CU
H
dwarf_CU_dieoffset_given_die
DS
f
CWint
dwarf_CU_dieoffset_given_die
Dwarf_Die
given_die
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_CU_dieoffset_given_die
fP
is
similar
to
f
CWdwarf_die_CU_offset
fP
except
that
it
puts
the
global
offset
of
the
CU
DIE
owning
f
CWgiven_die
fP
of
debug_info
the
f
CWreturn_offset
fP
is
a
global
section
offset
P
This
is
useful
when
processing
a
DIE
tree
and
encountering
an
error
or
other
surprise
in
a
DIE
as
the
f
CWreturn_offset
fP
can
be
passed
to
f
CWdwarf_offdie_b
fP
to
return
a
pointer
to
the
CU
die
of
the
CU
owning
the
f
CWgiven_die
fP
passed
to
f
CWdwarf_CU_dieoffset_given_die
fP
The
consumer
can
extract
information
from
the
CU
die
and
the
f
CWgiven_die
fP
in
the
normal
way
and
print
it
An
example
a
snippet
of
code
using
this
function
follows
It
assumes
that
f
CWin_die
fP
is
a
DIE
in
debug_info
that
for
some
reason
you
have
decided
needs
CU
context
printed
assuming
f
CWprint_die_data
fP
does
some
reasonable
printing
in
FG
Example7
dwarf_CU_dieoffset_given_die
DS
f
CW
void
example7
Dwarf_Debug
dbg
Dwarf_Die
in_die
Dwarf_Bool
is_info
int
res
Dwarf_Off
cudieoff
Dwarf_Die
cudie
Dwarf_Error
error
res
dwarf_CU_dieoffset_given_die
in_die
if
res
DW_DLV_OK
FAIL
return
res
dwarf_offdie_b
dbg
cudieoff
is_info
if
res
DW_DLV_OK
FAIL
return
do
something
with
cu_die
dwarf_dealloc_die
cudie
The
original
form
still
works
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
fPy
DE
in
H
dwarf_die_CU_offset_range
DS
f
CWint
dwarf_die_CU_offset_range
Dwarf_Die
die
Dwarf_Off
cu_global_offset
Dwarf_Off
cu_length
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_die_CU_offset_range
fP
returns
the
offset
of
the
beginning
of
the
CU
and
the
length
of
the
CU
The
offset
and
length
are
of
the
entire
CU
that
this
DIE
is
a
part
of
It
is
used
by
dwarfdump
for
example
to
check
the
validity
of
offsets
Most
applications
will
have
no
reason
to
call
this
function
H
dwarf_diename
DS
f
CWint
dwarf_diename
Dwarf_Die
die
char
return_name
Dwarf_Error
error
fP
DE
When
it
succeeds
the
function
f
CWdwarf_diename
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
of
characters
that
represents
the
name
attribute
f
CWDW_AT_name
fP
of
f
CWdie
fP
P
The
storage
pointed
to
by
a
successful
return
of
f
CWdwarf_diename
fP
should
not
be
freed
as
the
text
is
a
string
in
static
memory
for
some
error
cases
or
a
string
residing
in
a
DWARF
data
section
P
Up
to
March
this
document
said
that
dwarf_dealloc
with
DW_DLA_STRING
should
be
applied
to
the
string
returned
through
the
pointer
That
was
always
incorrect
However
doing
the
dwarf_dealloc
dbg
xxx
DW_DLA_STRING
that
was
previously
called
for
does
not
result
in
any
error
dwarf_dealloc
avoids
freeing
strings
like
this
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
have
a
name
attribute
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_die_text
DS
f
CWint
dwarf_die_text
Dwarf_Die
die
Dwarf_Half
attrnum
char
return_name
Dwarf_Error
error
fP
DE
When
it
succeeds
the
function
f
CWdwarf_die_text
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
of
characters
that
represents
a
string
value
attribute
of
f
CWdie
fP
if
an
attribute
f
CWattrnum
fP
is
present
P
The
storage
pointed
to
by
a
successful
return
of
f
CWdwarf_die_text
fP
must
never
be
freed
the
string
is
in
the
DWARF
data
and
is
not
dynamically
allocated
P
As
of
March
the
description
here
has
been
corrected
f
CWdwarf_dealloc
fP
should
never
have
been
applied
to
a
string
returned
by
f
CWdwarf_die_text
fP
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
have
the
attribute
f
CWattrnum
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_die_abbrev_code
DS
f
CWint
dwarf_die_abbrev_code
Dwarf_Die
die
fP
DE
The
function
returns
the
abbreviation
code
of
the
DIE
That
is
it
returns
the
abbreviation
index
into
the
abbreviation
table
for
the
compilation
unit
of
which
the
DIE
is
a
part
It
cannot
fail
No
errors
are
possible
The
pointer
f
CWdie
fP
must
not
be
NULL
H
dwarf_die_abbrev_children_flag
DS
f
CWint
dwarf_die_abbrev_children_flag
Dwarf_Die
die
Dwarf_Half
has_child
fP
DE
The
function
returns
the
has
children
flag
of
the
f
CWdie
fP
passed
in
through
the
f
CW
has_child
fP
passed
in
and
returns
f
CWDW_DLV_OK
fP
on
success
A
non
zero
value
of
f
CW
has_child
fP
means
the
f
CWdie
fP
has
children
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
The
function
was
developed
to
let
consumer
code
do
better
error
reporting
in
some
circumstances
it
is
not
generally
needed
H
dwarf_die_abbrev_global_offset
DS
f
CWint
dwarf_die_abbrev_global_offset
Dwarf_Die
die
Dwarf_Off
abbrev_offset
Dwarf_Unsigned
abbrev_count
Dwarf_Error
error
fP
DE
The
function
allows
more
detailed
printing
of
abbreviation
data
It
is
handy
for
analyzing
abbreviations
but
is
not
normally
needed
by
applications
The
function
first
appears
in
March
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
abbrev_offset
fP
to
the
global
offset
in
the
f
CW
debug_abbrev
fP
section
of
the
abbreviation
It
also
sets
f
CW
abbrev_count
fP
to
the
number
of
attribute
form
pairs
in
the
abbreviation
entry
It
is
possible
though
unusual
for
the
count
to
be
zero
meaning
there
is
abbreviation
instance
and
a
TAG
instance
which
have
no
attributes
P
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
P
It
should
never
return
f
CWDW_DLV_NO_ENTRY
fP
but
callers
should
allow
for
that
possibility
H
dwarf_get_version_of_die
DS
f
CWint
dwarf_get_version_of_die
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Half
offset_size
fP
DE
The
function
returns
the
CU
context
version
through
f
CW
version
fP
and
the
CU
context
offset
size
through
f
CW
offset_size
fP
and
returns
f
CWDW_DLV_OK
fP
on
success
In
case
of
error
the
only
errors
possible
involve
an
inappropriate
NULL
f
CWdie
fP
pointer
so
no
Dwarf_Debug
pointer
is
available
Therefore
setting
a
Dwarf_Error
would
not
be
very
meaningful
there
is
no
Dwarf_Debug
to
attach
it
to
The
function
returns
DW_DLV_ERROR
on
error
The
values
returned
through
the
pointers
are
the
values
two
arguments
to
dwarf_get_form_class
requires
H
dwarf_attrlist
DS
f
CWint
dwarf_attrlist
Dwarf_Die
die
Dwarf_Attribute
attrbuf
Dwarf_Signed
attrcount
Dwarf_Error
error
fP
DE
When
it
returns
f
CWDW_DLV_OK
fP
the
function
f
CWdwarf_attrlist
fP
sets
f
CWattrbuf
fP
to
point
to
an
array
of
f
CWDwarf_Attribute
fP
descriptors
corresponding
to
each
of
the
attributes
in
die
and
returns
the
number
of
elements
in
the
array
through
f
CWattrcount
fP
f
CWDW_DLV_NO_ENTRY
fP
is
returned
if
the
count
is
zero
no
f
CWattrbuf
fP
is
allocated
in
this
case
f
CWDW_DLV_ERROR
fP
is
returned
on
error
On
a
successful
return
from
f
CWdwarf_attrlist
fP
each
of
the
f
CWDwarf_Attribute
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ATTR
fP
followed
by
free
ing
the
list
pointed
to
by
f
CW
attrbuf
fP
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
no
longer
of
interest
see
f
CWdwarf_dealloc
fP
Freeing
the
attrlist
in
FG
Example8
dwarf_attrlist
free
DS
f
CW
void
example8
Dwarf_Debug
dbg
Dwarf_Die
somedie
Dwarf_Signed
atcount
Dwarf_Attribute
atlist
Dwarf_Error
error
int
errv
errv
dwarf_attrlist
somedie
if
errv
DW_DLV_OK
Dwarf_Signed
i
for
i
i
atcount
i
use
atlist
i
dwarf_dealloc_attribute
atlist
i
The
original
form
still
works
dwarf_dealloc
dbg
atlist
i
DW_DLA_ATTR
dwarf_dealloc
dbg
atlist
DW_DLA_LIST
fP
DE
in
P
H
dwarf_hasattr
DS
f
CWint
dwarf_hasattr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
When
it
succeeds
the
function
f
CWdwarf_hasattr
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_bool
fP
to
fInon
zero
fP
if
f
CWdie
fP
has
the
attribute
f
CWattr
fP
and
fIzero
fP
otherwise
If
it
fails
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_attr
DS
f
CWint
dwarf_attr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Attribute
return_attr
Dwarf_Error
error
fP
DE
P
When
it
returns
f
CWDW_DLV_OK
fP
the
function
f
CWdwarf_attr
fP
sets
f
CW
return_attr
fP
to
the
f
CWDwarf_Attribute
fP
descriptor
of
f
CWdie
fP
having
the
attribute
f
CWattr
fP
When
one
no
longer
needs
the
attribute
call
f
CWdwarf_dealloc_attribute
return_attr
fP
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWattr
fP
is
not
contained
in
f
CWdie
fP
P
It
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
error
argument
if
an
error
occurred
H
dwarf_lowpc
DS
f
CWint
dwarf_lowpc
Dwarf_Die
die
Dwarf_Addr
return_lowpc
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lowpc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_lowpc
fP
to
the
low
program
counter
value
associated
with
the
f
CWdie
fP
descriptor
if
f
CWdie
fP
represents
a
debugging
information
entry
with
the
f
CWDW_AT_low_pc
fP
attribute
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
have
this
attribute
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_highpc_b
DS
f
CWint
dwarf_highpc_b
Dwarf_Die
die
Dwarf_Addr
return_highpc
Dwarf_Half
return_form
enum
Dwarf_Form_Class
return_class
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_highpc_b
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_highpc
fP
to
the
value
of
the
f
CWDW_AT_high_pc
fP
attribute
It
also
sets
f
CW
return_form
fP
to
the
FORM
of
the
attribute
Beginning
April
f
CWreturn_form
fP
will
not
be
used
to
return
the
form
class
if
f
CWreturn_form
fP
is
null
Be
cautious
using
a
null
argument
unless
you
know
that
only
a
suitably
recent
version
of
libdwarf
will
be
used
It
sets
f
CW
return_class
fP
to
the
form
class
of
the
attribute
Beginning
April
f
CWreturn_class
fP
will
not
be
used
to
return
the
form
class
if
f
CWreturn_class
fP
is
null
Be
cautious
using
a
null
argument
unless
you
know
that
only
a
suitably
recent
version
of
libdwarf
will
be
used
If
the
form
class
returned
is
f
CWDW_FORM_CLASS_ADDRESS
fP
the
f
CWreturn_highpc
fP
is
an
actual
pc
address
higher
than
the
address
of
the
last
pc
in
the
address
range
If
the
form
class
returned
is
f
CWDW_FORM_CLASS_CONSTANT
fP
the
f
CWreturn_highpc
fP
is
an
offset
from
the
value
of
the
the
DIE
s
low
PC
address
see
DWARF4
section
Contiguous
Address
Range
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
have
the
f
CWDW_AT_high_pc
fP
attribute
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_highpc
DS
f
CWint
dwarf_highpc
Dwarf_Die
die
Dwarf_Addr
return_highpc
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_highpc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_highpc
fP
the
high
program
counter
value
associated
with
the
f
CWdie
fP
descriptor
if
f
CWdie
fP
represents
a
debugging
information
entry
with
the
f
CWDW_AT_high_pc
attribute
fP
and
the
form
is
f
CWDW_FORM_addr
fP
meaning
the
form
is
of
class
address
P
This
function
is
useless
for
a
f
CWDW_AT_high_pc
fP
which
is
encoded
as
a
constant
which
was
first
possible
in
DWARF4
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
have
this
attribute
P
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
or
if
the
form
is
not
of
class
address
H
dwarf_dietype_offset
DS
f
CWint
dwarf_dietype_offset
Dwarf_Die
die
Dwarf_Off
return_off
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_dietype_offset
fP
returns
the
offset
referred
to
by
f
CWDW_AT_type
fP
attribute
of
f
CWdie
fP
P
f
CWDW_DLV_NO_ENTRY
fP
is
returned
if
the
f
CWdie
fP
has
no
f
CWDW_AT_type
fP
attribute
P
f
CWDW_DLV_ERROR
fP
is
returned
if
an
error
is
detected
P
This
feature
was
introduced
in
February
H
dwarf_offset_list
DS
f
CWint
dwarf_offset_list
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Off
offbuf
Dwarf_Unsigned
offcnt
Dwarf_Error
error
DE
On
success
The
function
f
CWdwarf_offset_list
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
offbuf
fP
to
point
to
an
array
of
the
offsets
of
the
direct
children
of
the
die
at
f
CWoffset
fP
It
sets
f
CW
offcnt
fP
to
point
to
the
count
of
entries
in
the
f
CWoffset
fP
array
P
In
case
of
error
it
returns
f
CWDW_DLV_OK
fP
P
It
does
not
return
f
CWDW_DLV_NO_ENTRY
fP
but
callers
should
allow
for
that
possibility
anyway
P
This
feature
was
introduced
in
March
P
Freeing
the
offset_list
is
done
as
follows
in
FG
Exampleoffset_list
dwarf_offset_list
free
DS
f
CW
void
exampleoffset_list
Dwarf_Debug
dbg
Dwarf_Off
dieoffset
Dwarf_Bool
is_info
Dwarf_Unsigned
offcnt
Dwarf_Off
offbuf
Dwarf_Error
error
int
errv
errv
dwarf_offset_list
dbg
dieoffset
is_info
if
errv
DW_DLV_OK
Dwarf_Unsigned
i
for
i
i
offcnt
i
use
offbuf
i
dwarf_dealloc
dbg
offbuf
DW_DLA_LIST
fP
DE
in
P
H
dwarf_bytesize
DS
f
CWDwarf_Signed
dwarf_bytesize
Dwarf_Die
die
Dwarf_Unsigned
return_size
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_bytesize
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_size
fP
to
the
number
of
bytes
needed
to
contain
an
instance
of
the
aggregate
debugging
information
entry
represented
by
f
CWdie
fP
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
contain
the
byte
size
attribute
f
CWDW_AT_byte_size
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_bitsize
DS
f
CWint
dwarf_bitsize
Dwarf_Die
die
Dwarf_Unsigned
return_size
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_bitsize
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_size
fP
to
the
number
of
bits
occupied
by
the
bit
field
value
that
is
an
attribute
of
the
given
die
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
contain
the
bit
size
attribute
f
CWDW_AT_bit_size
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_bitoffset
DS
f
CWint
dwarf_bitoffset
Dwarf_Die
die
Dwarf_Unsigned
return_size
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_bitoffset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_size
fP
to
the
number
of
bits
to
the
left
of
the
most
significant
bit
of
the
bit
field
value
This
bit
offset
is
not
necessarily
the
net
bit
offset
within
the
structure
or
class
since
f
CWDW_AT_data_member_location
fP
may
give
a
byte
offset
to
this
f
CWDIE
fP
and
the
bit
offset
returned
through
the
pointer
does
not
include
the
bits
in
the
byte
offset
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
contain
the
bit
offset
attribute
f
CWDW_AT_bit_offset
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_srclang
DS
f
CWint
dwarf_srclang
Dwarf_Die
die
Dwarf_Unsigned
return_lang
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_srclang
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_lang
fP
to
a
code
indicating
the
source
language
of
the
compilation
unit
represented
by
the
descriptor
f
CWdie
fP
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
represent
a
source
file
debugging
information
entry
i
e
contain
the
attribute
f
CWDW_AT_language
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
dwarf_arrayorder
DS
f
CWint
dwarf_arrayorder
Dwarf_Die
die
Dwarf_Unsigned
return_order
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_arrayorder
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_order
fP
a
code
indicating
the
ordering
of
the
array
represented
by
the
descriptor
f
CWdie
fP
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWdie
fP
does
not
contain
the
array
order
attribute
f
CWDW_AT_ordering
fP
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
H
Attribute
Queries
Based
on
the
attributes
form
these
operations
are
concerned
with
returning
uninterpreted
attribute
data
Since
it
is
not
always
obvious
from
the
return
value
of
these
functions
if
an
error
occurred
one
should
always
supply
an
f
CWerror
fP
parameter
or
have
arranged
to
have
an
error
handling
function
invoked
see
f
CWdwarf_init_b
fP
to
determine
the
validity
of
the
returned
value
and
the
nature
of
any
errors
that
may
have
occurred
A
f
CWDwarf_Attribute
fP
descriptor
describes
an
attribute
of
a
specific
die
Thus
each
f
CWDwarf_Attribute
fP
descriptor
is
implicitly
associated
with
a
specific
die
H
dwarf_hasform
DS
f
CWint
dwarf_hasform
Dwarf_Attribute
attr
Dwarf_Half
form
Dwarf_Bool
return_hasform
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_hasform
fP
returns
f
CWDW_DLV_OK
fP
and
and
puts
a
fInon
zero
fP
value
in
the
f
CW
return_hasform
fP
boolean
if
the
attribute
represented
by
the
f
CWDwarf_Attribute
fP
descriptor
f
CWattr
fP
has
the
attribute
form
f
CWform
fP
If
the
attribute
does
not
have
that
form
fIzero
fP
is
put
into
f
CW
return_hasform
fP
f
CWDW_DLV_ERROR
fP
is
returned
on
error
H
dwarf_whatform
DS
f
CWint
dwarf_whatform
Dwarf_Attribute
attr
Dwarf_Half
return_form
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_whatform
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_form
fP
to
the
attribute
form
code
of
the
attribute
represented
by
the
f
CWDwarf_Attribute
fP
descriptor
f
CWattr
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
An
attribute
using
DW_FORM_indirect
effectively
has
two
forms
This
function
returns
the
final
form
for
f
CWDW_FORM_indirect
fP
not
the
f
CWDW_FORM_indirect
fP
itself
This
function
is
what
most
applications
will
want
to
call
H
dwarf_whatform_direct
DS
f
CWint
dwarf_whatform_direct
Dwarf_Attribute
attr
Dwarf_Half
return_form
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_whatform_direct
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_form
fP
to
the
attribute
form
code
of
the
attribute
represented
by
the
f
CWDwarf_Attribute
fP
descriptor
f
CWattr
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
An
attribute
using
f
CWDW_FORM_indirect
fP
effectively
has
two
forms
This
returns
the
form
directly
in
the
initial
form
field
That
is
it
returns
the
initial
form
of
the
attribute
P
So
when
the
form
field
is
f
CWDW_FORM_indirect
fP
this
call
returns
the
f
CWDW_FORM_indirect
fP
form
which
is
sometimes
useful
for
dump
utilities
P
It
is
confusing
that
the
_direct
function
returns
DW_FORM_indirect
if
an
indirect
form
is
involved
Just
think
of
this
as
returning
the
initial
form
the
first
form
value
seen
for
the
attribute
which
is
also
the
final
form
unless
the
initial
form
is
f
CWDW_FORM_indirect
fP
H
dwarf_whatattr
DS
f
CWint
dwarf_whatattr
Dwarf_Attribute
attr
Dwarf_Half
return_attr
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_whatattr
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_attr
fP
to
the
attribute
code
represented
by
the
f
CWDwarf_Attribute
fP
descriptor
f
CWattr
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_formref
DS
f
CWint
dwarf_formref
Dwarf_Attribute
attr
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_formref
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
CU
relative
offset
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWREFERENCE
fP
class
f
CWattr
fP
must
be
a
CU
local
reference
not
form
f
CWDW_FORM_ref_addr
fP
and
not
f
CWDW_FORM_sec_offset
fP
It
is
an
error
for
the
form
to
not
belong
to
the
f
CWREFERENCE
fP
class
It
returns
f
CWDW_DLV_ERROR
fP
on
error
Beginning
November
All
f
CWDW_DLV_ERROR
fP
returns
set
f
CW
return_offset
fP
Most
errors
set
f
CW
return_offset
fP
to
zero
but
for
error
f
CWDW_DLE_ATTR_FORM_OFFSET_BAD
fP
the
function
sets
f
CW
return_offset
fP
to
the
invalid
offset
which
allows
the
caller
to
print
a
more
detailed
error
message
See
also
f
CWdwarf_global_formref
fP
below
H
dwarf_global_formref
DS
f
CWint
dwarf_global_formref
Dwarf_Attribute
attr
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_global_formref
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
section
relative
offset
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWREFERENCE
fP
or
other
section
references
classes
P
f
CWattr
fP
can
be
any
legal
f
CWREFERENCE
fP
class
form
plus
f
CWDW_FORM_ref_addr
fP
or
f
CWDW_FORM_sec_offset
fP
It
is
an
error
for
the
form
to
not
belong
to
one
of
the
reference
classes
It
returns
f
CWDW_DLV_ERROR
fP
on
error
See
also
f
CWdwarf_formref
fP
above
P
The
caller
must
determine
which
section
the
offset
returned
applies
to
The
function
f
CWdwarf_get_form_class
fP
is
useful
to
determine
the
applicable
section
P
The
function
converts
CU
relative
offsets
from
forms
such
as
DW_FORM_ref4
into
global
section
offsets
H
dwarf_convert_to_global_offset
DS
f
CWint
dwarf_convert_to_global_offset
Dwarf_Attribute
attr
Dwarf_Off
offset
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_convert_to_global_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
section
relative
offset
represented
by
the
cu
relative
offset
f
CWoffset
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWREFERENCE
fP
class
f
CWattr
fP
must
be
a
CU
local
reference
DWARF
class
REFERENCE
or
form
f
CWDW_FORM_ref_addr
fP
and
the
f
CWattr
fP
must
be
directly
relevant
for
the
calculated
f
CW
return_offset
fP
to
mean
anything
The
function
returns
f
CWDW_DLV_ERROR
fP
on
error
The
function
is
not
strictly
necessary
but
may
be
a
convenience
for
attribute
printing
in
case
of
error
H
dwarf_formaddr
DS
f
CWint
dwarf_formaddr
Dwarf_Attribute
attr
Dwarf_Addr
return_addr
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_formaddr
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_addr
fP
to
the
address
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWADDRESS
fP
class
It
is
an
error
for
the
form
to
not
belong
to
this
class
It
returns
f
CWDW_DLV_ERROR
fP
on
error
One
possible
error
that
can
arise
in
a
dwo
object
file
or
a
dwp
package
file
is
f
CWDW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
fP
Such
an
error
means
that
the
dwo
or
dwp
file
is
missing
the
f
CW
debug_addr
fP
section
When
opening
a
dwo
object
file
or
a
dwp
package
file
one
should
also
open
the
corresponding
executable
and
use
f
CWdwarf_set_tied_dbg
fP
to
associate
the
objects
before
calling
dwarf_formaddr
H
dwarf_get_debug_addr_index
DS
f
CWint
dwarf_get_debug_addr_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
fP
DE
f
CWdwarf_get_debug_addr_index
fP
is
only
valid
on
attributes
with
form
f
CWDW_FORM_GNU_addr_index
fP
or
f
CWDW_FORM_addrx
fP
The
function
makes
it
possible
to
print
the
index
from
a
dwarf
dumper
program
When
it
succeeds
f
CWdwarf_get_debug_addr_index
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_index
fP
to
the
attribute
s
index
into
the
f
CW
debug_addr
fP
section
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_get_debug_str_index
DS
f
CWint
dwarf_get_debug_str_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
fP
DE
P
For
an
attribute
with
form
f
CWDW_FORM_strx
fP
or
f
CWDW_FORM_GNU_str_index
fP
this
function
retrieves
the
index
which
refers
to
a
debug_str_offsets
section
in
this
dwo
P
If
successful
the
function
f
CWdwarf_get_debug_str_index
fP
returns
f
CWDW_DLV_OK
fP
and
returns
the
index
through
the
f
CWreturn_index
fP
pointer
P
If
the
passed
in
attribute
does
not
have
this
form
or
there
is
no
valid
compilation
unit
context
for
the
attribute
the
function
returns
f
CWDW_DLV_ERROR
fP
P
f
CWDW_DLV_NO_ENTRY
fP
is
not
returned
H
dwarf_formflag
DS
f
CWint
dwarf_formflag
Dwarf_Attribute
attr
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_formflag
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_bool
fP
to
the
one
unsigned
byte
flag
value
Any
non
zero
value
means
true
A
zero
value
means
false
Before
November
this
would
only
return
or
zero
through
the
pointer
but
that
was
always
a
strange
thing
to
do
The
DWARF
specification
has
always
been
clear
that
any
non
zero
value
means
true
The
function
should
report
the
value
found
truthfully
and
now
it
does
It
returns
f
CWDW_DLV_ERROR
fP
on
error
or
if
the
f
CWattr
fP
does
not
have
form
flag
H
dwarf_formudata
DS
f
CWint
dwarf_formudata
Dwarf_Attribute
attr
Dwarf_Unsigned
return_uvalue
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formudata
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_uvalue
fP
to
the
f
CWDwarf_Unsigned
fP
value
of
the
attribute
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWCONSTANT
fP
class
and
and
the
value
is
non
negative
if
the
form
is
DW_FORM_sdata
for
example
but
the
value
is
non
negative
the
non
negative
value
is
returned
If
the
data
is
definitely
a
signed
type
the
form
will
be
DW_FORM_sdata
It
is
an
error
for
the
form
to
not
belong
to
this
class
or
in
case
the
FORM
is
a
signed
form
for
the
value
to
be
negative
It
returns
f
CWDW_DLV_ERROR
fP
on
error
The
function
never
returns
f
CWDW_DLV_NO_ENTRY
fP
For
DWARF2
and
DWARF3
f
CWDW_FORM_data4
fP
and
f
CWDW_FORM_data8
fP
are
possibly
class
f
CWCONSTANT
fP
and
for
DWARF4
and
later
they
are
definitely
class
f
CWCONSTANT
fP
H
dwarf_formsdata
DS
f
CWint
dwarf_formsdata
Dwarf_Attribute
attr
Dwarf_Signed
return_svalue
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formsdata
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_svalue
fP
to
the
f
CWDwarf_Signed
fP
value
of
the
attribute
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWCONSTANT
fP
class
It
is
an
error
for
the
form
to
not
belong
to
this
class
If
the
size
of
the
data
attribute
referenced
is
smaller
than
the
size
of
the
f
CWDwarf_Signed
fP
type
its
value
is
sign
extended
It
returns
f
CWDW_DLV_ERROR
fP
on
error
Never
returns
f
CWDW_DLV_NO_ENTRY
fP
For
DWARF2
and
DWARF3
f
CWDW_FORM_data4
fP
and
f
CWDW_FORM_data8
fP
are
possibly
class
f
CWCONSTANT
fP
and
for
DWARF4
and
later
they
are
definitely
class
f
CWCONSTANT
fP
H
dwarf_formblock
DS
f
CWint
dwarf_formblock
Dwarf_Attribute
attr
Dwarf_Block
return_block
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formblock
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_block
fP
to
a
pointer
to
a
f
CWDwarf_Block
fP
structure
containing
the
value
of
the
attribute
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWBLOCK
fP
class
It
is
an
error
for
the
form
to
not
belong
to
this
class
The
storage
pointed
to
by
a
successful
return
of
f
CWdwarf_formblock
fP
should
be
freed
using
the
allocation
type
f
CWDW_DLA_BLOCK
fP
when
no
longer
of
interest
see
f
CWdwarf_dealloc
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_formstring
DS
f
CWint
dwarf_formstring
Dwarf_Attribute
attr
char
return_string
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formstring
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_string
fP
to
a
pointer
to
a
null
terminated
string
containing
the
value
of
the
attribute
represented
by
the
descriptor
f
CWattr
fP
if
the
form
of
the
attribute
belongs
to
the
f
CWSTRING
fP
class
It
is
an
error
for
the
form
to
not
belong
to
this
class
P
The
storage
pointed
to
by
a
successful
return
of
f
CWdwarf_formstring
fP
should
not
be
freed
The
pointer
points
into
existing
DWARF
memory
and
the
pointer
becomes
stale
invalid
after
a
call
to
f
CWdwarf_finish
fP
f
CWdwarf_formstring
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_formsig8
DS
f
CWint
dwarf_formsig8
Dwarf_Attribute
attr
Dwarf_Sig8
return_sig8
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formsig8
fP
returns
f
CWDW_DLV_OK
fP
and
copies
the
byte
signature
to
a
f
CWDwarf_Sig8
fP
structure
provided
by
the
caller
if
the
form
of
the
attribute
is
of
form
f
CWDW_FORM_ref_sig8
fP
a
member
of
the
f
CWREFERENCE
fP
class
It
is
an
error
for
the
form
to
be
anything
but
f
CWDW_FORM_ref_sig8
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
P
This
form
is
used
to
refer
to
a
type
unit
H
dwarf_formexprloc
DS
f
CWint
dwarf_formexprloc
Dwarf_Attribute
attr
Dwarf_Unsigned
return_exprlen
Dwarf_Ptr
block_ptr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_formexprloc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
the
two
values
thru
the
pointers
to
the
length
and
bytes
of
the
DW_FORM_exprloc
entry
if
the
form
of
the
attribute
is
of
form
f
CWDW_FORM_experloc
fP
It
is
an
error
for
the
form
to
be
anything
but
f
CWDW_FORM_exprloc
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
P
On
success
the
value
set
through
the
f
CWreturn_exprlen
fP
pointer
is
the
length
of
the
location
expression
On
success
the
value
set
through
the
f
CWblock_ptr
fP
pointer
is
a
pointer
to
the
bytes
of
the
location
expression
itself
H
dwarf_get_form_class
DS
f
CWenum
Dwarf_Form_Class
dwarf_get_form_class
Dwarf_Half
dwversion
Dwarf_Half
attrnum
Dwarf_Half
offset_size
Dwarf_Half
form
fP
DE
P
The
function
is
just
for
the
convenience
of
libdwarf
clients
that
might
wish
to
categorize
the
FORM
of
a
particular
attribute
The
DWARF
specification
divides
FORMs
into
classes
in
Chapter
and
this
function
figures
out
the
correct
class
for
a
form
P
The
f
CWdwversion
fP
passed
in
shall
be
the
dwarf
version
of
the
compilation
unit
involved
for
DWARF2
for
DWARF3
for
DWARF
The
f
CWattrnum
fP
passed
in
shall
be
the
attribute
number
of
the
attribute
involved
for
example
f
CWDW_AT_name
fP
The
f
CWoffset_size
fP
passed
in
shall
be
the
length
of
an
offset
in
the
current
compilation
unit
for
dwarf
or
for
dwarf
The
f
CWform
fP
passed
in
shall
be
the
attribute
form
number
If
f
CWform
fP
f
CWDW_FORM_indirect
fP
is
passed
in
f
CWDW_FORM_CLASS_UNKNOWN
fP
will
be
returned
as
this
form
has
no
defined
class
P
When
it
returns
f
CWDW_FORM_CLASS_UNKNOWN
fP
the
function
is
simply
saying
it
could
not
determine
the
correct
class
given
the
arguments
presented
Some
user
defined
attributes
might
have
this
problem
The
function
f
CWdwarf_get_version_of_die
fP
may
be
helpful
in
filling
out
arguments
for
a
call
to
f
CWdwarf_get_form_class
fP
H
dwarf_discr_list
DS
f
CWint
dwarf_discr_list
Dwarf_Debug
dbg
Dwarf_Small
blockpointer
Dwarf_Unsigned
blocklen
Dwarf_Dsc_Head
dsc_head_out
Dwarf_Unsigned
dsc_array_length_out
Dwarf_Error
error
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_discr_list
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
dsc_head_out
fP
to
a
pointer
to
the
discriminant
information
for
the
discriminant
list
and
sets
f
CW
dsc_array_length_out
fP
to
the
count
of
discriminant
entries
The
only
current
applicability
is
the
block
value
of
a
f
CWDW_AT_discr_list
fP
attribute
P
Those
values
are
useful
for
calls
to
f
CWdwarf_discr_entry_u
fP
or
f
CWdwarf_discr_entry_s
fP
to
get
the
actual
discriminant
values
See
the
example
below
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
block
is
empty
It
returns
f
CWDW_DLV_ERROR
fP
if
an
error
occurred
P
When
the
call
was
successful
and
the
f
CWDwarf_Dsc_Head
fP
is
no
longer
needed
call
f
CWdwarf_dealloc
fP
to
free
all
the
space
related
to
this
DS
void
example_discr_list
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attr
Dwarf_Half
attrnum
Dwarf_Bool
isunsigned
Dwarf_Half
theform
Dwarf_Error
err
The
example
here
assumes
that
attribute
attr
is
a
DW_AT_discr_list
isunsigned
should
be
set
from
the
signedness
of
the
parent
of
die
per
DWARF
rules
for
DW_AT_discr_list
enum
Dwarf_Form_Class
fc
DW_FORM_CLASS_UNKNOWN
Dwarf_Half
version
Dwarf_Half
offset_size
int
wres
wres
dwarf_get_version_of_die
die
if
wres
DW_DLV_OK
FAIL
return
fc
dwarf_get_form_class
version
attrnum
offset_size
theform
if
fc
DW_FORM_CLASS_BLOCK
int
fres
Dwarf_Block
tempb
fres
dwarf_formblock
attr
err
if
fres
DW_DLV_OK
Dwarf_Dsc_Head
h
Dwarf_Unsigned
u
Dwarf_Unsigned
arraycount
int
sres
sres
dwarf_discr_list
dbg
Dwarf_Small
tempb
bl_data
tempb
bl_len
err
if
sres
DW_DLV_NO_ENTRY
Nothing
here
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
return
if
sres
DW_DLV_ERROR
FAIL
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
return
for
u
u
arraycount
u
int
u2res
Dwarf_Half
dtype
Dwarf_Signed
dlow
Dwarf_Signed
dhigh
Dwarf_Unsigned
ulow
Dwarf_Unsigned
uhigh
if
isunsigned
u2res
dwarf_discr_entry_u
h
u
err
else
u2res
dwarf_discr_entry_s
h
u
err
if
u2res
DW_DLV_ERROR
Something
wrong
dwarf_dealloc
dbg
h
DW_DLA_DSC_HEAD
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
return
if
u2res
DW_DLV_NO_ENTRY
Impossible
u
arraycount
dwarf_dealloc
dbg
h
DW_DLA_DSC_HEAD
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
return
Do
something
with
dtype
and
whichever
of
ulow
uhigh
dlow
dhigh
got
set
Probably
save
the
values
somewhere
Simple
casting
of
dlow
to
ulow
or
vice
versa
will
not
get
the
right
value
due
to
the
nature
of
LEB
values
Similarly
for
uhigh
dhigh
One
must
use
the
right
call
dwarf_dealloc
dbg
h
DW_DLA_DSC_HEAD
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
DE
H
dwarf_discr_entry_u
DS
f
CWint
dwarf_discr_entry_u
Dwarf_Dsc_Head
dsc_head
Dwarf_Unsigned
dsc_array_index
Dwarf_Half
dsc_type
Dwarf_Unsigned
dsc_low
Dwarf_Unsigned
dsc_high
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_discr_entry_u
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
dsc_type
fP
f
CW
dsc_low
fP
and
f
CW
dsc_high
fP
to
the
discriminant
values
for
that
index
Valid
f
CWdsc_array_index
fP
values
are
zero
to
f
CW
dsc_array_length_out
fP
from
a
f
CWdwarf_discr_list
fP
call
P
If
f
CW
dsc_type
fP
is
f
CWDW_DSC_label
fP
f
CW
dsc_low
fP
is
set
to
the
discriminant
value
and
f
CW
dsc_high
fP
is
set
to
zero
P
If
f
CW
dsc_type
fP
is
f
CWDW_DSC_range
fP
f
CW
dsc_low
fP
is
set
to
the
low
end
of
the
discriminant
range
and
and
f
CW
dsc_high
fP
is
set
to
the
high
end
of
the
discriminant
range
P
Due
to
the
nature
of
the
LEB
numbers
in
the
discriminant
representation
in
DWARF
one
must
call
the
correct
one
of
f
CWdwarf_discr_entry_u
fP
or
f
CWdwarf_discr_entry_s
fP
based
on
whether
the
discriminant
is
signed
or
unsigned
Casting
an
unsigned
to
signed
is
not
always
going
to
get
the
right
value
P
If
f
CWdsc_array_index
fP
is
outside
the
range
of
valid
indexes
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
an
error
pointer
H
dwarf_discr_entry_s
DS
f
CWint
dwarf_discr_entry_s
Dwarf_Dsc_Head
dsc_head
Dwarf_Unsigned
dsc_array_index
Dwarf_Half
dsc_type
Dwarf_Signed
dsc_low
Dwarf_Signed
dsc_high
Dwarf_Error
error
fP
DE
This
is
identical
to
f
CWdwarf_discr_entry_u
fP
except
that
the
discriminant
values
are
signed
values
in
this
interface
Callers
must
check
the
discriminant
type
and
call
the
correct
function
H
Location
List
Operations
Raw
debug_loclists
This
set
of
interfaces
is
to
read
the
entire
f
CW
debug_loclists
fP
section
without
reference
to
any
DIE
As
such
these
can
only
present
the
raw
data
from
the
file
There
is
no
way
in
these
interfaces
to
get
actual
addresses
These
might
be
of
interest
if
you
want
to
know
exactly
what
the
compiler
output
in
the
f
CW
debug_loclists
fP
section
dwarfdump
print
raw
loclists
try
adding
v
or
vvv
makes
these
calls
P
Here
is
an
example
using
all
the
following
calls
in
FG
Example
Raw
Loclist
DS
f
CW
int
example_raw_loclist
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
count
int
res
Dwarf_Unsigned
i
res
dwarf_load_loclists
dbg
error
if
res
DW_DLV_OK
return
res
for
i
i
count
i
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_locentry
Dwarf_Unsigned
offset_past_last_loceentry
res
dwarf_get_loclist_context_basics
dbg
i
error
if
res
DW_DLV_OK
return
res
Dwarf_Unsigned
e
unsigned
colmax
unsigned
col
Dwarf_Unsigned
global_offset_of_value
for
e
offset_entry_count
e
Dwarf_Unsigned
value
int
resc
resc
dwarf_get_loclist_offset_index_value
dbg
i
e
error
if
resc
DW_DLV_OK
return
resc
Do
something
col
if
col
colmax
col
Dwarf_Unsigned
curoffset
offset_of_first_loceentry
Dwarf_Unsigned
endoffset
offset_past_last_loceentry
int
rese
Dwarf_Unsigned
ct
for
curoffset
endoffset
ct
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
rese
dwarf_get_loclist_lle
dbg
i
curoffset
endoffset
error
if
rese
DW_DLV_OK
return
rese
curoffset
entrylen
if
curoffset
endoffset
return
DW_DLV_ERROR
return
DW_DLV_OK
fP
DE
in
H
dwarf_load_loclists
DS
f
CWint
dwarf_load_loclists
Dwarf_Debug
dbg
Dwarf_Unsigned
loclists_count
Dwarf_Error
error
fP
DE
On
a
successful
call
to
f
CWdwarf_load_loclists
fP
the
function
returns
f
CWDW_DLV_OK
fP
sets
f
CW
loclists_count
fP
if
and
only
if
f
CWloclists_count
fP
is
non
null
to
the
number
of
distinct
section
contents
that
exist
A
small
amount
of
data
for
each
Location
List
Table
DWARF5
section
is
recorded
in
f
CWdbg
fP
as
a
side
effect
Normally
libdwarf
will
have
already
called
this
but
if
an
application
never
requests
any
f
CW
debug_info
fP
data
the
section
might
not
be
loaded
If
the
section
is
loaded
this
returns
very
quickly
and
will
set
f
CW
loclists_count
fP
just
as
described
in
this
paragraph
P
If
there
is
no
f
CW
debug_loclists
fP
section
in
the
object
file
this
function
returns
f
CWDW_DLV_NO_ENTRY
fP
P
If
something
is
malformed
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
the
applicable
error
pointer
describing
the
problem
P
There
is
no
dealloc
call
Calling
f
CWdwarf_finish
fP
releases
the
modest
amount
of
memory
recorded
for
this
section
as
a
side
effect
P
H
dwarf_get_loclist_context_basics
DS
f
CWint
dwarf_get_loclist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_locentry
Dwarf_Unsigned
offset_past_last_locentry
Dwarf_Error
err
fP
DE
On
success
this
returns
f
CWDW_DLV_OK
fP
and
returns
values
through
the
pointer
arguments
other
than
f
CWdbg
fP
or
f
CWerror
fP
P
A
call
to
f
CWdwarf_load_loclists
fP
that
succeeds
gets
you
the
count
of
contexts
and
f
CWdwarf_get_loclist_context_basics
fP
for
any
i
and
i
count
gets
you
the
context
values
relevant
to
f
CW
debug_loclists
fP
P
Any
of
the
pointer
arguments
for
returning
context
values
can
be
passed
in
as
in
which
case
they
will
be
skipped
P
You
will
want
f
CW
offset_entry_count
fP
so
you
can
call
f
CWdwarf_get_loclist_offset_index_value
fP
usefully
P
If
the
f
CWcontext_index
fP
passed
in
is
out
of
range
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
P
At
the
present
time
f
CWDW_DLV_ERROR
fP
is
never
returned
H
dwarf_get_loclist_offset_index_value
DS
f
CWint
dwarf_get_loclist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
fP
DE
P
On
success
f
CWdwarf_get_loclist_offset_index_value
fP
returns
f
CWDW_DLV_OK
fP
sets
f
CW
offset_value_out
fP
to
the
value
in
the
Range
List
Table
offset
array
and
sets
f
CW
global_offset_value_out
fP
to
the
section
offset
in
f
CW
debug_addr
fP
of
the
offset
value
P
Pass
in
f
CWcontext_index
fP
exactly
as
the
same
field
passed
to
f
CWdwarf_get_loclist_context_basics
fP
P
Pass
in
f
CWoffset_entry_index
fP
based
on
the
return
field
f
CWoffset_entry_count
fP
from
f
CWdwarf_get_loclist_context_basics
fP
meaning
for
that
f
CWcontext_index
fP
an
f
CWoffset_entry_index
fP
and
f
CWoffset_entry_count
fP
P
Pass
in
f
CWoffset_entry_count
fP
exactly
as
the
same
field
passed
to
f
CWdwarf_get_loclist_context_basics
fP
P
If
one
of
the
indexes
passed
in
is
out
of
range
f
CWDW_DLV_NO_ENTRY
fP
will
be
returned
and
no
return
arguments
touched
P
If
there
is
some
corruption
of
DWARF5
data
then
f
CWDW_DLV_ERROR
fP
might
be
returned
and
f
CW
error
fP
set
to
the
error
details
H
dwarf_get_loclist_lle
DS
f
CWint
dwarf_get_loclist_lle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
entrylen
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
expr_ops_blocksize
Dwarf_Unsigned
expr_ops_offset
Dwarf_Small
expr_opsdata
Dwarf_Error
error
fP
DE
On
success
it
returns
a
single
f
CWDW_RLE
fP
record
see
dwarf
h
fields
P
f
CWcontextnumber
fP
is
the
number
of
the
current
loclist
context
P
f
CWentry_offset
fP
is
the
section
offset
section
global
offset
of
the
next
record
P
f
CWendoffset
fP
is
one
past
the
last
entry
in
this
rle
context
P
f
CW
entrylen
fP
returns
the
length
in
the
debug_loclists
section
of
the
particular
record
returned
It
s
used
to
increment
to
the
next
record
within
this
loclist
context
P
f
CW
entrykind
fP
returns
is
the
f
CWDW_RLE
fP
number
P
Some
record
kinds
have
or
operands
most
have
two
operands
the
records
describing
ranges
P
f
CW
expr_ops_blocksize
fP
returns
the
size
in
bytes
of
the
Dwarf
Expression
some
operations
have
no
Dwarf
Expression
and
those
that
do
can
have
a
zero
length
blocksize
P
f
CW
expr_ops_offset
fP
returns
the
offset
in
the
debug_loclists
section
of
the
first
byte
of
the
Dwarf
Expression
P
f
CW
expr_opsdata
fP
returns
a
pointer
to
the
bytes
of
the
Dwarf
Expression
P
If
the
contextnumber
is
out
of
range
it
will
return
f
CWDW_DLV_NO_ENTRY
fP
P
If
the
f
CW
debug_loclists
fP
section
is
malformed
or
the
f
CWentry_offset
fP
is
incorrect
it
may
return
f
CWDW_DLV_ERROR
fP
H
Location
List
operations
debug_loc
debug_loclists
These
operations
apply
to
the
debug_loc
section
in
DWARF2
DWARF3
DWARF4
and
DWARF5
object
files
Earlier
versions
still
work
as
well
as
ever
but
they
only
deal
with
at
most
DWARF2
DWARF3
and
DWARF4
H
dwarf_get_loclist_c
DS
f
CW
int
dwarf_get_loclist_c
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
locCount
Dwarf_Error
error
fP
DE
This
function
returns
a
pointer
that
is
in
turn
used
to
make
possible
calls
to
return
the
details
of
the
location
list
P
The
incoming
argument
f
CWattr
fP
should
have
one
of
the
FORMs
of
a
location
expression
or
location
list
P
On
success
this
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
loclist_head
fP
to
a
pointer
used
in
further
calls
see
the
example
and
descriptions
that
follow
it
f
CWlocCount
fP
is
set
to
the
number
of
entries
in
the
location
list
or
if
the
FORM
is
of
a
location
expression
the
f
CWlocCount
fP
will
be
set
to
one
At
this
point
one
cannot
yet
tell
if
it
was
a
location
list
or
a
location
expression
see
f
CWdwarf_get_locdesc_entry_c
fP
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
f
CW
error
fP
is
set
to
an
error
designation
P
A
return
of
f
CWDW_DLV_NO_ENTRY
fP
may
be
possible
but
is
a
bit
odd
DS
f
CW
void
example_loclistcv5
Dwarf_Debug
dbg
Dwarf_Attribute
someattr
Dwarf_Unsigned
lcount
Dwarf_Loc_Head_c
loclist_head
Dwarf_Error
error
int
lres
lres
dwarf_get_loclist_c
someattr
if
lres
DW_DLV_OK
Dwarf_Unsigned
i
Before
any
return
remember
to
call
dwarf_loc_head_c_dealloc
loclist_head
for
i
i
lcount
i
Dwarf_Small
loclist_lkind
Dwarf_Small
lle_value
Dwarf_Unsigned
rawval1
Dwarf_Unsigned
rawval2
Dwarf_Bool
debug_addr_unavailable
FALSE
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
loclist_expr_op_count
Dwarf_Locdesc_c
locdesc_entry
Dwarf_Unsigned
expression_offset
Dwarf_Unsigned
locdesc_offset
lres
dwarf_get_locdesc_entry_d
loclist_head
i
if
lres
DW_DLV_OK
Dwarf_Unsigned
j
int
opres
Dwarf_Small
op
for
j
j
loclist_expr_op_count
j
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
raw3
Dwarf_Unsigned
opd1
Dwarf_Unsigned
opd2
Dwarf_Unsigned
opd3
Dwarf_Unsigned
offsetforbranch
opres
dwarf_get_location_op_value_d
locdesc_entry
j
if
opres
DW_DLV_OK
Do
something
with
the
operators
Usually
you
want
to
use
opd1
as
appropriate
Calculations
involving
base
addresses
etc
have
already
been
incorporated
in
opd1
else
dwarf_dealloc_error
dbg
error
dwarf_loc_head_c_dealloc
loclist_head
Something
is
wrong
return
else
Something
is
wrong
Do
something
dwarf_loc_head_c_dealloc
loclist_head
dwarf_dealloc_error
dbg
error
return
Always
call
dwarf_loc_head_c_dealloc
to
free
all
the
memory
associated
with
loclist_head
if
error
dwarf_dealloc_error
dbg
error
dwarf_loc_head_c_dealloc
loclist_head
loclist_head
return
fP
DE
H
dwarf_get_locdesc_entry_d
Earlier
versions
of
this
work
with
earlier
versions
of
DWARF
This
works
with
all
DWARF
from
DWARF2
on
DS
f
CW
int
dwarf_get_locdesc_entry_d
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
index
Dwarf_Small
lle_value_out
Dwarf_Addr
rawval1_out
Dwarf_Addr
rawval2_out
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc_out
Dwarf_Addr
hipc_out
Dwarf_Unsigned
loc_expr_op_count_out
Dwarf_Locdesc_c
locentry_out
Dwarf_Small
loclist_kind
Dwarf_Unsigned
expression_offset_out
Dwarf_Unsigned
locdesc_offset_out
Dwarf_Error
error
fP
DE
This
function
returns
overall
information
about
a
location
list
or
location
description
Details
about
location
operators
are
retrieved
by
a
call
to
f
CWdwarf_get_location_op_value_d
fP
described
below
In
case
of
success
f
CWDW_DLV_OK
fP
is
returned
and
arguments
are
set
through
the
pointers
to
return
values
to
the
caller
Now
we
describe
each
argument
P
f
CW
loclist_kind
fP
returns
f
CWDW_LKIND_expression
fP
f
CWDW_LKIND_loclist
fP
f
CWDW_LKIND_GNU_exp_list
fP
or
f
CWDW_LKIND_loclists
fP
P
f
CWDW_LKIND_expression
fP
means
the
list
is
really
just
a
location
expression
The
only
entry
is
with
f
CWindex
fP
zero
In
this
case
f
CW
lle_value_out
fP
will
have
the
value
f
CWDW_LLE_start_end
fP
P
f
CWDW_LKIND_loclist
fP
means
the
list
is
from
DWARF2
DWARF3
or
DWARF4
The
f
CW
lle_value_out
fP
value
has
been
synthesized
as
if
it
were
a
DWARF5
expression
P
f
CWDW_LKIND_GNU_exp_list
fP
means
the
list
is
from
a
DWARF4
debug_loc
dwo
object
section
It
is
an
experimental
version
from
before
DWARF5
was
published
The
f
CW
lle_value_out
fP
is
f
CWDW_LLEX_start_end_entry
fP
or
one
of
the
other
DW_LLEX
values
P
f
CWDW_LKIND_loclists
fP
means
this
is
a
DWARF5
loclist
so
f
CWDW_LLE_start_end
fP
is
an
example
of
one
possible
f
CW
lle_value_out
fP
values
In
addition
if
f
CW
debug_addr_unavailable
fP
is
set
it
means
the
f
CW
lopc_out
fP
and
f
CW
hipc_out
fP
could
not
be
correctly
set
so
are
meaningless
because
the
debug_addr
section
is
missing
Very
likely
the
debug_addr
section
is
in
the
executable
and
that
file
needs
to
be
opened
and
attached
to
the
current
Dwarf_Debug
with
f
CWdwarf_set_tied_dbg
fP
P
f
CW
rawval1_out
fP
returns
the
value
of
the
first
operand
in
the
location
list
entry
Uninterpreted
Useful
for
reporting
or
for
those
wishing
to
do
their
own
calculation
of
f
CWlopc
fP
P
f
CW
rawval2_out
fP
returns
the
value
of
the
second
operand
in
the
location
list
entry
Uninterpreted
Useful
for
reporting
or
for
those
wishing
to
do
their
own
calculation
of
f
CWhipc
fP
The
argument
f
CWloc_expr_op_count_out
fP
returns
the
number
of
operators
in
the
location
expression
involved
which
may
be
zero
P
The
argument
f
CWlocentry_out
fP
returns
an
identifier
used
in
calls
to
f
CWdwarf_get_location_op_value_d
fP
P
The
argument
f
CWexpression_offset_out
fP
returns
the
offset
in
the
debug_loc
dso
or
debug_info
dwo
of
the
location
expression
itself
possibly
useful
for
debugging
P
The
argument
f
CWlocdesc_offset_out
fP
returns
the
offset
in
the
section
involved
see
f
CWloclist_kind
fP
of
the
location
list
entry
itself
possibly
useful
for
debugging
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
f
CW
error
fP
is
set
to
an
error
designation
P
A
return
of
f
CWDW_DLV_NO_ENTRY
fP
may
be
possible
but
is
a
bit
odd
f
CW
fP
H
dwarf_get_locdesc_entry_c
This
is
the
same
as
f
CWdwarf_get_locdesc_entry_d
fP
except
that
the
f
CWdebug_addr_unavailable
fP
field
is
missing
Earlier
versions
starting
with
f
CWdwarf_get_locdesc_entry
fP
exist
and
work
as
well
as
they
ever
did
but
we
suggest
you
stop
using
those
earlier
versions
We
suggest
you
switch
to
using
f
CWdwarf_get_locdesc_entry_d
fP
DS
f
CW
int
dwarf_get_locdesc_entry_c
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
index
Dwarf_Small
lle_value_out
Dwarf_Addr
rawval1_out
Dwarf_Addr
rawval2_out
Dwarf_Addr
lopc_out
Dwarf_Addr
hipc_out
Dwarf_Unsigned
loc_expr_op_count_out
Dwarf_Locdesc_c
locentry_out
Dwarf_Small
loclist_kind
Dwarf_Unsigned
expression_offset_out
Dwarf_Unsigned
locdesc_offset_out
Dwarf_Error
error
fP
DE
H
dwarf_get_loclist_head_kind
DS
f
CW
int
dwarf_get_loclist_head_kind
Dwarf_Loclists_Head
head
unsigned
int
kind
Dwarf_Error
error
fP
DE
Though
one
should
test
the
return
code
at
present
this
always
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
kind
fP
to
the
f
CWDW_LKIND
fP
value
for
this
f
CWhead
fP
P
At
the
present
time
neither
f
CWDW_DLV_ERROR
fP
nor
f
CWDW_DLV_NO_ENTRY
fP
is
returned
H
dwarf_get_location_op_value_d
DS
f
CW
int
dwarf_get_location_op_value_d
Dwarf_Locdesc_c
locdesc
Dwarf_Unsigned
index
Dwarf_Small
atom_out
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Unsigned
rawop1
Dwarf_Unsigned
rawop2
Dwarf_Unsigned
rawop3
Dwarf_Unsigned
offset_for_branch
Dwarf_Error
error
fP
DE
On
success
The
function
f
CWdwarf_get_location_op_value_d
fP
returns
the
information
for
the
single
operator
number
f
CWindex
fP
from
the
location
expression
f
CWlocdesc
fP
It
sets
the
following
values
P
f
CWatom_out
fP
is
set
to
the
applicable
operator
code
for
example
f
CWDW_OP_reg5
fP
P
f
CWoperand1
fP
f
CWoperand2
fP
and
f
CWoperand3
fP
are
set
to
the
operator
operands
as
applicable
see
DWARF
documents
on
the
operands
for
each
operator
All
additions
of
base
fields
if
any
have
been
done
already
f
CWoperand3
fP
is
new
as
of
DWARF5
P
In
some
cases
f
CWoperand3
fP
is
actually
a
pointer
into
section
data
in
memory
and
operand2
has
the
length
of
the
data
at
operand3
Callers
must
extract
the
bytes
and
deal
with
endianness
issues
of
the
extracted
value
P
f
CWrawop1
fP
f
CWrawop2
fP
and
f
CWrawop3
fP
are
set
to
the
operator
operands
as
applicable
see
DWARF
documents
on
the
operands
for
each
operator
before
any
base
values
were
added
in
As
for
the
previous
sometimes
dealing
with
f
CWrawop3
fP
means
interpreting
it
as
a
pointer
and
doing
a
dereference
P
More
on
the
pointer
values
in
Dwarf_Unsigned
When
a
DWARF
operand
is
not
of
a
size
fixed
by
dwarf
or
whose
type
is
unknown
or
is
possibly
too
large
for
a
dwarf
stack
entry
libdwarf
will
insert
a
pointer
to
memory
in
the
dwarf
data
somewhere
as
the
operand
value
f
CWDW_OP_implicit_value
operand
fP
f
CWDW_OP_
GNU_
entry_value
operand
fP
and
f
CWDW_OP_
GNU_
const_type
operand
fP
are
instances
of
this
The
problem
with
the
values
is
that
libdwarf
is
unclear
what
the
type
of
the
value
is
so
we
pass
the
problem
to
you
the
callers
P
f
CWoffset_for_branch
fP
is
set
to
the
offset
in
bytes
in
this
expression
of
this
operator
The
value
makes
it
possible
for
callers
to
implement
the
operator
branch
operators
P
In
case
of
an
error
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
an
error
value
P
f
CWDW_DLV_NO_ENTRY
fP
is
probably
not
a
possible
return
value
but
please
test
for
it
anyway
H
dwarf_loclist_from_expr_c
This
is
the
recommended
current
interface
It
uses
the
Dwarf_Loc_Head_c
opaque
struct
pointer
to
hold
the
information
for
detailed
printing
using
f
CWdwarf_get_locdesc_entry_c
fP
DS
f
CW
int
dwarf_loclist_from_expr_c
Dwarf_Debug
dbg
Dwarf_Ptr
expression_in
Dwarf_Unsigned
expression_length
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Small
dwarf_version
Dwarf_Loc_Head_c
loc_head
Dwarf_Unsigned
listlen
Dwarf_Error
error
fP
DE
Frame
operators
such
as
DW_CFA_def_cfa_expression
have
a
location
expression
and
the
location_expression
is
accessed
with
this
function
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
the
two
return
arguments
explained
a
few
lines
later
here
P
The
f
CWexpression_in
fP
argument
must
contain
a
valid
pointer
to
location
expression
bytes
The
f
CWexpression_length
fP
argument
must
contain
the
length
of
that
location
expression
in
bytes
P
The
f
CWaddress_size
fP
argument
must
contain
the
size
of
an
address
on
the
target
machine
for
this
expression
normally
or
The
f
CWoffset_size
fP
argument
must
contain
the
size
of
an
offset
in
the
expression
normally
sometimes
The
f
CWdwarf_version
fP
argument
must
contain
the
dwarf_version
of
the
expression
or
P
The
returned
value
f
CW
loc_head
fP
is
used
to
actually
access
the
location
expression
details
see
the
example
following
P
The
returned
value
f
CW
listlen
fP
is
the
number
of
location
expressions
ie
in
the
location
list
for
uniformity
of
access
we
make
it
look
like
a
single
entry
location
list
P
On
error
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
reflect
the
error
P
A
return
of
f
CWDW_DLV_NO_ENTRY
fP
is
probably
impossible
but
callers
should
assume
it
is
possible
No
return
arguments
are
set
in
this
case
DS
void
example_locexprc
Dwarf_Debug
dbg
Dwarf_Ptr
expr_bytes
Dwarf_Unsigned
expr_len
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
Dwarf_Loc_Head_c
head
Dwarf_Locdesc_c
locentry
int
res2
Dwarf_Unsigned
lopc
Dwarf_Unsigned
hipc
Dwarf_Unsigned
ulistlen
Dwarf_Unsigned
ulocentry_count
Dwarf_Unsigned
section_offset
Dwarf_Unsigned
locdesc_offset
Dwarf_Small
lle_value
Dwarf_Small
loclist_source
Dwarf_Unsigned
i
Dwarf_Error
error
res2
dwarf_loclist_from_expr_c
dbg
expr_bytes
expr_len
addr_size
offset_size
version
if
res2
DW_DLV_NO_ENTRY
return
if
res2
DW_DLV_ERROR
return
These
are
a
location
expression
not
loclist
So
we
just
need
the
entry
res2
dwarf_get_locdesc_entry_c
head
Data
from
LocDesc
if
res2
DW_DLV_ERROR
dwarf_loc_head_c_dealloc
head
return
else
if
res2
DW_DLV_NO_ENTRY
dwarf_loc_head_c_dealloc
head
return
ASSERT
ulistlen
for
i
i
ulocentry_count
i
Dwarf_Small
op
Dwarf_Unsigned
opd1
Dwarf_Unsigned
opd2
Dwarf_Unsigned
opd3
Dwarf_Unsigned
offsetforbranch
res2
dwarf_get_location_op_value_c
locentry
i
Do
something
with
the
expression
operator
and
operands
if
res2
DW_DLV_OK
dwarf_loc_head_c_dealloc
head
return
dwarf_loc_head_c_dealloc
head
DE
H
dwarf_loc_head_c_dealloc
DS
void
dwarf_loc_head_c_dealloc
Dwarf_Loc_Head_c
loclist_head
DE
This
function
takes
care
of
all
the
details
so
one
does
not
have
to
_dwarf_dealloc
the
pieces
individually
though
code
that
continues
to
do
the
pieces
individually
still
works
P
This
function
frees
all
the
memory
associated
with
the
f
CWloclist_head
fP
There
is
no
return
value
It
s
good
practice
to
set
f
CWloclist_head
fP
to
zero
immediately
after
the
call
as
the
pointer
is
stale
at
that
point
H
dwarf_loclist_from_expr_b
DS
f
CWint
dwarf_loclist_from_expr_a
Dwarf_Ptr
bytes_in
Dwarf_Unsigned
bytes_len
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version_stamp
Dwarf_Locdesc
llbuf
Dwarf_Signed
listlen
Dwarf_Error
error
fP
DE
This
function
is
obsolete
The
function
f
CWdwarf_loclist_from_expr_b
fP
is
identical
to
f
CWdwarf_loclist_from_expr_a
fP
in
every
way
except
that
the
caller
passes
an
additional
argument
f
CWversion_stamp
fP
containing
the
version
stamp
for
DWARF2
etc
of
the
CU
using
this
location
expression
and
an
additional
argument
of
the
offset
size
of
the
CU
using
this
location
expression
The
DW_OP_GNU_implicit_pointer
operation
requires
this
version
and
offset
information
to
be
correctly
processed
P
The
f
CWaddr_size
fP
argument
from
is
needed
to
correctly
interpret
frame
information
as
different
compilation
units
can
have
different
address
sizes
DWARF4
adds
address_size
to
the
CIE
header
P
H
dwarf_loclist_from_expr_a
DS
f
CWint
dwarf_loclist_from_expr_a
Dwarf_Ptr
bytes_in
Dwarf_Unsigned
bytes_len
Dwarf_Half
addr_size
Dwarf_Locdesc
llbuf
Dwarf_Signed
listlen
Dwarf_Error
error
fP
DE
This
function
is
obsolete
Use
f
CWdwarf_loclist_from_expr_b
fP
instead
This
function
is
obsolete
P
The
function
f
CWdwarf_loclist_from_expr_a
fP
is
identical
to
f
CWdwarf_loclist_from_expr
fP
in
every
way
except
that
the
caller
passes
the
additional
argument
f
CWaddr_size
fP
containing
the
address
size
normally
or
applying
this
location
expression
P
The
f
CWaddr_size
fP
argument
added
is
needed
to
correctly
interpret
frame
information
as
different
compilation
units
can
have
different
address
sizes
DWARF4
adds
address_size
to
the
CIE
header
P
H
Line
Number
Operations
These
functions
are
concerned
with
accessing
line
number
entries
mapping
debugging
information
entry
objects
to
their
corresponding
source
lines
and
providing
a
mechanism
for
obtaining
information
about
line
number
entries
Although
the
interface
talks
of
lines
what
is
really
meant
is
statements
In
case
there
is
more
than
one
statement
on
the
same
line
there
will
be
at
least
one
descriptor
per
statement
all
with
the
same
line
number
If
column
number
is
also
being
represented
they
will
have
the
column
numbers
of
the
start
of
the
statements
also
represented
P
There
can
also
be
more
than
one
Dwarf_Line
per
statement
For
example
if
a
file
is
preprocessed
by
a
language
translator
this
could
result
in
translator
output
showing
or
more
sets
of
line
numbers
per
translated
line
of
output
P
The
current
set
of
line
functions
is
f
CWdwarf_srclines_b
fP
with
f
CWdwarf_srclines_from_linecontext
fP
and
f
CWdwarf_srclines_dealloc_b
fP
These
functions
provide
for
handling
both
DWARF2
through
DWARF5
details
and
give
access
to
line
header
information
even
if
there
are
no
lines
in
a
particular
compilation
unit
s
line
table
P
H
Get
A
Set
of
Lines
including
skeleton
line
tables
This
set
of
functions
works
on
any
DWARF
version
DWARF2
and
the
DWARF4
based
experimental
two
level
line
tables
are
all
supported
What
was
once
done
by
dwarf_srclines
alone
is
now
done
with
two
calls
as
described
here
P
The
interfaces
support
reading
GNU
two
level
line
tables
The
format
of
such
tables
is
a
topic
beyond
the
scope
of
this
document
P
H
dwarf_srclines_b
This
is
the
DS
f
CWint
dwarf_srclines_b
Dwarf_Die
die
Dwarf_Unsigned
version_out
Dwarf_Small
table_count
Dwarf_Line_Context
context_out
Dwarf_Error
error
fP
DE
f
CWdwarf_srclines_b
fP
takes
a
single
argument
as
input
a
pointer
to
a
compilation
unit
CU
DIE
The
other
arguments
are
used
to
return
values
to
the
caller
On
success
f
CWDW_DLV_OK
fP
is
returned
and
values
are
returned
through
the
pointers
If
there
is
no
line
table
f
CWDW_DLV_NO_ENTRY
fP
is
returned
and
no
values
are
returned
though
the
pointers
If
f
CWDW_DLV_ERROR
fP
is
returned
the
involved
is
returned
through
the
f
CWerror
fP
pointer
P
The
values
returned
on
success
are
P
f
CW
version_out
fP
is
set
to
the
version
number
from
the
line
table
header
for
this
CU
The
experimental
two
level
line
table
value
is
Standard
numbers
are
and
P
f
CW
is_single_table
fP
is
set
to
non
zero
if
the
line
table
is
an
ordinary
single
line
table
If
the
line
table
is
anything
else
either
a
line
table
header
with
no
lines
or
an
experimental
two
level
line
table
it
is
set
to
zero
P
f
CW
context_out
fP
is
set
to
an
opaque
pointer
to
a
f
CWDwarf_Line_Context
fP
record
which
in
turn
is
used
to
get
other
data
from
this
line
table
See
below
P
See
f
CW
dwarf_srclines_dealloc_b
fP
for
examples
showing
correct
use
H
dwarf_get_line_section_name_from_die
DS
f
CWint
dwarf_get_line_section_name_from_die
Dwarf_Die
die
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CW
dwarf_get_line_section_name_from_die
fP
retrieves
the
object
file
section
name
of
the
applicable
line
section
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_srclines_from_linecontext
DS
f
CWint
dwarf_srclines_from_linecontext
Dwarf_Line_Context
line_context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Error
error
fP
DE
f
CW
dwarf_srclines_from_linecontext
fP
gives
access
to
the
line
tables
On
success
it
returns
f
CWDW_DLV_OK
fP
and
passes
back
line
tables
through
the
pointers
P
Though
f
CWDW_DLV_OK
fP
will
not
be
returned
callers
should
assume
it
is
possible
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
code
set
through
the
f
CWerror
fP
pointer
P
On
success
P
f
CW
linebuf
fP
is
set
to
an
array
of
Dwarf_Line
pointers
P
f
CW
linecount
fP
is
set
to
the
number
of
pointers
in
the
array
P
H
dwarf_srclines_two_levelfrom_linecontext
DS
f
CWint
dwarf_srclines_from_linecontext
Dwarf_Line_Context
line_context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Error
error
fP
DE
f
CW
dwarf_srclines_two_levelfrom_linecontext
fP
gives
access
to
the
line
tables
On
success
it
returns
f
CWDW_DLV_OK
fP
and
passes
back
line
tables
through
the
pointers
P
Though
f
CWDW_DLV_OK
fP
will
not
be
returned
callers
should
assume
it
is
possible
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
code
set
through
the
f
CWerror
fP
pointer
P
On
success
P
f
CW
linebuf
fP
is
set
to
an
array
of
Dwarf_Line
pointers
P
f
CW
linecount
fP
is
set
to
the
number
of
pointers
in
the
array
P
If
one
is
not
intending
that
the
experimental
two
level
line
tables
are
of
interest
then
pass
NULL
for
f
CW
linebuf_actuals
fP
and
f
CW
linecount_actuals
fP
The
NULL
pointers
notify
the
library
that
the
second
table
is
not
to
be
passed
back
P
If
a
line
table
is
actually
a
two
level
tables
f
CW
linebuf
fP
is
set
to
point
to
an
array
of
Logicals
lines
f
CW
linecount
fP
is
set
to
the
number
of
Logicals
f
CW
linebuf_actuals
fP
is
set
to
point
to
an
array
of
Actuals
lines
f
CW
linecount_actuals
fP
is
set
to
the
number
of
Actuals
H
dwarf_srclines_dealloc_b
DS
f
CWvoid
dwarf_srclines_dealloc_b
Dwarf_Line_Context
line_context
fP
DE
This
does
a
complete
deallocation
of
the
memory
of
the
f
CWDwarf_Line_Context
fP
and
the
f
CWDwarf_Line
fP
array
or
arrays
that
came
from
the
f
CWDwarf_Line_Context
fP
On
return
you
should
set
any
local
pointers
to
these
buffers
to
NULL
as
a
reminder
that
any
use
of
the
local
pointers
would
be
to
stale
memory
in
FG
Examplec
dwarf_srclines_b
DS
f
CW
void
examplec
Dwarf_Die
cu_die
EXAMPLE
DWARF5
style
access
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Line_Context
line_context
Dwarf_Signed
linecount_total
Dwarf_Small
table_count
Dwarf_Unsigned
lineversion
Dwarf_Error
err
int
sres
we
use
return
here
to
signify
we
can
do
nothing
more
at
this
point
in
the
code
sres
dwarf_srclines_b
cu_die
if
sres
DW_DLV_OK
Handle
the
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
No
memory
was
allocated
so
there
nothing
to
dealloc
return
if
table_count
A
line
table
with
no
actual
lines
This
occurs
in
a
DWARF5
or
DWARF5
DW_TAG_type_unit
as
such
has
no
lines
of
code
but
needs
data
for
DW_AT_decl_file
attributes
do
something
see
dwarf_srclines_files_count
etc
below
dwarf_srclines_dealloc_b
line_context
All
the
memory
is
released
the
line_context
and
linebuf
zeroed
now
as
a
reminder
they
are
stale
linebuf
line_context
else
if
table_count
Dwarf_Signed
i
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
Standard
dwarf
or
line
table
Do
something
First
let
us
index
through
all
the
files
listed
in
the
line
table
header
sres
dwarf_srclines_files_indexes
line_context
if
sres
DW_DLV_OK
Something
badly
wrong
return
Works
for
DWARF2
one
based
index
and
DWARF5
zero
based
index
for
i
baseindex
i
endindex
i
Dwarf_Unsigned
dirindex
Dwarf_Unsigned
modtime
Dwarf_Unsigned
flength
Dwarf_Form_Data16
md5data
int
vres
const
char
name
vres
dwarf_srclines_files_data_b
line_context
i
if
vres
DW_DLV_OK
something
very
wrong
return
Do
something
For
this
case
where
we
have
a
line
table
we
will
likely
wish
to
get
the
line
details
sres
dwarf_srclines_from_linecontext
line_context
if
sres
DW_DLV_OK
Error
Clean
up
the
context
information
dwarf_srclines_dealloc_b
line_context
return
The
lines
are
normal
line
table
lines
for
i
i
linecount
i
use
linebuf
i
dwarf_srclines_dealloc_b
line_context
All
the
memory
is
released
the
line_context
and
linebuf
zeroed
now
as
a
reminder
they
are
stale
linebuf
line_context
linecount
else
Dwarf_Signed
i
ASSERT
table_count
Experimental
two
level
line
table
Version
We
do
not
define
the
meaning
of
this
non
standard
set
of
tables
here
For
something
C
two
level
line
tables
one
codes
something
like
this
Note
that
we
do
not
define
the
meaning
or
use
of
two
level
line
tables
as
these
are
experimental
not
standard
DWARF
sres
dwarf_srclines_two_level_from_linecontext
line_context
if
sres
DW_DLV_OK
for
i
i
linecount
i
use
linebuf
i
these
are
the
logicals
entries
for
i
i
linecount_actuals
i
use
linebuf_actuals
i
these
are
the
actuals
entries
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
linecount
linebuf_actuals
linecount_actuals
else
if
sres
DW_DLV_NO_ENTRY
This
should
be
impossible
but
do
something
Then
Free
the
line_context
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
linecount
linebuf_actuals
linecount_actuals
else
ERROR
show
the
error
or
something
Free
the
line_context
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
linecount
linebuf_actuals
linecount_actuals
fP
DE
in
H
Line
Context
Details
DWARF5
style
New
in
October
When
a
f
CW
Dwarf_Line_Context
fP
has
been
returned
by
f
CWdwarf_srclines_b
fP
that
line
context
data
s
details
can
be
retrieved
with
the
following
set
of
calls
H
dwarf_srclines_table_offset
DS
f
CW
int
dwarf_srclines_table_offset
Dwarf_Line_Context
line_context
Dwarf_Unsigned
offset
Dwarf_Error
error
fP
DE
On
success
this
function
returns
the
offset
in
the
object
file
line
section
of
the
actual
line
data
i
e
after
the
line
header
for
this
compilation
unit
through
the
f
CWoffset
fP
pointer
The
offset
is
probably
only
of
interest
when
printing
detailed
information
about
a
line
table
header
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_version
DS
f
CW
int
dwarf_srclines_version
Dwarf_Line_Context
line_context
Dwarf_Unsigned
version
Dwarf_Error
error
fP
DE
On
success
f
CWDW_DLV_OK
fP
is
returned
and
the
line
table
version
number
is
returned
through
the
f
CWversion
fP
pointer
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_comp_dir
DS
f
CW
int
dwarf_srclines_comp_dir
Dwarf_Line_Context
line_context
const
char
compilation_directory
Dwarf_Error
error
fP
DE
On
success
this
returns
a
pointer
to
the
compilation
directory
string
for
this
line
table
in
f
CW
compilation_directory
fP
That
compilation
string
may
be
NULL
or
the
empty
string
The
string
pointer
is
valid
until
the
f
CWline_context
fP
has
been
deallocated
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_files_indexes
DS
f
CW
int
dwarf_srclines_files_indexes
Dwarf_Line_Context
line_context
Dwarf_Signed
baseindex
Dwarf_Signed
count
Dwarf_Signed
endindex
Dwarf_Error
error
fP
DE
With
DWARF5
the
base
file
number
index
in
the
line
table
changed
from
zero
DWARF2
to
one
DWARF5
Which
meant
iterating
through
the
valid
source
file
indexes
became
messy
if
one
used
the
older
f
CWdwarf_srclines_files_count
fP
function
zero
based
and
one
based
indexing
being
incompatible
See
Figure
Examplec
dwarf_srclines_b
above
for
use
of
this
function
in
accessing
file
names
P
The
base
index
of
files
in
the
files
list
of
a
line
table
header
will
be
returned
through
f
CWbaseindex
fP
P
The
number
of
files
in
the
files
list
of
a
line
table
header
will
be
returned
through
f
CWcount
fP
P
The
end
index
of
files
in
the
files
list
of
a
line
table
header
will
be
returned
through
f
CWendindex
fP
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_files_count
DS
f
CW
int
dwarf_srclines_files_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
fP
DE
On
success
the
number
of
files
in
the
files
list
of
a
line
table
header
will
be
returned
through
f
CWcount
fP
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_files_data_b
This
supplants
f
CWdwarf_srclines_files_data
fP
as
of
March
to
allow
access
to
the
md5
value
in
DWARF5
The
function
f
CWdwarf_srclines_files_data
fP
continues
to
be
supported
DS
f
CW
int
dwarf_srclines_files_data_b
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Unsigned
directory_index
Dwarf_Unsigned
last_mod_time
Dwarf_Unsigned
file_length
Dwarf_Form_Data16
md5_value
Dwarf_Error
error
fP
DE
On
success
data
about
a
single
file
in
the
files
list
will
be
returned
through
the
pointers
See
DWARF
documentation
for
the
meaning
of
these
fields
f
CWcount
fP
Valid
f
CWindex
fP
values
are
through
f
CWcount
fP
reflecting
the
way
the
table
is
defined
by
DWARF2
For
a
dwarf5
line
table
index
values
count
are
legal
This
is
certainly
awkward
P
If
f
CWmd5_value
fP
is
non
null
it
is
used
to
pass
a
back
a
pointer
to
a
f
CWDwarf_Form_Data16
fP
md5
value
if
the
md5
value
is
present
Otherwise
a
zero
value
is
passed
back
to
indicate
there
was
no
such
field
The
byte
value
pointed
to
is
inside
the
line_context
so
if
you
want
to
keep
the
value
you
should
probably
copy
it
to
storage
you
control
P
This
returns
the
raw
files
data
from
the
line
table
header
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_files_data
This
interface
was
created
in
October
It
cannot
return
the
DWARF5
MD5
value
See
the
newer
dwarf_srclines_files_data_b
DS
f
CW
int
dwarf_srclines_files_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Unsigned
directory_index
Dwarf_Unsigned
last_mod_time
Dwarf_Unsigned
file_length
Dwarf_Error
error
fP
DE
On
success
data
about
a
single
file
in
the
files
list
will
be
returned
through
the
pointers
See
DWARF
documentation
for
the
meaning
of
these
fields
f
CWcount
fP
Valid
f
CWindex
fP
values
are
through
f
CWcount
fP
reflecting
the
way
the
table
is
defined
by
DWARF2
For
a
dwarf5
line
table
index
values
count
are
legal
This
is
certainly
awkward
P
This
returns
the
raw
files
data
from
the
line
table
header
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_include_dir_count
DS
f
CW
int
dwarf_srclines_include_dir_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
fP
DE
On
success
the
number
of
files
in
the
includes
list
of
a
line
table
header
will
be
returned
through
f
CWcount
fP
P
Valid
f
CWindex
fP
values
are
through
f
CWcount
fP
reflecting
the
way
the
table
is
defined
by
DWARF
and
For
a
dwarf5
line
table
index
values
count
are
legal
This
is
certainly
awkward
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_include_dir_data
DS
f
CW
int
dwarf_srclines_include_dir_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Error
error
fP
DE
On
success
data
about
a
single
file
in
the
include
files
list
will
be
returned
through
the
pointers
See
DWARF
documentation
for
the
meaning
of
these
fields
P
Valid
f
CWindex
fP
values
are
through
f
CWcount
fP
reflecting
the
way
the
table
is
defined
by
DWARF
P
In
case
of
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
is
set
through
the
f
CWerror
fP
pointer
f
CWDW_DLV_NO_ENTRY
fP
will
not
be
returned
H
dwarf_srclines_subprog_count
f
CW
int
dwarf_srclines_subprog_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
fP
This
is
only
useful
with
experimental
two
level
line
tables
H
dwarf_srclines_subprog_data
f
CW
int
dwarf_srclines_subprog_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Unsigned
decl_file
Dwarf_Unsigned
decl_line
Dwarf_Error
error
fP
This
is
only
useful
with
experimental
two
level
line
tables
H
Get
A
Set
of
Lines
DWARF2
style
The
function
returns
information
about
every
source
line
for
a
particular
compilation
unit
The
compilation
unit
is
specified
by
the
corresponding
die
It
does
not
support
line
tables
with
no
lines
very
well
nor
does
it
support
experimental
two
level
linetables
H
dwarf_srclines
DS
f
CWint
dwarf_srclines
Dwarf_Die
die
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Error
error
fP
DE
This
function
is
not
useful
for
DWARF5
skeleton
line
tables
nor
for
two
level
line
tables
It
works
for
DWARF2
ordinary
single
line
tables
The
function
f
CWdwarf_srclines
fP
places
all
line
number
descriptors
for
a
single
compilation
unit
into
a
single
block
sets
f
CW
linebuf
fP
to
point
to
that
block
sets
f
CW
linecount
fP
to
the
number
of
descriptors
in
this
block
and
returns
f
CWDW_DLV_OK
fP
in
P
To
get
a
more
detailed
view
of
the
contents
of
a
dwarf
line
table
header
see
f
CWdwarf_srclines_b
fP
and
the
routines
that
use
the
Dwarf_Line_Context
information
such
as
f
CWdwarf_srcfiles_comp_dir
fP
f
CWdwarf_srclines_files_count
fP
f
CWdwarf_srclines_include_dir_count
fP
and
similar
functions
in
P
The
compilation
unit
is
indicated
by
the
given
f
CWdie
fP
which
must
be
a
compilation
unit
die
It
returns
f
CWDW_DLV_ERROR
fP
on
error
On
successful
return
line
number
information
should
be
freed
using
f
CWdwarf_srclines_dealloc
fP
when
no
longer
of
interest
P
in
FG
Exampled
dwarf_srclines
DS
f
CW
void
exampled
Dwarf_Die
somedie
Dwarf_Signed
count
Dwarf_Line_Context
context
Dwarf_Line
linebuf
Dwarf_Signed
i
Dwarf_Error
error
Dwarf_Line
line
Dwarf_Small
table_count
Dwarf_Unsigned
version
int
sres
sres
dwarf_srclines_b
somedie
if
sres
DW_DLV_OK
return
sres
dwarf_srclines_from_linecontext
context
if
sres
DW_DLV_OK
dwarf_srclines_dealloc_b
context
return
line
linebuf
for
i
i
count
line
use
line
dwarf_srclines_dealloc_b
context
fP
DE
in
P
An
alternative
using
f
CWdwarf_dealloc
fP
directly
is
no
longer
as
of
described
here
It
works
as
well
as
ever
but
it
has
been
obsolete
since
still
works
but
does
not
completely
free
all
data
allocated
The
f
CWdwarf_srclines_dealloc
fP
routine
was
created
to
fix
the
problem
of
incomplete
deallocation
H
Get
the
set
of
Source
File
Names
The
function
returns
the
names
of
the
source
files
that
have
contributed
to
the
compilation
unit
represented
by
the
given
DIE
Only
the
source
files
named
in
the
statement
program
prologue
which
in
current
DWARF
standards
is
referred
to
as
the
Line
Table
Header
are
returned
H
dwarf_srcfiles
This
works
for
for
all
line
tables
However
indexing
is
different
in
DWARF5
than
in
other
versions
of
dwarf
To
understand
the
DWARF5
version
look
at
the
following
which
explains
a
contradiction
in
the
DWARF5
document
and
how
libdwarf
and
at
least
some
compilers
resolve
it
Join
the
next
two
strings
together
with
no
spaces
to
recreate
the
web
reference
P
If
the
applicable
file
name
in
the
line
table
Statement
Program
Prolog
does
not
start
with
a
character
the
string
in
f
CWDW_AT_comp_dir
fP
if
applicable
and
present
and
the
applicable
directory
name
from
the
line
Statement
Program
Prolog
is
prepended
to
the
file
name
in
the
line
table
Statement
Program
Prolog
to
make
a
full
path
P
For
all
versions
of
dwarf
this
function
and
dwarf_linesrc
prepend
the
value
of
DW_AT_co
prepend
the
value
of
DW_AT_comp_dir
to
the
name
created
from
the
line
table
header
file
names
and
directory
names
if
the
line
table
header
name
s
are
not
full
paths
mp_dir
to
the
name
created
from
the
line
table
header
file
names
and
directory
names
if
the
line
table
header
name
s
are
not
full
paths
P
http
wiki
dwarfstd
org
index
php?title
DWARF5_Line_Table_File_Numbers
P
It
may
help
understand
the
file
tables
and
dwarf_srcfiles
to
use
f
CWdwarfdump
fP
The
f
CWdwarfdump
fP
utility
program
now
will
print
the
dwarf_srcfiles
values
in
addition
to
the
compilation
unit
DIE
and
the
line
table
header
details
and
much
more
if
one
does
dwarfdump
vvv
i
l
objfilename
or
dwarfdump
vvv
a
objfilename
for
example
Since
the
output
can
be
large
with
your
editor
focus
on
lines
beginning
with
COMPILE_UNIT
do
not
type
the
quotes
to
quickly
get
to
the
CU
die
and
the
line
table
for
that
CU
as
those
tend
to
be
far
apart
in
the
output
P
DWARF5
f
CWDW_MACRO_start_file
fP
f
CWDW_LNS_set_file
fP
f
CWDW_AT_decl_file
fP
f
CWDW_AT_call_file
fP
and
the
line
table
state
machine
file
numbers
begin
at
zero
To
index
srcfiles
use
the
values
directly
with
no
subtraction
P
DWARF2
and
experimental
line
table
f
CWDW_MACINFO_start_file
fP
f
CWDW_LNS_set_file
fP
f
CWDW_AT_decl_file
fP
and
line
table
state
machine
file
numbers
begin
at
one
In
all
these
the
value
of
means
there
is
no
source
file
or
source
file
name
To
index
the
srcfiles
array
subtract
one
from
the
f
CWDW_AT_decl_file
fP
etc
file
number
P
DS
f
CWint
dwarf_srcfiles
Dwarf_Die
die
char
srcfiles
Dwarf_Signed
srccount
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_srcfiles
fP
returns
f
CWDW_DLV_OK
fP
and
puts
the
number
of
source
files
named
in
the
statement
program
prologue
indicated
by
the
given
f
CWdie
fP
into
f
CW
srccount
fP
Source
files
defined
in
the
statement
program
are
ignored
The
given
f
CWdie
fP
should
have
the
tag
f
CWDW_TAG_compile_unit
fP
f
CWDW_TAG_partial_unit
fP
or
f
CWDW_TAG_type_unit
fP
The
location
pointed
to
by
f
CWsrcfiles
fP
is
set
to
point
to
a
list
of
pointers
to
null
terminated
strings
that
name
the
source
files
P
On
a
successful
return
from
f
CWdwarf_srcfiles
fP
each
of
the
strings
returned
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
This
should
be
followed
by
free
ing
the
list
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_LIST
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
corresponding
statement
program
i
e
if
there
is
no
line
information
P
in
FG
Exampled
dwarf_srcfiles
DS
f
CW
void
examplee
Dwarf_Debug
dbg
Dwarf_Die
somedie
Dwarf_Signed
count
char
srcfiles
Dwarf_Signed
i
Dwarf_Error
error
int
res
res
dwarf_srcfiles
somedie
if
res
DW_DLV_OK
for
i
i
count
i
use
srcfiles
i
dwarf_dealloc
dbg
srcfiles
i
DW_DLA_STRING
dwarf_dealloc
dbg
srcfiles
DW_DLA_LIST
fP
DE
in
H
Get
Information
About
a
Single
Line
Table
Line
The
following
functions
can
be
used
on
the
f
CWDwarf_Line
fP
descriptors
returned
by
f
CWdwarf_srclines
fP
or
f
CWdwarf_srclines_from_linecontext
fP
to
obtain
information
about
the
source
lines
H
dwarf_linebeginstatement
DS
f
CWint
dwarf_linebeginstatement
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_linebeginstatement
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_bool
fP
to
fInon
zero
fP
if
f
CWline
fP
represents
a
line
number
entry
that
is
marked
as
beginning
a
statement
or
fIzero
fP
if
f
CWline
fP
represents
a
line
number
entry
that
is
not
marked
as
beginning
a
statement
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
H
dwarf_lineendsequence
DS
f
CWint
dwarf_lineendsequence
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lineendsequence
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_bool
fP
fInon
zero
fP
in
which
case
f
CWline
fP
represents
a
line
number
entry
that
is
marked
as
ending
a
text
sequence
or
fIzero
fP
in
which
case
f
CWline
fP
represents
a
line
number
entry
that
is
not
marked
as
ending
a
text
sequence
A
line
number
entry
that
is
marked
as
ending
a
text
sequence
is
an
entry
with
an
address
one
beyond
the
highest
address
used
by
the
current
sequence
of
line
table
entries
that
is
the
table
entry
is
a
DW_LNE_end_sequence
entry
see
the
DWARF
specification
P
The
function
f
CWdwarf_lineendsequence
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
H
dwarf_lineno
DS
f
CWint
dwarf_lineno
Dwarf_Line
line
Dwarf_Unsigned
returned_lineno
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lineno
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_lineno
fP
to
the
source
statement
line
number
corresponding
to
the
descriptor
f
CWline
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
H
dwarf_line_srcfileno
DS
f
CWint
dwarf_line_srcfileno
Dwarf_Line
line
Dwarf_Unsigned
returned_fileno
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_line_srcfileno
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_fileno
fP
to
the
source
statement
line
number
corresponding
to
the
descriptor
f
CWfile
number
fP
P
DWARF2
and
experimental
When
the
number
returned
through
f
CW
returned_fileno
fP
is
zero
it
means
the
file
name
is
unknown
see
the
DWARF2
line
table
specification
When
the
number
returned
through
f
CW
returned_fileno
fP
is
non
zero
it
is
a
file
number
subtract
from
this
file
number
to
get
an
index
into
the
array
of
strings
returned
by
f
CWdwarf_srcfiles
fP
verify
the
resulting
index
is
in
range
for
the
array
of
strings
before
indexing
into
the
array
of
strings
The
file
number
may
exceed
the
size
of
the
array
of
strings
returned
by
f
CWdwarf_srcfiles
fP
because
f
CWdwarf_srcfiles
fP
does
not
return
files
names
defined
with
the
f
CWDW_DLE_define_file
fP
operator
P
DWARF5
To
index
into
the
array
of
strings
returned
by
f
CWdwarf_srcfiles
fP
use
the
number
returned
through
f
CW
returned_fileno
fP
P
The
function
f
CWdwarf_line_srcfileno
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
H
dwarf_lineaddr
DS
f
CWint
dwarf_lineaddr
Dwarf_Line
line
Dwarf_Addr
return_lineaddr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lineaddr
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_lineaddr
fP
to
the
address
associated
with
the
descriptor
f
CWline
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_lineoff_b
DS
f
CWint
dwarf_lineoff_b
Dwarf_Line
line
Dwarf_Unsigned
return_lineoff
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lineoff_b
fP
returns
the
unsigned
column
number
of
the
declaration
within
the
line
through
the
pointer
f
CWreturn_lineoff
fP
P
Per
the
standard
all
versions
a
column
number
of
zero
means
column
unknown
Actual
columns
start
with
one
Any
non
zero
value
comes
from
the
attribute
f
CWDW_AT_decl_column
fP
while
zero
could
be
from
f
CWDW_AT_decl_column
fP
or
could
mean
f
CWDW_AT_decl_column
fP
is
missing
the
attribute
is
very
often
missing
P
It
returns
f
CWDW_DLV_OK
fP
unless
the
f
CWline
fP
or
f
CWreturn_lineoff
fP
field
is
NULL
in
which
case
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
error
DIE
H
dwarf_linesrc
DS
f
CWint
dwarf_linesrc
Dwarf_Line
line
char
return_linesrc
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_linesrc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_linesrc
fP
to
a
pointer
to
a
null
terminated
string
of
characters
that
represents
the
name
of
the
source
file
where
f
CWline
fP
occurs
It
returns
f
CWDW_DLV_ERROR
fP
on
error
P
If
the
applicable
file
name
in
the
line
table
Statement
Program
Prolog
does
not
start
with
a
character
the
string
in
f
CWDW_AT_comp_dir
fP
if
applicable
and
present
or
the
applicable
directory
name
from
the
line
Statement
Program
Prolog
is
prepended
to
the
file
name
in
the
line
table
Statement
Program
Prolog
to
make
a
full
path
P
The
storage
pointed
to
by
a
successful
return
of
f
CWdwarf_linesrc
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_lineblock
DS
f
CWint
dwarf_lineblock
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lineblock
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_linesrc
fP
to
non
zero
i
e
true
if
the
line
is
marked
as
beginning
a
basic
block
or
zero
i
e
false
if
the
line
is
marked
as
not
beginning
a
basic
block
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_is_addr_set
DS
f
CWint
dwarf_line_is_addr_set
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_line_is_addr_set
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_bool
fP
to
non
zero
i
e
true
if
the
line
is
marked
as
being
a
DW_LNE_set_address
operation
or
zero
i
e
false
if
the
line
is
marked
as
not
being
a
DW_LNE_set_address
operation
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
This
is
intended
to
allow
consumers
to
do
a
more
useful
job
printing
and
analyzing
DWARF
data
it
is
not
strictly
necessary
H
dwarf_prologue_end_etc
DS
f
CWint
dwarf_prologue_end_etc
Dwarf_Line
line
Dwarf_Bool
prologue_end
Dwarf_Bool
epilogue_begin
Dwarf_Unsigned
isa
Dwarf_Unsigned
discriminator
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_prologue_end_etc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
the
returned
fields
to
values
currently
set
While
it
is
pretty
safe
to
assume
that
the
f
CWisa
fP
and
f
CWdiscriminator
fP
values
returned
are
very
small
integers
there
is
no
restriction
in
the
standard
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
This
function
is
new
in
December
H
Accelerated
Access
By
Name
operations
These
operations
operate
on
the
debug_pubnames
section
as
well
as
all
the
other
sections
with
this
specific
format
and
purpose
debug_pubtypes
debug_typenames
debug_varnames
debug_funcnames
and
debug_weaknames
The
first
in
the
list
is
generic
DWARF
The
second
in
the
list
is
generic
DWARF
The
rest
are
SGI
specific
and
rarely
used
P
The
interface
types
are
Dwarf_Global
Dwarf_Type
Dwarf_Weak
Dwarf_Func
and
Dwarf_Var
Only
Dwarf_Global
is
a
real
type
The
others
are
opaque
pointers
with
no
actual
definition
or
instantiation
and
can
be
converted
to
Dwarf_Global
with
a
simple
cast
P
In
hindsight
it
would
have
been
simpler
to
write
a
single
set
of
interfaces
for
Accelerated
Access
By
Name
H
Fine
Tuning
Accelerated
Access
By
default
the
various
dwarf_get
functions
here
return
an
array
of
pointers
to
opaque
records
with
a
debug_info
DIE
offset
and
a
string
the
fields
are
accessible
by
function
calls
While
the
actual
debug_pubnames
etc
section
contains
CU
local
DIE
offsets
for
the
named
things
the
accelerated
access
functions
below
return
a
debug_info
or
debug_types
global
section
offset
P
H
dwarf_return_empty_pubnames
New
March
Mostly
special
for
dwarfdump
If
called
with
a
flag
value
of
one
it
tells
libdwarf
for
any
pubnames
etc
section
list
returned
to
add
to
the
list
an
entry
with
a
global
DIE
offset
of
zero
for
any
section
Compilation
Unit
entry
with
no
pubnames
etc
name
ie
an
empty
list
for
the
Compilation
Unit
P
If
called
with
a
value
of
zero
zero
is
the
default
set
by
any
f
CWdwarf_init
fP
call
it
causes
such
empty
lists
to
be
omitted
from
the
array
of
pointers
returned
which
is
the
standard
behavior
of
libdwarf
since
libdwarf
was
first
written
P
Since
zero
is
never
a
valid
DIE
offset
in
debug_info
or
debug_types
consumers
requesting
such
can
detect
the
special
Dwarf_Global
entries
P
For
example
calling
f
CW
dwarf_global_name_offsets
fP
on
one
of
the
special
global
records
sets
f
CW
die_offset
fP
to
f
CW
return_name
fP
to
a
pointer
to
an
empty
string
and
f
CW
cu_offset
fP
to
the
offset
of
the
compilation
unit
die
in
the
debug_info
or
debug_types
if
applicable
section
DS
f
CWint
dwarf_return_empty_pubnames
Dwarf_Debug
dbg
int
flag
Dwarf_Error
error
fP
DE
Callers
should
pass
in
one
or
zero
no
other
value
On
success
it
returns
DW_DLV_OK
On
failure
it
returns
DW_DLV_ERROR
P
The
assumption
is
that
programs
calling
this
with
value
one
will
be
calling
dwarf_get_globals_header
to
retrieve
the
relevant
pubnames
etc
section
Compilation
Unit
header
H
dwarf_get_globals_header
New
February
For
more
complete
dwarfdump
printing
For
each
CU
represented
in
debug_pubnames
etc
there
is
a
debug_pubnames
header
For
any
given
Dwarf_Global
this
returns
the
content
of
the
applicable
header
P
This
allows
dwarfdump
or
any
DWARF
dumper
to
print
pubnames
etc
specific
CU
header
data
DS
f
CWint
dwarf_get_globals_header
Dwarf_Global
global
Dwarf_Off
offset_pub_header
Dwarf_Unsigned
offset_size
Dwarf_Unsigned
length_pub
Dwarf_Unsigned
version
Dwarf_Unsigned
header_info_offset
Dwarf_Unsigned
info_length
Dwarf_Error
error
fP
DE
On
success
it
returns
DW_DLV_OK
and
it
returns
the
header
data
and
calculated
values
though
the
pointers
Casting
Dwarf_Type
etc
to
Dwarf_Global
for
a
call
to
this
function
allows
this
to
be
used
for
any
of
these
accelerated
access
types
H
Accelerated
Access
Pubnames
H
dwarf_get_globals
This
is
debug_pubnames
and
is
standard
DWARF2
DWARF3
and
DWARF4
DS
f
CWint
dwarf_get_globals
Dwarf_Debug
dbg
Dwarf_Global
globals
Dwarf_Signed
return_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_globals
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_count
fP
to
the
count
of
pubnames
represented
in
the
section
containing
pubnames
i
e
debug_pubnames
It
also
stores
at
f
CW
globals
fP
a
pointer
to
a
list
of
f
CWDwarf_Global
fP
descriptors
one
for
each
of
the
pubnames
in
the
debug_pubnames
section
The
returned
results
are
for
the
entire
section
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_pubnames
section
does
not
exist
P
On
a
successful
return
from
f
CWdwarf_get_globals
fP
the
f
CWDwarf_Global
fP
descriptors
should
be
freed
using
f
CWdwarf_globals_dealloc
fP
f
CWdwarf_globals_dealloc
fP
is
new
as
of
July
and
is
the
preferred
approach
to
freeing
this
memory
P
Global
names
refer
exclusively
to
names
and
offsets
in
the
debug_info
section
See
section
Lookup
by
Name
in
the
dwarf
standard
in
FG
Exampled
dwarf_get_globals
DS
f
CW
void
examplef
Dwarf_Debug
dbg
Dwarf_Signed
count
Dwarf_Global
globs
Dwarf_Signed
i
Dwarf_Error
error
int
res
res
dwarf_get_globals
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
globs
i
dwarf_globals_dealloc
dbg
globs
count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
On
a
successful
return
from
f
CWdwarf_get_globals
fP
the
f
CWDwarf_Global
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_GLOBAL_CONTEXT
fP
or
f
CWDW_DLA_GLOBAL
fP
an
older
name
supported
for
compatibility
followed
by
the
deallocation
of
the
list
itself
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
the
descriptors
are
no
longer
of
interest
in
DS
f
CW
Dwarf_Signed
cnt
Dwarf_Global
globs
int
res
res
dwarf_get_globals
dbg
if
res
DW_DLV_OK
OBSOLETE
DO
NOT
USE
to
deallocate
for
i
i
cnt
i
use
globs
i
dwarf_dealloc
dbg
globs
i
DW_DLA_GLOBAL_CONTEXT
dwarf_dealloc
dbg
globs
DW_DLA_LIST
fP
DE
in
H
dwarf_globname
DS
f
CWint
dwarf_globname
Dwarf_Global
global
char
return_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_globname
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
pubname
represented
by
the
f
CWDwarf_Global
fP
descriptor
f
CWglobal
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_global_die_offset
DS
f
CWint
dwarf_global_die_offset
Dwarf_Global
global
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_global_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
pubname
that
is
described
by
the
f
CWDwarf_Global
fP
descriptor
f
CWglob
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_global_cu_offset
DS
f
CWint
dwarf_global_cu_offset
Dwarf_Global
global
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_global_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
pubname
described
by
the
f
CWDwarf_Global
fP
descriptor
f
CWglobal
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_get_cu_die_offset_given_cu_header_offset
DS
f
CWint
dwarf_get_cu_die_offset_given_cu_header_offset_b
Dwarf_Debug
dbg
Dwarf_Off
in_cu_header_offset
Dwarf_Bool
is_info
Dwarf_Off
out_cu_die_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_cu_die_offset_given_cu_header_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
out_cu_die_offset
fP
to
the
offset
of
the
compilation
unit
DIE
given
the
offset
f
CWin_cu_header_offset
fP
of
a
compilation
unit
header
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
If
f
CWis_info
fP
is
non
zero
the
f
CWin_cu_header_offset
fP
must
refer
to
a
debug_info
section
offset
If
f
CWis_info
fP
zero
the
f
CWin_cu_header_offset
fP
must
refer
to
a
debug_types
section
offset
Chaos
may
result
if
the
f
CWis_info
fP
flag
is
incorrect
This
effectively
turns
a
compilation
unit
header
offset
into
a
compilation
unit
DIE
offset
by
adding
the
size
of
the
applicable
CU
header
This
function
is
also
sometimes
useful
with
the
f
CWdwarf_weak_cu_offset
fP
f
CWdwarf_func_cu_offset
fP
f
CWdwarf_type_cu_offset
fP
and
f
CWint
dwarf_var_cu_offset
fP
functions
though
for
those
functions
the
data
is
only
in
debug_info
by
definition
H
dwarf_get_cu_die_offset_given_cu_header_offset
DS
f
CWint
dwarf_get_cu_die_offset_given_cu_header_offset
Dwarf_Debug
dbg
Dwarf_Off
in_cu_header_offset
Dwarf_Off
out_cu_die_offset
Dwarf_Error
error
fP
DE
This
function
is
superseded
by
f
CWdwarf_get_cu_die_offset_given_cu_header_offset_b
fP
a
function
which
is
still
supported
thought
it
refers
only
to
the
debug_info
section
P
f
CWdwarf_get_cu_die_offset_given_cu_header_offset
fP
added
Rev
June
P
This
function
was
declared
as
optional
in
libdwarf
h
on
IRIX
systems
so
the
_MIPS_SYMBOL_PRESENT
predicate
could
be
used
at
run
time
to
determine
if
the
version
of
libdwarf
linked
into
an
application
has
this
function
H
dwarf_global_name_offsets
DS
f
CWint
dwarf_global_name_offsets
Dwarf_Global
global
char
return_name
Dwarf_Off
die_offset
Dwarf_Off
cu_die_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_global_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
pubname
described
by
the
f
CWDwarf_Global
fP
descriptor
f
CWglobal
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
global
offset
of
the
DIE
representing
the
pubname
and
the
offset
of
the
DIE
representing
the
compilation
unit
containing
the
pubname
respectively
On
a
successful
return
from
f
CWdwarf_global_name_offsets
fP
the
storage
pointed
to
by
f
CWreturn_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
P
If
a
portion
of
debug_pubnames
or
debug_types
etc
represents
a
compilation
unit
with
no
names
there
is
a
debug_pubnames
header
there
with
no
content
In
that
case
a
single
Dwarf_Global
record
is
created
with
the
value
of
die_offset
zero
and
the
name
pointer
returned
points
to
the
empty
string
A
zero
is
never
a
valid
DIE
offset
so
zero
always
means
this
is
an
uninteresting
Dwarf_Global
H
Accelerated
Access
Pubtypes
Section
debug_pubtypes
is
in
DWARF3
and
DWARF4
P
These
functions
operate
on
the
debug_pubtypes
section
of
the
debugging
information
The
debug_pubtypes
section
contains
the
names
of
file
scope
user
defined
types
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
those
types
and
the
offsets
of
the
compilation
units
that
contain
the
definitions
of
those
types
H
dwarf_get_pubtypes
This
is
standard
DWARF3
and
DWARF4
DS
f
CWint
dwarf_get_pubtypes
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
typecount
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_pubtypes
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
typecount
fP
to
the
count
of
user
defined
type
names
represented
in
the
section
containing
user
defined
type
names
i
e
debug_pubtypes
It
also
stores
at
f
CW
types
fP
a
pointer
to
a
list
of
f
CWDwarf_Type
fP
descriptors
one
for
each
of
the
user
defined
type
names
in
the
debug_pubtypes
section
The
returned
results
are
for
the
entire
section
It
returns
f
CWDW_DLV_NOCOUNT
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_pubtypes
section
does
not
exist
P
On
a
successful
return
from
f
CWdwarf_get_pubtypes
fP
the
f
CWDwarf_Type
fP
descriptors
should
be
freed
using
f
CWdwarf_types_dealloc
fP
f
CWdwarf_types_dealloc
fP
is
used
for
both
f
CWdwarf_get_pubtypes
fP
and
f
CWdwarf_get_types
fP
as
the
data
types
are
the
same
P
Global
type
names
refer
exclusively
to
names
and
offsets
in
the
debug_info
section
See
section
Lookup
by
Name
in
the
dwarf
standard
in
FG
Exampled
dwarf_get_pubtypes
DS
f
CW
void
exampleg
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Type
types
Dwarf_Signed
i
int
res
res
dwarf_get_pubtypes
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
types
i
dwarf_types_dealloc
dbg
types
count
fP
DE
in
H
dwarf_pubtypename
DS
f
CWint
dwarf_pubtypename
Dwarf_Type
type
char
return_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_pubtypename
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
user
defined
type
represented
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
dwarf_pubtype_type_die_offset
DS
f
CWint
dwarf_pubtype_type_die_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_pubtype_type_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
user
defined
type
that
is
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_pubtype_cu_offset
DS
f
CWint
dwarf_pubtype_cu_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_pubtype_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
user
defined
type
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_pubtype_name_offsets
DS
f
CWint
dwarf_pubtype_name_offsets
Dwarf_Type
type
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_pubtype_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
user
defined
type
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
offsets
of
the
DIE
representing
the
user
defined
type
and
the
DIE
representing
the
compilation
unit
containing
the
user
defined
type
respectively
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
f
CWdwarf_pubtype_name_offsets
fP
the
storage
pointed
to
by
f
CWreturned_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
Accelerated
Access
Weaknames
This
section
is
SGI
specific
and
is
not
part
of
standard
DWARF
P
These
functions
operate
on
the
debug_varnames
section
of
the
debugging
information
The
debug_varnames
section
contains
the
names
of
file
scope
static
variables
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
those
variables
and
the
offsets
of
the
compilation
units
that
contain
the
definitions
of
those
variables
P
These
operations
operate
on
the
debug_weaknames
section
of
the
debugging
information
H
dwarf_get_weaks
DS
f
CWint
dwarf_get_weaks
Dwarf_Debug
dbg
Dwarf_Weak
weaks
Dwarf_Signed
weak_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_weaks
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
weak_count
fP
to
the
count
of
weak
names
represented
in
the
section
containing
weak
names
i
e
debug_weaknames
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
section
does
not
exist
It
also
stores
in
f
CW
weaks
fP
a
pointer
to
a
list
of
f
CWDwarf_Weak
fP
descriptors
one
for
each
of
the
weak
names
in
the
debug_weaknames
section
The
returned
results
are
for
the
entire
section
P
On
a
successful
return
from
this
function
the
f
CWDwarf_Weak
fP
descriptors
should
be
freed
using
f
CWdwarf_weaks_dealloc
fP
when
the
data
is
no
longer
of
interest
f
CWdwarf_weaks_dealloc
fPis
new
as
of
July
in
FG
Exampleh
dwarf_get_weaks
DS
f
CW
void
exampleh
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Weak
weaks
Dwarf_Signed
i
int
res
res
dwarf_get_weaks
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
weaks
i
dwarf_weaks_dealloc
dbg
weaks
count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
On
a
successful
return
from
f
CWdwarf_get_weaks
fP
the
f
CWDwarf_Weak
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_WEAK_CONTEXT
fP
or
f
CWDW_DLA_WEAK
fP
an
older
name
supported
for
compatibility
followed
by
the
deallocation
of
the
list
itself
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
the
descriptors
are
no
longer
of
interest
in
FG
Examplei
dwarf_get_weaks
obsolete
DS
f
CW
void
examplei
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Weak
weaks
Dwarf_Signed
i
int
res
Obsolete
see
exampleh
instead
res
dwarf_get_weaks
dbg
if
res
DW_DLV_OK
OBSOLETE
do
not
use
dealloc
for
this
See
above
for
i
i
count
i
use
weaks
i
dwarf_dealloc
dbg
weaks
i
DW_DLA_WEAK
dwarf_dealloc
dbg
weaks
DW_DLA_LIST
fP
DE
in
H
dwarf_weakname
DS
f
CWint
dwarf_weakname
Dwarf_Weak
weak
char
return_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_weakname
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
weak
name
represented
by
the
f
CWDwarf_Weak
fP
descriptor
f
CWweak
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
DS
f
CWint
dwarf_weak_die_offset
Dwarf_Weak
weak
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_weak_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
weak
name
that
is
described
by
the
f
CWDwarf_Weak
fP
descriptor
f
CWweak
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_weak_cu_offset
DS
f
CWint
dwarf_weak_cu_offset
Dwarf_Weak
weak
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_weak_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
weak
name
described
by
the
f
CWDwarf_Weak
fP
descriptor
f
CWweak
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_weak_name_offsets
DS
f
CWint
dwarf_weak_name_offsets
Dwarf_Weak
weak
char
weak_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_weak_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
weak_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
weak
name
described
by
the
f
CWDwarf_Weak
fP
descriptor
f
CWweak
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
offsets
of
the
DIE
representing
the
weakname
and
the
DIE
representing
the
compilation
unit
containing
the
weakname
respectively
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
f
CWdwarf_weak_name_offsets
fP
the
storage
pointed
to
by
f
CWweak_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
Accelerated
Access
Funcnames
This
section
is
SGI
specific
and
is
not
part
of
standard
DWARF
P
These
function
operate
on
the
debug_funcnames
section
of
the
debugging
information
The
debug_funcnames
section
contains
the
names
of
static
functions
defined
in
the
object
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
the
corresponding
functions
and
the
offsets
of
the
start
of
the
compilation
units
that
contain
the
definitions
of
those
functions
H
dwarf_get_funcs
DS
f
CWint
dwarf_get_funcs
Dwarf_Debug
dbg
Dwarf_Func
funcs
Dwarf_Signed
func_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_funcs
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
func_count
fP
to
the
count
of
static
function
names
represented
in
the
section
containing
static
function
names
i
e
debug_funcnames
It
also
stores
at
f
CW
funcs
fP
a
pointer
to
a
list
of
f
CWDwarf_Func
fP
descriptors
one
for
each
of
the
static
functions
in
the
debug_funcnames
section
The
returned
results
are
for
the
entire
section
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_funcnames
section
does
not
exist
P
On
a
successful
return
from
f
CWdwarf_get_funcs
fP
the
f
CWDwarf_Func
fP
descriptors
should
be
freed
using
f
CWdwarf_funcs_dealloc
fP
f
CWdwarf_funcs_dealloc
fP
is
new
as
of
July
in
FG
Examplej
dwarf_get_funcs
DS
f
CW
void
examplej
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Func
funcs
Dwarf_Signed
i
int
fres
fres
dwarf_get_funcs
dbg
if
fres
DW_DLV_OK
for
i
i
count
i
use
funcs
i
dwarf_funcs_dealloc
dbg
funcs
count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
On
a
successful
return
from
f
CWdwarf_get_funcs
fP
the
f
CWDwarf_Func
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_FUNC_CONTEXT
fP
or
f
CWDW_DLA_FUNC
fP
an
older
name
supported
for
compatibility
followed
by
the
deallocation
of
the
list
itself
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
the
descriptors
are
no
longer
of
interest
in
FG
Examplek
dwarf_get_funcs
obsolete
DS
f
CW
void
examplek
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Func
funcs
Dwarf_Signed
count
Dwarf_Signed
i
int
fres
fres
dwarf_get_funcs
dbg
if
fres
DW_DLV_OK
OBSOLETE
see
dwarf_funcs_dealloc
above
for
i
i
count
i
use
funcs
i
dwarf_dealloc
dbg
funcs
i
DW_DLA_FUNC
dwarf_dealloc
dbg
funcs
DW_DLA_LIST
fP
DE
in
H
dwarf_funcname
DS
f
CWint
dwarf_funcname
Dwarf_Func
func
char
return_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_funcname
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
static
function
represented
by
the
f
CWDwarf_Func
fP
descriptor
f
CWfunc
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
dwarf_func_die_offset
DS
f
CWint
dwarf_func_die_offset
Dwarf_Func
func
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_func_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
static
function
that
is
described
by
the
f
CWDwarf_Func
fP
descriptor
f
CWfunc
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_func_cu_offset
DS
f
CWint
dwarf_func_cu_offset
Dwarf_Func
func
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_func_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
static
function
described
by
the
f
CWDwarf_Func
fP
descriptor
f
CWfunc
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_func_name_offsets
DS
f
CWint
dwarf_func_name_offsets
Dwarf_Func
func
char
func_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_func_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
func_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
static
function
described
by
the
f
CWDwarf_Func
fP
descriptor
f
CWfunc
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
offsets
of
the
DIE
representing
the
static
function
and
the
DIE
representing
the
compilation
unit
containing
the
static
function
respectively
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
f
CWdwarf_func_name_offsets
fP
the
storage
pointed
to
by
f
CWfunc_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
Accelerated
Access
Typenames
Section
debug_typenames
is
SGI
specific
and
is
not
part
of
standard
DWARF
However
an
identical
section
is
part
of
DWARF
version
named
debug_pubtypes
see
f
CWdwarf_get_pubtypes
fP
above
P
These
functions
operate
on
the
debug_typenames
section
of
the
debugging
information
The
debug_typenames
section
contains
the
names
of
file
scope
user
defined
types
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
those
types
and
the
offsets
of
the
compilation
units
that
contain
the
definitions
of
those
types
H
dwarf_get_types
DS
f
CWint
dwarf_get_types
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
typecount
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_types
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
typecount
fP
to
the
count
of
user
defined
type
names
represented
in
the
section
containing
user
defined
type
names
i
e
debug_typenames
It
also
stores
at
f
CW
types
fP
a
pointer
to
a
list
of
f
CWDwarf_Type
fP
descriptors
one
for
each
of
the
user
defined
type
names
in
the
debug_typenames
section
The
returned
results
are
for
the
entire
section
It
returns
f
CWDW_DLV_NOCOUNT
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_typenames
section
does
not
exist
P
On
a
successful
return
from
f
CWdwarf_get_types
fP
the
f
CWDwarf_Type
fP
descriptors
should
be
freed
using
f
CWdwarf_types_dealloc
fP
f
CWdwarf_types_dealloc
fP
is
new
as
of
July
and
frees
all
memory
allocated
by
f
CWdwarf_get_types
fP
in
FG
Examplel
dwarf_get_types
DS
f
CW
void
examplel
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Type
types
Dwarf_Signed
i
int
res
res
dwarf_get_types
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
types
i
dwarf_types_dealloc
dbg
types
count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
On
a
successful
return
from
f
CWdwarf_get_types
fP
the
f
CWDwarf_Type
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_TYPENAME_CONTEXT
fP
or
f
CWDW_DLA_TYPENAME
fP
an
older
name
supported
for
compatibility
followed
by
the
deallocation
of
the
list
itself
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
the
descriptors
are
no
longer
of
interest
in
FG
Examplel
dwarf_get_types
obsolete
DS
f
CW
void
examplem
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Type
types
Dwarf_Signed
i
int
res
OBSOLETE
see
dwarf_types_dealloc
above
res
dwarf_get_types
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
types
i
dwarf_dealloc
dbg
types
i
DW_DLA_TYPENAME
dwarf_dealloc
dbg
types
DW_DLA_LIST
fP
DE
in
H
dwarf_typename
DS
f
CWint
dwarf_typename
Dwarf_Type
type
char
return_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_typename
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
user
defined
type
represented
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
dwarf_type_die_offset
DS
f
CWint
dwarf_type_die_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_type_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
user
defined
type
that
is
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_type_cu_offset
DS
f
CWint
dwarf_type_cu_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_type_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
user
defined
type
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_type_name_offsets
DS
f
CWint
dwarf_type_name_offsets
Dwarf_Type
type
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_type_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
user
defined
type
described
by
the
f
CWDwarf_Type
fP
descriptor
f
CWtype
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
offsets
of
the
DIE
representing
the
user
defined
type
and
the
DIE
representing
the
compilation
unit
containing
the
user
defined
type
respectively
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
f
CWdwarf_type_name_offsets
fP
the
storage
pointed
to
by
f
CWreturned_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
Accelerated
Access
varnames
This
section
is
SGI
specific
and
is
not
part
of
standard
DWARF
P
These
functions
operate
on
the
debug_varnames
section
of
the
debugging
information
The
debug_varnames
section
contains
the
names
of
file
scope
static
variables
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
those
variables
and
the
offsets
of
the
compilation
units
that
contain
the
definitions
of
those
variables
H
dwarf_get_vars
DS
f
CWint
dwarf_get_vars
Dwarf_Debug
dbg
Dwarf_Var
vars
Dwarf_Signed
var_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_vars
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
var_count
fP
to
the
count
of
file
scope
static
variable
names
represented
in
the
section
containing
file
scope
static
variable
names
i
e
debug_varnames
It
also
stores
at
f
CW
vars
fP
a
pointer
to
a
list
of
f
CWDwarf_Var
fP
descriptors
one
for
each
of
the
file
scope
static
variable
names
in
the
debug_varnames
section
The
returned
results
are
for
the
entire
section
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_varnames
section
does
not
exist
P
The
following
is
new
as
of
July
On
a
successful
return
from
f
CWdwarf_get_vars
fP
the
f
CWDwarf_Var
fP
descriptors
should
be
freed
using
f
CWdwarf_vars_dealloc
fP
in
FG
Examplen
dwarf_get_vars
DS
f
CW
void
examplen
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Var
vars
Dwarf_Signed
i
int
res
res
dwarf_get_vars
dbg
if
res
DW_DLV_OK
for
i
i
count
i
use
vars
i
dwarf_vars_dealloc
dbg
vars
count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
On
a
successful
return
from
f
CWdwarf_get_vars
fP
the
f
CWDwarf_Var
fP
descriptors
should
be
individually
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_VAR_CONTEXT
fP
or
f
CWDW_DLA_VAR
fP
an
older
name
supported
for
compatibility
followed
by
the
deallocation
of
the
list
itself
with
the
allocation
type
f
CWDW_DLA_LIST
fP
when
the
descriptors
are
no
longer
of
interest
in
FG
Exampleo
dwarf_get_vars
obsolete
DS
f
CW
void
exampleo
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Var
vars
Dwarf_Signed
i
int
res
res
dwarf_get_vars
dbg
if
res
DW_DLV_OK
DO
NOT
USE
see
dwarf_vars_dealloc
above
for
i
i
count
i
use
vars
i
dwarf_dealloc
dbg
vars
i
DW_DLA_VAR
dwarf_dealloc
dbg
vars
DW_DLA_LIST
fP
DE
in
H
dwarf_varname
DS
f
CWint
dwarf_varname
Dwarf_Var
var
char
returned_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_varname
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_name
fP
to
a
pointer
to
a
null
terminated
string
that
names
the
file
scope
static
variable
represented
by
the
f
CWDwarf_Var
fP
descriptor
f
CWvar
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
this
function
the
string
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
dwarf_var_die_offset
DS
f
CWint
dwarf_var_die_offset
Dwarf_Var
var
Dwarf_Off
returned_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_var_die_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
DIE
representing
the
file
scope
static
variable
that
is
described
by
the
f
CWDwarf_Var
fP
descriptor
f
CWvar
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_var_cu_offset
DS
f
CWint
dwarf_var_cu_offset
Dwarf_Var
var
Dwarf_Off
returned_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_var_cu_offset
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_offset
fP
to
the
offset
in
the
section
containing
DIEs
i
e
debug_info
of
the
compilation
unit
header
of
the
compilation
unit
that
contains
the
file
scope
static
variable
described
by
the
f
CWDwarf_Var
fP
descriptor
f
CWvar
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_var_name_offsets
DS
f
CWint
dwarf_var_name_offsets
Dwarf_Var
var
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_var_name_offsets
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_name
fP
to
a
pointer
to
a
null
terminated
string
that
gives
the
name
of
the
file
scope
static
variable
described
by
the
f
CWDwarf_Var
fP
descriptor
f
CWvar
fP
It
also
returns
in
the
locations
pointed
to
by
f
CWdie_offset
fP
and
f
CWcu_offset
fP
the
offsets
of
the
DIE
representing
the
representing
the
compilation
unit
containing
the
file
scope
static
variable
respectively
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
On
a
successful
return
from
f
CWdwarf_var_name_offsets
fP
the
storage
pointed
to
by
f
CWreturned_name
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
when
no
longer
of
interest
H
Names
Fast
Access
DWARF5
debug_names
The
section
f
CW
debug_names
fP
section
is
new
in
DWARF5
so
a
new
set
of
functions
is
defined
to
access
this
section
This
section
replaces
f
CW
debug_pubnames
fP
and
f
CW
debug_pubtypes
fP
as
those
older
sections
were
not
found
to
be
useful
in
practice
See
also
f
CWNames
Fast
Access
debug_gnu_pubnames
fP
H
dwarf_debugnames_header
DS
f
CWint
dwarf_debugnames_header
Dwarf_Debug
dbg
Dwarf_Dnames_Head
dn_out
Dwarf_Unsigned
dn_index_count_out
Dwarf_Error
error
fP
DE
P
The
function
f
CWdwarf_debugnames_header
fP
allocates
an
opaque
data
structure
used
in
all
the
other
debugnames
calls
P
Many
of
the
function
calls
here
let
one
extract
the
entire
content
of
the
section
which
is
useful
if
one
wishes
to
dump
the
section
or
to
use
its
data
to
create
one
s
own
internal
data
structures
P
To
free
space
allocated
when
one
has
finished
with
these
data
structures
call
DS
Debug_Dnames_Head
dn
Assume
set
somehow
dwarf_dealloc
dbg
dn
DW_DLA_DNAMES_HEAD
DE
which
will
free
up
all
data
allocated
for
f
CWdwarf_debugnames_header
fP
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
returns
a
pointer
to
the
Head
structure
through
f
CWdn_out
fP
P
It
also
returns
the
count
of
debugnames
entry
in
the
debugnames
index
through
the
f
CWdn_index_count_out
fP
value
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
f
CW
debug_names
fP
section
P
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
internal
error
such
as
data
corruption
in
the
section
H
dwarf_debugnames_sizes
DS
f
CW
int
dwarf_debugnames_sizes
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
section_offsets
Dwarf_Unsigned
version
Dwarf_Unsigned
offset_size
The
counts
are
entry
counts
not
byte
sizes
Dwarf_Unsigned
comp_unit_count
Dwarf_Unsigned
local_type_unit_count
Dwarf_Unsigned
foreign_type_unit_count
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
name_count
The
following
are
counted
in
bytes
Dwarf_Unsigned
indextable_overall_length
Dwarf_Unsigned
abbrev_table_size
Dwarf_Unsigned
entry_pool_size
Dwarf_Unsigned
augmentation_string_size
Dwarf_Error
error
fP
DE
P
Given
a
properly
created
head
f
CWdn
fP
this
Allows
access
to
fields
a
f
CW
debug_names
fP
f
CWDWARF5
fP
header
record
f
CWindex_number
fP
P
We
will
not
describe
the
fields
in
detail
here
See
the
f
CWDWARF5
fP
standard
and
f
CWdwarfdump
fP
for
the
motivation
of
this
function
H
dwarf_debugnames_cu_entry
DS
f
CW
int
dwarf_debugnames_cu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
fP
DE
Given
a
properly
created
head
f
CWdn
fP
this
Allows
access
to
fields
in
cu
entry
f
CWindex_number
fP
from
a
f
CW
debug_names
fP
f
CWDWARF5
fP
Compilation
Unit
entry
P
We
will
not
describe
the
fields
in
detail
here
See
the
f
CWDWARF5
fP
standard
and
f
CWdwarfdump
fP
for
the
motivation
of
this
function
H
dwarf_debugnames_local_tu_entry
DS
f
CW
int
dwarf_debugnames_local_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
fP
DE
P
The
same
as
f
CWdwarf_debugnames_cu_entry
fP
but
referencing
type
unit
fields
H
dwarf_debugnames_foreign_tu_entry
DS
f
CW
int
dwarf_debugnames_foreign_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
sig_number
Dwarf_Unsigned
sig_minimum
Dwarf_Unsigned
sig_count
Dwarf_Sig8
signature
Dwarf_Error
error
fP
DE
Allows
retrieving
the
data
for
foreign
type
unit
entries
H
dwarf_debugnames_bucket
DS
f
CW
int
dwarf_debugnames_bucket
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
bucket_number
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
index_of_name_entry
Dwarf_Error
error
fP
DE
Allows
retrieving
the
data
for
hash
buckets
H
dwarf_debugnames_name
DS
f
CW
int
dwarf_debugnames_bucket
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
name_entry
Dwarf_Unsigned
names_count
Dwarf_Sig8
signature
Dwarf_Unsigned
offset_to_debug_str
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Error
error
fP
DE
Allows
retrieving
the
data
about
names
and
signatures
H
dwarf_debugnames_abbrev_by_index
DS
f
CW
int
dwarf_debugnames_abbrev_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
number_of_abbrev
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
fP
DE
Allows
retrieving
the
abbreviations
from
a
portion
of
the
section
by
index
H
dwarf_debugnames_abbrev_by_code
DS
f
CW
int
dwarf_debugnames_abbrev_by_code
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
index_of_attr_form_entries
Dwarf_Error
error
fP
DE
Allows
retrieving
the
abbreviations
from
a
portion
of
the
section
by
abbrev
code
H
dwarf_debugnames_form_by_index
DS
f
CW
int
dwarf_debugnames_form_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry_index
Dwarf_Unsigned
abbrev_form_index
Dwarf_Unsigned
name_attr_index
Dwarf_Unsigned
form
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
fP
DE
Allows
retrieving
the
abbreviations
forms
from
a
portion
of
the
section
by
index
H
dwarf_debugnames_entrypool
DS
f
CW
int
dwarf_debugnames_entrypool
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
value_count
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_of_initial_value
Dwarf_Error
error
fP
DE
Allows
retrieving
the
data
from
a
portion
of
the
entrypool
by
index
and
offset
H
dwarf_debugnames_entrypool_values
DS
f
CW
int
dwarf_debugnames_entrypool_values
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_in_entrypool_of_values
Dwarf_Unsigned
array_dw_idx_number
Dwarf_Unsigned
array_form
Dwarf_Unsigned
array_of_offsets
Dwarf_Sig8
array_of_signatures
Dwarf_Error
error
fP
DE
Allows
retrieving
detailed
data
from
a
portion
of
the
entrypool
by
index
and
offset
H
Names
Fast
Access
debug_gnu_pubnames
The
sections
f
CW
debug_gnu_pubnames
fP
and
f
CW
debug_gnu_pubtypes
fP
are
non
standard
sections
emitted
by
gcc
and
clang
with
DWARF5
Typically
they
will
be
in
the
skeleton
executable
and
the
split
dwarf
section
f
CW
debug_info
dwo
fP
will
have
the
actual
DWARF
the
offsets
refer
to
These
sections
would
normally
be
read
once
by
a
program
wanting
them
and
filed
in
an
internal
format
and
then
the
program
would
do
the
cleanup
f
CWdwarf_gnu_index_dealloc
fP
P
Each
section
is
divided
into
what
we
term
blocks
here
and
within
each
block
there
is
an
array
of
entries
The
functions
below
enable
access
H
dwarf_get_gnu_index_head
DS
f
CWint
dwarf_get_gnu_index_head
Dwarf_Debug
dbg
The
following
arg
false
to
select
gnu_pubtypes
Dwarf_Bool
for_gdb_pubnames
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
index_block_count
Dwarf_Error
error
fP
DE
This
creates
an
open
header
to
use
in
subsequent
data
access
Free
the
memory
associated
with
this
by
calling
f
CWdwarf_gnu_index_dealloc
head
fP
f
CW
fP
P
The
field
f
CWindex_block_count
fP
is
set
through
the
pointer
to
the
number
of
blocks
in
the
section
Call
f
CWdwarf_get_gnu_index_block
fP
and
pass
in
valid
block
number
zero
through
index_block_count
to
get
block
information
P
If
the
section
does
not
exist
or
is
empty
it
returns
f
CWDW_DLV_NO_ENTRY
fP
and
does
nothing
else
P
If
there
is
data
corruption
or
some
serious
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
error
pointer
with
information
about
the
error
f
CW
fP
H
dwarf_gnu_index_dealloc
DS
f
CWvoid
dwarf_gnu_index_dealloc
Dwarf_Gnu_Index_Head
index_head
DE
This
frees
all
data
associated
with
the
section
H
dwarf_get_gnu_index_block
DS
f
CWint
dwarf_get_gnu_index_block
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
blocknumber
Dwarf_Unsigned
block_length
Dwarf_Half
version
Dwarf_Unsigned
offset_into_debug_info
Dwarf_Unsigned
size_of_debug_info_area
Dwarf_Unsigned
count_of_index_entries
Dwarf_Error
error
fP
DE
On
success
this
returns
f
CWDW_DLV_OK
fP
and
fills
in
the
various
fields
through
the
pointers
If
the
pointer
to
a
field
is
null
the
function
ignores
that
field
P
The
field
f
CWblock_length
fP
has
the
byte
length
of
the
block
with
its
entries
P
The
field
f
CWversion
fP
has
the
version
number
Currently
it
must
be
P
The
field
f
CWoffsetinto_debug_info
fP
is
the
offset
in
some
debug_info
or
debug_info
owo
section
of
a
Compilation
Unit
Header
P
The
field
f
CWsize_of_debug_info_area
fP
is
the
size
of
the
referenced
compilation
unit
P
The
field
f
CWcount_of_index_entries
fP
is
the
number
of
entries
attached
to
the
block
See
f
CWdwarf_get_gnu_index_block_entry
fP
P
If
the
block
number
is
outside
the
valid
range
zero
through
f
CWindex_block_count
fP
it
returns
f
CWDW_DLV_NO_ENTRY
fP
and
does
nothing
P
If
there
is
data
corruption
or
some
serious
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
error
pointer
with
information
about
the
error
H
dwarf_get_gnu_index_block_entry
DS
f
CWint
dwarf_get_gnu_index_block_entry
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
blocknumber
Dwarf_Unsigned
entrynumber
Dwarf_Unsigned
offset_in_debug_info
const
char
name
unsigned
char
flagbyte
unsigned
char
staticorglobal
unsigned
char
typeofentry
Dwarf_Error
error
fP
DE
If
either
f
CWblocknumber
fP
or
f
CWentrynumber
fP
is
outside
the
range
of
valid
values
it
returns
f
CWDW_DLV_NO_ENTRY
fP
and
does
nothing
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
information
about
each
entry
through
the
pointers
Any
pointers
pased
in
as
NULL
are
ignored
P
The
field
f
CWoffset_in_debug_info
fP
has
the
offset
of
DIE
in
a
debug_info
section
P
The
field
f
CWname
fP
has
a
pointer
to
the
name
of
the
variable
or
function
that
the
DIE
refers
to
P
The
field
f
CWflagbyte
fP
has
the
entire
bits
of
a
byte
that
has
two
useful
fields
The
next
two
fields
are
those
useful
fields
P
The
field
f
CWstaticorglobal
fP
has
an
integer
if
the
DIE
involved
describes
a
global
externally
visible
name
It
has
an
integer
if
the
name
refers
to
a
static
file
local
DIE
P
The
field
f
CWtypeofentry
fP
has
a
small
integer
describing
the
type
Zero
means
the
type
is
none
One
means
the
type
is
type
Two
means
the
type
is
variable
Three
means
the
type
is
function
Four
means
the
type
is
other
Any
other
value
has
apparently
no
assigned
meaning
P
If
there
is
data
corruption
or
some
serious
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
error
pointer
with
information
about
the
error
H
Macro
Information
Operations
DWARF4
DWARF5
This
section
refers
to
DWARF4
and
later
macro
information
from
the
debug_macro
section
for
DWARF
some
producers
generated
debug_macro
before
its
formal
standardization
in
DWARF
While
standard
operations
are
supported
there
is
as
yet
no
support
for
implementation
defined
extensions
Once
someone
has
defined
such
things
it
will
make
sense
to
design
an
interface
for
extensions
H
Getting
access
The
opaque
struct
pointer
Dwarf_Macro_Context
is
allocated
by
either
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
and
once
the
context
is
no
longer
needed
one
frees
up
all
its
storage
by
f
CWdwarf_dealloc_macro_context
fP
H
dwarf_get_macro_context
DS
f
CWint
dwarf_get_macro_context
Dwarf_Die
die
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_unit_offset_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length_out
Dwarf_Error
error
fP
DE
Given
a
Compilation
Unit
CU
die
on
success
f
CWdwarf_get_macro_context
fP
opens
a
f
CWDwarf_Macro_Context
fP
and
returns
a
pointer
to
it
and
some
data
from
the
macro
unit
for
that
CU
The
f
CWDwarf_Macro_Context
fP
is
used
to
get
at
the
details
of
the
macros
P
The
value
f
CWversion_out
fP
is
set
to
the
DWARF
version
number
of
the
macro
data
Version
means
DWARF5
version
information
Version
means
the
DWARF5
format
macro
data
is
present
as
an
extension
of
DWARF4
P
The
value
f
CWmacro_unit_offset_out
fP
is
set
to
the
offset
in
the
debug_macro
section
of
the
first
byte
of
macro
data
for
this
CU
P
Macro
unit
is
defined
in
the
DWARF5
standard
Section
Macro
Information
on
page
P
The
value
f
CWmacro_ops_count_out
fP
is
set
to
the
number
of
macro
entries
in
the
macro
data
data
for
this
CU
The
count
includes
the
final
zero
entry
which
is
not
really
a
macro
it
is
a
terminator
a
zero
byte
ending
the
macro
unit
P
The
value
f
CWmacro_ops_data_length_out
fP
is
set
to
the
number
of
bytes
of
data
in
the
set
of
ops
not
including
macro_unit
header
bytes
See
f
CWdwarf_macro_context_total_length
fP
to
get
the
macro
unit
total
length
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
the
CU
has
no
macro
data
attribute
or
there
is
no
debug_macro
section
present
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_get_macro_context_by_offset
DS
f
CWint
dwarf_get_macro_context_by_offset
Dwarf_Die
die
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_total_byte_len
Dwarf_Error
error
fP
DE
Given
a
Compilation
Unit
CU
die
and
the
offset
of
an
imported
macro
unit
f
CWdwarf_get_macro_context_by_offset
fP
opens
a
f
CWDwarf_Macro_Context
fP
and
returns
a
pointer
to
it
and
some
data
from
the
macro
unit
for
that
CU
on
success
P
On
success
the
function
produces
the
same
output
values
as
f
CWdwarf_get_macro_context
fP
P
If
f
CWDW_DLV_NO_ENTRY
fP
is
returned
there
is
no
debug_macro
section
present
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_macro_context_total_length
DS
f
CWint
dwarf_macro_context_total_length
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
total_length
Dwarf_Error
error
fP
DE
New
in
December
f
CWdwarf_macro_context_total_length
fP
because
callers
of
f
CWdwarf_get_macro_context
_by_offset
fP
sometimes
want
to
know
the
length
of
macro
ops
plus
the
length
of
the
DWARF5
style
header
P
On
success
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
total_length
fP
to
the
total
length
of
the
DWARF5
style
macro
unit
P
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
P
If
the
f
CW
fP
macro_context
argument
is
NULL
or
invalid
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
an
appropriate
error
value
H
dwarf_dealloc_macro_context
DS
f
CWvoid
dwarf_dealloc_macro_context
Dwarf_Macro_Context
macro_context
fP
DE
The
function
f
CWdwarf_dealloc_macro_context
fP
cleans
up
memory
allocated
by
a
successful
call
to
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
in
FG
Examplep5
dwarf_dealloc_macro_context
DS
f
CW
This
builds
an
list
or
some
other
data
structure
not
defined
to
give
an
import
somewhere
to
list
the
import
offset
and
then
later
to
enquire
if
the
list
has
unexamined
offsets
A
candidate
set
of
hypothetical
functions
that
callers
would
write
has_unchecked_import_in_list
get_next_import_from_list
mark_this_offset_as_examined
macro_unit_offset
add_offset_to_list
offset
void
examplep5
Dwarf_Debug
dbg
Dwarf_Die
cu_die
int
lres
Dwarf_Unsigned
version
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_unit_offset
Dwarf_Unsigned
number_of_ops
Dwarf_Unsigned
ops_total_byte_len
Dwarf_Bool
is_primary
TRUE
unsigned
k
Dwarf_Error
err
for
if
is_primary
lres
dwarf_get_macro_context
cu_die
is_primary
FALSE
else
if
has_unchecked_import_in_list
macro_unit_offset
get_next_import_from_list
else
We
are
done
break
lres
dwarf_get_macro_context_by_offset
cu_die
macro_unit_offset
mark_this_offset_as_examined
macro_unit_offset
if
lres
DW_DLV_ERROR
Something
is
wrong
return
if
lres
DW_DLV_NO_ENTRY
We
are
done
break
lres
DW_DLV_OK
for
k
k
number_of_ops
k
Dwarf_Unsigned
section_offset
Dwarf_Half
macro_operator
Dwarf_Half
forms_count
const
Dwarf_Small
formcode_array
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Unsigned
offset
const
char
macro_string
int
lres
lres
dwarf_get_macro_op
macro_context
k
if
lres
DW_DLV_OK
print_error
dbg
ERROR
from
dwarf_get_macro_op
lres
err
dwarf_dealloc_macro_context
macro_context
return
switch
macro_operator
case
Nothing
to
do
This
sigifies
it
is
the
end
marker
standing
in
for
the
byte
at
the
end
of
his
macro
group
break
case
DW_MACRO_end_file
Do
something
break
case
DW_MACRO_define
case
DW_MACRO_undef
case
DW_MACRO_define_strp
case
DW_MACRO_undef_strp
case
DW_MACRO_define_strx
case
DW_MACRO_undef_strx
case
DW_MACRO_define_sup
case
DW_MACRO_undef_sup
lres
dwarf_get_macro_defundef
macro_context
k
if
lres
DW_DLV_OK
print_error
dbg
ERROR
from
sup
dwarf_get_macro_defundef
lres
err
dwarf_dealloc_macro_context
macro_context
return
do
something
break
case
DW_MACRO_start_file
lres
dwarf_get_macro_startend_file
macro_context
k
if
lres
DW_DLV_OK
print_error
dbg
ERROR
from
dwarf_get_macro_startend_file
sup
lres
err
dwarf_dealloc_macro_context
macro_context
return
do
something
break
case
DW_MACRO_import
lres
dwarf_get_macro_import
macro_context
k
if
lres
DW_DLV_OK
print_error
dbg
ERROR
from
dwarf_get_macro_import
sup
lres
err
dwarf_dealloc_macro_context
macro_context
return
add_offset_to_list
offset
break
case
DW_MACRO_import_sup
lres
dwarf_get_macro_import
macro_context
k
if
lres
DW_DLV_OK
print_error
dbg
ERROR
from
dwarf_get_macro_import
sup
lres
err
dwarf_dealloc_macro_context
macro_context
return
do
something
break
dwarf_dealloc_macro_context
macro_context
macro_context
fP
DE
in
H
Getting
Macro
Unit
Header
Data
H
dwarf_macro_context_head
DS
f
CWint
dwarf_macro_context_head
Dwarf_Macro_Context
macro_context
Dwarf_Half
version
Dwarf_Unsigned
mac_offset
Dwarf_Unsigned
mac_len
Dwarf_Unsigned
mac_header_len
unsigned
flags
Dwarf_Bool
has_line_offset
Dwarf_Unsigned
line_offset
Dwarf_Bool
has_offset_size_64
Dwarf_Bool
has_operands_table
Dwarf_Half
opcode_count
Dwarf_Error
error
fP
DE
Given
a
f
CWDwarf_Macro_Context
fP
pointer
this
function
returns
the
basic
fields
of
a
macro
unit
header
Macro
Information
Header
on
success
P
The
value
f
CWversion
fP
is
set
to
the
DWARF
version
number
of
the
macro
unit
header
Version
means
DWARF5
version
information
Version
means
the
DWARF5
format
macro
data
is
present
as
an
extension
of
DWARF4
P
The
value
f
CWmac_offset
fP
is
set
to
the
offset
in
the
debug_macro
section
of
the
first
byte
of
macro
data
for
this
CU
P
The
value
f
CWmac_len
fP
is
set
to
the
number
of
bytes
of
data
in
the
macro
unit
including
the
macro
unit
header
P
The
value
f
CWmac_header_len
fP
is
set
to
the
number
of
bytes
in
the
macro
unit
header
not
a
field
that
is
generally
useful
P
The
value
f
CWflags
fP
is
set
to
the
value
of
the
f
CWflags
fP
field
of
the
macro
unit
header
P
The
value
f
CWhas_line_offset
fP
is
set
to
non
zero
if
the
f
CWdebug_line_offset_flag
fP
bit
is
set
in
the
f
CWflags
fP
field
of
the
macro
unit
header
If
f
CWhas_line_offset
fP
is
set
then
f
CWline_offset
fP
is
set
to
the
value
of
the
f
CWdebug_line_offset
fP
field
in
the
macro
unit
header
If
f
CWhas_line_offset
fP
is
not
set
there
is
no
f
CWdebug_line_offset
fP
field
present
in
the
macro
unit
header
P
The
value
f
CWhas_offset_size_64
fP
is
set
non
zero
if
the
f
CWoffset_size_flag
fP
bit
is
set
in
the
f
CWflags
fP
field
of
the
macro
unit
header
and
in
this
case
offset
fields
in
this
macro
unit
are
bits
If
f
CWhas_offset_size_64
fP
is
not
set
then
offset
fields
in
this
macro
unit
are
bits
P
The
value
f
CWhas_operands_table
fP
is
set
to
non
zero
if
the
f
CWopcod_operands_table_flag
fP
bit
is
set
in
the
f
CWflags
fP
field
of
the
macro
unit
header
P
If
f
CWhas_operands_table
fP
is
set
non
zero
then
The
value
f
CWopcode_count
fP
is
set
to
the
number
of
opcodes
in
the
macro
unit
header
f
CWopcode_operands_table
fP
See
f
CWdwarf_get_macro_op
fP
P
f
CWDW_DLV_NO_ENTRY
fP
is
not
returned
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_macro_operands_table
DS
f
CWint
dwarf_macro_operands_table
Dwarf_Macro_Context
macro_context
Dwarf_Half
index
to
opcode_count
Dwarf_Half
opcode_number
Dwarf_Half
operand_count
const
Dwarf_Small
operand_array
Dwarf_Error
error
fP
DE
f
CWdwarf_macro_operands_table
fP
is
used
to
index
through
the
operands
table
in
a
macro
unit
header
if
the
operands
table
exists
in
the
macro
unit
header
The
operands
table
provides
the
mechanism
for
implementations
to
add
extensions
to
the
macro
operations
while
allowing
clients
to
skip
macro
operations
the
client
code
does
not
recognize
P
The
f
CWmacro_context
fP
field
passed
in
identifies
the
macro
unit
involved
The
f
CWindex
fP
field
passed
in
identifies
which
macro
operand
to
look
at
Valid
index
values
are
zero
through
the
f
CWopcode_count
fP
returned
by
f
CWdwarf_macro_context_head
fP
P
The
f
CWopcode_number
fP
value
returned
through
the
pointer
is
the
the
macro
operation
code
The
operation
code
could
be
one
of
the
standard
codes
or
if
there
are
user
extensions
there
would
be
an
extension
code
in
the
f
CWDW_MACRO_lo_user
fP
to
f
CWDW_MACRO_hi_user
fP
range
P
The
f
CWoperand_count
fP
returned
is
the
number
of
form
codes
in
the
form
codes
array
of
unsigned
bytes
f
CWoperand_array
fP
P
f
CWDW_DLV_NO_ENTRY
fP
is
not
returned
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
Getting
Individual
Macro
Operations
Data
H
dwarf_get_macro_op
DS
f
CWint
dwarf_get_macro_op
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
op_start_section_offset
Dwarf_Half
macro_operator
Dwarf_Half
forms_count
const
Dwarf_Small
formcode_array
Dwarf_Error
error
fP
DE
Use
f
CWdwarf_get_macro_op
fP
to
access
the
macro
operations
of
this
macro
unit
P
The
f
CWmacro_context
fP
field
passed
in
identifies
the
macro
unit
involved
The
f
CWop_number
fP
field
passed
in
identifies
which
macro
operand
to
look
at
Valid
index
values
are
zero
through
f
CWmacro_ops_count_out
fP
field
returned
by
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
P
On
success
the
function
returns
values
through
the
pointers
P
If
f
CWmacro_operator
fP
returned
is
zero
that
means
this
is
a
placeholder
for
the
null
byte
at
the
end
of
this
array
of
macros
The
other
pointer
values
returned
are
also
zero
in
this
case
P
The
f
CWop_start_section_offset
fP
returned
is
useful
for
debugging
but
otherwise
is
not
normally
useful
It
is
the
byte
offset
of
the
beginning
of
this
macro
operator
s
data
P
The
f
CWmacro_operator
fP
returned
is
one
of
the
defined
macro
operations
such
as
f
CWDW_MACRO_define
fP
This
is
the
field
you
will
use
to
choose
what
call
to
use
to
get
the
data
for
a
macro
operator
For
example
for
f
CWDW_MACRO_undef
fP
one
would
call
f
CWdwarf_get_macro_defundef
fP
see
below
to
get
the
details
about
the
undefine
P
The
f
CWforms_count
fP
returned
is
useful
for
debugging
but
otherwise
is
not
normally
useful
It
is
the
number
of
bytes
of
form
numbers
in
the
f
CWformcode_array
fP
of
this
macro
operator
s
applicable
forms
P
f
CWDW_DLV_NO_ENTRY
fP
is
not
returned
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_get_macro_defundef
DS
f
CWint
dwarf_get_macro_defundef
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Unsigned
offset
Dwarf_Half
forms_count
const
char
macro_string
Dwarf_Error
error
fP
DE
Call
f
CWdwarf_get_macro_defundef
fP
for
any
of
the
macro
define
undefine
operators
Which
fields
are
set
through
the
pointers
depends
on
the
particular
operator
P
The
f
CWmacro_context
fP
field
passed
in
identifies
the
macro
unit
involved
The
f
CWop_number
fP
field
passed
in
identifies
which
macro
operand
to
look
at
Valid
index
values
are
zero
through
f
CWmacro_ops_count_out
fP
field
returned
by
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
P
The
f
CWline_number
fP
field
is
set
with
the
source
line
number
of
the
macro
P
The
f
CWindex
fP
field
only
set
meaningfully
if
the
macro
operator
is
f
CWDW_MACRO_define_strx
fP
or
f
CWDW_MACRO_undef_strx
fP
If
set
it
is
an
index
into
an
array
of
offsets
in
the
debug_str_offsets
section
P
The
f
CWoffset
fP
field
only
set
meaningfully
if
the
macro
operator
is
f
CWDW_MACRO_define_strx
fP
f
CWDW_MACRO_undef_strx
fP
f
CWDW_MACRO_define_strp
fP
or
f
CWDW_MACRO_undef_strp
fP
If
set
it
is
an
offset
of
a
string
in
the
debug_str
section
P
The
f
CWforms_count
fP
is
set
to
the
number
of
forms
that
apply
to
the
macro
operator
P
The
f
CWmacro_string
fP
pointer
is
used
to
return
a
pointer
to
the
macro
string
If
the
actual
string
cannot
be
found
as
when
section
with
the
string
is
in
a
different
object
see
f
CWset_tied_dbg
fP
the
string
returned
may
be
No
string
available
or
debug_str_offsets
not
available
without
the
quotes
P
The
function
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
macro
operation
is
not
one
of
the
define
undef
operations
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_get_macro_startend_file
DS
f
CWint
dwarf_get_macro_startend_file
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
name_index_to_line_tab
const
char
src_file_name
Dwarf_Error
error
fP
DE
Call
f
CWdwarf_get_macro_startend_file
fP
for
operators
f
CWDW_MACRO_start_file
fP
or
f
CWDW_MACRO_end_file
fP
P
The
f
CWmacro_context
fP
field
passed
in
identifies
the
macro
unit
involved
P
The
f
CWop_number
fP
field
passed
in
identifies
which
macro
operand
to
look
at
Valid
index
values
are
zero
through
f
CWmacro_ops_count_out
fP
field
returned
by
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
P
For
f
CWDW_MACRO_end_file
fP
none
of
the
following
fields
are
set
on
successful
return
they
are
only
set
for
f
CWDW_MACRO_start_file
fP
P
The
f
CWline_number
fP
field
is
set
with
the
source
line
number
of
the
macro
P
P
The
f
CWname_index_to_line_tab
fP
field
is
set
with
the
index
into
the
file
name
table
of
the
line
table
section
For
DWARF2
DWARF3
DWARF4
line
tables
the
index
value
assumes
DWARF2
line
table
header
rules
identical
to
DWARF3
DWARF4
line
table
header
rules
For
DWARF5
the
index
value
assumes
DWARF5
line
table
header
rules
The
f
CWsrc_file_name
fP
is
set
with
the
source
file
name
If
the
index
seems
wrong
or
the
line
table
is
unavailable
the
name
returned
is
no
source
file
name
available
P
The
function
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
macro
operation
is
not
one
of
the
start
end
operations
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
dwarf_get_macro_import
DS
f
CWint
dwarf_get_macro_import
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
target_offset
Dwarf_Error
error
fP
DE
Call
f
CWdwarf_get_macro_import
fP
for
operators
f
CWDW_MACRO_import
fP
or
f
CWDW_MACRO_import_sup
fP
P
The
f
CWmacro_context
fP
field
passed
in
identifies
the
macro
unit
involved
The
f
CWop_number
fP
field
passed
in
identifies
which
macro
operand
to
look
at
Valid
index
values
are
zero
through
f
CWmacro_ops_count_out
fP
field
returned
by
f
CWdwarf_get_macro_context
fP
or
f
CWdwarf_get_macro_context_by_offset
fP
P
On
success
the
f
CWtarget_offset
fP
field
is
set
to
the
offset
in
the
referenced
section
For
DW_MACRO_import
the
referenced
section
is
the
same
section
as
the
macro
operation
referenced
here
For
DW_MACRO_import_sup
the
referenced
section
is
in
a
supplementary
object
P
The
function
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
macro
operation
is
not
one
of
the
import
operations
P
On
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
error
details
are
returned
through
the
pointer
f
CWerror
fP
H
Macro
Information
Operations
DWARF2
DWARF3
DWARF4
This
section
refers
to
DWARF2
DWARF3
and
DWARF4
macro
information
from
the
debug_macinfo
section
These
do
not
apply
to
DWARF5
macro
data
H
General
Macro
Operations
H
dwarf_find_macro_value_start
DS
f
CWchar
dwarf_find_macro_value_start
char
macro_string
fP
DE
Given
a
macro
string
in
the
standard
form
defined
in
the
DWARF
document
name
space
value
or
name
args
space
value
this
returns
a
pointer
to
the
first
byte
of
the
macro
value
It
does
not
alter
the
string
pointed
to
by
macro_string
or
copy
the
string
it
returns
a
pointer
into
the
string
whose
address
was
passed
in
H
Debugger
Interface
Macro
Operations
Macro
information
is
accessed
from
the
debug_info
section
via
the
DW_AT_macro_info
attribute
whose
value
is
an
offset
into
debug_macinfo
P
No
Functions
yet
defined
H
Low
Level
Macro
Information
Operations
H
dwarf_get_macro_details
DS
f
CWint
dwarf_get_macro_details
Dwarf_Debug
dbg
Dwarf_Off
macro_offset
Dwarf_Unsigned
maximum_count
Dwarf_Signed
entry_count
Dwarf_Macro_Details
details
Dwarf_Error
err
fP
DE
f
CWdwarf_get_macro_details
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWentry_count
fP
to
the
number
of
f
CWdetails
fP
records
returned
through
the
f
CWdetails
fP
pointer
The
data
returned
through
f
CWdetails
fP
should
be
freed
by
a
call
to
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_STRING
fP
If
f
CWDW_DLV_OK
fP
is
returned
the
f
CWentry_count
fP
will
be
at
least
since
a
compilation
unit
with
macro
information
but
no
macros
will
have
at
least
one
macro
data
byte
of
P
f
CWdwarf_get_macro_details
fP
begins
at
the
f
CWmacro_offset
fP
offset
you
supply
and
ends
at
the
end
of
a
compilation
unit
or
at
f
CWmaximum_count
fP
detail
records
whichever
comes
first
If
f
CWmaximum_count
fP
is
it
is
treated
as
if
it
were
the
maximum
possible
unsigned
integer
P
f
CWdwarf_get_macro_details
fP
attempts
to
set
f
CWdmd_fileindex
fP
to
the
correct
file
in
every
f
CWdetails
fP
record
If
it
is
unable
to
do
so
or
whenever
the
current
file
index
is
unknown
it
sets
f
CWdmd_fileindex
fP
to
P
f
CWdwarf_get_macro_details
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
more
macro
information
at
that
f
CWmacro_offset
fP
If
f
CWmacro_offset
fP
is
passed
in
as
a
f
CWDW_DLV_NO_ENTRY
fP
return
means
there
is
no
macro
information
P
in
FG
Examplep2
dwarf_get_macro_details
DS
f
CW
void
examplep2
Dwarf_Debug
dbg
Dwarf_Off
cur_off
Dwarf_Error
error
Dwarf_Signed
count
Dwarf_Macro_Details
maclist
Dwarf_Signed
i
Dwarf_Unsigned
max
sanity
limit
int
errv
Given
an
offset
from
a
compilation
unit
start
at
that
offset
from
DW_AT_macroinfo
and
get
its
macro
details
errv
dwarf_get_macro_details
dbg
cur_off
max
if
errv
DW_DLV_OK
for
i
i
count
i
Dwarf_Macro_Details
mentry
maclist
i
example
of
use
Dwarf_Signed
lineno
mentry
dmd_lineno
functionusingsigned
lineno
dwarf_dealloc
dbg
maclist
DW_DLA_STRING
Loop
through
all
the
compilation
units
macro
info
from
zero
This
is
not
guaranteed
to
work
because
DWARF
does
not
guarantee
every
byte
in
the
section
is
meaningful
there
can
be
garbage
between
the
macro
info
for
CUs
But
this
loop
will
sometimes
work
cur_off
while
errv
dwarf_get_macro_details
dbg
cur_off
max
DW_DLV_OK
for
i
i
count
i
Dwarf_Macro_Details
mentry
maclist
i
example
of
use
Dwarf_Signed
lineno
mentry
dmd_lineno
functionusingsigned
lineno
cur_off
maclist
count
dmd_offset
dwarf_dealloc
dbg
maclist
DW_DLA_STRING
fP
DE
in
H
Low
Level
Frame
Operations
These
functions
provide
information
about
stack
frames
to
be
used
to
perform
stack
traces
The
information
is
an
abstraction
of
a
table
with
a
row
per
instruction
and
a
column
per
register
and
a
column
for
the
canonical
frame
address
CFA
which
corresponds
to
the
notion
of
a
frame
pointer
as
well
as
a
column
for
the
return
address
P
From
the
interface
we
ll
here
refer
to
as
DWARF2
made
the
CFA
be
a
column
in
the
matrix
but
left
DW_FRAME_UNDEFINED_VAL
and
DW_FRAME_SAME_VAL
out
of
the
matrix
giving
them
high
numbers
As
of
the
DWARF3
interfaces
introduced
in
this
document
in
April
there
are
two
interfaces
the
original
set
and
a
new
set
Several
frame
functions
work
transparently
for
either
set
we
will
focus
on
the
ones
that
are
not
equally
suitable
now
P
The
original
DWARF2
interface
set
still
exists
dwarf_get_fde_info_for_reg
dwarf_get_fde_info_for_cfa_reg
and
dwarf_get_fde_info_for_all_regs
and
works
adequately
for
MIPS
IRIX
DWARF2
and
ABI
ISA
sets
that
are
sufficiently
similar
to
MIPS
These
functions
not
a
good
choice
for
non
MIPS
architectures
nor
were
they
a
good
design
for
MIPS
either
It
s
better
to
switch
entirely
to
the
new
functions
mentioned
in
the
next
paragraph
This
DWARF2
interface
set
assumes
and
uses
DW_FRAME_CFA_COL
and
that
is
assumed
when
libdwarf
is
configured
with
enable
oldframecol
P
A
new
DWARF3
interface
set
of
dwarf_get_fde_info_for_reg3
dwarf_get_fde_info_for_cfa_reg3
dwarf_get_fde_info_for_all_regs3
dwarf_set_frame_rule_table_size
dwarf_set_frame_cfa_value
dwarf_set_frame_same_value
dwarf_set_frame_undefined_value
and
dwarf_set_frame_rule_initial_value
is
more
flexible
and
will
work
for
many
more
architectures
It
is
also
entirely
suitable
for
use
with
DWARF2
and
DWARF4
The
setting
of
the
frame
cfa
column
number
defaults
to
DW_FRAME_CFA_COL3
and
it
can
be
set
at
runtime
with
dwarf_set_frame_cfa_value
P
Mixing
use
of
the
DWARF2
interface
set
with
use
of
the
new
DWARF3
interface
set
on
a
single
open
Dwarf_Debug
instance
is
a
mistake
Do
not
do
it
P
We
will
pretend
from
here
on
unless
otherwise
specified
that
DW_FRAME_CFA_COL3
DW_FRAME_UNDEFINED_VAL
and
DW_FRAME_SAME_VAL
are
the
synthetic
column
numbers
These
columns
may
be
user
chosen
by
calls
of
dwarf_set_frame_cfa_value
dwarf_set_frame_undefined_value
and
dwarf_set_frame_same_value
respectively
P
Each
cell
in
the
table
contains
one
of
the
following
AL
LI
A
register
offset
a
b
LI
A
register
c
d
LI
A
marker
DW_FRAME_UNDEFINED_VAL
meaning
fIregister
value
undefined
fP
LI
A
marker
DW_FRAME_SAME_VAL
meaning
fIregister
value
same
as
in
caller
fP
LE
P
a
old
DWARF2
interface
When
the
column
is
DW_FRAME_CFA_COL
the
register
number
is
a
real
hardware
register
not
a
reference
to
DW_FRAME_CFA_COL
not
DW_FRAME_UNDEFINED_VAL
and
not
DW_FRAME_SAME_VAL
The
CFA
rule
value
should
be
the
stack
pointer
plus
offset
when
no
other
value
makes
sense
A
value
of
DW_FRAME_SAME_VAL
would
be
semi
logical
but
since
the
CFA
is
not
a
real
register
not
really
correct
A
value
of
DW_FRAME_UNDEFINED_VAL
would
imply
the
CFA
is
undefined
this
seems
to
be
a
useless
notion
as
the
CFA
is
a
means
to
finding
real
registers
so
those
real
registers
should
be
marked
DW_FRAME_UNDEFINED_VAL
and
the
CFA
column
content
whatever
register
it
specifies
becomes
unreferenced
by
anything
P
a
new
April
DWARF2
interface
The
CFA
is
separately
accessible
and
not
part
of
the
table
The
rule
number
for
the
CFA
is
a
number
outside
the
table
So
the
CFA
is
a
marker
not
a
register
number
See
DW_FRAME_CFA_COL3
in
libdwarf
h
and
dwarf_get_fde_info_for_cfa_reg3
and
dwarf_set_frame_rule_cfa_value
P
b
When
the
column
is
not
DW_FRAME_CFA_COL3
the
register
will
and
must
be
DW_FRAME_CFA_COL3
COL
implying
that
to
get
the
final
location
for
the
column
one
must
add
the
offset
here
plus
the
DW_FRAME_CFA_COL3
rule
value
P
c
When
the
column
is
DW_FRAME_CFA_COL3
then
the
register
number
is
must
be
a
real
hardware
register
This
paragraph
does
not
apply
to
the
April
new
interface
If
it
were
DW_FRAME_UNDEFINED_VAL
or
DW_FRAME_SAME_VAL
it
would
be
a
marker
not
a
register
number
P
d
When
the
column
is
not
DW_FRAME_CFA_COL3
the
register
may
be
a
hardware
register
It
will
not
be
DW_FRAME_CFA_COL3
P
There
is
no
column
for
DW_FRAME_UNDEFINED_VAL
or
DW_FRAME_SAME_VAL
Nor
for
DW_FRAME_CFA_COL3
Figure
n
aX
is
machine
dependent
and
represents
MIPS
CPU
register
assignments
The
DW_FRAME_CFA_COL
define
in
dwarf
h
is
historical
and
really
belongs
in
libdwarf
h
not
dwarf
h
DS
TS
center
box
tab
lfB
lfB
lfB
l
c
l
NAME
value
PURPOSE
_
DW_FRAME_CFA_COL
column
used
for
CFA
DW_FRAME_REG1
integer
register
DW_FRAME_REG2
integer
register
obvious
names
and
values
here
DW_FRAME_REG30
integer
register
DW_FRAME_REG31
integer
register
DW_FRAME_FREG0
floating
point
register
DW_FRAME_FREG1
floating
point
register
obvious
names
and
values
here
DW_FRAME_FREG30
floating
point
register
DW_FRAME_FREG31
floating
point
register
DW_FRAME_RA_COL
column
recording
ra
DW_FRAME_UNDEFINED_VAL
register
val
undefined
DW_FRAME_SAME_VAL
register
same
as
in
caller
TE
FG
Frame
Information
Rule
Assignments
MIPS
DE
P
The
following
table
shows
SGI
MIPS
specific
special
cell
values
these
values
mean
that
the
cell
has
the
value
fIundefined
fP
or
fIsame
value
fP
respectively
rather
than
containing
a
fIregister
fP
or
fIregister
offset
fP
It
assumes
DW_FRAME_CFA_COL
is
a
table
rule
which
is
not
readily
accomplished
or
even
sensible
for
some
architectures
P
DS
TS
center
box
tab
lfB
lfB
lfB
l
c
l
NAME
value
PURPOSE
_
DW_FRAME_UNDEFINED_VAL
means
undefined
value
Not
a
column
or
register
value
DW_FRAME_SAME_VAL
means
same
value
as
caller
had
Not
a
column
or
register
value
DW_FRAME_CFA_COL
means
register
zero
is
usurped
by
the
CFA
column
TE
FG
Frame
Information
Special
Values
any
architecture
DE
P
The
following
table
shows
more
general
special
cell
values
These
values
mean
that
the
cell
register
number
refers
to
the
fIcfa
register
fP
or
fIundefined
value
fP
or
fIsame
value
fP
respectively
rather
than
referring
to
a
fIregister
in
the
table
fP
The
generality
arises
from
making
DW_FRAME_CFA_COL3
be
outside
the
set
of
registers
and
making
the
cfa
rule
accessible
from
outside
the
rule
table
P
DS
TS
center
box
tab
lfB
lfB
lfB
l
c
l
NAME
value
PURPOSE
_
DW_FRAME_UNDEFINED_VAL
means
undefined
value
Not
a
column
or
register
value
DW_FRAME_SAME_VAL
means
same
value
as
caller
had
Not
a
column
or
register
value
DW_FRAME_CFA_COL3
means
cfa
register
is
referred
to
not
a
real
register
not
a
column
but
the
cfa
the
cfa
does
have
a
value
but
in
the
DWARF3
libdwarf
interface
it
does
not
have
a
real
register
number
TE
DE
P
H
dwarf_get_frame_section_name
DS
f
CWint
dwarf_get_frame_section_name
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CWdwarf_get_string_section_name
fP
lets
consumers
access
the
object
string
section
name
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
See
also
f
CWdwarf_get_frame_section_name_eh_gnu
fP
P
The
function
f
CWdwarf_get_frame_section_name
fP
operates
on
the
the
debug_frame
section
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_frame_section_name_eh_gnu
DS
f
CWint
dwarf_get_frame_section_name_eh_gnu
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CWdwarf_get_frame_section_name_eh_gnu
fP
lets
consumers
access
the
object
string
section
name
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
See
also
f
CWdwarf_get_frame_section_name
fP
P
The
function
f
CWdwarf_get_frame_section_name_eh_ghu
fP
operates
on
the
the
eh_frame
section
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_fde_list
DS
f
CWint
dwarf_get_fde_list
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_list
fP
stores
a
pointer
to
a
list
of
f
CWDwarf_Cie
fP
descriptors
in
f
CW
cie_data
fP
and
the
count
of
the
number
of
descriptors
in
f
CW
cie_element_count
fP
There
is
a
descriptor
for
each
CIE
in
the
debug_frame
section
Similarly
it
stores
a
pointer
to
a
list
of
f
CWDwarf_Fde
fP
descriptors
in
f
CW
fde_data
fP
and
the
count
of
the
number
of
descriptors
in
f
CW
fde_element_count
fP
There
is
one
descriptor
per
FDE
in
the
debug_frame
section
f
CWdwarf_get_fde_list
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
it
cannot
find
frame
entries
It
returns
f
CWDW_DLV_OK
fP
on
a
successful
return
P
On
successful
return
structures
pointed
to
by
a
descriptor
should
be
freed
using
f
CWdwarf_fde_cie_list_dealloc
fP
This
dealloc
approach
is
new
as
of
July
in
FG
Exampleq
dwarf_get_fde_list
DS
f
CW
void
exampleq
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_count
Dwarf_Error
error
int
fres
fres
dwarf_get_fde_list
dbg
if
fres
DW_DLV_OK
dwarf_fde_cie_list_dealloc
dbg
cie_data
cie_count
fde_data
fde_count
fP
DE
in
P
The
following
code
is
deprecated
as
of
July
as
it
does
not
free
all
relevant
memory
This
approach
still
works
as
well
as
it
ever
did
in
FG
Exampleqb
dwarf_get_fde_list
obsolete
DS
f
CW
OBSOLETE
EXAMPLE
void
exampleqb
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_count
Dwarf_Error
error
Dwarf_Signed
i
int
fres
fres
dwarf_get_fde_list
dbg
if
fres
DW_DLV_OK
for
i
i
cie_count
i
use
cie
i
dwarf_dealloc
dbg
cie_data
i
DW_DLA_CIE
for
i
i
fde_count
i
use
fde
i
dwarf_dealloc
dbg
fde_data
i
DW_DLA_FDE
dwarf_dealloc
dbg
cie_data
DW_DLA_LIST
dwarf_dealloc
dbg
fde_data
DW_DLA_LIST
fP
DE
in
P
H
dwarf_get_fde_list_eh
DS
f
CWint
dwarf_get_fde_list_eh
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_list_eh
fP
is
identical
to
f
CWdwarf_get_fde_list
fP
except
that
f
CWdwarf_get_fde_list_eh
fP
reads
the
GNU
gcc
section
named
eh_frame
C
exception
handling
information
f
CWdwarf_get_fde_list_eh
fP
stores
a
pointer
to
a
list
of
f
CWDwarf_Cie
fP
descriptors
in
f
CW
cie_data
fP
and
the
count
of
the
number
of
descriptors
in
f
CW
cie_element_count
fP
There
is
a
descriptor
for
each
CIE
in
the
debug_frame
section
Similarly
it
stores
a
pointer
to
a
list
of
f
CWDwarf_Fde
fP
descriptors
in
f
CW
fde_data
fP
and
the
count
of
the
number
of
descriptors
in
f
CW
fde_element_count
fP
There
is
one
descriptor
per
FDE
in
the
debug_frame
section
f
CWdwarf_get_fde_list
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
it
cannot
find
exception
handling
entries
It
returns
f
CWDW_DLV_OK
fP
on
a
successful
return
P
On
successful
return
structures
pointed
to
by
a
descriptor
should
be
freed
using
f
CWdwarf_fde_cie_list_dealloc
fP
This
dealloc
approach
is
new
as
of
July
in
FG
Exampler
dwarf_get_fde_list_eh
DS
f
CW
void
exampler
Dwarf_Debug
dbg
Dwarf_Addr
mypcval
Given
a
pc
value
for
a
function
find
the
FDE
and
CIE
data
for
the
function
Example
shows
basic
access
to
FDE
CIE
plus
one
way
to
access
details
given
a
PC
value
dwarf_get_fde_n
allows
accessing
all
FDE
CIE
data
so
one
could
build
up
an
application
specific
table
of
information
if
that
is
more
useful
Dwarf_Signed
count
Dwarf_Cie
cie_data
Dwarf_Signed
cie_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_count
Dwarf_Error
error
int
fres
fres
dwarf_get_fde_list_eh
dbg
if
fres
DW_DLV_OK
Dwarf_Fde
myfde
Dwarf_Addr
low_pc
Dwarf_Addr
high_pc
fres
dwarf_get_fde_at_pc
fde_data
mypcval
if
fres
DW_DLV_OK
Dwarf_Cie
mycie
fres
dwarf_get_cie_of_fde
myfde
if
fres
DW_DLV_OK
Now
we
can
access
a
range
of
information
about
the
fde
and
cie
applicable
dwarf_fde_cie_list_dealloc
dbg
cie_data
cie_count
fde_data
fde_count
ERROR
or
NO
ENTRY
Do
something
fP
DE
in
P
H
dwarf_get_cie_of_fde
DS
f
CWint
dwarf_get_cie_of_fde
Dwarf_Fde
fde
Dwarf_Cie
cie_returned
Dwarf_Error
error
fP
DE
f
CWdwarf_get_cie_of_fde
fP
stores
a
f
CWDwarf_Cie
fP
into
the
f
CWDwarf_Cie
fP
that
f
CWcie_returned
fP
points
at
If
one
has
called
f
CWdwarf_get_fde_list
fP
must
avoid
dwarf_dealloc
ing
the
FDEs
and
the
CIEs
for
those
FDEs
individually
see
its
documentation
here
Failing
to
observe
this
restriction
will
cause
the
FDE
s
not
dealloc
d
to
become
invalid
an
FDE
contains
hidden
in
it
a
CIE
pointer
which
will
be
be
invalid
stale
pointing
to
freed
memory
if
the
CIE
is
dealloc
d
The
invalid
CIE
pointer
internal
to
the
FDE
cannot
be
detected
as
invalid
by
libdwarf
If
one
later
passes
an
FDE
with
a
stale
internal
CIE
pointer
to
one
of
the
routines
taking
an
FDE
as
input
the
result
will
be
failure
of
the
call
returning
DW_DLV_ERROR
at
best
and
it
is
possible
a
coredump
or
worse
will
happen
eventually
f
CWdwarf_get_cie_of_fde
fP
returns
f
CWDW_DLV_OK
fP
if
it
is
successful
it
will
be
unless
fde
is
the
NULL
pointer
It
returns
f
CWDW_DLV_ERROR
fP
if
the
fde
is
invalid
NULL
P
Each
f
CWDwarf_Fde
fP
descriptor
describes
information
about
the
frame
for
a
particular
subroutine
or
function
f
CWint
dwarf_get_fde_for_die
fP
is
SGI
MIPS
specific
H
dwarf_get_fde_for_die
DS
f
CWint
dwarf_get_fde_for_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Fde
return_fde
Dwarf_Error
error
fP
DE
When
it
succeeds
f
CWdwarf_get_fde_for_die
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_fde
fP
to
a
f
CWDwarf_Fde
fP
descriptor
representing
frame
information
for
the
given
f
CWdie
fP
It
looks
for
the
f
CWDW_AT_MIPS_fde
fP
attribute
in
the
given
f
CWdie
fP
If
it
finds
it
is
uses
the
value
of
the
attribute
as
the
offset
in
the
debug_frame
section
where
the
FDE
begins
If
there
is
no
f
CWDW_AT_MIPS_fde
fP
it
returns
f
CWDW_DLV_NO_ENTRY
fP
If
there
is
an
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_get_fde_range
DS
f
CWint
dwarf_get_fde_range
Dwarf_Fde
fde
Dwarf_Addr
low_pc
Dwarf_Unsigned
func_length
Dwarf_Ptr
fde_bytes
Dwarf_Unsigned
fde_byte_length
Dwarf_Off
cie_offset
Dwarf_Signed
cie_index
Dwarf_Off
fde_offset
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_get_fde_range
fP
returns
f
CWDW_DLV_OK
fP
The
location
pointed
to
by
f
CWlow_pc
fP
is
set
to
the
low
pc
value
for
this
function
The
location
pointed
to
by
f
CWfunc_length
fP
is
set
to
the
length
of
the
function
in
bytes
This
is
essentially
the
length
of
the
text
section
for
the
function
The
location
pointed
to
by
f
CWfde_bytes
fP
is
set
to
the
address
where
the
FDE
begins
in
the
debug_frame
section
The
location
pointed
to
by
f
CWfde_byte_length
fP
is
set
to
the
length
in
bytes
of
the
portion
of
debug_frame
for
this
FDE
This
is
the
same
as
the
value
returned
by
f
CWdwarf_get_fde_range
fP
The
location
pointed
to
by
f
CWcie_offset
fP
is
set
to
the
offset
in
the
debug_frame
section
of
the
CIE
used
by
this
FDE
The
location
pointed
to
by
f
CWcie_index
fP
is
set
to
the
index
of
the
CIE
used
by
this
FDE
The
index
is
the
index
of
the
CIE
in
the
list
pointed
to
by
f
CWcie_data
fP
as
set
by
the
function
f
CWdwarf_get_fde_list
fP
However
if
the
function
f
CWdwarf_get_fde_for_die
fP
was
used
to
obtain
the
given
f
CWfde
fP
this
index
may
not
be
correct
The
location
pointed
to
by
f
CWfde_offset
fP
is
set
to
the
offset
of
the
start
of
this
FDE
in
the
debug_frame
section
f
CWdwarf_get_fde_range
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_get_cie_info_b
DS
f
CWint
dwarf_get_cie_info_b
Dwarf_Cie
cie
Dwarf_Unsigned
bytes_in_cie
Dwarf_Small
version
char
augmenter
Dwarf_Unsigned
code_alignment_factor
Dwarf_Signed
data_alignment_factor
Dwarf_Half
return_address_register_rule
Dwarf_Ptr
initial_instructions
Dwarf_Unsigned
initial_instructions_length
Dwarf_Half
offset_size
Dwarf_Error
error
fP
DE
f
CWdwarf_get_cie_info_b
fP
is
primarily
for
Internal
level
Interface
consumers
If
successful
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
bytes_in_cie
fP
to
the
number
of
bytes
in
the
portion
of
the
frames
section
for
the
CIE
represented
by
the
given
f
CWDwarf_Cie
fP
descriptor
f
CWcie
fP
The
other
fields
are
directly
taken
from
the
cie
and
returned
via
the
pointers
to
the
caller
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_get_cie_index
DS
f
CWint
dwarf_get_cie_index
Dwarf_Cie
cie
Dwarf_Signed
cie_index
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_get_cie_index
fP
returns
f
CWDW_DLV_OK
fP
On
error
this
function
returns
f
CWDW_DLV_ERROR
fP
The
location
pointed
to
by
f
CWcie_index
fP
is
set
to
the
index
of
the
CIE
of
this
FDE
The
index
is
the
index
of
the
CIE
in
the
list
pointed
to
by
f
CWcie_data
fP
as
set
by
the
function
f
CWdwarf_get_fde_list
fP
So
one
must
have
used
f
CWdwarf_get_fde_list
fP
or
f
CWdwarf_get_fde_list_eh
fP
to
get
a
cie
list
before
this
is
meaningful
This
function
is
occasionally
useful
but
is
little
used
H
dwarf_get_fde_instr_bytes
DS
f
CWint
dwarf_get_fde_instr_bytes
Dwarf_Fde
fde
Dwarf_Ptr
outinstrs
Dwarf_Unsigned
outlen
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_instr_bytes
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
outinstrs
fP
to
a
pointer
to
a
set
of
bytes
which
are
the
actual
frame
instructions
for
this
fde
It
also
sets
f
CW
outlen
fP
to
the
length
in
bytes
of
the
frame
instructions
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
The
intent
is
to
allow
low
level
consumers
like
a
dwarf
dumper
to
print
the
bytes
in
some
fashion
The
memory
pointed
to
by
f
CWoutinstrs
fP
must
not
be
changed
and
there
is
nothing
to
free
H
dwarf_get_fde_info_for_all_regs
DS
f
CWint
dwarf_get_fde_info_for_all_regs
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Regtable
reg_table
Dwarf_Addr
row_pc
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_info_for_all_regs
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
reg_table
fP
for
the
row
specified
by
f
CWpc_requested
fP
for
the
FDE
specified
by
f
CWfde
fP
P
The
intent
is
to
return
the
rules
for
decoding
all
the
registers
given
a
pc
value
f
CWreg_table
fP
is
an
array
of
rules
one
for
each
register
specified
in
f
CWdwarf
h
fP
The
rule
for
each
register
contains
three
items
f
CWdw_regnum
fP
which
denotes
the
register
value
for
that
rule
f
CWdw_offset
fP
which
denotes
the
offset
value
for
that
rule
and
f
CWdw_offset_relevant
fP
which
is
set
to
zero
if
offset
is
not
relevant
for
that
rule
See
f
CWdwarf_get_fde_info_for_reg
fP
for
a
description
of
f
CWrow_pc
fP
P
f
CWdwarf_get_fde_info_for_all_regs
fP
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
P
f
CWint
dwarf_get_fde_info_for_all_regs
fP
is
tailored
to
SGI
MIPS
please
use
dwarf_get_fde_info_for_all_regs3
instead
for
all
architectures
H
dwarf_fde_section_offset
DS
f
CWint
dwarf_fde_section_offset
Dwarf_Debug
dbg
Dwarf_Fde
in_fde
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_fde_section_offset
fP
returns
the
dwarf_line
section
offset
of
the
fde
passed
in
and
also
the
offset
of
its
CIE
P
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
P
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
P
It
is
intended
to
be
used
by
applications
like
dwarfdump
when
such
want
to
print
the
offsets
of
CIEs
and
FDEs
H
dwarf_cie_section_offset
DS
f
CWint
dwarf_cie_section_offset
Dwarf_Debug
dbg
Dwarf_Cie
in_cie
Dwarf_Off
cie_off
Dwarf_Error
err
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_cie_section_offset
fP
returns
the
dwarf_line
section
offset
of
the
cie
passed
in
P
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
P
It
is
intended
to
be
used
by
applications
like
dwarfdump
when
such
want
to
print
the
offsets
of
CIEs
H
dwarf_set_frame_rule_table_size
P
This
allows
consumers
to
set
the
size
of
the
internal
to
libdwarf
rule
table
when
using
the
reg3
interfaces
these
interfaces
are
strongly
preferred
over
the
older
reg
interfaces
It
should
be
at
least
as
large
as
the
number
of
real
registers
in
the
ABI
which
is
to
be
read
in
for
the
dwarf_get_fde_info_for_reg3_b
or
dwarf_get_fde_info_for_all_regs3
functions
to
work
properly
The
frame
rule
table
size
must
be
less
than
the
marker
values
DW_FRAME_UNDEFINED_VAL
DW_FRAME_SAME_VAL
DW_FRAME_CFA_COL3
dwarf_set_frame_rule_undefined_value
dwarf_set_frame_same_value
dwarf_set_frame_cfa_value
effectively
set
these
markers
so
the
frame
rule
table
size
can
actually
be
any
value
regardless
of
the
macro
values
in
libdwarf
h
as
long
as
the
table
size
does
not
overlap
these
markers
P
DS
f
CWDwarf_Half
dwarf_set_frame_rule_table_size
Dwarf_Debug
dbg
Dwarf_Half
value
fP
DE
f
CWdwarf_set_frame_rule_table_size
fP
sets
the
value
f
CWvalue
fP
as
the
size
of
libdwarf
internal
rules
tables
of
f
CWdbg
fP
P
The
function
returns
the
previous
value
of
the
rules
table
size
setting
taken
from
the
f
CWdbg
fP
structure
H
dwarf_set_frame_rule_initial_value
This
allows
consumers
to
set
the
initial
value
for
rows
in
the
frame
tables
By
default
it
is
taken
from
libdwarf
h
and
is
DW_FRAME_REG_INITIAL_VALUE
which
itself
is
either
DW_FRAME_SAME_VAL
or
DW_FRAME_UNDEFINED_VAL
The
MIPS
IRIX
default
is
DW_FRAME_SAME_VAL
Consumer
code
should
set
this
appropriately
and
for
many
architectures
but
probably
not
MIPS
DW_FRAME_UNDEFINED_VAL
is
an
appropriate
setting
Note
an
earlier
spelling
of
dwarf_set_frame_rule_inital_value
is
still
supported
as
an
interface
but
please
change
to
use
the
new
correctly
spelled
name
DS
f
CWDwarf_Half
dwarf_set_frame_rule_initial_value
Dwarf_Debug
dbg
Dwarf_Half
value
fP
DE
f
CWdwarf_set_frame_rule_initial_value
fP
sets
the
value
f
CWvalue
fP
as
the
initial
value
for
this
f
CWdbg
fP
when
initializing
rules
tables
P
The
function
returns
the
previous
value
of
initial
value
taken
from
the
f
CWdbg
fP
structure
H
dwarf_set_frame_cfa_value
This
allows
consumers
to
set
the
number
of
the
CFA
register
for
rows
in
the
frame
tables
By
default
it
is
taken
from
libdwarf
h
and
is
f
CWDW_FRAME_CFA_COL
fP
Consumer
code
should
set
this
appropriately
and
for
nearly
all
architectures
f
CWDW_FRAME_CFA_COL3
fP
is
an
appropriate
setting
DS
f
CWDwarf_Half
dwarf_set_frame_rule_cfa_value
Dwarf_Debug
dbg
Dwarf_Half
value
fP
DE
f
CWdwarf_set_frame_rule_cfa_value
fP
sets
the
value
f
CWvalue
fP
as
the
number
of
the
cfa
register
rule
for
this
f
CWdbg
fP
when
initializing
rules
tables
P
The
function
returns
the
previous
value
of
the
pseudo
register
taken
from
the
f
CWdbg
fP
structure
H
dwarf_set_frame_same_value
This
allows
consumers
to
set
the
number
of
the
pseudo
register
when
DW_CFA_same_value
is
the
operation
By
default
it
is
taken
from
libdwarf
h
and
is
f
CWDW_FRAME_SAME_VAL
fP
Consumer
code
should
set
this
appropriately
though
for
many
architectures
f
CWDW_FRAME_SAME_VAL
fP
is
an
appropriate
setting
DS
f
CWDwarf_Half
dwarf_set_frame_rule_same_value
Dwarf_Debug
dbg
Dwarf_Half
value
fP
DE
f
CWdwarf_set_frame_rule_same_value
fP
sets
the
value
f
CWvalue
fP
as
the
number
of
the
register
that
is
the
pseudo
register
set
by
the
DW_CFA_same_value
frame
operation
P
The
function
returns
the
previous
value
of
the
pseudo
register
taken
from
the
f
CWdbg
fP
structure
H
dwarf_set_frame_undefined_value
This
allows
consumers
to
set
the
number
of
the
pseudo
register
when
DW_CFA_undefined_value
is
the
operation
By
default
it
is
taken
from
libdwarf
h
and
is
f
CWDW_FRAME_UNDEFINED_VAL
fP
Consumer
code
should
set
this
appropriately
though
for
many
architectures
f
CWDW_FRAME_UNDEFINED_VAL
fP
is
an
appropriate
setting
DS
f
CWDwarf_Half
dwarf_set_frame_rule_undefined_value
Dwarf_Debug
dbg
Dwarf_Half
value
fP
DE
f
CWdwarf_set_frame_rule_undefined_value
fP
sets
the
value
f
CWvalue
fP
as
the
number
of
the
register
that
is
the
pseudo
register
set
by
the
DW_CFA_undefined_value
frame
operation
P
The
function
returns
the
previous
value
of
the
pseudo
register
taken
from
the
f
CWdbg
fP
structure
H
dwarf_set_default_address_size
This
allows
consumers
to
set
a
default
address
size
When
one
has
an
object
where
the
default
address_size
does
not
match
the
frame
address
size
where
there
is
no
debug_info
available
to
get
a
frame
specific
address
size
this
function
is
useful
For
example
if
an
Elf64
object
has
a
debug_frame
whose
real
address_size
is
bits
This
a
very
rare
situation
DS
f
CWDwarf_Small
dwarf_set_default_address_size
Dwarf_Debug
dbg
Dwarf_Small
value
fP
DE
f
CWdwarf_set_default_address_size
fP
sets
the
value
f
CWvalue
fP
as
the
default
address
size
for
this
activation
of
the
reader
but
only
if
f
CWvalue
fP
is
greater
than
zero
otherwise
the
default
address
size
is
not
changed
P
The
function
returns
the
previous
value
of
the
default
address
size
taken
from
the
f
CWdbg
fP
structure
H
dwarf_get_fde_info_for_reg3_b
This
interface
is
suitable
for
DWARF2
and
later
It
returns
the
values
for
a
particular
real
register
Not
for
the
CFA
virtual
register
see
dwarf_get_fde_info_for_cfa_reg3_b
below
If
the
application
is
going
to
retrieve
the
value
for
more
than
a
few
f
CWtable_column
fP
values
at
this
f
CWpc_requested
fP
by
calling
this
function
multiple
times
it
is
much
more
efficient
to
call
dwarf_get_fde_info_for_all_regs3
in
spite
of
the
additional
setup
that
requires
of
the
caller
DS
f
CWint
dwarf_get_fde_info_for_reg3_b
Dwarf_Fde
fde
Dwarf_Half
table_column
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register_num
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
fP
DE
P
if
f
CW
value_type
fP
has
the
value
DW_EXPR_OFFSET
then
in
P
It
sets
f
CW
offset_relevant
fP
to
non
zero
if
the
offset
is
relevant
for
the
row
specified
by
f
CWpc_requested
fP
and
column
specified
by
f
CWtable_column
fP
or
for
the
FDE
specified
by
f
CWfde
fP
In
this
case
the
f
CW
register_num
fP
will
be
set
to
DW_FRAME_CFA_COL3
This
is
an
offset
N
rule
as
specified
in
the
DWARF3
documents
P
Adding
the
value
of
f
CW
offset_or_block_len
fP
to
the
value
of
the
CFA
register
gives
the
address
of
a
location
holding
the
previous
value
of
register
f
CWtable_column
fP
P
If
offset
is
not
relevant
for
this
rule
f
CW
offset_relevant
fP
is
set
to
zero
f
CW
register_num
fP
will
be
set
to
the
number
of
the
real
register
holding
the
value
of
the
f
CWtable_column
fP
register
This
is
the
register
R
rule
as
specified
in
DWARF3
documents
P
The
intent
is
to
return
the
rule
for
the
given
pc
value
and
register
The
location
pointed
to
by
f
CWregister_num
fP
is
set
to
the
register
value
for
the
rule
The
location
pointed
to
by
f
CWoffset
fP
is
set
to
the
offset
value
for
the
rule
Since
more
than
one
pc
value
will
have
rows
with
identical
entries
the
user
may
want
to
know
the
earliest
pc
value
after
which
the
rules
for
all
the
columns
remained
unchanged
Recall
that
in
the
virtual
table
that
the
frame
information
represents
there
may
be
one
or
more
table
rows
with
identical
data
each
such
table
row
at
a
different
pc
value
Given
a
f
CWpc_requested
fP
which
refers
to
a
pc
in
such
a
group
of
identical
rows
the
location
pointed
to
by
f
CWrow_pc
fP
is
set
to
the
lowest
pc
value
within
the
group
of
identical
rows
in
P
If
f
CW
value_type
fP
has
the
value
DW_EXPR_VAL_OFFSET
then
in
This
will
be
a
val_offset
N
rule
as
specified
in
the
DWARF3
documents
so
f
CW
offset_relevant
fP
will
be
non
zero
P
The
calculation
is
identical
to
the
DW_EXPR_OFFSET
calculation
with
f
CW
offset_relevant
fP
non
zero
but
the
value
resulting
is
the
actual
f
CWtable_column
fP
value
rather
than
the
address
where
the
value
may
be
found
in
P
If
f
CW
value_type
fP
has
the
value
DW_EXPR_EXPRESSION
then
in
f
CW
offset_or_block_len
fP
is
set
to
the
length
in
bytes
of
a
block
of
memory
with
a
DWARF
expression
in
the
block
f
CW
block_ptr
fP
is
set
to
point
at
the
block
of
memory
The
consumer
code
should
evaluate
the
block
as
a
DWARF
expression
The
result
is
the
address
where
the
previous
value
of
the
register
may
be
found
This
is
a
DWARF3
expression
E
rule
in
P
If
f
CW
value_type
fP
has
the
value
DW_EXPR_VAL_EXPRESSION
then
in
The
calculation
is
exactly
as
for
DW_EXPR_EXPRESSION
but
the
result
of
the
DWARF
expression
evaluation
is
the
value
of
the
f
CWtable_column
fP
not
the
address
of
the
value
This
is
a
DWARF3
val_expression
E
rule
in
P
Arguments
f
CWhas_more_rows
fP
and
f
CWsubsequent_pc
fP
which
allow
the
caller
to
know
if
there
are
more
rows
in
the
frame
table
and
what
the
next
pc
value
in
the
frame
table
for
this
fde
is
The
two
new
arguments
may
be
passed
in
as
NULL
if
their
values
are
not
needed
by
the
caller
H
dwarf_get_fde_info_for_cfa_reg3
DS
f
CWint
dwarf_get_fde_info_for_cfa_reg3
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register_num
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Error
error
fP
DE
P
This
is
identical
to
f
CWdwarf_get_fde_info_for_reg3
fP
except
the
returned
values
are
for
the
CFA
rule
So
register
number
f
CW
register_num
fP
will
be
set
to
a
real
register
not
one
of
the
pseudo
registers
which
are
usually
DW_FRAME_CFA_COL3
DW_FRAME_SAME_VALUE
or
DW_FRAME_UNDEFINED_VALUE
P
Applications
like
dwarfdump
which
access
the
register
rules
for
every
pc
value
in
a
function
may
find
the
following
function
a
slight
performance
improvement
if
the
new
arguments
are
used
appropriately
See
f
CWdwarfdump
fP
for
an
example
of
use
H
dwarf_get_fde_info_for_cfa_reg3_b
DS
f
CWint
dwarf_get_fde_info_for_cfa_reg3_b
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register_num
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
fP
DE
P
This
is
identical
to
f
CWdwarf_get_fde_info_for_cfa_reg3
fP
except
for
the
new
arguments
f
CWhas_more_rows
fP
and
f
CWsubsequent_pc
fP
which
allow
the
caller
to
know
if
there
are
more
rows
in
the
frame
table
and
what
the
next
pc
value
is
The
two
new
arguments
may
be
passed
in
as
NULL
if
their
values
are
not
needed
by
the
caller
P
For
a
tool
just
wanting
the
frame
information
for
a
single
pc_value
this
interface
is
no
more
useful
or
efficient
than
f
CWdwarf_get_fde_info_for_cfa_reg3
fP
P
The
essential
difference
is
that
when
using
f
CWdwarf_get_fde_info_for_cfa_reg3
fP
for
all
pc
values
for
a
function
the
caller
has
no
idea
what
is
the
next
pc
value
that
might
have
new
frame
data
and
iterating
through
pc
values
calling
f
CWdwarf_get_fde_info_for_cfa_reg3
fP
on
each
is
a
waste
of
cpu
cycles
With
f
CWdwarf_get_fde_info_for_cfa_reg3_b
fP
the
f
CWhas_more_rows
fP
and
f
CWsubsequent_pc
fP
arguments
let
the
caller
know
whether
there
are
further
rows
and
if
so
at
what
pc
value
P
If
f
CWhas_more_rows
fP
is
non
null
then
is
returned
through
the
pointer
if
for
the
f
CWpc_requested
fP
there
is
frame
data
for
addresses
after
f
CWpc_requested
fP
in
the
frame
And
if
there
are
no
more
rows
in
the
frame
data
then
is
set
through
the
f
CWhas_more_rows
fP
pointer
P
If
f
CWsubsequent_pc
fP
is
non
null
then
the
pc
value
which
has
the
next
frame
operator
is
returned
through
the
pointer
If
no
more
rows
are
present
zero
is
returned
through
the
pointer
but
please
use
f
CWhas_more_rows
fP
to
determine
if
there
are
more
rows
H
dwarf_get_fde_info_for_all_regs3
DS
f
CWint
dwarf_get_fde_info_for_all_regs3
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Regtable3
reg_table
Dwarf_Addr
row_pc
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_info_for_all_regs3
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
reg_table
fP
for
the
row
specified
by
f
CWpc_requested
fP
for
the
FDE
specified
by
f
CWfde
fP
The
intent
is
to
return
the
rules
for
decoding
all
the
registers
given
a
pc
value
f
CWreg_table
fP
is
an
array
of
rules
the
array
size
specified
by
the
caller
plus
a
rule
for
the
CFA
The
rule
for
the
cfa
returned
in
f
CW
reg_table
fP
defines
the
CFA
value
at
f
CWpc_requested
fP
The
rule
for
each
register
contains
several
values
that
enable
the
consumer
to
determine
the
previous
value
of
the
register
see
the
earlier
documentation
of
Dwarf_Regtable3
f
CWdwarf_get_fde_info_for_reg3
fP
and
the
Dwarf_Regtable3
documentation
above
for
a
description
of
the
values
for
each
row
f
CWdwarf_get_fde_info_for_all_regs3
fP
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
It
is
up
to
the
caller
to
allocate
space
for
f
CW
reg_table
fP
and
initialize
it
properly
H
dwarf_get_fde_n
DS
f
CWint
dwarf_get_fde_n
Dwarf_Fde
fde_data
Dwarf_Unsigned
fde_index
Dwarf_Fde
returned_fde
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_n
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWreturned_fde
fP
to
the
f
CWDwarf_Fde
fP
descriptor
whose
index
is
f
CWfde_index
fP
in
the
table
of
f
CWDwarf_Fde
fP
descriptors
pointed
to
by
fPfde_data
fP
The
index
starts
with
The
table
pointed
to
by
fde_data
is
required
to
contain
at
least
one
entry
If
the
table
has
no
entries
at
all
the
error
checks
may
refer
to
uninitialized
memory
Returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
index
does
not
exist
in
the
table
of
f
CWDwarf_Fde
fP
descriptors
Returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
This
function
cannot
be
used
unless
the
block
of
f
CWDwarf_Fde
fP
descriptors
has
been
created
by
a
call
to
f
CWdwarf_get_fde_list
fP
H
dwarf_get_fde_at_pc
DS
f
CWint
dwarf_get_fde_at_pc
Dwarf_Fde
fde_data
Dwarf_Addr
pc_of_interest
Dwarf_Fde
returned_fde
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Error
error
fP
DE
f
CWdwarf_get_fde_at_pc
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWreturned_fde
fP
to
a
f
CWDwarf_Fde
fP
descriptor
for
a
function
which
contains
the
pc
value
specified
by
f
CWpc_of_interest
fP
In
addition
it
sets
the
locations
pointed
to
by
f
CWlopc
fP
and
f
CWhipc
fP
to
the
low
address
and
the
high
address
covered
by
this
FDE
respectively
The
table
pointed
to
by
fde_data
is
required
to
contain
at
least
one
entry
If
the
table
has
no
entries
at
all
the
error
checks
may
refer
to
uninitialized
memory
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
f
CWpc_of_interest
fP
is
not
in
any
of
the
FDEs
represented
by
the
block
of
f
CWDwarf_Fde
fP
descriptors
pointed
to
by
f
CWfde_data
fP
This
function
cannot
be
used
unless
the
block
of
f
CWDwarf_Fde
fP
descriptors
has
been
created
by
a
call
to
f
CWdwarf_get_fde_list
fP
H
dwarf_expand_frame_instructions
DS
f
CWint
dwarf_expand_frame_instructions
Dwarf_Cie
cie
Dwarf_Ptr
instruction
Dwarf_Unsigned
i_length
Dwarf_Frame_Op
returned_op_list
Dwarf_Signed
returned_op_count
Dwarf_Error
error
fP
DE
f
CWdwarf_expand_frame_instructions
fP
is
a
High
level
interface
function
which
expands
a
frame
instruction
byte
stream
into
an
array
of
f
CWDwarf_Frame_Op
fP
structures
To
indicate
success
it
returns
f
CWDW_DLV_OK
fP
The
address
where
the
byte
stream
begins
is
specified
by
f
CWinstruction
fP
and
the
length
of
the
byte
stream
is
specified
by
f
CWi_length
fP
The
location
pointed
to
by
f
CWreturned_op_list
fP
is
set
to
point
to
a
table
of
f
CWreturned_op_count
fP
pointers
to
f
CWDwarf_Frame_Op
fP
which
contain
the
frame
instructions
in
the
byte
stream
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
After
a
successful
return
the
array
of
structures
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_FRAME_BLOCK
fP
when
they
are
no
longer
of
interest
P
Not
all
CIEs
have
the
same
address
size
so
it
is
crucial
that
a
CIE
pointer
to
the
frame
s
CIE
be
passed
in
in
FG
Examples
dwarf_expand_frame_instructions
DS
f
CW
void
examples
Dwarf_Debug
dbg
Dwarf_Cie
cie
Dwarf_Ptr
instruction
Dwarf_Unsigned
len
Dwarf_Signed
count
Dwarf_Frame_Op
frameops
Dwarf_Error
error
int
res
res
dwarf_expand_frame_instructions
cie
instruction
len
if
res
DW_DLV_OK
Dwarf_Signed
i
for
i
i
count
i
use
frameops
i
dwarf_dealloc
dbg
frameops
DW_DLA_FRAME_BLOCK
fP
DE
in
H
dwarf_get_fde_exception_info
DS
f
CWint
dwarf_get_fde_exception_info
Dwarf_Fde
fde
Dwarf_Signed
offset_into_exception_tables
Dwarf_Error
error
DE
f
CWdwarf_get_fde_exception_info
fP
is
an
IRIX
specific
function
which
returns
an
exception
table
signed
offset
through
f
CWoffset_into_exception_tables
fP
The
function
never
returns
f
CWDW_DLV_NO_ENTRY
fP
If
f
CWDW_DLV_NO_ENTRY
fP
is
NULL
the
function
returns
f
CWDW_DLV_ERROR
fP
For
non
IRIX
objects
the
offset
returned
will
always
be
zero
For
non
C
objects
the
offset
returned
will
always
be
zero
The
meaning
of
the
offset
and
the
content
of
the
tables
is
not
defined
in
this
document
The
applicable
CIE
augmentation
string
see
above
determines
whether
the
value
returned
has
meaning
H
Location
Expression
Evaluation
An
interpreter
which
evaluates
a
location
expression
is
required
in
any
debugger
There
is
no
interface
defined
here
at
this
time
P
One
problem
with
defining
an
interface
is
that
operations
are
machine
dependent
they
depend
on
the
interpretation
of
register
numbers
and
the
methods
of
getting
values
from
the
environment
the
expression
is
applied
to
P
It
would
be
desirable
to
specify
an
interface
H
Location
List
Internal
level
Interface
H
dwarf_get_loclist_entry
DS
f
CWint
dwarf_get_loclist_entry
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Addr
hipc_offset
Dwarf_Addr
lopc_offset
Dwarf_Ptr
data
Dwarf_Unsigned
entry_len
Dwarf_Unsigned
next_entry
Dwarf_Error
error
fP
DE
This
function
is
ill
suited
to
use
with
century
DWARF
as
there
is
just
not
enough
data
provided
in
the
interface
Do
not
use
this
interface
Use
f
CWdwarf_get_locdesc_entry_c
fP
instead
P
The
function
reads
a
location
list
entry
starting
at
f
CWoffset
fP
and
returns
through
pointers
when
successful
the
high
pc
f
CWhipc_offset
fP
low
pc
f
CWlopc_offset
fP
a
pointer
to
the
location
description
data
f
CWdata
fP
the
length
of
the
location
description
data
f
CWentry_len
fP
and
the
offset
of
the
next
location
description
entry
f
CWnext_entry
fP
P
This
function
will
often
work
correctly
meaning
with
most
objects
compiled
for
DWARF3
or
DWARF3
but
will
not
work
correctly
and
can
crash
an
application
calling
it
if
either
some
location
list
applies
to
a
compilation
unit
with
an
address_size
different
from
the
overall
address_size
of
the
object
file
being
read
or
if
the
debug_loc
section
being
read
has
random
padding
bytes
between
loclists
Neither
of
these
characteristics
necessarily
represents
a
bug
in
the
compiler
linker
toolset
that
produced
the
object
file
being
read
The
DWARF
standard
allows
both
characteristics
P
f
CWdwarf_dwarf_get_loclist_entry
fP
returns
f
CWDW_DLV_OK
fP
if
successful
f
CWDW_DLV_NO_ENTRY
fP
is
returned
when
the
offset
passed
in
is
beyond
the
end
of
the
debug_loc
section
expected
if
you
start
at
offset
zero
and
proceed
through
all
the
entries
f
CWDW_DLV_ERROR
fP
is
returned
on
error
P
The
f
CWhipc_offset
fP
low
pc
f
CWlopc_offset
fP
are
offsets
from
the
beginning
of
the
current
procedure
not
genuine
pc
values
P
The
example
of
use
has
been
deleted
Do
not
use
this
function
H
Abbreviations
access
These
are
Internal
level
Interface
functions
Debuggers
can
ignore
this
H
dwarf_get_abbrev
DS
f
CWint
dwarf_get_abbrev
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Abbrev
returned_abbrev
Dwarf_Unsigned
length
Dwarf_Unsigned
attr_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_abbrev
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_abbrev
fP
to
f
CWDwarf_Abbrev
fP
a
descriptor
for
the
abbreviation
that
begins
at
offset
f
CW
offset
fP
in
the
abbreviations
section
i
e
debug_abbrev
on
success
The
user
is
responsible
for
making
sure
that
a
valid
abbreviation
begins
at
f
CWoffset
fP
in
the
abbreviations
section
The
location
pointed
to
by
f
CWlength
fP
is
set
to
the
length
in
bytes
of
the
abbreviation
set
in
the
abbreviations
section
The
location
pointed
to
by
f
CWattr_count
fP
is
set
to
the
number
of
attributes
in
the
abbreviation
An
abbreviation
entry
with
a
length
of
is
the
byte
of
the
last
abbreviation
entry
of
a
compilation
unit
P
f
CWdwarf_get_abbrev
fP
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
debug_abbrev
section
is
missing
or
if
the
offset
passed
in
is
past
the
end
of
the
section
P
f
CWdwarf_get_abbrev
fP
returns
f
CWDW_DLV_ERROR
fP
on
error
If
the
call
succeeds
the
storage
pointed
to
by
f
CW
returned_abbrev
fP
should
be
freed
using
f
CWdwarf_dealloc
fP
with
the
allocation
type
f
CWDW_DLA_ABBREV
fP
when
no
longer
needed
H
dwarf_get_abbrev_tag
DS
f
CWint
dwarf_get_abbrev_tag
Dwarf_Abbrev
abbrev
Dwarf_Half
return_tag
Dwarf_Error
error
fP
DE
If
successful
f
CWdwarf_get_abbrev_tag
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_tag
fP
to
the
fItag
fP
of
the
given
abbreviation
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_get_abbrev_code
DS
f
CWint
dwarf_get_abbrev_code
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
return_code
Dwarf_Error
error
fP
DE
If
successful
f
CWdwarf_get_abbrev_code
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
return_code
fP
to
the
abbreviation
code
of
the
given
abbreviation
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
never
returns
f
CWDW_DLV_NO_ENTRY
fP
H
dwarf_get_abbrev_children_flag
DS
f
CWint
dwarf_get_abbrev_children_flag
Dwarf_Abbrev
abbrev
Dwarf_Signed
returned_flag
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_abbrev_children_flag
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWreturned_flag
fP
to
f
CWDW_children_no
fP
if
the
given
abbreviation
indicates
that
a
die
with
that
abbreviation
has
no
children
or
f
CWDW_children_yes
fP
if
the
given
abbreviation
indicates
that
a
die
with
that
abbreviation
has
a
child
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_get_abbrev_entry_b
DS
f
CWint
dwarf_get_abbrev_entry_b
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
index
Dwarf_Bool
filter_outliers
Dwarf_Unsigned
returned_attr_num
Dwarf_Unsigned
returned_form
Dwarf_Signed
returned_implicit_const
Dwarf_Off
offset
Dwarf_Error
error
fP
DE
f
CWdwarf_get_abbrev_entry_b
fP
is
new
in
August
It
should
be
used
in
place
of
f
CWdwarf_get_abbrev_entry
fP
as
f
CWdwarf_get_abbrev_entry
fP
cannot
return
the
DWARF5
implicit
const
value
and
and
f
CWdwarf_get_abbrev_entry
fP
can
hide
some
instances
of
corrupt
uleb
abbreviation
values
P
While
the
f
CWreturned_attr_num
fP
and
and
f
CWreturned_form
fP
are
only
correct
if
they
each
fit
in
a
f
CWDwarf_Half
fP
value
we
return
larger
values
in
certain
cases
see
next
paragraph
P
If
f
CWfilter_outliers
fP
is
passed
in
zero
then
erroneous
f
CWreturned_attr_num
fP
or
and
f
CWreturned_form
fP
are
returned
whether
their
values
are
sensible
or
not
and
f
CWDW_DLV_OK
fP
is
the
returned
value
This
is
useful
for
dwarfdump
as
dwarfdump
checks
abbreviation
values
quite
thoroughly
and
reports
errors
in
detail
dwarfdump
kb
P
If
f
CWfilter_outliers
fP
is
passed
in
non
zero
then
f
CWDW_DLV_OK
fP
is
returned
only
if
f
CWreturned_attr_num
fP
and
and
f
CWreturned_form
fP
are
both
legitimate
values
P
If
successful
f
CWdwarf_get_abbrev_entry_b
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
attr_num
fP
to
the
attribute
code
of
the
attribute
whose
index
is
specified
by
f
CWindex
fP
in
the
given
abbreviation
P
The
index
starts
at
P
The
location
pointed
to
by
f
CWreturned_attr_num
fP
is
set
to
the
attribute
number
example
f
CWDW_AT_name
fP
The
location
pointed
to
by
f
CWreturned_form
fP
is
set
to
the
form
of
the
attribute
example
f
CWDW_FORM_string
fP
The
location
pointed
to
by
f
CWreturned_implicit_const
fP
is
set
to
the
implicit
const
value
if
and
only
if
the
FORM
returned
is
f
CWDW_FORM_implicit_const
fP
The
location
pointed
to
by
f
CWoffset
fP
is
set
to
the
byte
offset
of
the
attribute
in
the
abbreviations
section
P
The
function
returns
f
CWDW_DLV_NO_ENTRY
fP
if
the
index
specified
is
outside
the
range
of
attributes
in
this
abbreviation
P
The
function
returns
f
CWDW_DLV_ERROR
fP
on
error
and
sets
f
CW
error
fP
to
an
error
value
instance
H
String
Section
Operations
The
debug_str
section
contains
only
strings
Debuggers
need
never
use
this
interface
it
is
only
for
debugging
problems
with
the
string
section
itself
H
dwarf_get_string_section_name
DS
f
CWint
dwarf_get_string_section_name
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CWdwarf_get_string_section_name
fP
lets
consumers
access
the
object
string
section
name
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
See
also
f
CWdwarf_get_die_section_name_b
fP
P
The
function
f
CWdwarf_get_string_section_name
fP
operates
on
the
the
debug_string
dwo
section
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_str
DS
f
CWint
dwarf_get_str
Dwarf_Debug
dbg
Dwarf_Off
offset
char
string
Dwarf_Signed
returned_str_len
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_str
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_str_len
fP
to
the
length
of
the
string
not
counting
the
null
terminator
that
begins
at
the
offset
specified
by
f
CWoffset
fP
in
the
debug_str
section
The
location
pointed
to
by
f
CWstring
fP
is
set
to
a
pointer
to
this
string
The
next
string
in
the
debug_str
section
begins
at
the
previous
f
CWoffset
fP
f
CW
returned_str_len
fP
A
zero
length
string
is
NOT
the
end
of
the
section
If
there
is
no
debug_str
section
f
CWDW_DLV_NO_ENTRY
fP
is
returned
If
there
is
an
error
f
CWDW_DLV_ERROR
fP
is
returned
If
we
are
at
the
end
of
the
section
that
is
f
CWoffset
fP
is
one
past
the
end
of
the
section
f
CWDW_DLV_NO_ENTRY
fP
is
returned
If
the
f
CWoffset
fP
is
some
other
too
large
value
then
f
CWDW_DLV_ERROR
fP
is
returned
H
String
Offsets
Section
Operations
The
debug_str_offsets
section
contains
only
table
arrays
with
headers
and
Debuggers
should
never
need
to
use
this
interface
The
normal
string
access
functions
use
the
section
tables
transparently
The
functions
here
are
only
intended
to
allow
dwarfdump
or
the
like
print
the
section
completely
and
to
help
compiler
developers
look
for
bugs
in
the
section
in
FG
examplestringoffsets
dwarf_open_str_offsets_table_access
etc
DS
f
CW
void
examplestringoffsets
Dwarf_Debug
dbg
int
res
Dwarf_Str_Offsets_Table
sot
Dwarf_Unsigned
wasted_byte_count
Dwarf_Unsigned
table_count
Dwarf_Error
error
res
dwarf_open_str_offsets_table_access
dbg
if
res
DW_DLV_NO_ENTRY
No
such
table
return
if
res
DW_DLV_ERROR
Something
is
very
wrong
Print
the
error?
return
for
Dwarf_Unsigned
unit_length
Dwarf_Unsigned
unit_length_offset
Dwarf_Unsigned
table_start_offset
Dwarf_Half
entry_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
table_value_count
Dwarf_Unsigned
i
Dwarf_Unsigned
table_entry_value
res
dwarf_next_str_offsets_table
sot
if
res
DW_DLV_NO_ENTRY
We
have
dealt
with
all
tables
break
if
res
DW_DLV_ERROR
Something
badly
wrong
Do
something
return
One
could
call
dwarf_str_offsets_statistics
to
get
the
wasted
bytes
so
far
but
we
do
not
do
that
in
this
example
Possibly
print
the
various
table
related
values
returned
just
above
for
i
i
table_value_count
i
res
dwarf_str_offsets_value_by_index
sot
i
if
res
DW_DLV_OK
Something
is
badly
wrong
Do
something
return
Do
something
with
the
table_entry_value
at
this
index
Maybe
just
print
it
It
is
an
offset
in
debug_str
res
dwarf_str_offsets_statistics
sot
if
res
DW_DLV_OK
The
wasted
byte
count
is
set
Print
it
or
something
One
hopes
zero
bytes
are
wasted
Print
the
table
count
if
one
is
interested
res
dwarf_close_str_offsets_table_access
sot
There
is
little
point
in
checking
the
return
value
as
little
can
be
done
about
any
error
sot
fP
DE
in
H
dwarf_open_str_offsets_table_access
DS
f
CWint
dwarf_open_str_offsets_table_access
Dwarf_Debug
dbg
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
fP
DE
f
CWdwarf_open_str_offsets_table_access
fP
creates
an
opaque
struct
and
returns
a
pointer
to
it
on
success
That
struct
pointer
is
used
in
all
subsequent
operations
on
the
table
Through
the
function
f
CWdwarf_next_str_offsets_table
fP
the
caller
can
iterate
through
each
of
the
per
CU
offset
tables
P
If
there
is
no
such
section
or
if
the
section
is
empty
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
error
such
as
out
of
memory
the
function
returns
DW_DLV_ERROR
and
sets
an
error
value
through
the
f
CWerror
fP
pointer
H
dwarf_close_str_offsets_table_access
DS
f
CWint
dwarf_close_str_offsets_table_access
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_close_str_offsets_table_access
fP
frees
any
allocated
data
associated
with
the
struct
pointed
to
by
f
CWtable_data
fP
and
returns
DW_DLV_OK
It
is
up
to
the
caller
to
set
the
f
CWtable_data
fP
pointer
to
NULL
if
desired
The
pointer
is
unusable
at
that
point
and
any
other
calls
to
libdwarf
using
that
pointer
will
fail
P
It
returns
DW_DLV_OK
on
error
Any
error
suggests
there
is
memory
corruption
or
an
error
in
the
call
Something
serious
happened
P
It
never
returns
DW_DLV_NO_ENTRY
but
if
it
did
there
would
be
nothing
the
caller
could
do
anyway
P
If
one
forgets
to
call
this
function
the
memory
allocated
will
be
freed
automatically
by
to
call
to
f
CWdwarf_finish
fP
as
is
true
of
all
other
data
allocated
by
libdwarf
H
dwarf_next_str_offsets_table
DS
f
CWint
dwarf_next_str_offsets_table
Dwarf_Str_Offsets_Table
table
Dwarf_Unsigned
unit_length_out
Dwarf_Unsigned
unit_length_offset_out
Dwarf_Unsigned
table_start_offset_out
Dwarf_Half
entry_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Unsigned
table_value_count_out
Dwarf_Error
error
fP
DE
Each
call
to
f
CWdwarf_next_str_offsets_table
fP
returns
the
next
String
Offsets
table
in
the
debug_str_offsets
section
Typically
there
would
be
one
such
table
for
each
CU
in
debug_info
dwo
contributing
to
debug_str_offsets
The
f
CWtable
fP
contains
internally
hidden
the
section
offset
of
the
next
table
P
On
success
it
returns
DW_DLV_OK
and
sets
various
fields
representing
data
about
the
current
table
fields
described
below
P
If
there
are
no
more
tables
it
returns
DW_DLV_NO_ENTRY
P
On
error
it
returns
DW_DLV_ERROR
and
passes
back
error
details
through
the
f
CWerror
fP
pointer
P
The
returned
values
are
intended
to
let
the
caller
understand
the
table
header
and
the
table
in
detail
These
pointers
are
only
used
if
the
call
returned
DW_DLV_OK
P
f
CWunit_length_out
fP
is
set
to
the
unit_length
of
a
String
Offsets
Table
Header
Which
means
it
gives
the
length
in
bytes
of
the
data
following
the
length
value
that
belongs
to
this
table
P
f
CWunit_length_offset_out
fP
is
set
to
the
section
offset
of
the
table
header
P
f
CWtable_start_offset_out
fP
is
set
to
the
section
offset
of
the
array
of
offsets
in
this
table
P
f
CWentry_size_out
fP
is
set
to
the
size
of
a
table
entry
Which
is
for
bit
offsets
in
this
table
and
for
bit
offsets
in
this
table
P
f
CWversion_out
fP
is
set
to
the
version
number
in
the
table
header
The
only
current
valid
value
is
P
f
CWpadding_out
fP
is
set
to
the
bit
padding
value
in
the
table
header
In
a
correct
table
header
the
value
is
zero
P
f
CWtable_value_count_out
fP
is
set
to
the
number
of
entries
in
the
array
of
offsets
in
this
table
Each
entry
is
f
CWentry_size_out
fP
bytes
long
Use
this
value
in
calling
f
CWdwarf_str_offsets_value_by_index
fP
H
dwarf_str_offsets_value_by_index
DS
f
CWint
dwarf_str_offsets_value_by_index
Dwarf_Str_Offsets_Table
sot
Dwarf_Unsigned
index
Dwarf_Unsigned
stroffset
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_str_offsets_value_by_index
fP
returns
DW_DLV_OK
and
sets
the
offset
from
the
array
of
string
offsets
in
the
current
table
at
the
input
f
CWindex
fP
P
Valid
index
values
are
zero
through
f
CWtable_value_count_out
fP
P
A
function
is
used
instead
of
simply
letting
callers
use
pointers
as
libdwarf
correctly
handles
endianness
differences
between
the
system
running
libdwarf
and
the
object
file
being
inspected
so
offsets
can
be
reported
properly
P
DW_DLV_ERROR
is
returned
on
error
P
DW_DLV_NO_ENTRY
is
never
returned
H
dwarf_str_offsets_statistics
DS
f
CWint
dwarf_str_offsets_statistics
Dwarf_Str_Offsets_Table
table_data
Dwarf_Unsigned
wasted_byte_count
Dwarf_Unsigned
table_count
Dwarf_Error
error
fP
DE
Normally
called
after
all
tables
have
been
inspected
to
return
through
a
pointer
the
count
of
apparently
wasted
bytes
in
the
section
It
can
be
called
at
any
point
that
the
f
CWDwarf_Str_Offsets_Table
fP
pointer
is
valid
P
On
error
it
returns
DW_DLV_ERROR
and
sets
an
error
value
through
the
pointer
P
DW_DLV_NO_ENTRY
is
never
returned
P
On
success
it
returns
DW_DLV_OK
and
sets
values
through
the
two
pointers
Calling
just
after
each
table
is
accessed
by
f
CWdwarf_next_str_offsets_table
fP
will
reveal
the
sum
of
all
wasted
bytes
at
that
point
in
iterating
through
the
section
P
f
CWtable_count
fP
is
the
count
of
table
headers
encountered
so
far
P
By
wasted
bytes
we
mean
bytes
in
between
tables
libdwarf
has
no
idea
whether
any
apparently
valid
table
data
is
in
fact
useless
H
Address
Range
Operations
These
functions
provide
information
about
address
ranges
The
content
is
in
the
f
CW
debug_aranges
fP
section
Address
ranges
map
ranges
of
pc
values
to
the
corresponding
compilation
unit
die
that
covers
the
address
range
In
the
DWARF2
Standards
this
is
described
under
Accelerated
Access
Lookup
by
Address
H
dwarf_get_aranges_section_name
DS
f
CWint
dwarf_get_aranges_section_name
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CW
dwarf_get_aranges_section_name
fP
retrieves
the
object
file
section
name
of
the
applicable
aranges
section
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_aranges
DS
f
CWint
dwarf_get_aranges
Dwarf_Debug
dbg
Dwarf_Arange
aranges
Dwarf_Signed
returned_arange_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_aranges
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_arange_count
fP
to
the
count
of
the
number
of
address
ranges
in
the
debug_aranges
section
for
all
compilation
units
It
sets
f
CW
aranges
fP
to
point
to
a
block
of
f
CWDwarf_Arange
fP
descriptors
one
for
each
address
range
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
debug_aranges
section
P
This
not
only
reads
all
the
ranges
it
also
reads
the
per
compilation
unit
headers
in
debug_aranges
and
verifies
they
make
sense
in
FG
Exampleu
dwarf_get_aranges
DS
f
CW
void
exampleu
Dwarf_Debug
dbg
Dwarf_Signed
count
Dwarf_Arange
arang
int
res
Dwarf_Error
error
res
dwarf_get_aranges
dbg
if
res
DW_DLV_OK
Dwarf_Signed
i
for
i
i
count
i
use
arang
i
dwarf_dealloc
dbg
arang
i
DW_DLA_ARANGE
dwarf_dealloc
dbg
arang
DW_DLA_LIST
fP
DE
in
H
dwarf_get_arange
DS
f
CWint
dwarf_get_arange
Dwarf_Arange
aranges
Dwarf_Unsigned
arange_count
Dwarf_Addr
address
Dwarf_Arange
returned_arange
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_arange
fP
takes
as
input
a
pointer
to
a
block
of
f
CWDwarf_Arange
fP
pointers
and
a
count
of
the
number
of
descriptors
in
the
block
It
then
searches
for
the
descriptor
that
covers
the
given
f
CWaddress
fP
If
it
finds
one
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_arange
fP
to
the
descriptor
It
returns
f
CWDW_DLV_ERROR
fP
on
error
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
debug_aranges
entry
covering
that
address
P
H
dwarf_get_cu_die_offset
DS
f
CWint
dwarf_get_cu_die_offset
Dwarf_Arange
arange
Dwarf_Off
returned_cu_die_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_cu_die_offset
fP
takes
a
f
CWDwarf_Arange
fP
descriptor
as
input
and
if
successful
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_cu_die_offset
fP
to
the
offset
in
the
debug_info
section
of
the
compilation
unit
DIE
for
the
compilation
unit
represented
by
the
given
address
range
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_get_arange_cu_header_offset
DS
f
CWint
dwarf_get_arange_cu_header_offset
Dwarf_Arange
arange
Dwarf_Off
returned_cu_header_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_arange_cu_header_offset
fP
takes
a
f
CWDwarf_Arange
fP
descriptor
as
input
and
if
successful
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_cu_header_offset
fP
to
the
offset
in
the
debug_info
section
of
the
compilation
unit
header
for
the
compilation
unit
represented
by
the
given
address
range
It
returns
f
CWDW_DLV_ERROR
fP
on
error
This
function
added
Rev
June
This
function
is
declared
as
optional
in
libdwarf
h
on
IRIX
systems
so
the
_MIPS_SYMBOL_PRESENT
predicate
may
be
used
at
run
time
to
determine
if
the
version
of
libdwarf
linked
into
an
application
has
this
function
H
dwarf_get_arange_info_b
DS
f
CWint
dwarf_get_arange_info_b
Dwarf_Arange
arange
Dwarf_Unsigned
segment
Dwarf_Unsigned
segment_entry_size
Dwarf_Addr
start
Dwarf_Unsigned
length
Dwarf_Off
cu_die_offset
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_arange_info_b
fP
returns
f
CWDW_DLV_OK
fP
and
returns
detailed
information
on
the
address
range
through
the
pointers
P
f
CWsegment
fP
is
the
segment
number
for
segmented
addresss
spaces
and
it
is
only
meaningful
if
f
CWsegment_entry_size
fP
is
non
zero
P
It
puts
the
starting
value
of
the
address
range
in
the
location
pointed
to
by
f
CWstart
fP
and
the
length
of
the
address
range
in
the
location
pointed
to
by
f
CWlength
fP
P
It
sets
the
f
CWcu_die_offset
fP
in
the
f
CW
debug_info
fP
section
of
the
compilation
unit
DIE
for
the
compilation
unit
represented
by
the
address
range
P
It
returns
f
CWDW_DLV_ERROR
fP
on
error
and
sets
f
CWerror
fP
H
dwarf_get_arange_info
DS
f
CWint
dwarf_get_arange_info
Dwarf_Arange
arange
Dwarf_Addr
start
Dwarf_Unsigned
length
Dwarf_Off
cu_die_offset
Dwarf_Error
error
fP
DE
This
is
the
same
as
f
CWdwarf_get_arange_info_b
fP
except
that
this
earlier
function
does
not
have
a
way
to
return
the
segment
information
H
General
Low
Level
Operations
This
function
is
low
level
and
intended
for
use
only
by
programs
such
as
dwarf
dumpers
H
dwarf_get_offset_size
DS
f
CWint
dwarf_get_offset_size
Dwarf_Debug
dbg
Dwarf_Half
offset_size
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_offset_size
fP
returns
f
CWDW_DLV_OK
fP
on
success
and
sets
the
f
CW
offset_size
fP
to
the
size
in
bytes
of
an
offset
In
case
of
error
it
returns
f
CWDW_DLV_ERROR
fP
and
does
not
set
f
CW
offset_size
fP
The
offset
size
returned
is
the
overall
address
size
which
can
be
misleading
if
different
compilation
units
have
different
address
sizes
Many
ABIs
have
only
a
single
address
size
per
executable
but
differing
address
sizes
are
becoming
more
common
H
dwarf_get_address_size
DS
f
CWint
dwarf_get_address_size
Dwarf_Debug
dbg
Dwarf_Half
addr_size
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_address_size
fP
returns
f
CWDW_DLV_OK
fP
on
success
and
sets
the
f
CW
addr_size
fP
to
the
size
in
bytes
of
an
address
In
case
of
error
it
returns
f
CWDW_DLV_ERROR
fP
and
does
not
set
f
CW
addr_size
fP
The
address
size
returned
is
the
overall
address
size
which
can
be
misleading
if
different
compilation
units
have
different
address
sizes
Many
ABIs
have
only
a
single
address
size
per
executable
but
differing
address
sizes
are
becoming
more
common
Use
f
CWdwarf_get_die_address_size
fP
instead
whenever
possible
H
dwarf_get_die_address_size
DS
f
CWint
dwarf_get_die_address_size
Dwarf_Die
die
Dwarf_Half
addr_size
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_die_address_size
fP
returns
f
CWDW_DLV_OK
fP
on
success
and
sets
the
f
CW
addr_size
fP
to
the
size
in
bytes
of
an
address
In
case
of
error
it
returns
f
CWDW_DLV_ERROR
fP
and
does
not
set
f
CW
addr_size
fP
The
address
size
returned
is
the
address
size
of
the
compilation
unit
owning
the
f
CWdie
fP
This
is
the
preferred
way
to
get
address
size
when
the
f
CWDwarf_Die
fP
is
known
H
dwarf_decode_leb128
See
the
DWARF5
standard
Section
for
a
general
description
of
LEB
encoded
values
DS
f
CWint
dwarf_decode_leb128
char
leb
Dwarf_Unsigned
leblen
Dwarf_Unsigned
outval
char
endptr
fP
DE
In
December
this
makes
library
decoding
visible
to
library
users
for
the
first
time
P
The
user
should
pass
in
f
CWleb
fP
with
a
pointer
to
the
initial
byte
of
the
leb
number
and
pass
in
f
CWendptr
fP
with
a
pointer
at
least
one
past
the
content
of
the
leb
value
Typically
f
CWendptr
fP
points
at
an
end
of
section
if
reading
object
sections
or
some
other
value
representing
the
end
of
memory
the
function
should
be
allowed
to
read
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWleblen
fP
if
f
CWleblen
fP
passed
in
non
null
to
the
number
of
bytes
read
in
decoding
It
sets
f
CWoutval
fP
to
the
unsigned
value
decoded
P
If
the
function
detects
it
has
read
to
the
f
CWendptr
fP
it
returns
f
CWDW_DLV_ERROR
fP
P
If
the
function
reads
too
many
bytes
without
reaching
a
terminator
or
f
CWendptr
fP
it
returns
f
CWDW_DLV_ERROR
fP
on
the
assumption
that
nobody
would
intentionally
produce
wastefully
long
LEB
data
so
something
is
wrong
P
Only
the
argument
f
CWleblen
fP
may
be
passed
in
as
NULL
the
others
must
be
valid
non
null
values
P
There
is
no
way
for
the
library
to
determine
whether
the
value
is
signed
or
unsigned
The
caller
must
know
and
call
the
the
correct
function
H
dwarf_decode_signed_leb128
See
the
DWARF5
standard
Section
for
a
general
description
of
LEB
encoded
values
DS
f
CWint
dwarf_decode_signed_leb128
char
leb
Dwarf_Unsigned
leblen
Dwarf_Signed
outval
char
endptr
fP
DE
In
December
this
makes
library
decoding
visible
to
library
users
for
the
first
time
P
The
user
should
pass
in
f
CWleb
fP
with
a
pointer
to
the
initial
byte
of
the
leb
number
and
pass
in
f
CWendptr
fP
with
a
pointer
at
least
one
past
the
content
of
the
leb
value
Typically
f
CWendptr
fP
points
at
an
end
of
section
if
reading
object
sections
or
some
other
value
representing
the
end
of
memory
the
function
should
be
allowed
to
read
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWleblen
fP
if
f
CWleblen
fP
passed
in
non
null
to
the
number
of
bytes
read
in
decoding
It
sets
f
CWoutval
fP
to
the
signed
value
decoded
P
If
the
function
detects
it
has
read
to
the
f
CWendptr
fP
it
returns
f
CWDW_DLV_ERROR
fP
P
If
the
function
reads
too
many
bytes
without
reaching
a
terminator
or
f
CWendptr
fP
it
returns
f
CWDW_DLV_ERROR
fP
on
the
assumption
that
nobody
would
intentionally
produce
wastefully
long
LEB
data
so
something
is
wrong
P
P
Only
the
argument
f
CWleblen
fP
may
be
passed
in
as
NULL
the
others
must
be
valid
non
null
values
P
There
is
no
way
for
the
library
to
determine
whether
the
value
is
signed
or
unsigned
The
caller
must
know
and
call
the
the
correct
function
H
Ranges
Operations
DWARF5
debug_rnglists
These
functions
provide
information
about
the
address
ranges
indicated
by
a
f
CWDW_AT_ranges
fP
attribute
of
a
DIE
The
ranges
are
recorded
in
the
f
CW
debug_rnglists
fP
section
P
The
section
requires
that
each
group
of
ranges
has
a
header
and
the
compilation
unit
may
have
a
f
CWDW_AT_ranges_base
fP
attribute
that
must
be
added
to
the
f
CWDW_AT_ranges
fP
attribute
value
to
get
the
true
ranges
offset
P
A
compiler
generating
f
CWDW_AT_ranges_base
fP
will
add
a
relocation
for
that
attribute
value
but
will
not
have
to
make
the
f
CWDW_AT_ranges
fP
attributes
relocatable
and
will
thus
save
space
in
the
object
ie
o
file
and
save
link
time
P
See
DWARF5
Section
Non
Contiguous
Address
Ranges
and
Section
Range
List
Table
P
Section
describes
the
header
fields
for
a
Range
List
Table
There
will
usually
be
many
such
tables
in
some
sequence
in
the
debug_rnglists
section
Here
we
call
each
header
f
CWDwarf_Rnglists_Head
fP
a
pointer
to
an
opaque
struct
H
Getting
rnglists
data
for
a
DIE
This
set
of
interfaces
provides
access
to
the
DWARF5
debug_rnglists
entries
for
a
particular
DIE
Here
is
an
example
using
the
functions
described
below
in
DS
FG
Example
debug_rnglist
for
attribute
f
CW
int
example_rnglist_for_attribute
Dwarf_Attribute
attr
Dwarf_Unsigned
attrvalue
Dwarf_Error
error
attrvalue
must
be
the
DW_AT_ranges
DW_FORM_rnglistx
or
DW_FORM_sec_offset
value
extracted
from
attr
int
res
Dwarf_Half
theform
Dwarf_Unsigned
entries_count
Dwarf_Unsigned
global_offset_of_rle_set
Dwarf_Rnglists_Head
rnglhead
Dwarf_Unsigned
i
res
dwarf_rnglists_get_rle_head
attr
theform
attrvalue
error
if
res
DW_DLV_OK
return
res
for
i
i
entries_count
i
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
rawlowpc
Dwarf_Unsigned
rawhighpc
Dwarf_Unsigned
lowpc
Dwarf_Unsigned
highpc
Dwarf_Bool
debug_addr_unavailable
FALSE
Actual
addresses
are
most
likely
what
one
wants
to
know
not
the
lengths
offsets
recorded
in
debug_rnglists
res
dwarf_get_rnglists_entry_fields_a
rnglhead
i
error
if
res
DW_DLV_OK
dwarf_dealloc_rnglists_head
rnglhead
return
res
if
code
DW_RLE_end_of_list
we
are
done
break
if
code
DW_RLE_base_addressx
code
DW_RLE_base_address
We
do
not
need
to
use
these
they
have
been
accounted
for
already
continue
if
debug_addr_unavailable
lowpc
and
highpc
are
not
real
addresses
continue
Here
do
something
with
lowpc
and
highpc
these
are
real
addresses
dwarf_dealloc_rnglists_head
rnglhead
return
DW_DLV_OK
fP
DE
in
H
dwarf_rnglists_get_rle_head
This
function
is
used
to
enable
access
to
the
specific
set
of
rnglist
entries
applying
to
a
specific
f
CWDW_AT_rangees
fP
attribute
DS
f
CWint
dwarf_rnglists_get_rle_head
Dwarf_Attribute
attr
Dwarf_Half
theform
Dwarf_Unsigned
attr_val
Dwarf_Rnglists_Head
head_out
Dwarf_Unsigned
entries_count_out
Dwarf_Unsigned
global_offset_of_rle_set
Dwarf_Error
error
fP
DE
P
Given
a
f
CWDW_AT_ranges
fP
f
CWDwarf_Attribute
fP
the
FORM
from
that
attribute
and
the
value
of
the
the
attribute
which
might
be
an
index
from
f
CWDW_FORM_rnglistx
fP
or
a
section
offset
from
f
CWDW_FORM_sec_offset
fP
the
function
determines
which
f
CWDwarf_Rnglists_Head
fP
applies
and
returns
the
pointer
on
success
meaning
it
returned
f
CWDW_DLV_OK
fP
And
on
success
it
also
returns
the
global
offset
of
a
set
of
rnglist
entries
within
that
particular
Dwarf_Rnglists_Head
not
needed
except
to
show
it
to
users
as
well
as
the
count
of
entries
in
that
set
which
is
crucial
to
iterate
through
the
rnglist
entries
applicable
P
If
not
successful
none
of
the
pointers
f
CWhead_out
fP
f
CWentries_count_out
fP
f
CWglobal_offset
fP
will
not
be
touched
by
the
function
P
If
there
is
some
problem
with
the
section
it
will
return
f
CWDW_DLV_ERROR
fP
and
return
the
error
informatio
through
f
CW
error
fP
P
There
is
currently
no
situation
in
which
it
will
return
f
CWDW_DLV_NO_ENTRY
fP
P
See
f
CWdwarf_dealloc_rnglists_head
fP
below
to
release
the
storage
allocated
by
a
successful
call
here
H
dwarf_get_rnglist_head_basics
DS
int
dwarf_get_rnglist_head_basics
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
rle_count
Dwarf_Unsigned
rle_version
Dwarf_Unsigned
rnglists_index_returned
Dwarf_Unsigned
bytes_total_in_rle
unsigned
offset_size
unsigned
address_size
unsigned
segment_selector_size
Dwarf_Unsigned
overall_offset_of_this_context
Dwarf_Unsigned
total_length_of_this_context
Dwarf_Bool
rnglists_base_present
Dwarf_Unsigned
rnglists_base
Dwarf_Bool
rnglists_base_address_present
Dwarf_Unsigned
rnglists_base_address
Dwarf_Bool
rnglists_debug_addr_base_present
Dwarf_Unsigned
rnglists_debug_addr_base
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_rnglist_head_basics
fP
allows
caller
to
print
or
display
the
fields
of
the
Dwarf_Rnglists_Head
that
might
be
of
interest
for
understanding
the
section
data
for
that
f
CWDwarf_Rnglists_Head
fP
P
It
is
not
needed
to
access
the
rangelist
data
It
currently
returns
only
f
CWDW_DLV_OK
fP
f
CW
fP
H
dwarf_get_rnglists_entry_fields_a
DS
f
CWint
dwarf_get_rnglists_entry_fields_a
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
entrynum
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Bool
debug_addr_unavailable
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
Dwarf_Error
err
fP
DE
This
is
the
function
to
access
the
rnglist
entries
for
this
f
CWDwarf_Rnglists_Head
fP
f
CWCall
this
with
fP
f
CWentrynum
fP
in
the
normal
iteration
i
i
entries_count
i
where
f
CWentries_count
fP
was
returned
by
f
CWdwarf_rnglists_get_rle_head
fP
through
a
pointer
P
On
success
f
CWDW_DLV_OK
fP
is
returned
and
the
following
fields
are
set
through
the
pointers
P
The
f
CWentrylen
fP
value
returned
is
the
length
in
bytes
of
the
single
entry
s
length
P
The
f
CWcode
fP
value
returned
is
the
type
of
entry
f
CWDW_RLE_startx_endx
fP
see
f
CWdwarf
h
fP
P
The
f
CWraw1
fP
and
f
CWraw2
fP
values
returned
are
the
actual
values
in
the
rangelist
entry
address
length
or
index
depending
For
basename
entries
both
values
are
set
to
the
single
value
in
the
entry
an
address
or
index
For
end
of
list
entries
neither
value
is
set
P
If
f
CWdebug_addr_unavailable
fP
is
returns
non
zero
then
the
f
CWcooked1
fP
and
f
CWcooked2
fP
values
are
not
set
usefully
and
should
be
ignored
The
issue
arises
because
with
dwp
dwo
object
files
the
f
CW
debug_addr
fP
section
will
be
in
the
executable
and
if
the
f
CWdwarf_set_tied_dbg
fP
function
was
not
called
to
enable
access
to
debug_addr
the
cooked
fields
cannot
be
calculated
P
The
f
CWcooked1
fP
f
CWcooked2
fP
values
returned
are
the
actual
addresses
in
the
rangelist
entry
after
any
necessary
translation
of
indexes
and
offsets
and
lengths
For
non
basename
entries
these
two
values
are
the
start
and
end
addresses
of
the
rnglist
entry
If
and
only
if
f
CWdebug_addr_unavailable
fP
returns
zero
For
basename
entries
these
two
values
are
both
the
basename
address
For
end
of
list
entries
neither
value
means
anything
P
If
the
f
CWentrynum
fP
is
out
of
range
f
CWDW_DLV_NO_ENTRY
fP
is
returned
P
At
present
f
CWDW_DLV_ERROR
fP
is
never
returned
but
callers
should
not
assume
that
will
always
be
true
H
dwarf_get_rnglists_entry_fields
DS
f
CWint
dwarf_get_rnglists_entry_fields
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
entrynum
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
Dwarf_Error
err
fP
DE
This
the
same
as
f
CWdwarf_get_rnglists_entry_fields_a
fP
except
this
is
missing
the
f
CWdebug_addr_unavailable
fP
argument
so
it
s
impossible
for
callers
to
know
that
the
cooked
values
are
not
calculated
Do
not
use
this
function
H
dwarf_dealloc_rnglists_head
DS
f
CWint
dwarf_dealloc_rnglists_head
Dwarf_Rnglists_Head
head
DE
This
frees
the
storage
allocated
by
the
f
CWdwarf_rnglists_get_rle_head
fP
call
that
created
the
f
CWDwarf_Rnglists_Head
fP
pointer
P
It
only
returns
DW_DLV_OK
H
Getting
raw
debug_rnglists
entries
This
set
of
interfaces
is
to
read
the
entire
f
CW
debug_rnglists
fP
section
without
reference
to
any
DIE
As
such
these
can
only
present
the
raw
data
from
the
file
There
is
no
way
in
these
interfaces
to
get
actual
addresses
These
might
be
of
interest
if
you
want
to
know
exactly
what
the
compiler
output
in
the
f
CW
debug_rnglists
fP
section
dwarfdump
print
raw
rnglists
try
adding
v
or
vvv
makes
these
calls
P
Here
is
an
example
using
all
the
following
calls
example_rngl
in
FG
Examplev
dwarf_rnglists
DS
f
CW
int
example_raw_rnglist
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
count
int
res
Dwarf_Unsigned
i
res
dwarf_load_rnglists
dbg
error
if
res
DW_DLV_OK
return
res
for
i
i
count
i
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_rangeentry
Dwarf_Unsigned
offset_past_last_rangeentry
res
dwarf_get_rnglist_context_basics
dbg
i
error
if
res
DW_DLV_OK
return
res
Dwarf_Unsigned
e
unsigned
colmax
unsigned
col
Dwarf_Unsigned
global_offset_of_value
for
e
offset_entry_count
e
Dwarf_Unsigned
value
int
resc
resc
dwarf_get_rnglist_offset_index_value
dbg
i
e
error
if
resc
DW_DLV_OK
return
resc
Do
something
col
if
col
colmax
col
Dwarf_Unsigned
curoffset
offset_of_first_rangeentry
Dwarf_Unsigned
endoffset
offset_past_last_rangeentry
int
rese
Dwarf_Unsigned
ct
for
curoffset
endoffset
ct
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
rese
dwarf_get_rnglist_rle
dbg
i
curoffset
endoffset
error
if
rese
DW_DLV_OK
return
rese
curoffset
entrylen
if
curoffset
endoffset
return
DW_DLV_ERROR
return
DW_DLV_OK
fP
DE
in
H
dwarf_load_rnglists
DS
f
CWint
dwarf_load_rnglists
Dwarf_Debug
dbg
Dwarf_Unsigned
rnglists_count
Dwarf_Error
error
fP
DE
On
a
successful
call
to
f
CWdwarf_load_rnglists
fP
the
function
returns
f
CWDW_DLV_OK
fP
sets
f
CW
rnglists_count
fP
if
and
only
if
f
CWrnglists_count
fP
is
non
null
to
the
number
of
distinct
section
contents
that
exist
A
small
amount
of
data
for
each
Range
Line
Table
is
recorded
in
f
CWdbg
fP
as
a
side
effect
Normally
libdwarf
will
have
already
called
this
but
if
an
application
never
requests
any
f
CW
debug_info
fP
data
the
section
might
not
be
loaded
If
the
section
is
loaded
this
returns
very
quickly
and
will
set
f
CW
rnglists_count
fP
just
as
described
in
this
paragraph
P
If
there
is
no
f
CW
debug_rnglists
fP
section
in
the
object
file
this
function
returns
f
CWDW_DLV_NO_ENTRY
fP
P
If
something
is
malformed
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
the
applicable
error
pointer
describing
the
problem
P
There
is
no
dealloc
call
Calling
f
CWdwarf_finish
fP
releases
the
modest
amount
of
memory
recorded
for
this
section
as
a
side
effect
P
H
dwarf_get_rnglist_context_basics
DS
f
CWint
dwarf_get_rnglist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_rangeentry
Dwarf_Unsigned
offset_past_last_rangeentry
Dwarf_Error
err
fP
DE
On
success
this
returns
f
CWDW_DLV_OK
fP
and
returns
values
through
the
pointer
arguments
other
than
f
CWdbg
fP
or
f
CWerror
fP
P
A
call
to
f
CWdwarf_load_rnglists
fP
that
suceeds
gets
you
the
count
of
contexts
and
f
CWdwarf_get_rnglist_context_basics
fP
for
any
i
and
i
count
gets
you
the
context
values
relevant
to
f
CW
debug_rnglists
fP
P
Any
of
the
pointer
arguments
for
returning
context
values
can
be
passed
in
as
in
which
case
they
will
be
skipped
P
You
will
want
f
CW
offset_entry_count
fP
so
you
can
call
f
CWdwarf_get_rnglist_offset_index_value
fP
usefully
P
If
the
f
CWcontext_index
fP
passed
in
is
out
of
range
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
P
At
the
present
time
f
CWDW_DLV_ERROR
fP
is
never
returned
H
dwarf_get_rnglist_offset_index_value
DS
f
CWint
dwarf_get_rnglist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
fP
DE
P
On
success
f
CWdwarf_get_rnglist_offset_index_value
fP
returns
f
CWDW_DLV_OK
fP
sets
f
CW
offset_value_out
fP
to
the
value
in
the
Range
List
Table
offset
array
and
sets
f
CW
global_offset_value_out
fP
to
the
section
offset
in
f
CW
debug_addr
fP
of
the
offset
value
P
Pass
in
f
CWcontext_index
fP
exactly
as
the
same
field
passed
to
f
CWdwarf_get_rnglist_context_basics
fP
P
Pass
in
f
CWoffset_entry_index
fP
based
on
the
return
field
f
CWoffset_entry_count
fP
from
f
CWdwarf_get_rnglist_context_basics
fP
meaning
for
that
f
CWcontext_index
fP
an
f
CWoffset_entry_index
fP
and
f
CWoffset_entry_count
fP
P
Pass
in
f
CWoffset_entry_count
fP
exactly
as
the
same
field
passed
to
f
CWdwarf_get_rnglist_context_basics
fP
P
If
one
of
the
indexes
passed
in
is
out
of
range
f
CWDW_DLV_NO_ENTRY
fP
will
be
returned
and
no
return
arguments
touched
P
If
there
is
some
corruption
of
DWARF5
data
then
f
CWDW_DLV_ERROR
fP
might
be
returned
and
f
CW
error
fP
set
to
the
error
details
H
dwarf_get_rnglist_rle
DS
f
CWint
dwarf_get_rnglist_rle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
entrylen
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Error
error
fP
DE
On
success
it
returns
a
single
f
CWDW_RLE
fP
record
see
dwarf
h
fields
P
f
CWcontextnumber
fP
is
the
number
of
the
current
rnglist
context
P
f
CWentry_offset
fP
is
the
section
offset
section
global
offset
of
the
next
record
P
f
CWendoffset
fP
is
one
past
the
last
entry
in
this
rle
context
P
f
CW
entrylen
fP
returns
the
length
in
the
debug_rnglists
section
of
the
particular
record
returned
It
s
used
to
increment
to
the
next
record
within
this
rnglist
context
P
f
CW
entrykind
fP
returns
is
the
f
CWDW_RLE
fP
number
P
Some
record
kinds
have
or
operands
most
have
two
operands
the
records
describing
ranges
P
If
the
contextnumber
is
out
of
range
it
will
return
f
CWDW_DLV_NO_ENTRY
fP
P
If
the
f
CW
debug_rnglists
fP
section
is
malformed
or
the
f
CWentry_offset
fP
is
incorrect
it
may
return
f
CWDW_DLV_ERROR
fP
H
Ranges
Operations
DWARF3
debug_ranges
These
functions
provide
information
about
the
address
ranges
indicated
by
a
f
CWDW_AT_ranges
fP
attribute
the
ranges
are
recorded
in
the
f
CW
debug_ranges
fP
section
of
a
DIE
These
functions
apply
to
DWARF3
and
DWARF4
Each
call
of
f
CWdwarf_get_ranges_a
fP
or
f
CWdwarf_get_ranges
fP
returns
a
an
array
of
Dwarf_Ranges
structs
each
of
which
represents
a
single
ranges
entry
The
struct
is
defined
in
f
CWlibdwarf
h
fP
P
New
in
DWARF3
for
DWARF3
and
DWARF4
the
section
contains
just
ranges
The
ranges
are
referenced
by
f
CWDW_AT_ranges
fP
attributes
in
various
DIEs
P
For
DWARF5
the
section
requires
that
each
group
of
ranges
has
a
header
and
the
compilation
unit
may
have
a
f
CWDW_AT_ranges_base
fP
attribute
that
must
be
added
to
the
f
CWDW_AT_ranges
fP
attribute
value
to
get
the
true
ranges
offset
P
A
compiler
generating
f
CWDW_AT_ranges_base
fP
will
add
a
relocation
for
that
attribute
value
but
will
not
have
to
make
the
f
CWDW_AT_ranges
fP
attributes
relocatable
and
will
thus
save
space
in
the
object
ie
o
file
and
link
time
H
dwarf_get_ranges_section_name
DS
f
CWint
dwarf_get_ranges_section_name
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
fP
DE
f
CW
dwarf_get_ranges_section_name
fP
retrieves
the
object
file
section
name
of
the
applicable
ranges
section
This
is
useful
for
applications
wanting
to
print
the
name
but
of
course
the
object
section
name
is
not
really
a
part
of
the
DWARF
information
Most
applications
will
probably
not
call
this
function
It
can
be
called
at
any
time
after
the
Dwarf_Debug
initialization
is
done
P
If
the
function
succeeds
f
CW
sec_name
fP
is
set
to
a
pointer
to
a
string
with
the
object
section
name
and
the
function
returns
f
CWDW_DLV_OK
fP
Do
not
free
the
string
whose
pointer
is
returned
For
non
Elf
objects
it
is
possible
the
string
pointer
returned
will
be
NULL
or
will
point
to
an
empty
string
It
is
up
to
the
calling
application
to
recognize
this
possibility
and
deal
with
it
appropriately
P
If
the
section
does
not
exist
the
function
returns
DW_DLV_NO_ENTRY
P
If
there
is
an
internal
error
detected
the
function
returns
f
CWDW_DLV_ERROR
fP
and
sets
the
f
CW
error
fP
pointer
H
dwarf_get_ranges_b
DS
f
CWint
dwarf_get_ranges_b
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Die
die
Dwarf_Off
finaloffset
Dwarf_Ranges
ranges
Dwarf_Signed
returned_ranges_count
Dwarf_Unsigned
returned_byte_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_ranges_b
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_ranges_count
fP
to
the
count
of
the
number
of
address
ranges
in
the
group
of
ranges
in
the
debug_ranges
section
where
the
f
CWDW_AT_ranges
fP
attribute
gives
offset
f
CWoffset
fP
This
function
is
new
as
of
September
P
DWARF4
GNU
split
dwarf
extension
ONLY
With
a
dwp
object
and
the
tied
executable
a
out
involved
the
actual
debug_ranges
offset
is
determined
from
the
DW_AT_GNU_ranges_base
from
the
tied
file
and
the
offset
from
f
CWDW_AT_ranges
fP
in
the
dwp
object
and
returned
through
the
f
CWfinaloffset
fP
pointer
If
f
CWfinaloffset
fP
pointer
is
null
the
function
ignores
it
P
If
there
is
no
use
of
the
GNU
split
dwarf
extension
to
DWARF4
the
f
CWfinaloffset
fP
value
returned
is
identical
to
the
f
CWoffset
fP
passed
in
If
the
pointer
is
null
it
is
ignored
by
the
function
P
This
function
is
normally
used
when
one
has
a
DIE
with
the
f
CWDW_AT_ranges
fP
attribute
whose
value
is
the
offset
needed
The
ranges
thus
apply
to
the
DIE
involved
If
no
DIE
is
available
or
possible
pass
in
NULL
as
the
DIE
pointer
P
See
also
f
CWdwarf_get_aranges
fP
P
The
f
CWoffset
fP
argument
should
be
the
value
of
a
f
CWDW_AT_ranges
fP
attribute
of
a
Debugging
Information
Entry
P
The
f
CWdie
fP
argument
should
be
the
value
of
a
f
CWDwarf_Die
fP
pointer
of
a
f
CWDwarf_Die
fP
with
the
attribute
containing
this
range
set
offset
Because
each
compilation
unit
has
its
own
address_size
field
this
argument
is
necessary
to
to
correctly
read
ranges
Most
executables
have
the
same
address_size
in
every
compilation
unit
but
some
ABIs
allow
multiple
address
sized
in
an
executable
If
a
NULL
pointer
is
passed
in
libdwarf
assumes
a
single
address_size
is
appropriate
for
all
ranges
records
and
that
TIED
files
are
not
involved
or
available
P
On
success
The
call
sets
f
CW
ranges
fP
to
point
to
a
block
of
f
CWDwarf_Ranges
fP
structs
one
for
each
address
range
If
the
f
CW
returned_byte_count
fP
pointer
is
passed
as
non
NULL
the
number
of
bytes
that
the
returned
ranges
were
taken
from
is
returned
through
the
pointer
for
example
if
the
returned_ranges_count
is
and
the
pointer
size
is
then
returned_byte_count
will
be
If
the
f
CW
returned_byte_count
fP
pointer
is
passed
as
NULL
the
parameter
is
ignored
The
f
CW
returned_byte_count
fP
is
only
of
use
to
certain
dumper
applications
most
applications
will
not
use
it
The
f
CWfinaloffset
fP
pointer
is
only
of
use
to
certain
dumper
applications
and
if
null
is
passed
the
function
ignores
the
argument
P
On
error
the
function
returns
f
CWDW_DLV_ERROR
fP
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
no
f
CW
debug_ranges
fP
section
or
if
f
CWoffset
fP
is
past
the
end
of
the
f
CW
debug_ranges
fP
section
in
FG
Examplev
dwarf_get_ranges_b
DS
f
CW
void
examplev
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Die
die
Dwarf_Signed
count
Dwarf_Ranges
ranges
Dwarf_Unsigned
bytes
Dwarf_Error
error
Dwarf_Off
finaloffset
int
res
res
dwarf_get_ranges_b
dbg
offset
die
if
res
DW_DLV_OK
Dwarf_Signed
i
for
i
i
count
i
Dwarf_Ranges
cur
ranges
i
Use
cur
functionusingrange
cur
dwarf_ranges_dealloc
dbg
ranges
count
fP
DE
in
H
dwarf_ranges_dealloc
DS
f
CWint
dwarf_ranges_dealloc
Dwarf_Debug
dbg
Dwarf_Ranges
ranges
Dwarf_Signed
range_count
fP
DE
The
function
f
CWdwarf_ranges_dealloc
fP
takes
as
input
a
pointer
to
a
block
of
f
CWDwarf_Ranges
fP
array
and
the
number
of
structures
in
the
block
It
frees
all
the
data
in
the
array
of
structures
H
Gdb
Index
operations
These
functions
get
access
to
the
fast
lookup
tables
defined
by
gdb
and
gcc
and
stored
in
the
f
CW
gdb_index
fP
section
The
section
is
of
sufficient
complexity
that
a
number
of
function
interfaces
are
needed
For
additional
information
see
https
sourceware
org
gdb
onlinedocs
gdb
Index
Section
Format
html
Index
Section
Format
We
split
the
url
to
two
pieces
so
it
can
fit
on
the
printed
page
join
the
pieces
to
make
a
usable
url
H
dwarf_gdbindex_header
DS
int
dwarf_gdbindex_header
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
version
Dwarf_Unsigned
cu_list_offset
Dwarf_Unsigned
types_cu_list_offset
Dwarf_Unsigned
address_area_offset
Dwarf_Unsigned
symbol_table_offset
Dwarf_Unsigned
constant_pool_offset
Dwarf_Unsigned
section_size
Dwarf_Unsigned
unused_reserved
const
char
section_name
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_header
fP
takes
as
input
a
pointer
to
a
Dwarf_Debug
structure
and
returns
fields
through
various
pointers
P
If
the
function
returns
DW_DLV_NO_ENTRY
there
is
no
gdb_index
section
and
none
of
the
return
pointer
argument
values
are
set
P
If
the
function
returns
DW_DLV_ERROR
f
CWerror
fP
is
set
to
indicate
the
specific
error
but
no
other
return
pointer
arguments
are
touched
P
If
successful
the
function
returns
DW_DLV_OK
and
other
values
are
set
The
other
values
are
set
as
follows
P
The
field
f
CW
gdbindexptr
fP
is
set
to
an
opaque
pointer
to
a
libdwarf_internal
structure
used
as
an
argument
to
other
gdbindex
functions
below
P
The
remaining
fields
are
set
to
values
that
are
mostly
of
interest
to
a
pretty
printer
application
See
the
detailed
layout
specification
for
specifics
The
values
returned
are
recorded
in
the
Dwarf_Gdbindex
opaque
structure
for
the
other
gdbindex
functions
documented
below
P
The
field
f
CW
version
fP
is
set
to
the
version
of
the
gdb
index
header
P
The
field
f
CW
cu_list_offset
fP
is
set
to
the
offset
in
the
gdb_index
section
of
the
cu
list
P
The
field
f
CW
types_cu_list_offset
fP
is
set
to
the
offset
in
the
gdb_index
section
of
the
types
list
P
The
field
f
CW
address_area_offset
fP
is
set
to
the
offset
in
the
gdb_index
section
of
the
address
area
P
The
field
f
CW
symbol_table_offset
fP
is
set
to
the
offset
in
the
gdb_index
section
of
the
symbol
table
P
The
field
f
CW
constant_pool_offset
fP
is
set
to
the
offset
in
the
gdb_index
section
of
the
constant
pool
P
The
field
f
CW
section_size
fP
is
set
to
the
length
of
the
gdb_index
section
P
The
field
f
CW
unused_reserved
fP
is
set
to
zero
P
The
field
f
CW
section_name
fP
is
set
to
the
Elf
object
file
section
name
gdb_index
If
a
non
Elf
object
file
has
such
a
section
the
value
set
might
be
NULL
or
might
point
to
an
empty
string
NUL
terminated
so
code
to
account
for
NULL
or
empty
P
The
field
f
CW
error
fP
is
not
set
P
Here
we
show
a
use
of
the
set
of
cu_list
functions
using
all
the
functions
in
one
example
makes
it
rather
too
long
in
FG
Examplew
dwarf_get_gdbindex_header
DS
f
CW
void
examplew
Dwarf_Debug
dbg
Dwarf_Gdbindex
gindexptr
Dwarf_Unsigned
version
Dwarf_Unsigned
cu_list_offset
Dwarf_Unsigned
types_cu_list_offset
Dwarf_Unsigned
address_area_offset
Dwarf_Unsigned
symbol_table_offset
Dwarf_Unsigned
constant_pool_offset
Dwarf_Unsigned
section_size
Dwarf_Unsigned
reserved
Dwarf_Error
error
const
char
section_name
int
res
res
dwarf_gdbindex_header
dbg
if
res
DW_DLV_NO_ENTRY
return
else
if
res
DW_DLV_ERROR
return
do
something
with
the
data
Dwarf_Unsigned
length
Dwarf_Unsigned
typeslength
Dwarf_Unsigned
i
res
dwarf_gdbindex_culist_array
gindexptr
Example
actions
if
res
DW_DLV_OK
for
i
i
length
i
Dwarf_Unsigned
cuoffset
res
dwarf_gdbindex_culist_entry
gindexptr
i
if
res
DW_DLV_OK
Do
something
with
cuoffset
culength
res
dwarf_gdbindex_types_culist_array
gindexptr
if
res
DW_DLV_OK
for
i
i
typeslength
i
Dwarf_Unsigned
cuoffset
Dwarf_Unsigned
tuoffset
Dwarf_Unsigned
culength
Dwarf_Unsigned
type_signature
res
dwarf_gdbindex_types_culist_entry
gindexptr
i
if
res
DW_DLV_OK
Do
something
with
cuoffset
etc
dwarf_gdbindex_free
gindexptr
fP
DE
in
H
dwarf_gdbindex_culist_array
DS
int
dwarf_gdbindex_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_culist_array
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
P
While
currently
only
DW_DLV_OK
is
returned
one
should
test
for
DW_DLV_NO_ENTRY
and
DW_DLV_ERROR
and
do
something
sensible
if
either
is
returned
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
number
of
entries
in
the
culist
through
the
f
CWlist_length
fP
pointer
H
dwarf_gdbindex_culist_entry
DS
int
dwarf_gdbindex_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
cu_offset
Dwarf_Unsigned
cu_length
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_culist_entry
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
index
into
the
culist
array
Valid
indexes
are
through
f
CWlist_length
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
vale
returned
through
the
f
CWerror
fP
pointer
P
On
success
it
returns
DW_DLV_OK
and
returns
the
f
CWcu_offset
fP
the
section
global
offset
of
the
CU
in
debug_info
and
f
CWcu_length
fP
the
length
of
the
CU
in
debug_info
values
through
the
pointers
H
dwarf_gdbindex_types_culist_array
DS
int
dwarf_gdbindex_types_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
types_list_length
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_types_culist_array
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
P
While
currently
only
DW_DLV_OK
is
returned
one
should
test
for
DW_DLV_NO_ENTRY
and
DW_DLV_ERROR
and
do
something
sensible
if
either
is
returned
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
number
of
entries
in
the
types
culist
through
the
f
CWlist_length
fP
P
H
dwarf_gdbindex_types_culist_entry
DS
int
dwarf_gdbindex_types_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
cu_offset
Dwarf_Unsigned
tu_offset
Dwarf_Unsigned
type_signature
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_types_culist_entry
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
index
into
the
types
culist
array
Valid
indexes
are
through
f
CWtypes_list_length
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
On
success
it
returns
DW_DLV_OK
and
returns
the
f
CWtu_offset
fP
the
section
global
offset
of
the
CU
in
debug_types
and
f
CWtu_length
fP
the
length
of
the
CU
in
debug_types
values
through
the
pointers
It
also
returns
the
type
signature
a
value
through
the
f
CWtype_signature
fP
pointer
H
dwarf_gdbindex_addressarea
DS
int
dwarf_gdbindex_addressarea
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
addressarea_list_length
Dwarf_Error
error
DE
The
function
f
CWdwarf_addressarea
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
returns
the
length
of
the
address
area
through
f
CWaddressarea_list_length
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
number
of
entries
in
the
address
area
through
the
f
CWaddressarea_list_length
fP
pointer
H
dwarf_gdbindex_addressarea_entry
DS
int
dwarf_gdbindex_addressarea_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
low_address
Dwarf_Unsigned
high_address
Dwarf_Unsigned
cu_index
Dwarf_Error
error
DE
The
function
f
CWdwarf_addressarea_entry
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
index
into
the
address
area
valid
indexes
are
zero
through
f
CWaddressarea_list_length
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
The
f
CWlow_address
fP
f
CWhigh_address
fP
and
f
CWcu_index
fP
through
the
pointers
P
Given
an
open
Dwarf_Gdbindex
one
uses
the
function
as
follows
P
DS
FG
Examplewgdbindex
dwarf_gdbindex_addressarea
f
CW
void
examplewgdbindex
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
list_len
Dwarf_Unsigned
i
int
res
Dwarf_Error
err
res
dwarf_gdbindex_addressarea
gdbindex
if
res
DW_DLV_OK
Something
wrong
ignore
the
addressarea
Iterate
through
the
address
area
for
i
i
list_len
i
Dwarf_Unsigned
lowpc
Dwarf_Unsigned
highpc
Dwarf_Unsigned
cu_index
res
dwarf_gdbindex_addressarea_entry
gdbindex
i
if
res
DW_DLV_OK
Something
wrong
ignore
the
addressarea
return
We
have
a
valid
address
area
entry
do
something
with
it
fP
DE
H
dwarf_gdbindex_symboltable_array
DS
int
dwarf_gdbindex_symboltable_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
symtab_list_length
Dwarf_Error
error
DE
One
can
look
at
the
symboltable
as
a
two
level
table
with
The
outer
level
indexes
through
symbol
names
and
the
inner
level
indexes
through
all
the
compilation
units
that
define
that
symbol
each
symbol
having
a
different
number
of
compilation
units
this
is
not
a
simple
rectangular
table
P
The
function
f
CWdwarf_gdbindex_symboltable_array
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
The
f
CWsymtab_list_length
fP
through
the
pointer
P
Given
a
valid
Dwarf_Gdbindex
pointer
one
can
access
the
entire
symbol
table
as
follows
using
return
here
to
indicate
we
are
giving
up
due
to
a
problem
while
keeping
the
example
code
fairly
short
DS
FG
Examplex
dwarf_gdbindex_symboltable_array
f
CW
void
examplex
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
symtab_list_length
Dwarf_Unsigned
i
Dwarf_Error
err
int
res
res
dwarf_gdbindex_symboltable_array
gdbindex
if
res
DW_DLV_OK
return
for
i
i
symtab_list_length
i
Dwarf_Unsigned
symnameoffset
Dwarf_Unsigned
cuvecoffset
Dwarf_Unsigned
cuvec_len
Dwarf_Unsigned
ii
const
char
name
res
dwarf_gdbindex_symboltable_entry
gdbindex
i
if
res
DW_DLV_OK
return
res
dwarf_gdbindex_string_by_offset
gdbindex
symnameoffset
if
res
DW_DLV_OK
return
res
dwarf_gdbindex_cuvector_length
gdbindex
cuvecoffset
if
res
DW_DLV_OK
return
for
ii
ii
cuvec_len
ii
Dwarf_Unsigned
attributes
Dwarf_Unsigned
cu_index
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
symbol_kind
Dwarf_Unsigned
is_static
res
dwarf_gdbindex_cuvector_inner_attributes
gdbindex
cuvecoffset
ii
if
res
DW_DLV_OK
return
attributes
is
a
value
with
various
internal
fields
so
we
expand
the
fields
res
dwarf_gdbindex_cuvector_instance_expand_value
gdbindex
attributes
if
res
DW_DLV_OK
return
Do
something
with
the
attributes
fP
DE
H
dwarf_gdbindex_symboltable_entry
DS
int
dwarf_gdbindex_symboltable_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
string_offset
Dwarf_Unsigned
cu_vector_offset
Dwarf_Error
error
DE
P
The
function
f
CWdwarf_gdbindex_symboltable_entry
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
entry
index
valid
index
values
being
zero
through
f
CWsymtab_list_length
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
The
f
CWstring_offset
fP
and
f
CWcu_vector_offset
fP
through
the
pointers
See
the
example
above
which
uses
this
function
H
dwarf_gdbindex_cuvector_length
DS
int
dwarf_gdbindex_cuvector_length
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innercount
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_cuvector_length
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
a
cu
vector
offset
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
f
CWinner_count
fP
through
the
pointer
The
f
CWinner_count
fP
is
the
number
of
compilation
unit
vectors
for
this
array
of
vectors
See
the
example
above
which
uses
this
function
H
dwarf_gdbindex_cuvector_inner_attributes
DS
int
dwarf_gdbindex_cuvector_inner_attributes
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innerindex
The
attr_value
is
a
field
of
bits
For
expanded
version
use
dwarf_gdbindex_cuvector_expand_value
Dwarf_Unsigned
attr_value
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_cuvector_inner_attributes
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
a
cu
vector
offset
and
a
f
CWinner_index
fP
valid
f
CWinner_index
fP
values
are
zero
through
f
CWinner_count
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
The
f
CWattr_value
fP
through
the
pointer
The
f
CWattr_value
fP
is
actually
composed
of
several
fields
see
the
next
function
which
expands
the
value
See
the
example
above
which
uses
this
function
H
dwarf_gdbindex_cuvector_instance_expand_value
DS
int
dwarf_gdbindex_cuvector_instance_expand_value
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
attr_value
Dwarf_Unsigned
cu_index
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
symbol_kind
Dwarf_Unsigned
is_static
Dwarf_Error
error
DE
The
function
f
CWdwarf_gdbindex_cuvector_instance_expand_value
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
an
f
CWattr_value
fP
P
If
it
returns
DW_DLV_NO_ENTRY
there
is
a
coding
error
If
it
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
following
values
through
the
pointers
The
f
CWcu_index
fP
field
is
the
index
in
the
applicable
CU
list
of
a
compilation
unit
For
the
purpose
of
indexing
the
CU
list
and
the
types
CU
list
form
a
single
array
so
the
f
CWcu_index
fP
can
be
indicating
either
list
The
f
CWsymbol_kind
fP
field
is
a
small
integer
with
the
symbol
kind
zero
is
reserved
one
is
a
type
is
a
variable
or
enum
value
etc
The
f
CWreserved1
fP
field
should
have
the
value
zero
and
is
the
value
of
a
bit
field
defined
as
reserved
for
future
use
The
f
CWis_static
fP
field
is
zero
if
the
CU
indexed
is
global
and
one
if
the
CU
indexed
is
static
See
the
example
above
which
uses
this
function
H
dwarf_gdbindex_string_by_offset
DS
f
CWint
dwarf_gdbindex_string_by_offset
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
stringoffset
const
char
string_ptr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_gdbindex_string_by_offset
fP
takes
as
input
valid
Dwarf_Gdbindex
pointer
and
a
f
CWstringoffset
fP
If
it
returns
f
CWDW_DLV_NO_ENTRY
fP
there
is
a
coding
error
If
it
returns
f
CWDW_DLV_ERROR
fP
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
it
succeeds
the
call
returns
a
pointer
to
a
string
from
the
constant
pool
through
the
f
CWstring_ptr
fP
The
string
pointed
to
must
never
be
free
d
P
See
the
example
above
which
uses
this
function
H
GNU
linking
gnu_debuglink
note
gnu
build
id
operations
This
section
deals
with
the
way
GNU
tools
allow
creation
of
DWARF
separated
from
the
executable
file
involved
See
https
sourceware
org
gdb
onlinedocs
gdb
Separate
Debug
Files
html
for
more
information
The
function
here
is
new
in
September
revised
in
October
An
example
of
use
follows
the
description
of
arguments
P
These
functions
are
concerned
with
finding
DWARF
data
in
a
companion
file
There
is
no
Split
Dwarf
involved
this
is
a
different
way
of
splitting
DWARF
out
of
an
executable
or
shared
object
It
never
applies
to
simple
o
object
files
only
to
executable
objects
or
shared
libraries
H
dwarf_gnu_debuglink
DS
f
CWint
dwarf_gnu_debuglink
Dwarf_Debug
dbg
char
debuglink_path_returned
unsigned
char
crc_returned
char
debuglink_fullpath_returned
unsigned
buildid_type
returned
char
builid_returned
unsigned
builid_length_returned
char
paths_returned
unsigned
paths_count_returned
Dwarf_Error
error
fP
DE
This
returns
f
CWDW_DLV_NO_ENTRY
fP
if
there
is
neither
a
f
CW
gnu_debuglink
fP
object
file
section
nor
a
f
CW
note
gnu
build
id
fP
section
in
the
object
file
P
If
there
is
an
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CW
error
fP
to
point
to
the
error
value
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
the
fields
through
the
pointers
as
described
below
Two
fields
must
be
free
d
to
avoid
a
memory
leak
None
of
the
other
fields
should
be
freed
P
If
there
is
a
f
CW
gnu_debuglink
fP
section
the
first
four
fields
will
be
set
P
f
CW
debuglink_path_returned
fP
points
to
the
null
terminated
string
in
the
section
Do
not
free
this
The
bytes
are
in
the
object
itself
and
the
pointer
is
invalid
once
dwarf_finish
is
run
on
the
dbg
P
f
CW
crc_returned
fP
points
to
a
byte
CRC
value
The
bytes
pointed
to
are
not
a
string
P
f
CW
debuglink_fullpath_returned
fP
points
to
a
full
pathname
derived
from
the
f
CW
debuglink_fullpath_returned
fP
string
And
then
f
CW
debuglink_fullpath_strlen
fP
is
set
to
the
length
of
f
CW
debuglink_fullpath_returned
fP
just
as
f
CWstrlen
fP
would
count
the
length
Callers
must
free
f
CW
debuglink_fullpath_returned
fP
P
If
there
is
a
f
CW
note
gnu
build
id
fP
section
the
buildid
fields
will
be
set
through
the
pointers
P
f
CW
buildid_type_returned
fP
will
be
set
to
the
value
P
f
CW
buildid_owner_name_returned
fP
will
be
set
to
point
to
the
null
terminated
string
which
will
be
GNU
Do
not
free
this
The
bytes
are
in
the
object
itself
and
the
pointer
is
invalid
once
dwarf_finish
is
run
on
the
dbg
P
f
CW
buildid_returned
fP
will
be
set
to
point
to
the
group
of
bytes
of
length
f
CW
buildid_length_returned
fP
This
is
not
a
string
and
is
not
null
terminated
It
is
normally
a
byte
field
to
be
used
in
its
ascii
hex
form
Do
not
free
this
The
bytes
are
in
the
object
itself
and
the
pointer
is
invalid
once
dwarf_finish
is
run
on
the
dbg
P
If
f
CW
paths_returned
fP
is
passed
as
NULL
then
no
paths
calculation
will
be
made
and
f
CW
paths_count_returned
fP
is
not
referenced
by
libdwarf
P
If
f
CW
paths_returned
fP
is
passed
in
non
NULL
then
f
CW
paths_returned
fP
and
f
CW
paths_count_returned
fP
provide
an
array
of
pointers
to
strings
with
the
actual
strings
following
the
array
and
the
count
of
the
pointers
in
the
array
When
the
strings
are
no
longer
needed
free
f
CW
paths_returned
fP
The
number
of
paths
returned
will
depend
on
which
of
the
two
sections
exist
and
on
how
many
global
paths
have
been
set
by
f
CWdwarf_add_debuglink_global_path
fP
and
defined
by
the
rules
described
in
the
web
page
mentioned
above
The
default
global
path
is
usr
lib
debug
and
that
is
set
by
libdwarf
as
f
CWpaths_returned
fP
P
An
example
of
calling
this
function
follows
DS
FG
Example
debuglink
f
CWvoid
exampledebuglink
Dwarf_Debug
dbg
int
res
char
debuglink_path
unsigned
char
crc
char
debuglink_fullpath
unsigned
debuglink_fullpath_strlen
unsigned
buildid_type
char
buildidowner_name
unsigned
char
buildid_itself
unsigned
buildid_length
char
paths
unsigned
paths_count
Dwarf_Error
error
unsigned
i
This
is
just
an
example
if
one
knows
of
another
place
full
DWARF
objects
may
be
usr
lib
debug
is
automatically
set
res
dwarf_add_debuglink_global_path
dbg
some
path
debug
if
res
DW_DLV_OK
Something
is
wrong
but
we
ll
ignore
that
res
dwarf_gnu_debuglink
dbg
if
res
DW_DLV_ERROR
Do
something
with
the
error
return
if
res
DW_DLV_NO_ENTRY
No
such
sections
as
note
gnu
build
id
or
gnu_debuglink
return
if
debuglink_fullpath_strlen
printf
debuglink
path
s
n
debuglink_path
printf
crc
length
u
crc
for
i
i
i
printf
crc
i
printf
n
printf
debuglink
fullpath
s
n
debuglink_fullpath
if
buildid_length
printf
buildid
type
u
n
buildid_type
printf
Buildid
owner
s
n
buildidowner_name
printf
buildid
byte
count
u
n
buildid_length
printf
buildid_length
should
be
for
i
i
buildid_length
i
printf
buildid_itself
i
printf
n
printf
Possible
paths
count
u
n
paths_count
for
i
paths_count
i
printf
s
n
i
paths
i
free
debuglink_fullpath
free
paths
return
fP
DE
H
dwarf_add_debuglink_global_path
DS
f
CWint
dwarf_add_debuglink_global_path
Dwarf_Debug
dbg
const
char
path
Dwarf_Error
error
fP
DE
This
is
unlikely
to
return
f
CWDW_DLV_ERROR
fP
unless
one
passes
in
a
NULL
instead
of
an
open
f
CWDwarf_Debug
fP
It
cannot
return
f
CWDW_DLV_NO_ENTRY
fP
P
On
success
it
returns
f
CWDW_DLV_OK
fP
after
adding
the
path
to
the
global
list
recorded
in
the
f
CWDwarf_Debug
fP
H
dwarf_crc32
DS
f
CWint
dwarf_crc32
Dwarf_Debug
dbg
unsigned
char
crc_buf
Dwarf_Error
error
fP
DE
The
caller
must
pass
the
address
of
a
byte
array
of
unsigned
char
in
f
CWcrc_buf
fP
And
the
Dwarf_Debug
must
have
been
opened
with
f
CWdwarf_init_path
fP
to
be
useful
If
the
executable
is
named
f
CWexecutable
fP
the
file
containing
most
of
the
f
CWDWARF
fP
data
would
often
be
f
CWexecutable
debug
fP
This
is
normally
called
from
libdwarf
code
on
opening
f
CWexecutable
fP
and
f
CWlibdwarf
fP
may
call
this
function
on
f
CWexecutable
debug
fP
Library
users
could
would
likely
never
call
it
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
the
bytes
pointed
to
by
f
CWcrc_buf
fP
to
the
calculated
CRC
value
P
If
it
returns
f
CWDW_DLV_NO_ENTRY
fP
or
f
CWDW_DLV_ERROR
fP
somethine
went
wrong
and
f
CWcrc_buf
fP
is
not
touched
P
The
function
was
added
October
H
dwarf_basic_crc32
DS
f
CWunsigned
int
dwarf_crc32
const
unsigned
char
buf
int
len
unsigned
int
init
fP
DE
This
computes
the
crc
on
f
CWbuf
fP
of
length
f
CWlen
fP
with
initial
value
f
CWinit
fP
See
libdwarf
source
for
the
details
of
calling
this
It
is
not
likely
useful
for
library
uses
to
call
this
directly
P
The
function
was
added
October
H
DWARF5
debug_sup
section
access
The
debug_sup
section
is
new
in
DWARF5
and
this
function
returns
all
the
data
in
that
section
The
section
enables
splitting
off
some
DWARF5
information
to
a
separate
file
enabling
a
debugger
to
find
the
file
and
ensuring
the
file
found
actually
matches
See
the
DWARF5
standard
H
dwarf_get_debug_sup
DS
f
CWint
dwarf_get_debug_sup
Dwarf_Debug
dbg
Dwarf_Half
version
Dwarf_Small
is_supplementary
char
filename
Dwarf_Unsigned
checksum_len
Dwarf_Small
checksum
Dwarf_Error
error
fP
DE
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
values
through
the
pointer
fields
other
than
f
CWerror
fP
If
any
of
the
pointer
fields
are
NULL
those
pointers
are
ignored
There
is
nothing
resulting
from
this
call
to
free
or
dealloc
P
The
pointer
values
are
as
follows
P
f
CWversion
fP
is
defined
to
be
and
any
other
value
is
an
error
libdwarf
does
not
indicate
an
error
P
f
CWis_supplementary
fP
is
a
flag
and
only
or
should
be
present
and
any
other
value
is
an
error
though
libdwarf
does
not
indicate
an
error
P
f
CWfilename
fP
is
a
null
terminated
string
P
f
CWchecksum_len
fP
is
the
length
in
bytes
of
the
data
f
CWchecksum
fP
points
to
P
If
there
is
no
debug_sup
section
or
if
that
is
empty
f
CWDW_DLV_NO_ENTRY
fP
is
returned
P
On
error
for
example
if
a
field
runs
off
the
end
of
the
section
due
to
data
corruption
f
CWDW_DLV_ERROR
fP
is
returned
and
f
CW
error
fP
returns
the
error
information
as
is
standard
in
libdwarf
H
Debug
Fission
debug_tu_index
debug_cu_index
operations
We
name
things
xu
as
these
sections
have
the
same
format
so
we
let
x
stand
for
either
section
The
DWARF5
standard
refers
to
Split
Dwarf
while
libdwarf
tends
to
refer
to
this
as
Fission
P
These
functions
get
access
to
the
index
functions
needed
to
access
and
print
the
contents
of
an
object
file
which
is
an
aggregate
of
dwo
objects
These
sections
are
implemented
in
gcc
gdb
and
are
DWARF5
The
idea
is
that
much
debug
information
can
be
separated
off
into
individual
dwo
Elf
objects
and
then
aggregated
simply
into
a
single
dwp
object
so
the
executable
need
not
have
the
complete
debug
information
in
it
at
runtime
yet
allow
good
debugging
P
For
additional
information
see
https
gcc
gnu
org
wiki
DebugFissionDWP
https
gcc
gnu
org
wiki
DebugFission
and
http
www
bayarea
net
dwarf
Accelerated
png
and
as
of
February
the
DWARF5
standard
P
There
are
FORM
access
functions
related
to
Debug
Fission
Split
Dwarf
See
f
CWdwarf_formaddr
fP
and
f
CWdwarf_get_debug_addr_index
fP
and
f
CWdwarf_get_debug_str_index
fP
P
The
FORM
with
the
hash
value
for
a
reference
to
a
type
unit
is
f
CWDW_FORM_ref_sig8
fP
P
In
a
compilation
unit
of
Debug
Fission
object
or
a
dwp
Package
FIle
f
CWDW_AT_dwo_id
fP
the
hash
is
expected
to
be
f
CWDW_FORM_data8
fP
P
The
f
CWDWARF5
fP
standard
defines
the
hash
as
an
byte
value
which
we
could
use
f
CWDwarf_Unsigned
fP
Instead
and
mostly
for
type
safety
we
define
the
value
as
a
structure
whose
type
name
is
f
CWDwarf_Sig8
fP
P
To
look
up
a
name
in
the
hash
to
find
which
CU
s
it
exists
in
use
f
CWdwarf_get_debugfission_for_key
fP
defined
below
P
The
second
group
of
interfaces
here
beginning
with
f
CWdwarf_get_xu_index_header
fP
are
useful
if
one
wants
to
print
a
debug_tu_index
or
debug_cu_index
section
P
To
access
DIE
macro
etc
information
the
support
is
built
into
DIE
Macro
etc
operations
so
applications
usually
won
t
need
to
use
these
operations
at
all
H
Dwarf_Debug_Fission_Per_CU
DS
define
DW_FISSION_SECT_COUNT
struct
Dwarf_Debug_Fission_Per_CU_s
Do
not
free
the
string
It
contains
cu
or
tu
If
this
is
not
set
ie
not
a
CU
TU
in
DWP
Package
File
then
pcu_type
will
be
NULL
const
char
pcu_type
pcu_index
is
the
index
range
to
N
into
the
tu
cu
table
of
offsets
and
the
table
of
sizes
to
N
as
the
zero
index
is
reserved
for
special
purposes
Not
a
value
one
actually
needs
Dwarf_Unsigned
pcu_index
Dwarf_Sig8
pcu_hash
byte
has
offset
and
size
are
DW_SECT_
indexes
and
the
values
are
the
offset
and
size
of
the
respective
section
contribution
of
a
single
dwo
object
When
pcu_size
n
is
zero
the
corresponding
section
is
not
present
Dwarf_Unsigned
pcu_offset
DW_FISSION_SECT_COUNT
Dwarf_Unsigned
pcu_size
DW_FISSION_SECT_COUNT
Dwarf_Unsigned
unused1
Dwarf_Unsigned
unused2
DE
P
The
structure
is
used
to
return
data
to
callers
with
the
data
from
either
debug_tu_index
or
debug_cu_index
that
is
applicable
to
a
single
compilation
unit
or
type
unit
P
Callers
to
the
applicable
functions
see
below
should
allocate
the
structure
and
zero
all
the
bytes
in
it
The
structure
has
a
few
fields
that
are
presently
unused
These
are
reserved
for
future
use
since
it
is
impossible
to
alter
the
structure
without
breaking
binary
compatibility
H
dwarf_die_from_hash_signature
DS
int
dwarf_die_from_hash_signature
Dwarf_Debug
dbg
Dwarf_Sig8
hash_sig
const
char
sig_type
Dwarf_Die
returned_die
Dwarf_Error
error
DE
The
function
f
CWdwarf_die_from_hash_signature
fP
is
the
most
direct
way
to
go
from
the
hash
data
from
a
f
CWDW_FORM_ref_sig8
fP
or
a
f
CWDW_AT_dwo_id
fP
form
f
CWDW_FORM_data8
fP
to
a
DIE
from
a
dwp
package
file
or
a
dwo
object
file
dwo
access
not
supported
yet
P
The
caller
passes
in
f
CWdbg
fP
which
should
be
f
CWDwarf_Debug
fP
open
initialized
on
a
dwp
package
file
or
a
dwo
object
file
P
The
caller
also
passes
in
f
CWhash_sig
fP
a
pointer
to
the
hash
signature
for
which
the
caller
wishes
to
find
a
DIE
P
The
caller
also
passes
in
f
CWsig_type
fP
which
must
contain
either
tu
identifying
the
hash
referring
to
a
type
unit
or
cu
identifying
the
hash
as
referring
to
a
compilation
unit
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
returned_die
fP
to
be
a
pointer
to
a
valid
DIE
for
the
compilation
unit
or
type
unit
If
the
type
is
tu
the
DIE
returned
is
the
specific
type
DIE
that
the
hash
refers
to
If
the
type
is
cu
the
DIE
returned
is
the
compilation
unit
DIE
of
the
compilation
unit
referred
to
P
When
appropriate
the
caller
should
free
the
space
of
the
returned
DIE
by
a
call
something
like
DS
dwarf_dealloc
dbg
die
DW_DLA_DIE
DE
P
If
there
is
no
DWP
Package
File
section
or
the
hash
cannot
be
found
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
and
leaves
f
CWreturned_die
fP
untouched
Only
dwo
objects
and
dwp
package
files
have
the
package
file
index
sections
P
If
there
is
an
error
of
some
sort
the
function
returns
f
CWDW_DLV_ERROR
fP
leaves
f
CWreturned_die
fP
untouched
and
sets
f
CW
error
fP
to
indicate
the
precise
error
encountered
P
H
dwarf_get_debugfission_for_die
DS
int
dwarf_get_debugfission_for_die
Dwarf_Die
die
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_debugfission_for_die
fP
returns
the
debug
fission
for
the
compilation
unit
the
DIE
is
a
part
of
Any
DIE
in
the
compilation
or
type
unit
will
get
the
same
result
P
On
a
call
to
this
function
ensure
the
pointed
to
space
is
fully
initialized
P
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
fills
in
the
fields
of
f
CW
percu_out
fP
for
which
it
has
data
P
If
there
is
no
DWP
Package
File
section
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
and
leaves
f
CW
percu_out
fP
untouched
Only
dwp
package
files
have
the
package
file
index
sections
P
If
there
is
an
error
of
some
sort
the
function
returns
f
CWDW_DLV_ERROR
fP
leaves
f
CW
percu_out
fP
untouched
and
sets
f
CW
error
fP
to
indicate
the
precise
error
encountered
H
dwarf_get_debugfission_for_key
DS
int
dwarf_get_debugfission_for_key
Dwarf_Debug
dbg
Dwarf_Sig8
key
const
char
key_type
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_debugfission_for_key
fP
returns
the
debug
fission
data
for
the
compilation
unit
in
a
dwp
package
file
P
If
there
is
no
DWP
Package
File
section
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
and
leaves
f
CW
percu_out
fP
untouched
Only
dwp
package
files
have
the
package
file
index
sections
P
If
there
is
an
error
of
some
sort
the
function
returns
f
CWDW_DLV_ERROR
fP
leaves
f
CW
percu_out
fP
untouched
and
sets
f
CW
error
fP
to
indicate
the
precise
error
encountered
H
dwarf_get_xu_index_header
DS
int
dwarf_get_xu_index_header
Dwarf_Debug
dbg
const
char
section_type
tu
or
cu
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
version_number
Dwarf_Unsigned
offsets_count
L
Dwarf_Unsigned
units_count
N
Dwarf_Unsigned
hash_slots_count
M
const
char
sect_name
Dwarf_Error
err
DE
The
function
f
CWdwarf_get_xu_index_header
fP
takes
as
input
a
valid
Dwarf_Debug
pointer
and
an
f
CWsection_type
fP
value
which
must
one
of
the
strings
f
CWtu
fP
or
f
CWcu
fP
P
It
returns
DW_DLV_NO_ENTRY
if
the
section
requested
is
not
in
the
object
file
P
It
returns
DW_DLV_ERROR
there
is
an
error
of
some
kind
and
the
error
is
indicated
by
the
value
returned
through
the
f
CWerror
fP
pointer
P
If
successful
the
function
returns
DW_DLV_OK
and
returns
the
following
values
through
the
pointers
P
The
f
CWxuhdr
fP
field
is
a
pointer
usable
in
other
operations
see
below
P
The
f
CWversion_number
fP
field
is
a
the
index
version
number
For
gcc
before
DWARF5
the
version
number
is
For
DWARF5
the
version
number
is
P
The
f
CWoffsets_count
fP
field
is
a
the
number
of
columns
in
the
table
of
section
offsets
Sometimes
known
as
f
CWL
fP
P
The
f
CWunits_count
fP
field
is
a
the
number
of
compilation
units
or
type
units
in
the
index
Sometimes
known
as
f
CWN
fP
P
The
f
CWhash_slots_count
fP
field
is
a
the
number
of
slots
in
the
hash
table
Sometimes
known
as
f
CWM
fP
P
The
f
CWsect_name
fP
field
is
the
name
of
the
section
in
the
object
file
Because
non
Elf
objects
may
not
use
section
names
callers
must
recognize
that
the
sect_name
may
be
set
to
NULL
zero
or
to
point
to
the
empty
string
and
this
is
not
considered
an
error
P
An
example
of
initializing
and
disposing
of
a
f
CWDwarf_Xu_Index_Header
fP
follows
DS
FG
Exampley
dwarf_get_xu_index_header
f
CW
void
exampley
Dwarf_Debug
dbg
const
char
type
type
is
tu
or
cu
int
res
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
version_number
Dwarf_Unsigned
offsets_count
L
Dwarf_Unsigned
units_count
M
Dwarf_Unsigned
hash_slots_count
N
Dwarf_Error
err
const
char
section_name
res
dwarf_get_xu_index_header
dbg
type
if
res
DW_DLV_NO_ENTRY
No
such
section
return
if
res
DW_DLV_ERROR
Something
wrong
return
Do
something
with
the
xuhdr
here
dwarf_xu_header_free
xuhdr
fP
DE
H
dwarf_get_xu_index_section_type
DS
int
dwarf_get_xu_index_section_type
Dwarf_Xu_Index_Header
xuhdr
const
char
typename
const
char
sectionname
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_xu_section_type
fP
takes
as
input
a
valid
f
CWDwarf_Xu_Index_Header
fP
It
is
only
useful
when
one
already
as
an
open
f
CWxuhdr
fP
but
one
does
not
know
if
this
is
a
type
unit
or
compilation
unit
index
section
P
If
it
returns
DW_DLV_NO_ENTRY
something
is
wrong
should
never
happen
If
it
returns
DW_DLV_ERROR
something
is
wrong
and
the
f
CWerror
fP
field
is
set
to
indicate
a
specific
error
P
If
successful
the
function
returns
DW_DLV_OK
and
sets
the
following
arguments
through
the
pointers
P
f
CWtypename
fP
is
set
to
the
string
f
CWtu
fP
or
f
CWcu
fP
to
indicate
the
index
is
of
a
type
unit
or
a
compilation
unit
respectively
P
f
CWsectionname
fP
is
set
to
name
of
the
object
file
section
Because
non
Elf
objects
may
not
use
section
names
callers
must
recognize
that
the
sect_name
may
be
set
to
NULL
zero
or
to
point
to
the
empty
string
and
this
is
not
considered
an
error
P
Neither
string
should
be
free
d
H
dwarf_get_xu_header_free
DS
void
dwarf_xu_header_free
Dwarf_Xu_Index_Header
xuhdr
DE
The
function
f
CWdwarf_get_xu_header_free
fP
takes
as
input
a
valid
f
CWDwarf_Xu_Index_Header
fP
and
frees
all
the
special
data
allocated
for
this
access
type
Once
called
any
pointers
returned
by
use
of
the
f
CWxuhdr
fP
should
be
considered
stale
and
unusable
H
dwarf_get_xu_hash_entry
DS
int
dwarf_get_xu_hash_entry
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
index
Dwarf_Sig8
hash_value
Dwarf_Unsigned
index_to_sections
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_xu_hash_entry
fP
takes
as
input
a
valid
f
CWDwarf_Xu_Index_Header
fP
and
an
f
CWindex
fP
of
a
hash
slot
entry
valid
hash
slot
index
values
are
zero
through
f
CWhash_slots_count
fP
M
P
If
it
returns
DW_DLV_NO_ENTRY
something
is
wrong
P
If
it
returns
DW_DLV_ERROR
something
is
wrong
and
the
f
CWerror
fP
field
is
set
to
indicate
a
specific
error
P
If
successful
the
function
returns
DW_DLV_OK
and
sets
the
following
arguments
through
the
pointers
P
f
CWhash_value
fP
is
set
to
the
hash
of
of
the
symbol
name
P
f
CWindex_to_sections
fP
is
set
to
the
index
into
offset
size
tables
of
this
hash
entry
P
If
both
f
CWhash_value
fP
and
f
CWindex_to_sections
fP
are
zero
then
the
hash
slot
is
unused
f
CWindex_to_sections
fP
is
used
in
calls
to
the
function
f
CWdwarf_get_xu_section_offset
fP
as
the
f
CWrow_index
fP
P
An
example
of
use
follows
DS
FG
Examplez
dwarf_get_xu_hash_entry
f
CW
void
examplez
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
hash_slots_count
hash_slots_count
returned
by
dwarf_get_xu_index_header
see
above
static
Dwarf_Sig8
zerohashval
Dwarf_Error
err
Dwarf_Unsigned
h
for
h
h
hash_slots_count
h
Dwarf_Sig8
hashval
Dwarf_Unsigned
index
int
res
res
dwarf_get_xu_hash_entry
xuhdr
h
if
res
DW_DLV_ERROR
Oops
hash_slots_count
wrong
return
else
if
res
DW_DLV_NO_ENTRY
Impossible
return
else
if
memcmp
sizeof
Dwarf_Sig8
index
An
unused
hash
slot
continue
Here
hashval
and
index
a
row
index
into
offsets
and
lengths
are
valid
But
the
row
to
be
passed
into
various
functions
here
is
index
fP
DE
H
dwarf_get_xu_section_names
DS
int
dwarf_get_xu_section_names
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
column_index
Dwarf_Unsigned
number
const
char
name
Dwarf_Error
err
DE
The
function
f
CWdwarf_get_xu_section_names
fP
takes
as
input
a
valid
f
CWDwarf_Xu_Index_Header
fP
and
a
f
CWcolumn_index
fP
of
a
hash
slot
entry
valid
column_index
values
are
zero
through
f
CWoffsets_count
fP
L
P
If
it
returns
DW_DLV_NO_ENTRY
something
is
wrong
P
If
it
returns
DW_DLV_ERROR
something
is
wrong
and
the
f
CWerror
fP
field
is
set
to
indicate
a
specific
error
P
If
successful
the
function
returns
DW_DLV_OK
and
sets
the
following
arguments
through
the
pointers
P
f
CWnumber
fP
is
set
to
a
number
identifying
which
section
this
column
applies
to
For
example
if
the
value
is
f
CWDW_SECT_INFO
fP
the
column
came
from
a
debug_info
dwo
section
See
the
table
of
f
CWDW_SECT_
fP
identifiers
and
assigned
numbers
in
DWARF5
P
f
CWname
fP
is
set
to
the
applicable
spelling
of
the
section
identifier
for
example
f
CWDW_SECT_INFO
fP
H
dwarf_get_xu_section_offset
DS
int
dwarf_get_xu_section_offset
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
row_index
Dwarf_Unsigned
column_index
Dwarf_Unsigned
sec_offset
Dwarf_Unsigned
sec_size
Dwarf_Error
error
DE
The
function
f
CWdwarf_get_xu_section_offset
fP
takes
as
input
a
valid
f
CWDwarf_Xu_Index_Header
fP
and
a
f
CWrow_index
fP
see
f
CWdwarf_get_xu_hash_entry
fP
above
and
a
f
CWcolumn_index
fP
P
Valid
row_index
values
are
zero
through
f
CWunits_count
fP
N
but
one
uses
f
CWdwarf_get_xu_hash_entry
fP
above
to
get
row
index
and
it
returns
a
origin
index
as
that
is
what
the
DWARF5
standard
specifies
Since
a
zero
index
from
f
CWdwarf_get_xu_hash_entry
fP
means
this
is
not
an
actual
entry
such
must
be
skipped
P
Hence
it
makes
some
sense
to
subtract
one
making
a
zero
origin
as
that
is
the
sense
of
all
but
the
first
row
of
the
offsets
table
P
Valid
column_index
values
are
zero
through
f
CWoffsets_count
fP
L
P
If
it
returns
DW_DLV_NO_ENTRY
something
is
wrong
P
If
it
returns
DW_DLV_ERROR
something
is
wrong
and
the
f
CWerror
fP
field
is
set
to
indicate
a
specific
error
P
If
successful
the
function
returns
DW_DLV_OK
and
sets
the
following
arguments
through
the
pointers
P
f
CWsec_offset
fP
f
CWbase
offset
fP
is
set
to
the
base
offset
of
the
initial
compilation
unit
header
section
taken
from
a
dwo
object
The
base
offset
is
the
data
from
a
single
section
of
a
dwo
object
P
f
CWsec_size
fP
is
set
to
the
length
of
the
original
section
taken
from
a
dwo
object
This
is
the
length
in
the
applicable
section
in
the
dwp
over
which
the
base
offset
applies
P
An
example
of
use
of
f
CWdwarf_get_xu_section_names
fP
and
f
CWdwarf_get_xu_section_offset
fP
follows
DS
FG
Exampleza
dwarf_get_xu_section_names
f
CW
void
exampleza
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
offsets_count
Dwarf_Unsigned
index
Dwarf_Error
err
Dwarf_Unsigned
col
We
use
offsets_count
returned
by
a
dwarf_get_xu_index_header
call
We
use
index
returned
by
a
dwarf_get_xu_hash_entry
call
for
col
col
offsets_count
col
Dwarf_Unsigned
off
Dwarf_Unsigned
len
const
char
name
Dwarf_Unsigned
num
int
res
res
dwarf_get_xu_section_names
xuhdr
col
if
res
DW_DLV_OK
break
res
dwarf_get_xu_section_offset
xuhdr
index
col
if
res
DW_DLV_OK
break
Here
we
have
the
DW_SECT_
name
and
number
and
the
base
offset
and
length
of
the
section
data
applicable
to
the
hash
that
got
us
here
Use
the
values
DE
H
TAG
ATTR
etc
names
as
strings
These
functions
turn
a
value
into
a
string
So
applications
wanting
the
string
DW_TAG_compile_unit
given
the
value
the
value
defined
for
this
TAG
can
do
so
easily
The
general
form
is
in
DS
f
CWint
dwarf_get_
something
_name
unsigned
value
char
s_out
fP
DE
in
If
the
f
CWvalue
fP
passed
in
is
known
the
function
returns
f
CWDW_DLV_OK
fP
and
places
a
pointer
to
the
appropriate
string
into
f
CW
s_out
fP
The
string
is
in
static
storage
and
applications
must
never
free
the
string
If
the
f
CWvalue
fP
is
not
known
f
CWDW_DLV_NO_ENTRY
fP
is
returned
and
f
CW
s_out
fP
is
not
set
f
CWDW_DLV_ERROR
fP
is
never
returned
f
CWLibdwarf
fP
generates
these
functions
at
libdwarf
build
time
by
reading
dwarf
h
All
these
follow
this
pattern
rigidly
so
the
details
of
each
are
not
repeated
for
each
function
The
choice
of
unsigned
for
the
value
type
argument
the
code
value
argument
is
somewhat
arbitrary
int
could
have
been
used
The
library
simply
assumes
the
value
passed
in
is
applicable
So
for
example
passing
a
TAG
value
code
to
f
CWdwarf_get_ACCESS_name
fP
is
a
coding
error
which
libdwarf
will
process
as
if
it
was
an
accessibility
code
value
Examples
of
bad
and
good
usage
are
in
DS
FG
Examplezb
dwarf_get_TAG_name
f
CW
void
examplezb
void
const
char
out
int
res
The
following
is
wrong
do
not
do
it
res
dwarf_get_ACCESS_name
DW_TAG_entry_point
Nothing
one
does
here
with
res
or
out
is
meaningful
The
following
is
meaningful
res
dwarf_get_TAG_name
DW_TAG_entry_point
if
res
DW_DLV_OK
Here
out
is
a
pointer
one
can
use
which
points
to
the
string
DW_TAG_entry_point
else
Here
out
has
not
been
touched
it
is
uninitialized
Do
not
use
it
fP
DE
in
H
dwarf_get_ACCESS_name
Returns
an
accessibility
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_AT_name
Returns
an
attribute
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_ATE_name
Returns
a
base
type
encoding
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_ADDR_name
Returns
an
address
type
encoding
name
through
the
f
CWs_out
fP
pointer
As
of
this
writing
only
f
CWDW_ADDR_none
fP
is
defined
in
f
CWdwarf
h
fP
H
dwarf_get_ATCF_name
Returns
a
SUN
code
flag
encoding
name
through
the
f
CWs_out
fP
pointer
This
code
flag
is
entirely
a
DWARF
extension
H
dwarf_get_CHILDREN_name
Returns
a
child
determination
name
which
is
seen
in
the
abbreviations
section
data
through
the
f
CWs_out
fP
pointer
The
only
value
this
recognizes
for
a
yes
value
is
As
a
flag
value
this
is
not
quite
correct
any
non
zero
value
means
yes
but
dealing
with
this
is
left
up
to
client
code
normally
compilers
really
do
emit
a
value
of
for
a
flag
H
dwarf_get_children_name
Returns
a
child
determination
name
through
the
f
CWs_out
fP
pointer
though
this
version
is
really
a
libdwarf
artifact
The
standard
function
is
f
CWdwarf_get_CHILDREN_name
fP
which
appears
just
above
As
a
flag
value
this
is
not
quite
correct
any
non
zero
value
means
yes
but
dealing
with
this
is
left
up
to
client
code
normally
compilers
really
do
emit
a
value
of
for
a
flag
H
dwarf_get_CC_name
Returns
a
calling
convention
case
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_CFA_name
Returns
a
call
frame
information
instruction
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_DS_name
Returns
a
decimal
sign
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_DSC_name
Returns
a
discriminant
descriptor
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_EH_name
Returns
a
GNU
exception
header
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_END_name
Returns
an
endian
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_FORM_name
Returns
an
form
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_FRAME_name
Returns
a
frame
code
name
through
the
f
CWs_out
fP
pointer
These
are
dependent
on
the
particular
ABI
so
unless
the
f
CWdwarf
h
fP
used
to
generate
libdwarf
matches
your
ABI
these
names
are
unlikely
to
be
very
useful
and
certainly
won
t
be
entirely
appropriate
H
dwarf_get_ID_name
Returns
an
identifier
case
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_INL_name
Returns
an
inline
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_LANG_name
Returns
a
language
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_LLE_name
Returns
a
split
dwarf
loclist
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_LNE_name
Returns
a
line
table
extended
opcode
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_LNS_name
Returns
a
line
table
standard
opcode
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_MACINFO_name
Returns
a
macro
information
macinfo
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_MACRO_name
Returns
a
DWARF5
macro
information
macro
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_OP_name
Returns
a
DWARF
expression
operation
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_ORD_name
Returns
an
array
ordering
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_TAG_name
Returns
a
TAG
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_VIRTUALITY_name
Returns
a
virtuality
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_VIS_name
Returns
a
visibility
code
name
through
the
f
CWs_out
fP
pointer
H
dwarf_get_FORM_CLASS_name
Only
different
from
the
others
in
that
it
applies
to
an
enum
value
It
returns
the
name
for
example
DW_FORM_CLASS_REFERENCE
through
the
pointer
in
DS
f
CWint
dwarf_get_FORM_CLASS_name
enum
Dwarf_Form_Class
fc
char
s_out
fP
DE
in
If
the
enum
value
is
out
of
the
valid
range
it
returns
f
CWDW_DLV_NO_ENTRY
fP
and
ignores
f
CWs_out
fP
P
It
never
returns
f
CWDW_DLV_ERROR
fP
H
Section
Operations
In
checking
DWARF
in
linkonce
sections
for
correctness
it
has
been
found
useful
to
have
certain
section
oriented
operations
when
processing
object
files
Normally
these
operations
are
not
needed
or
useful
in
a
fully
linked
executable
or
shared
library
While
the
code
is
written
with
Elf
sections
in
mind
it
is
quite
possible
to
process
non
Elf
objects
with
code
that
implements
certain
function
pointers
see
f
CWstruct
Dwarf_Obj_Access_interface_s
fP
So
far
no
one
with
such
non
elf
code
has
come
forward
to
open
source
it
H
dwarf_get_section_count
DS
f
CWint
dwarf_get_section_count
Dwarf_Debug
dbg
fP
DE
P
Returns
a
count
of
the
number
of
object
sections
found
P
If
there
is
an
incomplete
or
damaged
dbg
passed
in
this
can
return
H
dwarf_get_section_info_by_name
DS
f
CWint
dwarf_get_section_info_by_name
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_section_info_by_name
fP
returns
f
CWDW_DLV_OK
fP
if
the
section
given
by
f
CWsection_name
fP
was
seen
by
libdwarf
On
success
it
sets
f
CW
section_addr
fP
to
the
virtual
address
assigned
to
the
section
by
the
linker
or
compiler
and
f
CW
section_size
fP
to
the
size
of
the
object
section
It
returns
DW_DLV_ERROR
on
error
H
dwarf_get_section_info_by_index
DS
f
CWint
dwarf_get_section_info_by_index
int
section_index
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_section_info_by_index
fP
returns
f
CWDW_DLV_OK
fP
if
the
section
given
by
f
CWsection_index
fP
was
seen
by
libdwarf
f
CW
section_addr
fP
to
the
virtual
address
assigned
to
the
section
by
the
linker
or
compiler
and
f
CW
section_size
fP
to
the
size
of
the
object
section
No
free
or
deallocate
of
information
returned
should
be
done
by
callers
H
Utility
Operations
These
functions
aid
in
the
management
of
errors
encountered
when
using
functions
in
the
fIlibdwarf
fP
library
and
releasing
memory
allocated
as
a
result
of
a
fIlibdwarf
fP
operation
P
For
clients
that
wish
to
encode
LEB
numbers
two
interfaces
are
provided
to
the
producer
code
s
internal
LEB
function
H
dwarf_errno
DS
f
CWDwarf_Unsigned
dwarf_errno
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_errno
fP
returns
the
error
number
corresponding
to
the
error
specified
by
f
CWerror
fP
H
dwarf_errmsg
DS
f
CWconst
char
dwarf_errmsg
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_errmsg
fP
returns
a
pointer
to
a
null
terminated
error
message
string
corresponding
to
the
error
specified
by
f
CWerror
fP
The
string
should
not
be
deallocated
using
f
CWdwarf_dealloc
fP
The
string
should
be
considered
to
be
a
temporary
string
That
is
the
returned
pointer
may
become
stale
if
you
do
libdwarf
calls
on
the
f
CWDwarf_Debug
fP
instance
other
than
f
CWdwarf_errmsg
fP
or
f
CWdwarf_errno
fP
So
copy
the
errmsg
string
or
print
it
but
do
not
depend
on
the
pointer
remaining
valid
past
other
libdwarf
calls
to
the
f
CWDwarf_Debug
fP
instance
that
detected
an
error
H
dwarf_errmsg_by_number
DS
f
CWconst
char
dwarf_errmsg_by_number
Dwarf_Unside
errcode
fP
DE
The
function
f
CWdwarf_errmsg_by_number
fP
returns
a
pointer
to
a
null
terminated
error
message
string
corresponding
to
the
error
number
specified
by
f
CWerrcode
fP
The
string
should
not
be
deallocated
or
freed
If
the
f
CWerrcode
fP
is
too
large
for
the
table
of
static
error
strings
a
string
reflecting
that
fact
is
returned
P
For
some
places
in
the
code
a
f
CWDwarf_Error
fP
is
inconvenient
and
this
function
lets
dwarfdump
report
better
information
in
those
cases
Function
new
December
H
dwarf_get_endian_copy_function
DS
f
CWvoid
dwarf_get_endian_copy_function
Dwarf_Debug
dbg
void
const
void
src
unsigned
long
srclen
fP
DE
When
reader
client
code
wants
to
extract
endian
dependent
integers
from
dwarf
and
the
existing
interfaces
won
t
do
that
for
example
in
printing
frame
instructions
as
done
by
dwarfdump
f
CWdwarf_get_endian_copy_function
fP
helps
by
returning
the
proper
copy
function
needed
the
one
libdwarf
itself
uses
The
client
code
needs
a
bit
of
glue
to
finish
the
job
as
demonstrated
by
the
ASNAR
macro
in
dwarfdump
print_frames
c
P
On
success
this
returns
a
pointer
to
the
correct
copy
function
P
On
failure
it
returns
the
null
pointer
It
s
up
to
the
client
code
to
decide
how
to
deal
with
the
situation
In
no
reasonable
case
will
the
null
pointer
be
returned
P
New
December
H
dwarf_get_harmless_error_list
DS
f
CWint
dwarf_get_harmless_error_list
Dwarf_Debug
dbg
unsigned
count
const
char
errmsg_ptrs_array
unsigned
newerr_count
fP
DE
The
harmless
errors
are
not
denoted
by
error
returns
from
the
other
libdwarf
functions
Instead
this
function
returns
strings
of
any
harmless
errors
that
have
been
seen
in
the
current
object
Clients
never
need
call
this
but
if
a
client
wishes
to
report
any
such
errors
it
may
call
Only
a
fixed
number
of
harmless
errors
are
recorded
It
is
a
circular
list
so
if
more
than
the
current
maximum
is
encountered
older
harmless
error
messages
are
lost
The
caller
passes
in
a
pointer
to
an
array
of
pointer
to
char
as
the
argument
f
CWerrmsg_ptrs_array
fP
The
caller
must
provide
this
array
libdwarf
does
not
provide
it
The
caller
need
not
initialize
the
array
elements
The
caller
passes
in
the
number
of
elements
of
the
array
of
pointer
to
char
thru
f
CWcount
fP
Since
the
If
there
are
no
unreported
harmless
errors
the
function
returns
f
CWDW_DLV_NO_ENTRY
fP
and
the
function
arguments
are
ignored
Otherwise
the
function
returns
f
CWDW_DLV_OK
fP
and
uses
the
arguments
f
CWlibdwarf
fP
assigns
error
strings
to
the
errmsg_ptrs_array
The
MININUM
count
number
of
messages
recorded
pointers
are
assigned
to
the
array
The
array
is
terminated
with
a
NULL
pointer
That
is
one
array
entry
is
reserved
for
a
NULL
pointer
So
if
f
CWcount
fP
is
up
to
strings
may
be
returned
through
the
array
and
one
array
entry
is
set
to
NULL
Because
the
list
is
circular
and
messages
may
have
been
dropped
the
function
also
returns
the
actual
error
count
of
harmless
errors
encountered
through
f
CWnewerr_count
fP
unless
the
argument
is
NULL
in
which
case
it
is
ignored
Each
call
to
this
function
resets
the
circular
error
buffer
and
the
error
count
So
think
of
this
call
as
reporting
harmless
errors
since
the
last
call
to
it
The
pointers
returned
through
f
CWerrmsg_ptrs_array
fP
are
only
valid
till
the
next
call
to
libdwarf
Do
not
save
the
pointers
they
become
invalid
Copy
the
strings
if
you
wish
to
save
them
Calling
this
function
neither
allocates
any
space
in
memory
nor
frees
any
space
in
memory
H
dwarf_insert_harmless_error
DS
void
dwarf_insert_harmless_error
Dwarf_Debug
dbg
char
newerror
DE
This
function
is
used
to
test
f
CWdwarf_get_harmless_error_list
fP
It
simply
adds
a
harmless
error
string
There
is
little
reason
client
code
should
use
this
function
It
exists
so
that
the
harmless
error
functions
can
be
easily
tested
for
correctness
and
leaks
H
dwarf_set_harmless_error_list_size
DS
f
CWunsigned
dwarf_set_harmless_error_list_size
Dwarf_Debug
dbg
unsigned
maxcount
fP
DE
f
CWdwarf_set_harmless_error_list_size
fP
returns
the
number
of
harmless
error
strings
the
library
is
currently
set
to
hold
If
f
CWmaxcount
fP
is
non
zero
the
library
changes
the
maximum
it
will
record
to
be
f
CWmaxcount
fP
It
is
extremely
unwise
to
make
f
CWmaxcount
fP
large
because
f
CWlibdwarf
fP
allocates
space
for
f
CWmaxcount
fP
strings
immediately
P
The
set
of
errors
enumerated
in
Figure
n
aX
below
were
defined
in
Dwarf
These
errors
are
not
used
by
the
f
CWlibdwarf
fP
implementation
for
Dwarf
or
later
DS
TS
center
box
tab
lfB
lfB
l
l
SYMBOLIC
NAME
DESCRIPTION
_
DW_DLE_NE
No
error
DW_DLE_VMM
Version
of
DWARF
information
newer
than
libdwarf
DW_DLE_MAP
Memory
map
failure
DW_DLE_LEE
Propagation
of
libelf
error
DW_DLE_NDS
No
debug
section
DW_DLE_NLS
No
line
section
DW_DLE_ID
Requested
information
not
associated
with
descriptor
DW_DLE_IOF
I
O
failure
DW_DLE_MAF
Memory
allocation
failure
DW_DLE_IA
Invalid
argument
DW_DLE_MDE
Mangled
debugging
entry
DW_DLE_MLE
Mangled
line
number
entry
DW_DLE_FNO
File
descriptor
does
not
refer
to
an
open
file
DW_DLE_FNR
File
is
not
a
regular
file
DW_DLE_FWA
File
is
opened
with
wrong
access
DW_DLE_NOB
File
is
not
an
object
file
DW_DLE_MOF
Mangled
object
file
header
DW_DLE_EOLL
End
of
location
list
entries
DW_DLE_NOLL
No
location
list
section
DW_DLE_BADOFF
Invalid
offset
DW_DLE_EOS
End
of
section
DW_DLE_ATRUNC
Abbreviations
section
appears
truncated
DW_DLE_BADBITC
Address
size
passed
to
dwarf
bad
TE
FG
Dwarf
Error
Codes
DE
The
set
of
errors
returned
by
f
CWLibdwarf
fP
functions
is
listed
below
The
list
does
lengthen
the
ones
listed
here
are
far
from
a
complete
list
Some
of
the
errors
are
SGI
specific
See
libdwarf
dwarf_errmsg_list
h
for
the
complete
list
DS
TS
center
box
tab
lfB
lfB
l
SYMBOLIC
NAME
description
not
shown
here
_
DW_DLE_DBG_ALLOC
DW_DLE_FSTAT_ERROR
DW_DLE_FSTAT_MODE_ERROR
DW_DLE_INIT_ACCESS_WRONG
DW_DLE_ELF_BEGIN_ERROR
DW_DLE_ELF_GETEHDR_ERROR
DW_DLE_ELF_GETSHDR_ERROR
DW_DLE_ELF_STRPTR_ERROR
DW_DLE_DEBUG_INFO_DUPLICATE
DW_DLE_DEBUG_INFO_NULL
DW_DLE_DEBUG_ABBREV_DUPLICATE
DW_DLE_DEBUG_ABBREV_NULL
DW_DLE_DEBUG_ARANGES_DUPLICATE
DW_DLE_DEBUG_ARANGES_NULL
DW_DLE_DEBUG_LINE_DUPLICATE
DW_DLE_DEBUG_LINE_NULL
DW_DLE_DEBUG_LOC_DUPLICATE
DW_DLE_DEBUG_LOC_NULL
DW_DLE_DEBUG_MACINFO_DUPLICATE
DW_DLE_DEBUG_MACINFO_NULL
DW_DLE_DEBUG_PUBNAMES_DUPLICATE
DW_DLE_DEBUG_PUBNAMES_NULL
DW_DLE_DEBUG_STR_DUPLICATE
DW_DLE_DEBUG_STR_NULL
DW_DLE_CU_LENGTH_ERROR
DW_DLE_VERSION_STAMP_ERROR
DW_DLE_ABBREV_OFFSET_ERROR
DW_DLE_ADDRESS_SIZE_ERROR
DW_DLE_DEBUG_INFO_PTR_NULL
DW_DLE_DIE_NULL
DW_DLE_STRING_OFFSET_BAD
DW_DLE_DEBUG_LINE_LENGTH_BAD
DW_DLE_LINE_PROLOG_LENGTH_BAD
DW_DLE_LINE_NUM_OPERANDS_BAD
DW_DLE_LINE_SET_ADDR_ERROR
TE
FG
Dwarf
and
later
Error
Codes
DE
This
list
of
errors
is
not
complete
additional
errors
have
been
added
Some
of
the
above
errors
may
be
unused
Errors
may
not
have
the
same
meaning
in
different
releases
Since
most
error
codes
are
returned
from
only
one
place
or
a
very
small
number
of
places
in
the
source
it
is
normally
very
useful
to
simply
search
the
f
CWlibdwarf
fP
source
to
find
out
where
a
particular
error
code
is
generated
See
f
CWlibdwarf
dwarf_errmsg_list
h
fP
for
the
complete
message
set
with
short
descriptions
H
dwarf_dealloc
DS
f
CWvoid
dwarf_dealloc
Dwarf_Debug
dbg
void
space
Dwarf_Unsigned
type
fP
DE
The
function
f
CWdwarf_dealloc
fP
frees
the
dynamic
storage
pointed
to
by
f
CWspace
fP
and
allocated
to
the
given
f
CWDwarf_Debug
fP
The
argument
f
CWtype
fP
is
an
integer
code
that
specifies
the
allocation
type
of
the
region
pointed
to
by
the
f
CWspace
fP
Refer
to
section
for
details
on
fIlibdwarf
fP
memory
management
H
dwarf_encode_leb128
DS
int
dwarf_encode_leb128
Dwarf_Unsigned
val
int
nbytes
char
space
int
splen
DE
The
function
f
CWdwarf_encode_leb128
fP
encodes
the
value
f
CWval
fP
in
the
caller
provided
buffer
that
f
CWspace
fP
points
to
The
caller
provided
buffer
must
be
at
least
f
CWsplen
fP
bytes
long
The
function
returns
f
CWDW_DLV_OK
fP
if
the
encoding
succeeds
If
f
CWsplen
fP
is
too
small
to
encode
the
value
f
CWDW_DLV_ERROR
fP
will
be
returned
If
the
call
succeeds
the
number
of
bytes
of
f
CWspace
fP
that
are
used
in
the
encoding
are
returned
through
the
pointer
f
CWnbytes
fP
H
dwarf_encode_signed_leb128
DS
int
dwarf_encode_signed_leb128
Dwarf_Signed
val
int
nbytes
char
space
int
splen
DE
The
function
f
CWdwarf_encode_signed_leb128
fP
is
the
same
as
f
CWdwarf_encode_leb128
fP
except
that
the
argument
f
CWval
fP
is
signed
H
Finding
Memory
Leaks
f
CW
fP
If
you
are
using
f
CWdwarf_set_de_alloc_flag
fP
to
turn
off
the
garbage
collection
f
CWdwarfinish
fP
does
and
you
find
memory
leaks
there
are
a
couple
specific
tools
provided
that
may
ease
the
process
of
tracking
down
the
errors
you
have
made
P
This
chapter
is
new
as
of
March
H
Compiling
libdwarf
DDEBUG
P
The
first
tool
is
to
build
libdwarf
with
options
f
CW
g
O0
DDEBUG
fP
The
O0
is
simply
to
help
a
debugger
valgrind
or
other
too
identify
source
lines
accurately
The
f
CW
DDEBUG
fP
Turns
on
printf
statements
in
dwarf_alloc
c
and
dwarf_error
c
that
emit
lines
like
DS
libdwarfdetector
ALLOC
ret
size
libdwarfdetector
DEALLOC
ret
size
libdwarfdetector
ALLOC
creating
error
string
libdwarfdetector
DEALLOC
Now
destruct
error
string
DE
at
each
point
of
particular
interest
P
The
first
two
relate
to
actually
malloc
free
The
ret
will
be
a
hex
address
of
the
pointer
yuur
code
is
presented
for
allocations
inside
libdwarf
P
The
second
two
relate
to
allocation
free
of
a
string
in
Dwarf_Error
record
when
an
error
record
with
variable
descriptive
error
information
is
being
built
freed
P
H
Making
use
of
the
output
of
DDEBUG
A
small
Python
program
alloctrack
py
in
the
libdwarf
regressiontests
on
SourceForge
net
will
read
through
a
file
with
libdwarfdetector
lines
and
report
on
mismatches
in
the
alloc
dealloc
counts
for
each
memory
blob
libdwarf
created
All
other
lines
are
skipped
P
This
has
been
found
very
useful
P
Since
the
regression
tests
are
large
and
you
won
t
otherwise
need
them
a
copy
of
alloctrack
py
follows
so
you
need
not
clone
the
test
code
DS
f
CW
usr
bin
env
python3
Copyright
David
Anderson
This
Python
code
is
hereby
placed
into
the
public
domain
for
use
by
anyone
for
any
purpose
Useful
for
finding
the
needle
of
a
single
leaking
allocation
in
the
haystack
of
all
the
libdwarfdetector
lines
libdwarf
can
emit
if
compiled
DDEBUG
import
sys
import
os
def
trackallocs
fi
valdict
line
while
True
line
int
line
try
recf
fi
readline
except
EOFError
break
if
len
recf
eof
break
rec
recf
strip
if
rec
find
ALLOC
if
rec
find
libdwarfdetector
ALLOC
ret
wds
rec
split
off
wds
if
off
in
valdict
allo
deallo
valdict
off
if
int
allo
r
deallo
valdict
off
r
else
print
Duplicate
use
of
off
line
line
r
int
allo
deallo
valdict
off
r
else
allo
deallo
r
allo
deallo
valdict
off
r
continue
if
rec
find
libdwarfdetector
DEALLOC
ret
wds
rec
split
off
wds
if
off
in
valdict
allo
deallo
valdict
off
if
int
deallo
r
allo
valdict
off
r
else
print
Duplicate
use
of
off
line
line
r
allo
int
deallo
valdict
off
r
else
allo
deallo
r
allo
deallo
valdict
off
r
continue
if
__name__
__main__
if
len
sys
argv
fname
sys
argv
try
file
open
fname
r
except
IOError
as
message
print
File
could
not
be
opened
fname
message
sys
exit
else
file
sys
stdin
vals
trackallocs
file
vals
for
s
in
vals
allo
deallo
vals
s
if
int
allo
int
deallo
print
Mismatch
on
s
a
vs
d
allo
deallo
if
int
allo
print
Reuse
of
s
a
vs
d
allo
deallo
fP
DE
SK
S
TC
CS
the
following
line
may
be
removed
if
the
ff
ligature
works
on
your
machine
lg
set
up
heading
formats
ds
HF
ds
HP
nr
Hs
nr
Hb
Increment
body
point
size
S
Put
current
date
in
the
following
at
each
rev
ds
vE
Rev
January
ds
ds
ds
if
t
ds
Cw
f
CW
if
n
ds
Cw
fB
de
Cf
Place
every
other
arg
in
Cw
font
beginning
with
first
if
n
Cw
fP
if
n
Cw
fP
if
n
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
if
n
Cw
fP
Cw
fP
Cw
fP
Cw
fP
Cw
nr
Cl
SA
TL
A
Producer
Library
Interface
to
DWARF
AF
AU
David
Anderson
PF
vE
nP
AS
This
document
describes
an
interface
to
a
library
of
functions
to
create
DWARF
debugging
information
entries
and
DWARF
line
number
information
It
does
not
make
recommendations
as
to
how
the
functions
described
in
this
document
should
be
implemented
nor
does
it
suggest
possible
optimizations
P
The
document
is
oriented
to
creating
DWARF
version
Support
for
creating
DWARF3
and
DWARF4
and
DWARF5
is
only
partial
various
features
since
DWARF2
cannot
be
created
P
vE
AE
MT
H
INTRODUCTION
This
document
describes
an
interface
to
f
CWlibdwarf
fP
a
library
of
functions
to
provide
creation
of
DWARF
debugging
information
records
DWARF
line
number
information
DWARF
address
range
and
pubnames
information
weak
names
information
and
DWARF
frame
description
information
H
Copyright
Copyright
Silicon
Graphics
Inc
Copyright
David
Anderson
Permission
is
hereby
granted
to
copy
or
republish
or
use
any
or
all
of
this
document
without
restriction
except
that
when
publishing
more
than
a
small
amount
of
the
document
please
acknowledge
Silicon
Graphics
Inc
and
David
Anderson
This
document
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
H
Purpose
and
Scope
The
purpose
of
this
document
is
to
propose
a
library
of
functions
to
create
DWARF
debugging
information
Reading
consuming
of
such
records
is
discussed
in
a
separate
document
The
functions
in
this
document
have
mostly
been
implemented
at
Silicon
Graphics
and
used
by
the
SGI
code
generator
to
provide
DWARF2
debugging
information
in
the
s
Some
functions
and
support
for
some
extensions
were
provided
by
Sun
Microsystems
Example
code
showing
one
use
of
the
functionality
may
be
found
in
the
dwarfgen
f
CWdwarfgen
fP
and
f
CWsimpleexample
fP
application
provided
in
the
source
distribution
along
with
libdwarf
P
The
focus
of
this
document
is
the
functional
interface
and
as
such
implementation
and
optimization
issues
are
intentionally
ignored
P
Error
handling
error
codes
and
certain
f
CWLibdwarf
fP
codes
are
discussed
in
the
fIA
Consumer
Library
Interface
to
DWARF
fP
which
should
be
read
before
reading
this
document
P
Before
December
very
few
functions
in
the
Producer
Library
follow
the
error
returns
as
defined
in
fIA
Consumer
Library
Interface
to
DWARF
fP
P
As
of
December
every
Producer
Library
call
has
a
version
that
supports
that
Consumer
Library
Interface
and
returns
DW_DLV_OK
or
DW_DLV_ERROR
the
Producer
Library
has
no
use
of
DW_DLV_NO_ENTRY
The
table
of
contents
of
this
document
lists
the
latest
version
of
each
function
However
all
the
earlier
documentation
is
present
here
immediately
following
the
documentation
of
the
latest
and
preferred
interface
All
the
earlier
interfaces
are
supported
in
the
library
P
Early
interfaces
before
December
The
general
style
of
functions
here
in
the
producer
library
is
rather
C
traditional
with
various
types
as
return
values
quite
different
from
the
consumer
library
interfaces
The
style
generally
follows
the
style
of
the
original
DWARF1
reader
proposed
as
an
interface
to
DWARF
When
the
style
of
the
reader
interfaces
was
changed
in
the
dwarf
reader
See
the
Document
History
section
of
A
Consumer
Library
Interface
to
DWARF
the
interfaces
here
were
not
changed
as
it
seemed
like
too
much
of
a
change
for
the
two
applications
then
using
the
interface
So
this
interface
remains
in
the
traditional
C
style
of
returning
various
data
types
with
various
somewhat
inconsistent
means
of
indicating
failure
P
December
and
later
function
interfaces
all
return
either
DW_DLV_OK
or
DW_DLV_ERROR
in
a
simple
int
P
The
error
handling
code
in
the
library
may
either
return
a
value
or
abort
The
library
user
can
provide
a
function
that
the
producer
code
will
call
on
errors
which
would
allow
callers
avoid
testing
for
error
returns
if
the
user
function
exits
or
aborts
See
the
f
CWdwarf_producer_init
fP
description
below
for
more
details
H
Document
History
This
document
originally
prominently
referenced
UNIX
International
Programming
Languages
Special
Interest
Group
PLSIG
Both
UNIX
International
and
the
affiliated
Programming
Languages
Special
Interest
Group
are
defunct
UNIX
is
a
registered
trademark
of
UNIX
System
Laboratories
Inc
in
the
United
States
and
other
countries
Nothing
except
the
general
interface
style
is
actually
related
to
anything
shown
to
the
PLSIG
this
document
was
open
sourced
with
libdwarf
in
the
mid
s
P
See
http
www
dwarfstd
org
for
information
on
current
DWARF
standards
and
committee
activities
H
Definitions
DWARF
debugging
information
entries
DIEs
are
the
segments
of
information
placed
in
the
f
CW
debug_info
fP
and
related
sections
by
compilers
assemblers
and
linkage
editors
that
in
conjunction
with
line
number
entries
are
necessary
for
symbolic
source
level
debugging
Refer
to
the
document
fIDWARF
Debugging
Information
Format
fP
from
UI
PLSIG
for
a
more
complete
description
of
these
entries
P
This
document
adopts
all
the
terms
and
definitions
in
fIDWARF
Debugging
Information
Format
fP
version
and
the
fIA
Consumer
Library
Interface
to
DWARF
fP
P
In
addition
this
document
refers
to
Elf
the
ATT
USL
System
V
Release
object
format
This
is
because
the
library
was
first
developed
for
that
object
format
Hopefully
the
functions
defined
here
can
easily
be
applied
to
other
object
formats
H
Overview
The
remaining
sections
of
this
document
describe
a
proposed
producer
compiler
or
assembler
interface
to
fILibdwarf
fP
first
by
describing
the
purpose
of
additional
types
defined
by
the
interface
followed
by
descriptions
of
the
available
operations
This
document
assumes
you
are
thoroughly
familiar
with
the
information
contained
in
the
fIDWARF
Debugging
Information
Format
fP
document
and
fIA
Consumer
Library
Interface
to
DWARF
fP
P
The
interface
necessarily
knows
a
little
bit
about
the
object
format
which
is
assumed
to
be
Elf
We
make
an
attempt
to
make
this
knowledge
as
limited
as
possible
For
example
fILibdwarf
fP
does
not
do
the
writing
of
object
data
to
the
disk
The
producer
program
does
that
H
Revision
History
VL
LI
March
Work
on
dwarf2
sgi
producer
draft
begins
LI
March
Adding
a
function
to
allow
any
number
of
trips
through
the
dwarf_get_section_bytes_a
call
LI
April
Added
support
for
assembler
text
output
of
dwarf
as
when
the
output
must
pass
through
an
assembler
Revamped
internals
for
better
performance
and
simpler
provision
for
differences
in
ABI
LI
Sep
Added
support
for
little
and
cross
endian
debug
info
creation
LI
May
This
library
interface
now
cleans
up
deallocating
all
memory
it
uses
the
application
simply
calls
dwarf_producer_finish
dbg
LI
September
Now
documents
the
marker
feature
of
DIE
creation
LI
May
The
dwarf_producer_init
code
has
a
new
interface
and
DWARF
is
configured
at
run
time
by
its
arguments
The
producer
code
used
to
be
configured
at
configure
time
but
the
configure
time
producer
configure
options
are
no
longer
used
The
configuration
was
unnecessarily
complicated
the
run
time
configuration
is
simpler
to
understand
LI
September
Beginning
the
process
of
creating
new
interfaces
so
that
checking
for
error
is
consistent
across
all
calls
as
is
done
in
the
consumer
library
The
old
interfaces
are
kept
and
supported
so
we
have
binary
and
source
compatibility
with
old
code
LI
December
All
function
interfaces
now
have
a
version
that
returns
only
DW_DLV_OK
or
DW_DLV_ERROR
and
pointer
and
other
values
are
returned
through
pointer
arguments
For
example
dwarf_add_frame_info_c
is
the
December
version
while
dwarf_add_frame_info
dwarf_add_frame_info_b
are
earlier
versions
LI
July
To
enable
testing
of
reading
the
DWARF5
section
debug_sup
the
new
function
dwarf_add_debug_sup
is
added
dwarfgen
can
call
this
function
though
dwarfgen
presently
only
fills
out
a
bogus
debug_sup
section
to
enable
simple
testing
LI
January
dwarf_add_AT_block_a
now
also
supports
the
DWARF5
form
DW_FORM_exprloc
LI
June
Removing
the
obsolete
functions
that
return
Dwarf_Unsigned
etc
and
required
ugly
casting
to
check
success
fail
The
ones
returning
int
DW_DLV_OK
etc
are
the
only
ones
that
should
be
used
The
library
is
now
in
its
own
file
libdwarfp
a
or
libdwarfp
so
and
the
source
in
its
own
directory
src
lib
libdwarfp
libdwarfp
is
only
built
if
a
build
of
dwarfgen
is
requested
Meaning
with
standard
builds
this
library
is
not
provided
It
only
creates
DWARF2
with
any
completeness
so
it
s
not
clear
how
it
could
possibly
be
generally
useful
LE
H
Type
Definitions
H
General
Description
The
fIlibdwarf
h
fP
header
file
contains
typedefs
and
preprocessor
definitions
of
types
and
symbolic
names
used
to
reference
objects
of
and
types
used
by
fIlibdwarf
fP
and
some
declarations
needed
by
fIlibdwarfp
fP
The
fIlibdwarfp
h
fP
header
file
defines
producer
functions
and
type
specifically
used
by
fIlibdwarfp
fP
The
types
defined
by
typedefs
contained
in
fI
libdwarf
h
fP
and
fI
libdwarfp
h
fP
all
use
the
convention
of
adding
fI
Dwarf_
fP
as
a
prefix
to
indicate
that
they
refer
to
objects
used
by
Libdwarf
The
prefix
fI
Dwarf_P_
fP
is
used
for
objects
referenced
by
the
fI
Libdwarf
fP
Producer
when
there
are
similar
but
distinct
objects
used
by
the
Consumer
H
Namespace
issues
Application
programs
should
avoid
creating
names
beginning
with
f
CWDwarf_
fP
f
CWdwarf_
fP
or
f
CWDW_
fP
as
these
are
reserved
to
dwarf
and
libdwarf
H
libdwarf
and
Elf
and
relocations
Much
of
the
description
below
presumes
that
Elf
is
the
object
format
in
use
The
library
is
probably
usable
with
other
object
formats
that
allow
arbitrary
sections
to
be
created
The
library
does
not
write
anything
to
disk
Instead
it
provides
access
so
that
callers
can
do
that
in
whatever
object
format
is
appropriate
H
binary
or
assembler
output
With
f
CWDW_DLC_STREAM_RELOCATIONS
fP
see
below
it
is
assumed
that
the
calling
app
will
simply
write
the
streams
and
relocations
directly
into
an
Elf
file
without
going
through
an
assembler
With
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
the
calling
app
must
either
A
generate
binary
relocation
streams
and
write
the
generated
debug
information
streams
and
the
relocation
streams
direct
to
an
elf
file
or
B
generate
assembler
output
text
for
an
assembler
to
read
and
produce
an
object
file
With
case
B
the
libdwarf
calling
application
must
use
the
relocation
information
to
change
points
of
each
binary
stream
into
references
to
symbolic
names
It
is
necessary
for
the
assembler
to
be
willing
to
accept
and
generate
relocations
for
references
from
arbitrary
byte
boundaries
For
example
sp
nf
in
data
producing
bytes
of
data
word
mylabel
producing
a
reference
word
endlabel
startlabel
producing
absolute
length
in
fi
sp
H
libdwarf
relationship
to
Elf
When
the
documentation
below
refers
to
an
elf
section
number
it
is
really
only
dependent
on
getting
via
the
callback
function
passed
by
the
caller
of
f
CWdwarf_producer_init
fP
a
sequence
of
integers
back
with
as
the
lowest
When
the
documentation
below
refers
to
an
Elf
symbol
index
it
is
really
dependent
on
Elf
symbol
numbers
only
if
f
CWDW_DLC_STREAM_RELOCATIONS
fP
are
being
generated
see
below
With
f
CWDW_DLC_STREAM_RELOCATIONS
fP
the
library
is
generating
Elf
relocations
and
the
section
numbers
in
binary
form
so
the
section
numbers
and
symbol
indices
must
really
be
Elf
or
elf
like
numbers
With
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
the
values
passed
as
symbol
indexes
can
be
any
integer
set
or
even
pointer
set
All
that
libdwarf
assumes
is
that
where
values
are
unique
they
get
unique
values
Libdwarf
does
not
generate
any
kind
of
symbol
table
from
the
numbers
and
does
not
check
their
uniqueness
or
lack
thereof
H
libdwarf
and
relocations
With
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
libdwarf
creates
binary
streams
of
debug
information
and
arrays
of
relocation
information
describing
the
necessary
relocation
The
Elf
section
numbers
and
symbol
numbers
appear
nowhere
in
the
binary
streams
Such
appear
only
in
the
relocation
information
and
the
passed
back
information
from
calls
requesting
the
relocation
information
As
a
consequence
the
symbol
indices
can
be
any
pointer
or
integer
value
as
the
caller
must
arrange
that
the
output
deal
with
relocations
With
f
CWDW_DLC_STREAM_RELOCATIONS
fP
all
the
relocations
are
directly
created
by
libdwarf
as
binary
streams
libdwarf
only
creates
the
streams
in
memory
it
does
not
write
them
to
disk
H
symbols
addresses
and
offsets
The
following
applies
to
calls
that
pass
in
symbol
indices
addresses
and
offsets
such
as
f
CWdwarf_add_AT_targ_address_c
fP
f
CWdwarf_add_arange_c
fP
and
f
CWdwarf_add_frame_fde_c
fP
With
f
CWDW_DLC_STREAM_RELOCATIONS
fP
a
passed
in
address
is
one
of
a
a
section
offset
and
the
non
global
symbol
index
of
a
section
symbol
b
A
symbol
index
global
symbol
and
a
zero
offset
With
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
the
same
approach
can
be
used
or
instead
a
passed
in
address
may
be
c
a
symbol
handle
and
an
offset
In
this
case
since
it
is
up
to
the
calling
app
to
generate
binary
relocations
if
appropriate
or
to
turn
the
binary
stream
into
a
text
stream
for
input
to
an
assembler
if
appropriate
the
application
has
complete
control
of
the
interpretation
of
the
symbol
handles
H
Memory
Management
Several
of
the
functions
that
comprise
the
fILibdwarf
fP
producer
interface
dynamically
allocate
values
and
some
return
pointers
to
those
spaces
The
dynamically
allocated
spaces
can
not
be
reclaimed
and
must
not
be
freed
except
that
all
such
libdwarf
allocated
memory
is
freed
by
f
CWdwarf_producer_finish_a
dbg
fP
All
data
for
a
particular
f
CWDwarf_P_Debug
fP
descriptor
is
separate
from
the
data
for
any
other
f
CWDwarf_P_Debug
fP
descriptor
in
use
in
the
library
calling
application
H
Read
Only
Properties
The
read
only
properties
specified
in
the
consumer
interface
document
do
not
generally
apply
to
the
functions
described
here
H
Storage
Deallocation
Calling
f
CWdwarf_producer_finish_a
dbg
fP
frees
all
the
space
and
invalidates
all
pointers
returned
from
f
CWLibdwarf
fP
functions
on
or
descended
from
f
CWdbg
fP
H
Error
Handling
In
general
any
error
detected
by
the
producer
should
be
considered
fatal
That
is
it
is
impossible
to
produce
correct
output
so
producing
anything
seems
questionable
P
The
original
producer
interfaces
tended
to
return
a
pointer
or
a
large
integer
as
a
result
and
required
the
caller
to
cast
that
value
to
determine
if
it
was
actually
a
meaning
there
was
an
error
P
Beginning
in
September
additional
interfaces
are
being
added
to
eliminate
the
necessity
for
callers
to
do
this
ugly
casting
of
results
In
December
that
process
has
reached
completion
The
revised
functions
return
f
CWDW_DLV_OK
fP
or
f
CWDW_DLV_ERROR
fP
which
are
small
signed
integers
and
will
have
an
additional
pointer
argument
that
will
provide
the
value
that
used
to
be
the
return
value
This
will
make
the
interfaces
type
safe
P
The
function
f
CWdwarf_get_section_bytes_a
fP
can
also
return
f
CWDW_DLV_NO_ENTRY
fP
P
H
Functional
Interface
This
section
describes
the
functions
available
in
the
fILibdwarf
fP
library
Each
function
description
includes
its
definition
followed
by
a
paragraph
describing
the
function
s
operation
P
The
following
sections
describe
these
functions
P
The
functions
may
be
categorized
into
groups
fIinitialization
and
termination
operations
fP
fIdebugging
information
entry
creation
fP
fIElf
section
callback
function
fP
fIattribute
creation
fP
fIexpression
creation
fP
fIline
number
creation
fP
fIfast
access
aranges
creation
fP
fIfast
access
pubnames
creation
fP
fIfast
access
weak
names
creation
fP
fImacro
information
creation
fP
fIlow
level
debug_frame
creation
fP
and
fIlocation
list
debug_loc
creation
fP
P
H
Initialization
and
Termination
Operations
These
functions
setup
f
CWLibdwarf
fP
to
accumulate
debugging
information
for
an
object
usually
a
compilation
unit
provided
by
the
producer
The
actual
addition
of
information
is
done
by
functions
in
the
other
sections
of
this
document
Once
all
the
information
has
been
added
functions
from
this
section
are
used
to
transform
the
information
to
appropriate
byte
streams
and
help
to
write
out
the
byte
streams
to
disk
Typically
then
a
producer
application
would
create
a
f
CWDwarf_P_Debug
fP
descriptor
to
gather
debugging
information
for
a
particular
compilation
unit
using
f
CWdwarf_producer_init
fP
The
producer
application
would
use
this
f
CWDwarf_P_Debug
fP
descriptor
to
accumulate
debugging
information
for
this
object
using
functions
from
other
sections
of
this
document
Once
all
the
information
had
been
added
it
would
call
f
CWdwarf_transform_to_disk_form_a
fP
to
convert
the
accumulated
information
into
byte
streams
in
accordance
with
the
f
CWDWARF
fP
standard
The
application
would
then
repeatedly
call
f
CWdwarf_get_section_bytes_a
fP
for
each
of
the
f
CW
debug_
fP
created
This
gives
the
producer
information
about
the
data
bytes
to
be
written
to
disk
At
this
point
the
producer
would
release
all
resource
used
by
f
CWLibdwarf
fP
for
this
object
by
calling
f
CWdwarf_producer_finish_a
fP
It
is
also
possible
to
create
assembler
input
character
streams
from
the
byte
streams
created
by
this
library
This
feature
requires
slightly
different
interfaces
than
direct
binary
output
The
details
are
mentioned
in
the
text
H
dwarf_producer_init
DS
f
CWint
dwarf_producer_init
Dwarf_Unsigned
flags
Dwarf_Callback_Func
func
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
void
user_data
const
char
isa_name
const
char
dwarf_version
const
char
extra
Dwarf_P_Debug
dbg_returned
Dwarf_Error
error
fP
DE
P
The
function
f
CWdwarf_producer_init
fP
returns
a
new
f
CWDwarf_P_Debug
fP
descriptor
that
can
be
used
to
add
f
CWDwarf
fP
information
to
the
object
On
success
it
returns
f
CWDW_DLV_OK
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
f
CWflags
fP
determine
whether
the
target
object
is
bit
or
bit
f
CWfunc
fP
is
a
pointer
to
a
function
called
back
from
f
CWLibdwarf
fP
whenever
f
CWLibdwarf
fP
needs
to
create
a
new
object
section
as
it
will
for
each
debug_
section
and
related
relocation
section
P
The
f
CWflags
fP
values
to
be
OR
d
together
in
the
flags
field
in
the
calling
code
are
as
follows
in
f
CWDW_DLC_WRITE
fP
is
required
The
values
f
CWDW_DLC_READ
fP
f
CWDW_DLC_RDWR
fP
are
not
supported
by
the
producer
and
must
not
be
passed
The
flag
bit
f
CWDW_DLC_POINTER64
fP
or
f
CWDW_DLC_SIZE_64
fP
Indicates
the
target
has
a
bit
byte
address
size
The
flag
bit
f
CWDW_DLC_POINTER32
fP
or
f
CWDW_DLC_SIZE_32
fP
Indicates
the
target
has
a
bit
byte
address
size
If
none
of
these
pointer
sizes
is
passed
in
f
CWDW_DLC_POINTER32
fP
is
assumed
The
flag
bit
f
CWDW_DLC_OFFSET32
fP
indicates
that
offsets
should
be
used
in
the
generated
DWARF
The
flag
bit
f
CWDW_DLC_OFFSET64
fP
f
CWDW_DLC_OFFSET_SIZE_64
fP
indicates
that
offsets
should
be
used
in
the
generated
DWARF
The
flag
bit
f
CWDW_DLC_IRIX_OFFSET64
fP
indicates
that
the
generated
DWARF
should
use
the
early
pre
DWARF3
IRIX
method
of
generating
bit
offsets
In
this
case
f
CWDW_DLC_POINTER64
fP
should
also
be
passed
in
and
the
f
CWisa_name
fP
passed
in
see
below
should
be
irix
If
f
CWDW_DLC_TARGET_BIGENDIAN
fP
or
f
CWDW_DLC_TARGET_LITTLEENDIAN
fP
is
not
ORed
into
f
CWflags
fP
then
endianness
the
same
as
the
host
is
assumed
If
both
f
CWDW_DLC_TARGET_LITTLEENDIAN
fP
and
f
CWDW_DLC_TARGET_BIGENDIAN
fP
are
OR
d
in
it
is
an
error
Either
one
of
two
output
forms
is
specifiable
f
CWDW_DLC_STREAM_RELOCATIONS
fP
or
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
The
default
is
f
CWDW_DLC_STREAM_RELOCATIONS
fP
The
f
CWDW_DLC_STREAM_RELOCATIONS
fP
are
relocations
in
a
binary
stream
as
used
in
a
MIPS
IRIX
Elf
object
The
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
are
the
same
relocations
but
expressed
in
an
array
of
structures
defined
by
libdwarf
which
the
caller
of
the
relevant
function
see
below
must
deal
with
appropriately
This
method
of
expressing
relocations
allows
the
producer
application
to
easily
produce
assembler
text
output
of
debugging
information
When
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
is
ORed
into
f
CWflags
fP
then
relocations
are
returned
not
as
streams
but
through
an
array
of
structures
in
P
The
function
f
CWfunc
fP
must
be
provided
by
the
user
of
this
library
Its
prototype
is
DS
f
CWtypedef
int
Dwarf_Callback_Func
char
name
int
size
Dwarf_Unsigned
type
Dwarf_Unsigned
flags
Dwarf_Unsigned
link
Dwarf_Unsigned
info
Dwarf_Unsigned
sect_name_index
void
user_data
int
error
fP
DE
For
each
section
in
the
object
file
that
f
CWlibdwarf
fP
needs
to
create
it
calls
this
function
once
calling
it
from
f
CWdwarf_transform_to_disk_form
fP
passing
in
the
section
f
CWname
fP
the
section
f
CWtype
fP
the
section
f
CWflags
fP
the
f
CWlink
fP
field
and
the
f
CWinfo
fP
field
For
an
Elf
object
file
these
values
should
be
appropriate
Elf
section
header
values
For
example
for
relocation
callbacks
the
f
CWlink
fP
field
is
supposed
to
be
set
by
the
app
to
the
index
of
the
symtab
section
the
link
field
passed
through
the
callback
must
be
ignored
by
the
app
And
for
relocation
callbacks
the
f
CWinfo
fP
field
is
passed
as
the
elf
section
number
of
the
section
the
relocations
apply
to
P
The
f
CWsect_name_index
fP
field
is
a
field
you
use
to
pass
a
symbol
index
back
to
libdwarf
In
Elf
each
section
gets
an
elf
symbol
table
entry
so
that
relocations
have
an
address
to
refer
to
relocations
rely
on
addresses
in
the
Elf
symbol
table
You
will
create
the
Elf
symbol
table
so
you
have
to
tell
libdwarf
the
index
to
put
into
relocation
records
for
the
section
newly
defined
here
P
On
success
the
user
function
should
return
the
Elf
section
number
of
the
newly
created
Elf
section
P
On
success
the
function
should
also
set
the
integer
pointed
to
by
f
CWsect_name_index
fP
to
the
Elf
symbol
number
assigned
in
the
Elf
symbol
table
of
the
new
Elf
section
This
symbol
number
is
needed
with
relocations
dependent
on
the
relocation
of
this
new
section
P
Use
the
f
CWdwarf_producer_init_c
fP
interface
instead
of
this
interface
P
For
example
the
f
CW
debug_line
fP
section
s
third
data
element
in
a
compilation
unit
is
the
offset
from
the
beginning
of
the
f
CW
debug_info
fP
section
of
the
compilation
unit
entry
for
this
f
CW
debug_line
fP
set
The
relocation
entry
in
f
CW
rel
debug_line
fP
for
this
offset
must
have
the
relocation
symbol
index
of
the
symbol
f
CW
debug_info
fP
returned
by
the
callback
of
that
section
creation
through
the
pointer
f
CWsect_name_index
fP
P
On
failure
the
function
should
return
and
set
the
f
CWerror
fP
integer
to
an
error
code
P
Nothing
in
libdwarf
actually
depends
on
the
section
index
returned
being
a
real
Elf
section
The
Elf
section
is
simply
useful
for
generating
relocation
records
Similarly
the
Elf
symbol
table
index
returned
through
the
f
CWsect_name_index
fP
must
be
an
index
that
can
be
used
in
relocations
against
this
section
The
application
will
probably
want
to
note
the
values
passed
to
this
function
in
some
form
even
if
no
Elf
file
is
being
produced
P
f
CWerrhand
fP
is
a
pointer
to
a
function
that
will
be
used
as
a
default
fall
back
function
for
handling
errors
detected
by
f
CWLibdwarf
fP
P
f
CWerrarg
fP
is
the
default
error
argument
used
by
the
function
pointed
to
by
f
CWerrhand
fP
P
For
historical
reasons
the
error
handling
is
complicated
and
the
following
three
paragraphs
describe
the
three
possible
scenarios
when
a
producer
function
detects
an
error
In
all
cases
a
short
error
message
is
printed
on
stdout
if
the
error
number
is
negative
as
all
such
should
be
see
libdwarf
h
Then
further
action
is
taken
as
follows
P
First
if
the
Dwarf_Error
argument
to
any
specific
producer
function
see
the
functions
documented
below
is
non
null
the
f
CWerrhand
fP
argument
here
is
ignored
in
that
call
and
the
specific
producer
function
sets
the
Dwarf_Error
and
returns
some
specific
value
for
dwarf_producer_init
it
is
DW_DLV_OK
as
mentioned
just
above
indicating
there
is
an
error
P
Second
if
the
Dwarf_Error
argument
to
any
specific
producer
function
see
the
functions
documented
below
is
NULL
and
the
f
CWerrarg
fP
to
f
CWdwarf_producer_init
fP
is
non
NULL
then
on
an
error
in
the
producer
code
the
Dwarf_Handler
function
is
called
and
if
that
called
function
returns
the
producer
code
returns
a
specific
value
for
dwarf_producer_init
it
is
DW_DLV_OK
as
mentioned
just
above
indicating
there
is
an
error
P
Third
if
the
Dwarf_Error
argument
to
any
specific
producer
function
see
the
functions
documented
below
is
NULL
and
the
f
CWerrarg
fP
to
f
CWdwarf_producer_init
fP
is
NULL
then
on
an
error
f
CWabort
fP
is
called
P
The
f
CWuser_data
fP
argument
is
not
examined
by
libdwarf
It
is
passed
to
user
code
in
all
calls
by
libdwarf
to
the
f
CWDwarf_Callback_Func
fP
function
and
may
be
used
by
consumer
code
for
the
consumer
s
own
purposes
Typical
uses
might
be
to
pass
in
a
pointer
to
some
user
data
structure
or
to
pass
an
integer
that
somehow
is
useful
to
the
libdwarf
using
code
P
The
f
CWisa_name
fP
argument
must
be
non
null
and
contain
one
of
the
strings
defined
in
the
isa_relocs
array
in
pro_init
c
irix
mips
x86
x86_64
arm
arm64
ppc
ppc64
sparc
The
names
are
not
strictly
ISA
names
nor
ABI
names
but
a
hopefully
meaningful
mixing
of
the
concepts
of
ISA
and
ABI
The
intent
is
mainly
to
define
relocation
codes
applicable
to
DW_DLC_STREAM_RELOCATIONS
New
f
CWisa_name
fP
values
will
be
provided
as
users
request
In
the
irix
case
a
special
relocation
is
defined
so
a
special
CIE
reference
field
can
be
created
if
and
only
if
the
augmentation
string
is
z
P
The
f
CWdwarf_version
fP
argument
should
be
one
of
V2
V3
V4
V5
to
indicate
which
DWARF
version
is
the
overall
format
to
be
emitted
Individual
section
version
numbers
will
obey
the
standard
for
that
overall
DWARF
version
P
The
f
CWextra
fP
argument
is
supports
a
comma
separated
list
of
options
Passing
in
a
null
pointer
or
an
empty
string
is
acceptable
if
no
such
options
are
needed
or
used
All
lowercase
option
names
are
reserved
to
the
libdwarf
implementation
itself
specific
implementations
may
want
to
use
a
leading
upper
case
letter
for
additional
options
P
The
available
options
are
DS
default_is_stmt
address_size
minimum_instruction_length
maximum_operations_per_instruction
opcode_base
line_base
line_range
linetable_version
segment_selector_size
and
segment_size
DE
P
For
example
to
set
the
line
table
generation
default
value
of
is_stmt
to
pass
in
DS
default_is_stmt
DE
To
also
set
the
minimum_instruction_length
used
in
calculating
line
table
address
advance
values
to
one
one
would
pass
in
DS
default_is_stmt
minimum_instruction_length
DE
It
s
appropriate
to
add
DS
opcode_base
DE
for
DWARF3
through
DWARF5
All
these
default
to
something
but
the
something
depends
on
environment
what
macro
names
are
set
by
the
environment
or
a
just
constants
which
makes
it
difficult
to
alter
these
values
See
pro_line
h
for
the
use
of
line
table
related
constants
which
will
vary
depending
on
the
target
ISA
and
ABI
and
compilers
P
The
f
CWerror
fP
argument
is
set
through
the
pointer
to
return
specific
error
if
f
CWerror
fP
is
non
null
and
and
there
is
an
error
The
error
details
will
be
passed
back
through
this
pointer
argument
H
dwarf_pro_set_default_string_form
DS
f
CWint
dwarf_pro_set_default_string_form
Dwarf_P_Debug
dbg
int
desired_form
Dwarf_Error
error
fP
DE
P
The
function
f
CWdwarf_pro_set_default_string_form
fP
sets
the
f
CWDwarf_P_Debug
fP
descriptor
to
favor
one
of
the
two
allowed
values
f
CWDW_FORM_string
fP
the
default
or
f
CWDW_FORM_strp
fP
P
When
f
CWDW_FORM_strp
fP
is
selected
very
short
names
will
still
use
form
f
CWDW_FORM_string
fP
P
The
function
should
be
called
immediately
after
a
successful
call
to
f
CWdwarf_producer_init
fP
P
Strings
for
f
CWDW_FORM_strp
fP
are
not
duplicated
in
the
f
CW
debug_str
fP
section
each
unique
string
appears
exactly
once
P
On
success
it
returns
f
CWDW_DLV_OK
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_transform_to_disk_form_a
DS
f
CWint
dwarf_transform_to_disk_form_a
Dwarf_P_Debug
dbg
Dwarf_Signed
chunk_count_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_transform_to_disk_form_a
fP
is
new
in
September
It
produces
the
same
result
as
f
CWdwarf_transform_to_disk_form
fP
but
returns
the
count
through
the
new
pointer
argument
f
CWchunk_count_out
fP
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CWchunk_count_out
fP
to
the
number
of
chunks
of
section
data
to
be
accessed
by
f
CWdwarf_get_section_bytes_a
fP
P
It
turns
the
DIE
and
other
information
specified
for
this
f
CWDwarf_P_Debug
fP
into
a
stream
of
bytes
for
each
section
being
produced
These
byte
streams
can
be
retrieved
from
the
f
CWDwarf_P_Debug
fP
by
calls
to
f
CWdwarf_get_section_bytes_a
fP
see
below
P
In
case
of
error
f
CWdwarf_transform_to_disk_form_a
fP
returns
f
CWDW_DLV_ERROR
fP
P
The
number
of
chunks
is
used
to
access
data
by
f
CWdwarf_get_section_bytes_a
fP
see
below
and
the
section
data
provided
your
code
will
insert
into
an
object
file
or
the
like
Each
section
of
the
resulting
object
is
typically
many
small
chunks
Each
chunk
has
a
section
index
and
a
length
as
well
as
a
pointer
to
a
block
of
data
see
f
CWdwarf_get_section_bytes_a
fP
P
For
each
unique
section
being
produced
f
CWdwarf_transform_to_disk_form_a
fP
calls
the
f
CWDwarf_Callback_Func
fP
exactly
once
The
callback
provides
the
connection
between
Elf
sections
which
we
presume
is
the
object
format
to
be
emitted
and
the
f
CWlibdwarf
fP
internal
section
numbering
P
For
f
CWDW_DLC_STREAM_RELOCATIONS
fP
a
call
to
f
CWDwarf_Callback_Func
fP
is
made
by
libdwarf
for
each
relocation
section
Calls
to
f
CWdwarf_get_section_bytes_a
fP
see
below
allow
the
f
CWdwarf_transform_to_disk_form_a
fP
caller
to
get
byte
streams
and
write
them
to
an
object
file
as
desired
just
as
with
the
other
sections
of
the
object
being
created
P
For
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
the
user
code
should
use
f
CWdwarf_get_relocation_info_count
fP
and
f
CWdwarf_get_relocation_info
fP
to
retrieve
the
relocation
info
generated
by
f
CWdwarf_transform_to_disk_form
fP
and
do
something
with
it
P
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
and
returns
an
error
pointer
through
f
CW
error
fP
H
dwarf_transform_to_disk_form
DS
f
CWDwarf_Signed
dwarf_transform_to_disk_form
Dwarf_P_Debug
dbg
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_transform_to_disk_form
fP
is
the
original
call
to
generate
output
and
a
better
interface
is
used
by
f
CWdwarf_transform_to_disk_form_a
fP
though
both
do
the
same
work
and
have
the
same
meaning
H
dwarf_get_section_bytes_a
DS
f
CWint
dwarf_get_section_bytes_a
Dwarf_P_Debug
dbg
Dwarf_Signed
dwarf_section
Dwarf_Signed
elf_section_index
Dwarf_Unsigned
length
Dwarf_Ptr
section_bytes
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_section_bytes_a
fP
must
be
called
repetitively
with
the
index
f
CWdwarf_section
fP
starting
at
and
continuing
for
the
number
of
sections
returned
by
f
CWdwarf_transform_to_disk_form_a
fP
P
It
returns
f
CWDW_DLV_NO_ENTRY
fP
to
indicate
that
there
are
no
more
sections
of
f
CWDwarf
fP
information
Normally
one
would
index
through
using
the
sectioncount
from
dwarf_transform_to_disk_form_a
so
f
CWDW_DLV_NO_ENTRY
fP
would
never
be
seen
For
each
successful
return
return
value
f
CWDW_DLV_OK
fP
f
CW
section_bytes
fP
points
to
f
CW
length
fP
bytes
of
data
that
are
normally
added
to
the
output
object
in
f
CWElf
fP
section
f
CW
elf_section
fP
by
the
producer
application
It
is
illegal
to
call
these
in
any
order
other
than
through
N
where
N
is
the
number
of
dwarf
sections
returned
by
f
CWdwarf_transform_to_disk_form_a
fP
The
elf
section
number
is
returned
through
the
pointer
f
CWelf_section_index
fP
The
f
CWdwarf_section
fP
number
is
ignored
the
data
is
returned
as
if
the
caller
passed
in
the
correct
dwarf_section
numbers
in
the
required
sequence
P
In
case
of
an
error
f
CWDW_DLV_ERROR
fP
is
returned
and
the
f
CWerror
fP
argument
is
set
to
indicate
the
error
P
There
is
no
requirement
that
the
section
bytes
actually
be
written
to
an
elf
file
For
example
consider
the
debug_info
section
and
its
relocation
section
the
call
back
function
would
resulted
in
assigning
section
numbers
and
the
link
field
to
tie
these
together
rel
debug_info
would
have
a
link
to
debug_info
One
could
examine
the
relocations
split
the
debug_info
data
at
relocation
boundaries
emit
byte
streams
in
hex
as
assembler
output
and
at
each
relocation
point
emit
an
assembler
directive
with
a
symbol
name
for
the
assembler
Examining
the
relocations
is
awkward
though
It
is
much
better
to
use
f
CWdwarf_get_section_relocation_info
fP
P
The
memory
space
of
the
section
byte
stream
is
freed
by
the
f
CWdwarf_producer_finish_a
fP
call
or
would
be
if
the
f
CWdwarf_producer_finish_a
fP
was
actually
correct
along
with
all
the
other
space
in
use
with
that
Dwarf_P_Debug
H
dwarf_get_relocation_info_count
DS
f
CWint
dwarf_get_relocation_info_count
Dwarf_P_Debug
dbg
Dwarf_Unsigned
count_of_relocation_sections
int
drd_buffer_version
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_relocation_info
fP
returns
through
the
pointer
f
CWcount_of_relocation_sections
fP
the
number
of
times
that
f
CWdwarf_get_relocation_info
fP
should
be
called
The
function
f
CWdwarf_get_relocation_info
fP
returns
DW_DLV_OK
if
the
call
was
successful
the
f
CWcount_of_relocation_sections
fP
is
therefore
meaningful
though
f
CWcount_of_relocation_sections
fP
could
be
zero
f
CW
drd_buffer_version
fP
is
the
value
If
the
structure
pointed
to
by
the
f
CW
reldata_buffer
fP
changes
this
number
will
change
The
application
should
verify
that
the
number
is
the
version
it
understands
that
it
matches
the
value
of
DWARF_DRD_BUFFER_VERSION
from
libdwarf
h
The
value
version
was
never
used
in
production
MIPS
libdwarf
version
did
exist
in
source
It
returns
DW_DLV_NO_ENTRY
if
f
CWcount_of_relocation_sections
fP
is
not
meaningful
because
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
was
not
passed
to
the
f
CWdwarf_producer_init_c
fP
f
CWdwarf_producer_init_b
fP
or
f
CWdwarf_producer_init
fP
call
whichever
one
was
used
It
returns
DW_DLV_ERROR
if
there
was
an
error
in
which
case
f
CWcount_of_relocation_sections
fP
is
not
meaningful
H
dwarf_get_relocation_info
DS
f
CWint
dwarf_get_relocation_info
Dwarf_P_Debug
dbg
Dwarf_Signed
elf_section_index
Dwarf_Signed
elf_section_index_link
Dwarf_Unsigned
relocation_buffer_count
Dwarf_Relocation_Data
reldata_buffer
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_relocation_info
fP
should
normally
be
called
repetitively
for
the
number
of
relocation
sections
that
f
CWdwarf_get_relocation_info_count
fP
indicated
exist
It
returns
f
CWDW_DLV_OK
fP
to
indicate
that
valid
values
are
returned
through
the
pointer
arguments
The
f
CWerror
fP
argument
is
not
set
It
returns
DW_DLV_NO_ENTRY
if
there
are
no
entries
the
count
of
relocation
arrays
is
zero
The
f
CWerror
fP
argument
is
not
set
It
returns
f
CWDW_DLV_ERROR
fP
if
there
is
an
error
Calling
f
CWdwarf_get_relocation_info
fP
more
than
the
number
of
times
indicated
by
f
CWdwarf_get_relocation_info_count
fP
without
an
intervening
call
to
f
CWdwarf_reset_section_bytes
fP
results
in
a
return
of
f
CWDW_DLV_ERROR
fP
once
past
the
valid
count
The
f
CWerror
fP
argument
is
set
to
indicate
the
error
Now
consider
the
returned
through
pointer
values
for
f
CWDW_DLV_OK
fP
f
CW
elf_section_index
fP
is
the
elf
section
index
of
the
section
implied
by
this
group
of
relocations
f
CW
elf_section_index_link
fP
is
the
section
index
of
the
section
that
these
relocations
apply
to
f
CW
relocation_buffer_count
fP
is
the
number
of
array
entries
of
relocation
information
in
the
array
pointed
to
by
f
CW
reldata_buffer
fP
f
CW
reldata_buffer
fP
points
to
an
array
of
struct
Dwarf_Relocation_Data_s
structures
The
version
array
information
is
as
follows
nf
enum
Dwarf_Rel_Type
dwarf_drt_none
dwarf_drt_data_reloc
dwarf_drt_segment_rel
dwarf_drt_first_of_length_pair
dwarf_drt_second_of_length_pair
typedef
struct
Dwarf_Relocation_Data_s
Dwarf_Relocation_Data
struct
Dwarf_Relocation_Data_s
unsigned
char
drd_type
contains
Dwarf_Rel_Type
unsigned
char
drd_length
typically
or
Dwarf_Unsigned
drd_offset
where
the
data
to
reloc
is
Dwarf_Unsigned
drd_symbol_index
fi
The
f
CWDwarf_Rel_Type
fP
enum
is
encoded
via
casts
if
necessary
into
the
single
unsigned
char
f
CWdrd_type
fP
field
to
control
the
space
used
for
this
information
keep
the
space
to
byte
The
unsigned
char
f
CWdrd_length
fP
field
holds
the
size
in
bytes
of
the
field
to
be
relocated
So
for
elf32
object
formats
with
bit
apps
f
CWdrd_length
fP
will
be
For
objects
with
MIPS
contents
f
CWdrd_length
fP
will
be
For
some
dwarf
bit
environments
such
as
ia64
f
CWdrd_length
fP
is
for
some
relocations
file
offsets
for
example
and
for
others
run
time
addresses
for
example
If
f
CWdrd_type
fP
is
f
CWdwarf_drt_none
fP
this
is
an
unused
slot
and
it
should
be
ignored
If
f
CWdrd_type
fP
is
f
CWdwarf_drt_data_reloc
fP
this
is
an
ordinary
relocation
The
relocation
type
means
either
R_MIPS_64
or
R_MIPS_32
or
the
like
for
the
particular
ABI
f
CWdrd_length
fP
gives
the
length
of
the
field
to
be
relocated
f
CWdrd_offset
fP
is
an
offset
of
the
value
to
be
relocated
in
the
section
this
relocation
stuff
is
linked
to
f
CWdrd_symbol_index
fP
is
the
symbol
index
if
elf
symbol
indices
were
provided
or
the
handle
to
arbitrary
information
if
that
is
what
the
caller
passed
in
to
the
relocation
creating
dwarf
calls
of
the
symbol
that
the
relocation
is
relative
to
When
f
CWdrd_type
fP
is
f
CWdwarf_drt_first_of_length_pair
fP
the
next
data
record
will
be
f
CWdrt_second_of_length_pair
fP
and
the
f
CWdrd_offset
fP
of
the
two
data
records
will
match
The
relevant
offset
in
the
section
this
reloc
applies
to
should
contain
a
symbolic
pair
like
nf
in
word
second_symbol
first_symbol
in
fi
to
generate
a
length
f
CWdrd_length
fP
gives
the
length
of
the
field
to
be
relocated
f
CWdrt_segment_rel
fP
means
R_MIPS_SCN_DISP
is
the
real
relocation
R_MIPS_SCN_DISP
applies
to
exception
tables
and
this
part
may
need
further
work
f
CWdrd_length
fP
gives
the
length
of
the
field
to
be
relocated
P
The
memory
space
of
the
section
byte
stream
is
freed
by
the
f
CWdwarf_producer_finish_a
fP
call
or
would
be
if
the
f
CWdwarf_producer_finish_a
fP
was
actually
correct
along
with
all
the
other
space
in
use
with
that
Dwarf_P_Debug
H
dwarf_reset_section_bytes
DS
f
CWvoid
dwarf_reset_section_bytes
Dwarf_P_Debug
dbg
fP
DE
The
function
f
CWdwarf_reset_section_bytes
fP
is
used
to
reset
the
internal
information
so
that
f
CWdwarf_get_section_bytes_a
fP
will
begin
on
the
next
call
at
the
initial
dwarf
section
again
It
also
resets
so
that
calls
to
f
CWdwarf_get_relocation_info
fP
will
begin
again
at
the
initial
array
of
relocation
information
Some
dwarf
producers
need
to
be
able
to
run
through
the
f
CWdwarf_get_section_bytes_a
fP
and
or
the
f
CWdwarf_get_relocation_info
fP
calls
more
than
once
and
this
call
makes
additional
passes
possible
The
set
of
Dwarf_Ptr
values
returned
is
identical
to
the
set
returned
by
the
first
pass
It
is
acceptable
to
call
this
before
finishing
a
pass
of
f
CWdwarf_get_section_bytes_a
fP
or
f
CWdwarf_get_relocation_info
fP
calls
No
errors
are
possible
as
this
just
resets
some
internal
pointers
It
is
unwise
to
call
this
before
f
CWdwarf_transform_to_disk_form
fP
has
been
called
P
H
dwarf_pro_get_string_stats
DS
f
CWint
dwarf_pro_get_string_stats
Dwarf_P_Debug
dbg
Dwarf_Unsigned
str_count
Dwarf_Unsigned
str_total_length
Dwarf_Unsigned
strp_count_debug_str
Dwarf_Unsigned
strp_len_debug_str
Dwarf_Unsigned
strp_reused_count
Dwarf_Unsigned
strp_reused_len
Dwarf_Error
error
fP
DE
If
it
returns
f
CWDW_DLV_OK
fP
the
function
f
CWdwarf_pro_get_string_stats
fP
returns
information
about
how
f
CWDW_AT_name
fP
etc
strings
were
stored
in
the
output
object
The
values
suggest
how
much
string
duplication
was
detected
in
the
DWARF
being
created
P
Call
it
after
calling
f
CWdwarf_transform_to_disk_form
fP
and
before
calling
f
CWdwarf_producer_finish_a
fP
It
has
no
effect
on
the
object
being
output
P
On
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
through
the
pointer
H
dwarf_producer_finish_a
DS
f
CWint
dwarf_producer_finish_a
Dwarf_P_Debug
dbg
Dwarf_Error
error
fP
DE
This
is
new
in
September
and
has
the
newer
interface
style
but
is
otherwise
identical
to
f
CWdwarf_producer_finish
fP
P
The
function
f
CWdwarf_producer_finish_a
fP
should
be
called
after
all
the
bytes
of
data
have
been
copied
somewhere
normally
the
bytes
are
written
to
disk
It
frees
all
dynamic
space
allocated
for
f
CWdbg
fP
include
space
for
the
structure
pointed
to
by
f
CWdbg
fP
This
should
not
be
called
till
the
data
have
been
copied
or
written
to
disk
or
are
no
longer
of
interest
It
returns
f
CWDW_DLV_OK
fP
if
successful
P
On
error
it
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
through
the
pointer
H
Debugging
Information
Entry
Creation
The
functions
in
this
section
add
new
f
CWDIE
fPs
to
the
object
and
also
the
relationships
among
the
f
CWDIE
fP
to
be
specified
by
linking
them
up
as
parents
children
left
or
right
siblings
of
each
other
In
addition
there
is
a
function
that
marks
the
root
of
the
graph
thus
created
H
dwarf_add_die_to_debug_a
DS
f
CWint
dwarf_add_die_to_debug_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
first_die
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_die_to_debug_a
fP
indicates
to
f
CWLibdwarf
fP
the
root
f
CWDIE
fP
of
the
f
CWDIE
fP
graph
that
has
been
built
so
far
It
is
intended
to
mark
the
compilation
unit
f
CWDIE
fP
for
the
object
represented
by
f
CWdbg
fP
The
root
f
CWDIE
fP
is
specified
by
f
CWfirst_die
fP
P
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_error
fP
on
error
H
dwarf_new_die_a
DS
f
CWint
dwarf_new_die_a
Dwarf_P_Debug
dbg
Dwarf_Tag
new_tag
Dwarf_P_Die
parent
Dwarf_P_Die
child
Dwarf_P_Die
left_sibling
Dwarf_P_Die
right_sibling
Dwarf_P_Die
die_out
Dwarf_Error
error
fP
DE
On
success
f
CWdwarf_new_die_a
fP
returns
DW_DLV_OK
and
creates
a
new
f
CWDIE
fP
with
its
parent
child
left
sibling
and
right
sibling
f
CWDIE
fPs
specified
by
f
CWparent
fP
f
CWchild
fP
f
CWleft_sibling
fP
and
f
CWright_sibling
fP
respectively
The
new
die
is
passed
to
the
caller
via
the
argument
f
CWdie_out
fP
There
is
no
requirement
that
all
of
these
f
CWDIE
fPs
be
specified
i
e
any
of
these
descriptors
may
be
f
CWNULL
fP
If
none
is
specified
this
will
be
an
isolated
f
CWDIE
fP
A
f
CWDIE
fP
is
transformed
to
disk
form
by
f
CWdwarf_transform_to_disk_form
fP
only
if
there
is
a
path
from
the
f
CWDIE
fP
specified
by
f
CWdwarf_add_die_to_debug
fP
to
it
P
The
value
of
f
CWnew_tag
fP
is
the
tag
which
is
given
to
the
new
f
CWDIE
fP
f
CWparent
fP
f
CWchild
fP
f
CWleft_sibling
fP
and
f
CWright_sibling
fP
are
pointers
to
establish
links
to
existing
f
CWDIE
fPs
Only
one
of
f
CWparent
fP
f
CWchild
fP
f
CWleft_sibling
fP
and
f
CWright_sibling
fP
may
be
non
NULL
If
f
CWparent
fP
f
CWchild
fP
is
given
the
f
CWDIE
fP
is
linked
into
the
list
after
before
the
f
CWDIE
fP
pointed
to
If
f
CWleft_sibling
fP
f
CWright_sibling
fP
is
given
the
f
CWDIE
fP
is
linked
into
the
list
after
before
the
f
CWDIE
fP
pointed
to
P
To
add
attributes
to
the
new
f
CWDIE
fP
use
the
f
CWAttribute
Creation
fP
functions
defined
in
the
next
section
P
On
failure
f
CWdwarf_new_die_a
fP
returns
DW_DLV_ERROR
and
sets
f
CW
error
fP
H
dwarf_die_link_a
DS
f
CWint
dwarf_die_link_a
Dwarf_P_Die
die
Dwarf_P_Die
parent
Dwarf_P_Die
child
Dwarf_P_Die
left
sibling
Dwarf_P_Die
right_sibling
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_die_link_a
fP
returns
f
CWDW_DLV_OK
fP
and
links
an
existing
f
CWDIE
fP
described
by
the
given
f
CWdie
fP
to
other
existing
f
CWDIE
fPs
The
given
f
CWdie
fP
can
be
linked
to
a
parent
f
CWDIE
fP
a
child
f
CWDIE
fP
a
left
sibling
f
CWDIE
fP
or
a
right
sibling
f
CWDIE
fP
by
specifying
non
NULL
f
CWparent
fP
f
CWchild
fP
f
CWleft_sibling
fP
and
f
CWright_sibling
fP
f
CWDwarf_P_Die
fP
descriptors
Only
one
of
f
CWparent
fP
f
CWchild
fP
f
CWleft_sibling
fP
and
f
CWright_sibling
fP
may
be
non
NULL
If
f
CWparent
fP
f
CWchild
fP
is
given
the
f
CWDIE
fP
is
linked
into
the
list
after
before
the
f
CWDIE
fP
pointed
to
If
f
CWleft_sibling
fP
f
CWright_sibling
fP
is
given
the
f
CWDIE
fP
is
linked
into
the
list
after
before
the
f
CWDIE
fP
pointed
to
Non
NULL
links
overwrite
the
corresponding
links
the
given
f
CWdie
fP
may
have
had
before
the
call
to
f
CWdwarf_die_link_a
fP
If
there
is
an
error
f
CWdwarf_die_link_a
fP
returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
with
the
specific
applicable
error
code
H
DIE
Markers
DIE
markers
provide
a
way
for
a
producer
to
extract
DIE
offsets
from
DIE
generation
The
markers
do
not
influence
the
generation
of
DWARF
they
simply
allow
a
producer
to
extract
debug_info
offsets
for
whatever
purpose
the
producer
finds
useful
for
example
a
producer
might
want
some
unique
other
section
unknown
to
libdwarf
to
know
a
particular
DIE
offset
One
marks
one
or
more
DIEs
as
desired
any
time
before
calling
f
CWdwarf_transform_to_disk_form
fP
After
calling
f
CWdwarf_transform_to_disk_form
fP
call
f
CWdwarf_get_die_markers
fP
which
has
the
offsets
where
the
marked
DIEs
were
written
in
the
generated
debug_info
data
H
dwarf_add_die_marker_a
DS
f
CWint
dwarf_add_die_marker_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
Dwarf_Unsigned
marker
Dwarf_Error
error
fP
DE
This
is
preferred
over
f
CWdwarf_add_die_marker
fP
The
function
f
CWdwarf_add_die_marker_a
fP
writes
the
value
f
CWmarker
fP
to
the
f
CWDIE
fP
descriptor
given
by
f
CWdie
fP
Passing
in
a
marker
of
means
there
is
no
marker
zero
is
the
default
in
DIEs
It
returns
f
CWDW_DLV_OK
fP
on
success
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_get_die_marker_a
DS
f
CWint
dwarf_get_die_marker_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
Dwarf_Unsigned
marker
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_die_marker_a
fP
returns
the
current
marker
value
for
this
DIE
through
the
pointer
f
CWmarker
fP
A
marker
value
of
means
no
marker
was
set
It
returns
f
CWDW_DLV_OK
fP
on
success
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_get_die_markers_a
DS
f
CWint
dwarf_get_die_markers_a
Dwarf_P_Debug
dbg
Dwarf_P_Marker
marker_list
Dwarf_Unsigned
marker_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_die_markers_a
fP
returns
a
pointer
to
an
array
of
f
CWDwarf_P_Marker
fP
pointers
to
f
CWstruct
Dwarf_P_Marker_s
fP
structures
through
the
pointer
f
CWmarker_list
fP
The
array
length
is
returned
through
the
pointer
f
CWmarker_count
fP
The
call
is
only
meaningful
after
a
call
to
f
CWdwarf_transform_to_disk_form
fP
as
the
transform
call
creates
the
f
CWstruct
Dwarf_P_Marker_s
fP
structures
one
for
each
DIE
generated
for
debug_info
but
only
for
DIEs
that
had
a
non
zero
marker
value
The
field
f
CWma_offset
fP
in
the
structure
is
set
during
generation
of
the
debug_info
byte
stream
The
field
f
CWma_marker
fP
in
the
structure
is
a
copy
of
the
DIE
marker
of
the
DIE
given
that
offset
It
returns
f
CWDW_DLV_OK
fP
on
success
On
error
it
returns
f
CWDW_DLV_ERROR
fP
if
there
are
no
markers
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_get_die_markers
DS
f
CWDwarf_Signed
dwarf_get_die_markers
Dwarf_P_Debug
dbg
Dwarf_P_Marker
marker_list
Dwarf_Unsigned
marker_count
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_get_die_marker
fP
returns
a
pointer
to
an
array
of
f
CWDwarf_P_Marker
fP
pointers
to
f
CWstruct
Dwarf_P_Marker_s
fP
structures
through
the
pointer
f
CWmarker_list
fP
The
array
length
is
returned
through
the
pointer
f
CWmarker_count
fP
The
call
is
only
meaningful
after
a
call
to
f
CWdwarf_transform_to_disk_form
fP
as
the
transform
call
creates
the
f
CWstruct
Dwarf_P_Marker_s
fP
structures
one
for
each
DIE
generated
for
debug_info
but
only
for
DIEs
that
had
a
non
zero
marker
value
The
field
f
CWma_offset
fP
in
the
structure
is
set
during
generation
of
the
debug_info
byte
stream
The
field
f
CWma_marker
fP
in
the
structure
is
a
copy
of
the
DIE
marker
of
the
DIE
given
that
offset
It
returns
f
CW0
fP
on
success
On
error
it
returns
f
CWDW_DLV_BADADDR
fP
if
there
are
no
markers
it
returns
f
CWDW_DLV_BADADDR
fP
H
Attribute
Creation
The
functions
in
this
section
add
attributes
to
a
f
CWDIE
fP
These
functions
return
a
f
CWDwarf_P_Attribute
fP
descriptor
that
represents
the
attribute
added
to
the
given
f
CWDIE
fP
In
most
cases
the
return
value
is
only
useful
to
determine
if
an
error
occurred
Some
of
the
attributes
have
values
that
are
relocatable
They
need
a
symbol
with
respect
to
which
the
linker
will
perform
relocation
This
symbol
is
specified
by
means
of
an
index
into
the
Elf
symbol
table
for
the
object
of
course
the
symbol
index
can
be
more
general
than
an
index
H
dwarf_add_AT_location_expr_a
DS
f
CWint
dwarf_add_AT_location_expr_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_P_Expr
loc_expr
Dwarf_P_Attr
attr_out
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_add_AT_location_expr_a
fP
returns
f
CWDW_DLV_OK
fP
and
adds
the
attribute
specified
by
f
CWattr
fP
to
the
f
CWDIE
fP
descriptor
given
by
f
CWownerdie
fP
The
new
attribute
is
passed
back
to
the
caller
through
the
pointer
f
CWattr_out
fP
The
attribute
should
be
one
that
has
a
location
expression
as
its
value
The
location
expression
that
is
the
value
is
represented
by
the
f
CWDwarf_P_Expr
fP
descriptor
f
CWloc_expr
fP
If
the
expression
has
a
f
CWDW_OP_addr
fP
the
code
simply
assumes
that
f
CWDW_OP_addr
fP
is
the
first
operation
and
bases
the
only
relocation
that
can
be
created
on
that
assumption
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_name_a
DS
f
CWint
dwarf_add_AT_name_a
Dwarf_P_Die
ownerdie
char
name
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_name_a
fP
adds
the
string
specified
by
f
CWname
fP
as
the
value
of
the
f
CWDW_AT_name
fP
attribute
for
the
given
f
CWDIE
fP
f
CWownerdie
fP
It
returns
DW_DLV_OK
on
success
and
assigns
the
new
attribute
descriptor
to
f
CW
attr_out
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
and
does
not
set
f
CW
attr_out
fP
H
dwarf_add_AT_comp_dir_a
DS
f
CWint
dwarf_add_AT_comp_dir_a
Dwarf_P_Die
ownerdie
char
current_working_directory
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_comp_dir_a
fP
adds
the
string
given
by
f
CWcurrent_working_directory
fP
as
the
value
of
the
f
CWDW_AT_comp_dir
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
attr_out
fP
to
the
new
attribute
P
On
error
it
returns
f
CWDW_DLV_ERROR
fP
and
does
not
touch
f
CWattr_out
fP
H
dwarf_add_AT_producer_a
DS
f
CWint
dwarf_add_AT_producer_a
Dwarf_P_Die
ownerdie
char
producer_string
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_producer_a
fP
adds
the
string
given
by
f
CWproducer_string
fP
as
the
value
of
the
f
CWDW_AT_producer
fP
attribute
for
the
f
CWDIE
fP
given
by
f
CWownerdie
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
the
new
attribute
descriptor
representing
this
attribute
through
the
pointer
argument
f
CWattr_out
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_any_value_sleb_a
DS
f
CWint
dwarf_add_AT_any_value_sleb_a
Dwarf_P_Die
ownerdie
Dwarf_Half
attrnum
Dwarf_Signed
signed_value
Dwarf_P_Attribute
out_attr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_any_value_sleb_a
fP
adds
the
given
f
CWDwarf_Signed
fP
value
f
CWsigned_value
fP
as
the
value
of
the
f
CWDW_AT_const_value
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
The
FORM
of
the
output
value
is
f
CWDW_FORM_sdata
fP
signed
leb
number
and
the
attribute
will
be
f
CWDW_AT_const_value
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
out_attr
fP
to
the
created
attribute
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_const_value_signedint_a
DS
f
CWint
dwarf_add_AT_const_value_signedint_a
Dwarf_P_Die
ownerdie
Dwarf_Signed
signed_value
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_const_value_signedint_a
fP
adds
the
given
f
CWDwarf_Signed
fP
value
f
CWsigned_value
fP
as
the
value
of
the
f
CWDW_AT_const_value
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
The
FORM
of
the
output
value
is
f
CWDW_FORM_data
n
fP
signed
leb
number
and
the
attribute
will
be
f
CWDW_AT_const_value
fP
With
this
interface
and
output
there
is
no
way
for
consumers
to
know
from
the
FORM
that
the
value
is
signed
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
attr_out
to
the
created
attribute
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_implicit_const
DS
f
CWint
dwarf_add_AT_implicit_const
Dwarf_P_Die
ownerdie
Dwarf_Half
attrnum
Dwarf_Signed
signed_value
Dwarf_P_Attribute
outattr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_implicit_const
fP
creates
a
new
attribute
and
adds
the
signed
value
to
the
abbreviation
entry
for
this
new
attribute
and
attaches
the
new
attribute
to
the
DIE
passed
in
P
The
new
attribute
has
f
CWattrnum
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
The
f
CWform
fP
in
the
generated
attribute
is
f
CWDW_FORM_implicit_const
fP
The
f
CWsigned_value
fP
argument
will
be
inserted
in
the
abbreviation
table
as
a
signed
leb
value
P
For
a
successful
call
the
function
returns
f
CWDW_DLV_OK
fP
and
a
pointer
to
the
created
argument
is
returned
through
the
pointer
f
CWoutaddr
fP
P
In
case
of
error
the
function
returns
f
CWDW_DLV_ERROR
fP
and
no
attribute
is
created
H
dwarf_add_AT_any_value_uleb_a
DS
f
CWint
dwarf_add_AT_any_value_uleb_a
Dwarf_P_Die
ownerdie
Dwarf_Half
attrnum
Dwarf_Unsigned
unsigned_value
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_any_value_uleb_a
fP
adds
the
given
f
CWDwarf_Unsigned
fP
value
f
CWunsigned_value
fP
as
the
value
of
the
f
CWattrnum
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
The
FORM
of
the
output
value
is
f
CWDW_FORM_udata
fP
unsigned
leb
number
and
the
attribute
is
f
CWattrnum
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
attr_out
fP
to
the
newly
created
attribute
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_const_value_unsignedint_a
DS
f
CWint
dwarf_add_AT_const_value_unsignedint_a
Dwarf_P_Die
ownerdie
Dwarf_Unsigned
unsigned_value
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_const_value_unsignedint_a
fP
adds
the
given
f
CWDwarf_Unsigned
fP
value
f
CWunsigned_value
fP
as
the
value
of
the
f
CWDW_AT_const_value
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
The
FORM
of
the
output
value
is
f
CWDW_FORM_data
n
fP
and
the
attribute
will
be
f
CWDW_AT_const_value
fP
With
this
interface
and
output
there
is
no
way
for
consumers
to
know
from
the
FORM
that
the
value
is
signed
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
attr_out
fP
to
the
newly
created
attribute
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_const_value_string_a
DS
f
CWint
dwarf_add_AT_const_value_string_a
Dwarf_P_Die
ownerdie
char
string_value
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_const_value_string_a
fP
adds
the
string
value
given
by
f
CWstring_value
fP
as
the
value
of
the
f
CWDW_AT_const_value
fP
attribute
for
the
f
CWDIE
fP
described
by
the
given
f
CWownerdie
fP
P
On
success
it
returns
f
CWDW_DLV_OK
fP
f
CW
attr_out
fP
to
a
newly
created
attribute
P
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_targ_address_c
DS
f
CWint
dwarf_add_AT_targ_address_c
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Unsigned
pc_value
Dwarf_Unsigned
sym_index
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_targ_address_c
fP
is
identical
to
P
f
CWsym_index
fP
is
guaranteed
to
be
large
enough
that
it
can
contain
a
pointer
to
arbitrary
data
so
the
caller
can
pass
in
a
real
elf
symbol
index
an
arbitrary
number
or
a
pointer
to
arbitrary
data
The
ability
to
pass
in
a
pointer
through
f
CWsym_index
fP
is
only
usable
with
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
On
success
the
function
returns
f
CWDW_DLV_OK
fP
f
CWDwarf_P_Attribute
fP
and
f
CWpc_value
fP
is
put
into
the
section
stream
output
and
the
f
CWsym_index
fP
is
applied
to
the
relocation
information
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
Do
not
use
this
function
for
attr
f
CWDW_AT_high_pc
fP
if
the
value
to
be
recorded
is
an
offset
not
a
pc
use
f
CWdwarf_add_AT_unsigned_const_afP
or
f
CWdwarf_add_AT_any_value_uleb_afP
instead
On
failure
the
function
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_block_a
DS
f
CWint
dwarf_add_AT_block_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Small
block_data
Dwarf_Unsigned
block_size
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
DE
This
function
works
with
all
f
CWDW_FORM_block
fP
forms
as
well
as
f
CWDW_FORM_exprloc
fP
On
success
this
returns
f
CWDW_DLV_OK
fP
an
attribute
with
a
f
CWDW_FORM_block
fP
instance
does
not
create
f
CWDW_FORM_block1
fP
f
CWDW_FORM_block2
fP
or
f
CWDW_FORM_block4
fP
at
present
and
returns
a
pointer
to
the
new
attribute
through
the
pointer
f
CWattr_out
fP
On
failure
this
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_dataref_a
DS
f
CWint
dwarf_add_AT_dataref_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Unsigned
pc_value
Dwarf_Unsigned
sym_index
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
This
is
very
similar
to
f
CWdwarf_add_AT_targ_address_b
fP
but
results
in
a
different
FORM
results
in
DW_FORM_data4
or
DW_FORM_data8
Useful
for
adding
relocatable
addresses
in
location
lists
f
CWsym_index
fP
is
guaranteed
to
be
large
enough
that
it
can
contain
a
pointer
to
arbitrary
data
so
the
caller
can
pass
in
a
real
elf
symbol
index
an
arbitrary
number
or
a
pointer
to
arbitrary
data
The
ability
to
pass
in
a
pointer
through
f
CWsym_index
fP
is
only
usable
with
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
the
f
CWpc_value
fP
is
put
into
the
section
stream
output
and
the
f
CWsym_index
fP
is
applied
to
the
relocation
information
Do
not
use
this
function
for
f
CWDW_AT_high_pc
fP
use
f
CWdwarf_add_AT_unsigned_const
fP
or
f
CWdwarf_add_AT_any_value_uleb
fP
if
the
value
to
be
recorded
is
an
offset
of
f
CWDW_AT_low_pc
fP
or
f
CWdwarf_add_AT_targ_address_b
fP
if
the
value
to
be
recorded
is
an
address
H
dwarf_add_AT_ref_address_a
DS
f
CWint
dwarf_add_AT_ref_address_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Unsigned
pc_value
Dwarf_Unsigned
sym_index
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
This
is
very
similar
to
f
CWdwarf_add_AT_targ_address_c
fP
but
results
in
a
different
FORM
results
in
f
CWDW_FORM_ref_addr
fP
being
generated
Useful
for
f
CWDW_AT_type
fP
and
f
CWDW_AT_import
fP
attributes
f
CWsym_index
fP
is
guaranteed
to
be
large
enough
that
it
can
contain
a
pointer
to
arbitrary
data
so
the
caller
can
pass
in
a
real
elf
symbol
index
an
arbitrary
number
or
a
pointer
to
arbitrary
data
The
ability
to
pass
in
a
pointer
through
f
CWsym_index
fP
is
only
usable
with
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
f
CWpc_value
fP
is
put
into
the
section
stream
output
and
the
f
CWsym_index
fP
is
applied
to
the
relocation
information
On
failure
the
function
returns
f
CWDW_DLV_ERROR
fP
Do
not
use
this
function
for
f
CWDW_AT_high_pc
fP
H
dwarf_add_AT_unsigned_const_a
DS
f
CWint
dwarf_add_AT_unsigned_const_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Unsigned
value
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_unsigned_const_a
fP
adds
an
attribute
with
a
f
CWDwarf_Unsigned
fP
value
belonging
to
the
constant
class
to
the
f
CWDIE
fP
specified
by
f
CWownerdie
fP
The
object
that
the
f
CWDIE
fP
belongs
to
is
specified
by
f
CWdbg
fP
The
attribute
is
specified
by
f
CWattr
fP
and
its
value
is
specified
by
f
CWvalue
fP
The
FORM
of
the
output
will
be
one
of
the
f
CWDW_FORM_data
n
fP
forms
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
attr_out
fP
to
the
newly
created
attribute
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_add_AT_signed_const_a
DS
f
CWint
dwarf_add_AT_signed_const_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Signed
value
Dwarf_P_Attribute
out_addr
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_signed_const_a
fP
adds
an
attribute
with
a
f
CWDwarf_Signed
fP
value
belonging
to
the
constant
class
to
the
f
CWDIE
fP
specified
by
f
CWownerdie
fP
The
object
that
the
f
CWDIE
fP
belongs
to
is
specified
by
f
CWdbg
fP
The
attribute
is
specified
by
f
CWattr
fP
and
its
value
is
specified
by
f
CWvalue
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
out_addr
fP
with
a
pointer
to
the
new
attribute
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_reference_c
DS
f
CWint
dwarf_add_AT_reference_c
Dwarf_P_Debug
dbg
Dwarf_Half
attr
Dwarf_P_Die
ownerdie
Dwarf_P_Die
otherdie
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
f
CWdwarf_add_AT_reference_c
fP
accepts
a
NULL
f
CWotherdie
fP
with
the
assumption
that
f
CWdwarf_fixup_AT_reference_die
fP
will
be
called
by
user
code
to
fill
in
the
missing
f
CWotherdie
fP
before
the
DIEs
are
transformed
to
disk
form
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
a
pointer
to
the
new
attribute
through
f
CW
attr_out
fP
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_fixup_AT_reference_die
DS
f
CWint
dwarf_fixup_AT_reference_die
Dwarf_Half
attrnum
Dwarf_P_Die
ownerdie
Dwarf_P_Die
otherdie
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_fixup_AT_reference_die
fP
is
provided
to
set
the
NULL
f
CWotherdie
fP
that
f
CWdwarf_add_AT_reference_c
fP
allows
to
the
reference
target
DIE
This
must
be
done
before
transforming
to
disk
form
f
CWattrnum
fP
should
be
the
attribute
number
of
the
attribute
of
fCWownerdie
fP
which
is
to
be
updated
For
example
if
a
local
forward
reference
was
in
a
fCWDW_AT_sibling
fP
attribute
in
ownerdie
pass
the
value
fCWDW_AT_sibling
fP
as
attrnum
P
Since
no
attribute
number
can
appear
more
than
once
on
a
given
DIE
the
f
CWattrnum
fP
suffices
to
uniquely
identify
which
attribute
of
fCWownerdie
fP
to
update
P
It
returns
either
f
CWDW_DLV_OK
fP
on
success
or
f
CWDW_DLV_ERROR
fP
on
error
Calling
this
on
an
attribute
where
f
CWotherdie
fP
was
already
set
is
an
error
H
dwarf_add_AT_flag_a
DS
f
CWint
dwarf_add_AT_flag_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
Dwarf_Small
flag
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_flag_a
fP
adds
an
attribute
with
a
f
CWDwarf_Small
fP
value
belonging
to
the
flag
class
to
the
f
CWDIE
fP
specified
by
f
CWownerdie
fP
The
object
that
the
f
CWDIE
fP
belongs
to
is
specified
by
f
CWdbg
fP
The
attribute
is
specified
by
f
CWattr
fP
and
its
value
is
specified
by
f
CWflag
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
passes
back
a
pointer
to
the
new
attribute
through
f
CW
attr_out
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_string_a
DS
f
CWint
dwarf_add_AT_string_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
ownerdie
Dwarf_Half
attr
char
string
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_string
fP
adds
an
attribute
with
a
value
that
is
a
character
string
to
the
f
CWDIE
fP
specified
by
f
CWownerdie
fP
The
object
that
the
f
CWDIE
fP
belongs
to
is
specified
by
f
CWdbg
fP
The
attribute
is
specified
by
f
CWattr
fP
and
its
value
is
pointed
to
by
f
CWstring
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
set
f
CW
attr_out
fP
with
a
pointer
to
the
new
attribute
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_with_ref_sig8_a
DS
f
CWint
dwarf_add_AT_with_ref_sig8_a
Dwarf_P_Die
ownerdie
Dwarf_Half
attrnum
const
Dwarf_Sig8
sig8_in
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_AT_with_sig8_a
fP
creates
an
attribute
containing
the
byte
signature
block
pointed
to
by
f
CWsig8_in
fP
f
CWDW_FORM_ref_sig8
fP
with
form
f
CWDW_FORM_ref_sig8
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
attr_out
f
CW
attr_out
fP
to
the
newly
created
attribute
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_AT_data16
DS
f
CWint
dwarf_add_AT_data16
Dwarf_P_Die
ownerdie
Dwarf_Half
attrnum
Dwarf_Form_Data16
ptr_to_val
Dwarf_P_Attribute
attr_out
Dwarf_Error
error
fP
DE
The
DWARF5
standard
refers
to
byte
as
simply
data
It
is
up
to
the
eventual
reader
of
the
DWARF
entry
this
call
creates
to
understand
what
the
sixteen
bytes
mean
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
the
new
attribute
through
the
pointer
f
CWattr_out
fP
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_compress_integer_block
DS
f
CWvoid
dwarf_compress_integer_block
Dwarf_P_Debug
dbg
Dwarf_Bool
unit_is_signed
Dwarf_Small
unit_length_in_bits
void
input_block
Dwarf_Unsigned
input_length_in_units
Dwarf_Unsigned
output_length_in_bytes_ptr
Dwarf_Error
error
DE
This
was
created
in
in
support
of
the
attribute
DW_AT_SUN_func_offsets
but
the
particular
DWARF
project
involving
this
seems
to
have
died
We
have
not
provided
a
way
to
create
the
attribute
So
this
is
pretty
useless
at
this
time
H
Expression
Creation
The
following
functions
are
used
to
convert
location
expressions
into
blocks
so
that
attributes
with
values
that
are
location
expressions
can
store
their
values
as
a
f
CWDW_FORM_blockn
fP
value
This
is
for
both
debug_info
and
debug_loc
expression
blocks
To
create
an
expression
first
call
f
CWdwarf_new_expr_a
fP
to
get
a
f
CWDwarf_P_Expr
fP
descriptor
that
can
be
used
to
build
up
the
block
containing
the
location
expression
Then
insert
the
parts
of
the
expression
in
prefix
order
exactly
the
order
they
would
be
interpreted
in
in
an
expression
interpreter
The
bytes
of
the
expression
are
then
built
up
as
specified
by
the
user
H
dwarf_new_expr_a
DS
f
CWint
dwarf_new_expr_a
Dwarf_P_Debug
dbg
Dwarf_P_Expr
expr_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_new_expra
fP
creates
a
new
expression
area
in
which
a
location
expression
stream
can
be
created
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
a
Dwarf_Expr
f
CWDwarf_Expr
fP
through
the
pointer
which
can
be
used
to
add
operators
a
to
build
up
a
location
expression
On
failure
it
returns
f
CWDW_DLV_OK
fP
H
dwarf_add_expr_gen_a
DS
f
CWint
dwarf_add_expr_gen_a
Dwarf_P_Expr
expr
Dwarf_Small
opcode
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
Dwarf_Unsigned
stream_length_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_expr_gen
fP
takes
an
operator
specified
by
f
CWopcode
fP
along
with
up
to
operands
specified
by
f
CWval1
fP
and
f
CWval2
fP
converts
it
into
the
f
CWDwarf
fP
representation
and
appends
the
bytes
to
the
byte
stream
being
assembled
for
the
location
expression
represented
by
f
CWexpr
fP
The
first
operand
if
present
to
f
CWopcode
fP
is
in
f
CWval1
fP
and
the
second
operand
if
present
is
in
f
CWval2
fP
Both
the
operands
may
actually
be
signed
or
unsigned
depending
on
f
CWopcode
fP
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
stream_length_out
fP
to
the
number
of
bytes
in
the
byte
stream
for
f
CWexpr
fP
currently
generated
i
e
after
the
addition
of
f
CWopcode
fP
It
returns
f
CWDW_DLV_ERROR
fP
on
error
The
function
f
CWdwarf_add_expr_gen_a
fP
works
for
all
opcodes
except
those
that
have
a
target
address
as
an
operand
This
is
because
the
function
cannot
not
set
up
a
relocation
record
that
is
needed
when
target
addresses
are
involved
H
dwarf_add_expr_addr_c
DS
f
CWint
dwarf_add_expr_addr_c
Dwarf_P_Expr
expr
Dwarf_Unsigned
address
Dwarf_Unsigned
sym_index
Dwarf_Unsigned
stream_length_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_expr_addr_c
fP
is
identical
to
f
CWdwarf_add_expr_addr_b
fP
except
that
f
CWdwarf_add_expr_addr_c
fP
returns
a
simple
integer
code
P
f
CWsym_index
fP
is
guaranteed
to
be
large
enough
that
it
can
contain
a
pointer
to
arbitrary
data
so
the
caller
can
pass
in
a
real
elf
symbol
index
an
arbitrary
number
or
a
pointer
to
arbitrary
data
The
ability
to
pass
in
a
pointer
through
f
CWsym_index
fP
is
only
usable
with
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
On
success
the
function
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
stream_length_out
fP
to
to
the
total
length
of
the
expression
stream
in
f
CWexpr
fP
On
failure
the
function
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_expr_current_offset_a
DS
f
CWint
dwarf_expr_current_offset_a
Dwarf_P_Expr
expr
Dwarf_Unsigned
stream_offset_out
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_expr_current_offset_a
fP
returns
f
CWDW_DLV_OK
fP
and
sets
f
CW
stream_offset_out
fP
to
the
current
length
in
bytes
of
the
expression
stream
On
failure
the
function
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_expr_into_block_a
DS
f
CWint
dwarf_expr_into_block_a
Dwarf_P_Expr
expr
Dwarf_Unsigned
length
Dwarf_Small
address
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_expr_into_block_a
fP
returns
f
CWDW_DLV_OK
fP
and
sets
the
length
of
the
f
CWexpr
fP
expression
into
f
CW
length
fP
and
sets
the
value
of
a
pointer
into
memory
where
the
expression
is
currently
held
in
the
executing
libdwarf
into
f
CW
address
fP
P
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_expr_reset
DS
f
CWvoid
dwarf_expr_reset
Dwarf_P_Expr
expr
Dwarf_Error
error
fP
DE
This
resets
the
expression
content
of
f
CWexpr
fP
to
be
empty
H
Line
Number
Operations
These
are
operations
on
the
debug_line
section
They
provide
information
about
instructions
in
the
program
and
the
source
lines
the
instruction
come
from
Typically
code
is
generated
in
contiguous
blocks
which
may
then
be
relocated
as
contiguous
blocks
To
make
the
provision
of
relocation
information
more
efficient
the
information
is
recorded
in
such
a
manner
that
only
the
address
of
the
start
of
the
block
needs
to
be
relocated
This
is
done
by
providing
the
address
of
the
first
instruction
in
a
block
using
the
function
f
CWdwarf_lne_set_address
fP
Information
about
the
instructions
in
the
block
are
then
added
using
the
function
f
CWdwarf_add_line_entry_c
fP
which
specifies
offsets
from
the
address
of
the
first
instruction
The
end
of
a
contiguous
block
is
indicated
by
calling
the
function
f
CWdwarf_lne_end_sequence
fP
P
Line
number
operations
do
not
support
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
H
dwarf_add_line_entry_c
DS
f
CWint
dwarf_add_line_entry_c
Dwarf_P_Debug
dbg
Dwarf_Unsigned
file_index
Dwarf_Addr
code_offset
Dwarf_Unsigned
lineno
Dwarf_Signed
column_number
Dwarf_Bool
is_source_stmt_begin
Dwarf_Bool
is_basic_block_begin
Dwarf_Bool
is_epilogue_begin
Dwarf_Bool
is_prologue_end
Dwarf_Unsigned
isa
Dwarf_Unsigned
discriminator
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_line_entry_c
fP
adds
an
entry
to
the
section
containing
information
about
source
lines
It
specifies
in
f
CWcode_offset
fP
the
address
of
this
line
The
function
subtracts
f
CWcode_offset
fP
from
the
value
given
as
the
address
of
a
previous
line
call
to
compute
an
offset
and
the
offset
is
what
is
recorded
in
the
line
instructions
so
no
relocation
will
be
needed
on
the
line
instruction
generated
P
The
source
file
that
gave
rise
to
the
instruction
is
specified
by
f
CWfile_index
fP
the
source
line
number
is
specified
by
f
CWlineno
fP
and
the
source
column
number
is
specified
by
f
CWcolumn_number
fP
column
numbers
begin
at
if
the
source
column
is
unknown
specify
f
CWfile_index
fP
is
the
index
of
the
source
file
in
a
list
of
source
files
which
is
built
up
using
the
function
f
CWdwarf_add_file_decl
fP
f
CWis_source_stmt_begin
fP
is
a
boolean
flag
that
is
true
only
if
the
instruction
at
f
CWcode_address
fP
is
the
first
instruction
in
the
sequence
generated
for
the
source
line
at
f
CWlineno
fP
Similarly
f
CWis_basic_block_begin
fP
is
a
boolean
flag
that
is
true
only
if
the
instruction
at
f
CWcode_address
fP
is
the
first
instruction
of
a
basic
block
f
CWis_epilogue_begin
fP
is
a
boolean
flag
that
is
true
only
if
the
instruction
at
f
CWcode_address
fP
is
the
first
instruction
in
the
sequence
generated
for
the
function
epilogue
code
Similarly
f
CWis_prolgue_end
fP
is
a
boolean
flag
that
is
true
only
if
the
instruction
at
f
CWcode_address
fP
is
the
last
instruction
of
the
sequence
generated
for
the
function
prologue
f
CWisa
fP
should
be
zero
unless
the
code
at
f
CWcode_address
fP
is
generated
in
a
non
standard
isa
The
values
assigned
to
non
standard
isas
are
defined
by
the
compiler
implementation
f
CWdiscriminator
fP
should
be
zero
unless
the
line
table
needs
to
distinguish
among
multiple
blocks
associated
with
the
same
source
file
line
and
column
The
values
assigned
to
f
CWdiscriminator
fP
are
defined
by
the
compiler
implementation
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_lne_set_address_a
DS
f
CWint
dwarf_lne_set_address_a
Dwarf_P_Debug
dbg
Dwarf_Addr
offs
Dwarf_Unsigned
symidx
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lne_set_address_a
fP
sets
the
target
address
at
which
a
contiguous
block
of
instructions
begin
Information
about
the
instructions
in
the
block
is
added
to
debug_line
using
calls
to
f
CWdwarfdwarf_add_line_entry_c
fP
which
specifies
the
offset
of
each
instruction
in
the
block
relative
to
the
start
of
the
block
This
is
done
so
that
a
single
relocation
record
can
be
used
to
obtain
the
final
target
address
of
every
instruction
in
the
block
The
relocatable
address
of
the
start
of
the
block
of
instructions
is
specified
by
f
CWoffs
fP
The
symbol
used
to
relocate
the
address
is
given
by
f
CWsymidx
fP
which
is
normally
the
index
of
the
symbol
in
the
Elf
symbol
table
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_lne_end_sequence_a
DS
f
CWint
dwarf_lne_end_sequence_a
Dwarf_P_Debug
dbg
Dwarf_Addr
address
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_lne_end_sequence_a
fP
indicates
the
end
of
a
contiguous
block
of
instructions
f
CWaddress
fP
should
be
just
higher
than
the
end
of
the
last
address
in
the
sequence
of
instructions
Before
the
next
block
of
instructions
if
any
a
call
to
f
CWdwarf_lne_set_address_a
fP
will
have
to
be
made
to
set
the
address
of
the
start
of
the
target
address
of
the
block
followed
by
calls
to
f
CWdwarf_add_line_entry_a
fP
for
each
of
the
instructions
in
the
block
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_add_directory_decl_a
DS
f
CWint
dwarf_add_directory_decl_a
Dwarf_P_Debug
dbg
char
name
Dwarf_Unsigned
index_in_directories
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_directory_decl
fP
adds
the
string
specified
by
f
CWname
fP
to
the
list
of
include
directories
in
the
statement
program
prologue
of
the
debug_line
section
The
string
should
therefore
name
a
directory
from
which
source
files
have
been
used
to
create
the
present
object
On
success
it
returns
f
CWDW_DLV_OK
fP
and
sets
the
index
of
the
string
just
added
in
the
list
of
include
directories
for
the
object
This
index
is
then
used
to
refer
to
this
string
The
index
is
passed
back
through
the
pointer
argument
f
CWindex_in_directories
fP
The
first
successful
call
of
this
function
returns
one
not
zero
to
be
consistent
with
the
directory
indices
that
f
CWdwarf_add_file_decl_a
fP
below
expects
DWARF5
is
a
bit
different
TBD
FIXME
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_add_file_decl_a
DS
f
CWint
dwarf_add_file_decl_a
Dwarf_P_Debug
dbg
char
name
Dwarf_Unsigned
dir_idx
Dwarf_Unsigned
time_mod
Dwarf_Unsigned
length
Dwarf_Unsigned
file_entry_count_out
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_file_decl_a
fP
adds
the
name
of
a
source
file
that
contributed
to
the
present
object
The
name
of
the
file
is
specified
by
f
CWname
fP
which
must
not
be
the
empty
string
or
a
null
pointer
it
must
point
to
a
string
with
length
greater
than
In
case
the
name
is
not
a
fully
qualified
pathname
it
is
considered
prefixed
with
the
name
of
the
directory
specified
by
f
CWdir_idx
fP
which
does
not
mean
the
f
CWname
fP
is
changed
or
physically
prefixed
by
this
producer
function
we
simply
describe
the
meaning
here
f
CWdir_idx
fP
is
the
index
of
the
directory
to
be
prefixed
in
the
list
builtup
using
f
CWdwarf_add_directory_decl_a
fP
As
specified
by
the
DWARF
spec
a
f
CWdir_idx
fP
of
zero
will
be
interpreted
as
meaning
the
directory
of
the
compilation
and
another
index
must
refer
to
a
valid
directory
as
FIXME
P
f
CWtime_mod
fP
gives
the
time
at
which
the
file
was
last
modified
and
f
CWlength
fP
gives
the
length
of
the
file
in
bytes
P
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
the
index
of
the
source
file
in
the
list
built
up
so
far
through
the
pointer
f
CWfile_entry_count_out
fP
This
index
can
then
be
used
to
refer
to
this
source
file
in
calls
to
f
CWdwarf_add_line_entry_a
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
Fast
Access
aranges
Operations
These
functions
operate
on
the
debug_aranges
section
H
dwarf_add_arange_c
DS
f
CWint
dwarf_add_arange_c
Dwarf_P_Debug
dbg
Dwarf_Addr
begin_address
Dwarf_Unsigned
length
Dwarf_Unsigned
symbol_index
Dwarf_Unsigned
end_symbol_index
Dwarf_Addr
offset_from_end_symbol
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_arange_c
fP
adds
another
address
range
to
be
added
to
the
section
containing
address
range
information
debug_aranges
If
f
CWend_symbol_index
is
not
zero
fP
we
are
using
two
symbols
to
create
a
length
must
be
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
to
be
useful
sp
in
f
CWbegin_address
fP
is
the
offset
from
the
symbol
specified
by
f
CWsymbol_index
fP
f
CWoffset_from_end_symbol
fP
is
the
offset
from
the
symbol
specified
by
f
CWend_symbol_index
fP
f
CWlength
fP
is
ignored
This
begin
end
pair
will
be
show
up
in
the
relocation
array
returned
by
f
CWdwarf_get_relocation_info
fP
as
a
f
CWdwarf_drt_first_of_length_pair
fP
and
f
CWdwarf_drt_second_of_length_pair
fP
pair
of
relocation
records
The
consuming
application
will
turn
that
pair
into
something
conceptually
identical
to
sp
nf
in
word
end_symbol
offset_from_end
start_symbol
begin_address
in
fi
sp
The
reason
offsets
are
allowed
on
the
begin
and
end
symbols
is
to
allow
the
caller
to
re
use
existing
labels
when
the
labels
are
available
and
the
corresponding
offset
is
known
economizing
on
the
number
of
labels
in
use
The
offset_from_end
begin_address
will
actually
be
in
the
binary
stream
not
the
relocation
record
so
the
app
processing
the
relocation
array
must
read
that
stream
value
into
for
example
net_offset
and
actually
emit
something
like
sp
nf
in
word
end_symbol
start_symbol
net_offset
in
fi
sp
in
If
f
CWend_symbol_index
fP
is
zero
we
must
be
given
a
length
either
f
CWDW_DLC_STREAM_RELOCATIONS
fP
or
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
sp
in
The
relocatable
start
address
of
the
range
is
specified
by
f
CWbegin_address
fP
and
the
length
of
the
address
range
is
specified
by
f
CWlength
fP
The
relocatable
symbol
to
be
used
to
relocate
the
start
of
the
address
range
is
specified
by
f
CWsymbol_index
fP
which
is
normally
the
index
of
the
symbol
in
the
Elf
symbol
table
The
f
CWoffset_from_end_symbol
fP
is
ignored
in
The
function
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
DWARF5
debug_sup
section
creation
The
debug_sup
section
see
the
DWARF5
standard
enables
symbolically
linking
two
DWARF5
object
files
together
sp
H
dwarf_add_debug_sup
This
call
provides
all
the
information
that
the
debug_sup
section
has
DS
f
CWint
dwarf_add_debug_sup
Dwarf_P_Debug
dbg
Dwarf_Half
version
Dwarf_Small
is_supplementary
char
filename
Dwarf_Unsigned
checksum_len
Dwarf_Small
checksum
Dwarf_Error
error
fP
DE
On
success
it
returns
f
CWDW_DLV_OK
fP
and
records
the
fields
for
creating
the
section
sp
The
fields
are
as
follows
sp
f
CWversion
fP
should
be
passed
in
as
sp
f
CWfilename
fP
must
be
a
null
terminated
string
sp
f
CWis_supplementary
fP
should
be
passed
in
as
or
depending
on
which
type
of
object
file
is
involved
see
the
DWARF5
standard
sp
f
CWchecksum
fP
must
be
a
byte
array
of
length
f
CWchecksum_len
fP
used
to
validate
by
a
debugger
the
use
of
the
target
object
file
sp
f
CWDW_DLV_NO
ENTRY
fP
is
never
returned
sp
f
CWDW_DLV_ERROR
fP
is
returned
in
case
of
an
error
and
f
CW
error
fP
is
set
as
usual
in
libdwarf
H
Fast
Access
pubnames
Operations
These
functions
operate
on
the
debug_pubnames
section
sp
H
dwarf_add_pubname_a
DS
f
CWint
dwarf_add_pubname_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
pubname_name
Dwarf_Error
error
fP
DE
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
Fast
Access
pubtypes
Operations
These
functions
operate
on
the
debug_pubtypes
section
An
SGI
defined
extension
Not
part
of
standard
DWARF
sp
H
dwarf_add_pubtype_a
DS
f
CWint
dwarf_add_pubtype_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
pubname_name
Dwarf_Error
error
fP
DE
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
Fast
Access
weak
names
Operations
These
functions
operate
on
the
debug_weaknames
section
An
SGI
defined
extension
Not
part
of
standard
DWARF
H
dwarf_add_weakname_a
DS
f
CWint
dwarf_add_weakname_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
weak_name
Dwarf_Error
error
fP
DE
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
H
Static
Function
Names
Operations
The
debug_funcnames
section
contains
the
names
of
static
function
names
defined
in
the
object
and
also
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
the
functions
in
the
debug_info
section
An
SGI
defined
extension
Not
part
of
standard
DWARF
H
dwarf_add_funcname_a
DS
f
CWint
dwarf_add_funcname_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
func_name
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_funcname_a
fP
adds
the
name
of
a
static
function
specified
by
f
CWfunc_name
fP
to
the
section
containing
the
names
of
static
functions
defined
in
the
object
represented
by
f
CWdbg
fP
The
f
CWDIE
fP
that
represents
the
definition
of
the
function
is
specified
by
f
CWdie
fP
P
It
returns
f
CWDW_DLV_OK
fP
on
success
P
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
File
scope
User
defined
Type
Names
Operations
The
debug_typenames
section
contains
the
names
of
file
scope
user
defined
types
in
the
given
object
and
also
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definitions
of
the
types
in
the
debug_info
section
An
SGI
defined
extension
Not
part
of
standard
DWARF
H
dwarf_add_typename_a
DS
f
CWint
dwarf_add_typename_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
type_name
Dwarf_Error
error
fP
DE
This
the
same
as
f
CWdwarf_add_typename
fP
except
that
on
success
this
returns
f
CWDW_DLV_OK
fP
and
on
failure
this
returns
f
CWDW_DLV_ERROR
fP
H
File
scope
Static
Variable
Names
Operations
The
debug_varnames
section
contains
the
names
of
file
scope
static
variables
in
the
given
object
and
also
the
offsets
of
the
f
CWDIE
fPs
that
represent
the
definition
of
the
variables
in
the
debug_info
section
An
SGI
defined
section
H
dwarf_add_varname_a
DS
f
CWint
dwarf_add_varname_a
Dwarf_P_Debug
dbg
Dwarf_P_Die
die
char
var_name
Dwarf_Error
error
fP
DE
This
the
same
as
f
CWdwarf_add_varname
fP
except
that
on
success
this
returns
f
CWDW_DLV_OK
fP
and
on
failure
this
returns
f
CWDW_DLV_ERROR
fP
H
Macro
Information
Creation
All
strings
passed
in
by
the
caller
are
copied
by
these
functions
so
the
space
in
which
the
caller
provides
the
strings
may
be
ephemeral
on
the
stack
or
immediately
reused
or
whatever
without
this
causing
any
difficulty
H
dwarf_def_macro
DS
f
CWint
dwarf_def_macro
Dwarf_P_Debug
dbg
Dwarf_Unsigned
lineno
char
name
char
value
Dwarf_Error
error
fP
DE
Adds
a
macro
definition
The
f
CWname
fP
argument
should
include
the
parentheses
and
parameter
names
if
this
is
a
function
like
macro
Neither
string
should
contain
extraneous
whitespace
f
CWdwarf_def_macro
fP
adds
the
mandated
space
after
the
name
and
before
the
value
in
the
output
DWARF
section
but
does
not
change
the
strings
pointed
to
by
the
arguments
If
this
is
a
definition
before
any
files
are
read
f
CWlineno
fP
should
be
Returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
if
there
is
an
error
Returns
f
CWDW_DLV_OK
fP
if
the
call
was
successful
H
dwarf_undef_macro
DS
f
CWint
dwarf_undef_macro
Dwarf_P_Debug
dbg
Dwarf_Unsigned
lineno
char
name
Dwarf_Error
error
fP
DE
Adds
a
macro
un
definition
note
If
this
is
a
definition
before
any
files
are
read
f
CWlineno
fP
should
be
Returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
if
there
is
an
error
Returns
f
CWDW_DLV_OK
fP
if
the
call
was
successful
H
dwarf_start_macro_file
DS
f
CWint
dwarf_start_macro_file
Dwarf_P_Debug
dbg
Dwarf_Unsigned
lineno
Dwarf_Unsigned
fileindex
Dwarf_Error
error
fP
DE
f
CWfileindex
fP
is
an
index
in
the
debug_line
header
the
index
of
the
file
name
See
the
function
f
CWdwarf_add_file_decl
fP
The
f
CWlineno
fP
should
be
if
this
file
is
the
file
of
the
compilation
unit
source
itself
which
of
course
is
not
a
include
in
any
file
Returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
if
there
is
an
error
Returns
f
CWDW_DLV_OK
fP
if
the
call
was
successful
H
dwarf_end_macro_file
DS
f
CWint
dwarf_end_macro_file
Dwarf_P_Debug
dbg
Dwarf_Error
error
fP
DE
Returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
if
there
is
an
error
Returns
f
CWDW_DLV_OK
fP
if
the
call
was
successful
H
dwarf_vendor_ext
DS
f
CWint
dwarf_vendor_ext
Dwarf_P_Debug
dbg
Dwarf_Unsigned
constant
char
string
Dwarf_Error
error
fP
DE
The
meaning
of
the
f
CWconstant
fP
and
the
f
CWstring
fP
in
the
macro
info
section
are
undefined
by
DWARF
itself
but
the
string
must
be
an
ordinary
null
terminated
string
This
call
is
not
an
extension
to
DWARF
It
simply
enables
storing
macro
information
as
specified
in
the
DWARF
document
Returns
f
CWDW_DLV_ERROR
fP
and
sets
f
CWerror
fP
if
there
is
an
error
Returns
f
CWDW_DLV_OK
fP
if
the
call
was
successful
H
Low
Level
debug_frame
operations
These
functions
operate
on
the
debug_frame
section
Refer
to
f
CWlibdwarf
h
fP
for
the
register
names
and
register
assignment
mapping
Both
of
these
are
necessarily
machine
dependent
H
dwarf_new_fde_a
DS
f
CWint
dwarf_new_fde_a
Dwarf_P_Debug
dbg
Dwarf_P_Fde
fde_out
Dwarf_Error
error
fP
DE
On
success
the
function
f
CWdwarf_new_fde_a
fP
returns
f
CWDW_DLV_OK
fP
and
returns
a
pointer
to
the
fde
through
f
CWfde_out
fP
The
descriptor
should
be
used
to
build
a
complete
f
CWFDE
fP
Subsequent
calls
to
routines
that
build
up
the
f
CWFDE
fP
should
use
the
same
f
CWDwarf_P_Fde
fP
descriptor
P
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_add_frame_cie_a
DS
f
CWint
dwarf_add_frame_cie_a
Dwarf_P_Debug
dbg
char
augmenter
Dwarf_Small
code_align
Dwarf_Small
data_align
Dwarf_Small
ret_addr_reg
Dwarf_Ptr
init_bytes
Dwarf_Unsigned
init_bytes_len
Dwarf_Unsigned
cie_index_out
Dwarf_Error
error
fP
DE
On
success
The
function
f
CWdwarf_add_frame_cie_a
fP
returns
f
CWDW_DLV_OK
fP
creates
a
f
CWCIE
fP
and
returns
an
index
to
it
through
the
pointer
f
CWcie_index_out
fP
P
f
CWCIE
fPs
are
used
by
f
CWFDE
fPs
to
setup
initial
values
for
frames
The
augmentation
string
for
the
f
CWCIE
fP
is
specified
by
f
CWaugmenter
fP
The
code
alignment
factor
data
alignment
factor
and
the
return
address
register
for
the
f
CWCIE
fP
are
specified
by
f
CWcode_align
fP
f
CWdata_align
fP
and
f
CWret_addr_reg
fP
respectively
f
CWinit_bytes
fP
points
to
the
bytes
that
represent
the
instructions
for
the
f
CWCIE
fP
being
created
and
f
CWinit_bytes_len
fP
specifies
the
number
of
bytes
of
instructions
P
There
is
no
convenient
way
to
generate
the
f
CWinit_bytes
fP
stream
One
just
has
to
calculate
it
by
hand
or
separately
generate
something
with
the
correct
sequence
and
use
dwarfdump
v
and
readelf
or
objdump
and
some
kind
of
hex
dumper
to
see
the
bytes
This
is
a
serious
inconvenience
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_frame_fde_c
DS
f
CWint
dwarf_add_frame_fde_c
Dwarf_P_Debug
dbg
Dwarf_P_Fde
fde
Dwarf_P_Die
die
Dwarf_Unsigned
cie
Dwarf_Addr
virt_addr
Dwarf_Unsigned
code_len
Dwarf_Unsigned
sym_idx
Dwarf_Unsigned
sym_idx_of_end
Dwarf_Addr
offset_from_end_sym
Dwarf_Unsigned
index_to_fde
Dwarf_Error
error
fP
DE
This
function
is
like
f
CWdwarf_add_frame_fde
fP
except
that
f
CWdwarf_add_frame_fde_c
fP
has
new
arguments
to
allow
use
with
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
and
a
new
argument
to
return
the
fde
index
The
function
f
CWdwarf_add_frame_fde_c
fP
adds
the
f
CWFDE
fP
specified
by
f
CWfde
fP
to
the
list
of
f
CWFDE
fPs
for
the
object
represented
by
the
given
f
CWdbg
fP
f
CWdie
fP
specifies
the
f
CWDIE
fP
that
represents
the
function
whose
frame
information
is
specified
by
the
given
f
CWfde
fP
If
the
MIPS
IRIX
specific
DW_AT_MIPS_fde
attribute
is
not
needed
in
debug_info
pass
in
as
the
f
CWdie
fP
argument
f
CWcie
fP
specifies
the
index
of
the
f
CWCIE
fP
that
should
be
used
to
setup
the
initial
conditions
for
the
given
frame
f
CWvirt_addr
fP
represents
the
relocatable
address
at
which
the
code
for
the
given
function
begins
and
f
CWsym_idx
fP
gives
the
index
of
the
relocatable
symbol
to
be
used
to
relocate
this
address
f
CWvirt_addr
fP
that
is
f
CWcode_len
fP
specifies
the
size
in
bytes
of
the
machine
instructions
for
the
given
function
If
f
CWsym_idx_of_end
fP
is
zero
may
be
f
CWDW_DLC_STREAM_RELOCATIONS
fP
or
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
sp
in
f
CWvirt_addr
fP
represents
the
relocatable
address
at
which
the
code
for
the
given
function
begins
and
f
CWsym_idx
fP
gives
the
index
of
the
relocatable
symbol
to
be
used
to
relocate
this
address
f
CWvirt_addr
fP
that
is
f
CWcode_len
fP
specifies
the
size
in
bytes
of
the
machine
instructions
for
the
given
function
f
CWsym_idx_of_end
fP
and
f
CWoffset_from_end_sym
fP
are
unused
in
sp
If
f
CWsym_idx_of_end
fP
is
non
zero
must
be
f
CWDW_DLC_SYMBOLIC_RELOCATIONS
fP
to
be
useful
sp
in
f
CWvirt_addr
fP
is
the
offset
from
the
symbol
specified
by
f
CWsym_idx
fP
f
CWoffset_from_end_sym
fP
is
the
offset
from
the
symbol
specified
by
f
CWsym_idx_of_end
fP
f
CWcode_len
fP
is
ignored
This
begin
end
pair
will
be
show
up
in
the
relocation
array
returned
by
f
CWdwarf_get_relocation_info
fP
as
a
f
CWdwarf_drt_first_of_length_pair
fP
and
f
CWdwarf_drt_second_of_length_pair
fP
pair
of
relocation
records
The
consuming
application
will
turn
that
pair
into
something
conceptually
identical
to
sp
nf
in
word
end_symbol
begin
start_symbol
offset_from_end
in
fi
sp
The
reason
offsets
are
allowed
on
the
begin
and
end
symbols
is
to
allow
the
caller
to
re
use
existing
labels
when
the
labels
are
available
and
the
corresponding
offset
is
known
economizing
on
the
number
of
labels
in
use
The
offset_from_end
begin_address
will
actually
be
in
the
binary
stream
not
the
relocation
record
so
the
app
processing
the
relocation
array
must
read
that
stream
value
into
for
example
net_offset
and
actually
emit
something
like
sp
nf
in
word
end_symbol
start_symbol
net_offset
in
fi
sp
in
On
success
it
returns
f
CWDW_DLV_OK
fP
and
returns
index
to
the
given
f
CWfde
fP
through
the
pointer
f
CWindex_to_fde
fP
On
error
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_add_frame_info_c
DS
f
CWint
dwarf_add_frame_info_c
Dwarf_P_Debug
dbg
Dwarf_P_Fde
fde
Dwarf_P_Die
die
Dwarf_Unsigned
cie
Dwarf_Addr
virt_addr
Dwarf_Unsigned
code_len
Dwarf_Unsigned
sym_idx
Dwarf_Unsigned
end_symbol_index
Dwarf_Addr
offset_from_end_symbol
Dwarf_Signed
offset_into_exception_tables
Dwarf_Unsigned
exception_table_symbol
Dwarf_Unsigned
index_to_fde
Dwarf_Error
error
fP
DE
P
On
success
The
function
f
CWdwarf_add_frame_fde_c
fP
returns
f
CWDW_DLV_OK
fP
adds
the
f
CWFDE
fP
specified
by
f
CWfde
fP
to
the
list
of
f
CWFDE
fPs
for
the
object
represented
by
the
given
f
CWdbg
fP
and
passes
the
index
of
the
fde
back
through
the
pointer
f
CWindex_to_fde
fP
On
failure
it
returns
f
CWDW_DLV_ERROR
fP
H
dwarf_fde_cfa_offset_a
DS
f
CWint
dwarf_fde_cfa_offset_a
Dwarf_P_Fde
fde
Dwarf_Unsigned
reg
Dwarf_Signed
offset
Dwarf_Error
error
fP
DE
P
The
function
f
CWdwarf_fde_cfa_offset
fP
appends
a
f
CWDW_CFA_offset
fP
operation
to
the
f
CWFDE
fP
specified
by
f
CWfde
fP
being
constructed
The
first
operand
of
the
f
CWDW_CFA_offset
fP
operation
is
specified
by
f
CWreg
fP
The
register
specified
should
not
exceed
bits
The
second
operand
of
the
f
CWDW_CFA_offset
fP
operation
is
specified
by
f
CWoffset
fP
P
It
returns
f
CWDW_DLV_OK
fP
on
success
P
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_add_fde_inst_a
DS
f
CWint
dwarf_add_fde_inst_a
Dwarf_P_Fde
fde
Dwarf_Small
op
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_add_fde_inst
fP
adds
the
operation
specified
by
f
CWop
fP
to
the
f
CWFDE
fP
specified
by
f
CWfde
fP
Up
to
two
operands
can
be
specified
in
f
CWval1
fP
and
f
CWval2
fP
Based
on
the
operand
specified
f
CWLibdwarf
fP
decides
how
many
operands
are
meaningful
for
the
operand
It
also
converts
the
operands
to
the
appropriate
datatypes
they
are
passed
to
f
CWdwarf_add_fde_inst
fP
as
f
CWDwarf_Unsigned
fP
P
It
returns
f
CWDW_DLV_OK
fP
on
success
It
returns
f
CWDW_DLV_ERROR
fP
on
error
H
dwarf_insert_fde_inst_bytes
DS
f
CWint
dwarf_insert_fde_inst_bytes
Dwarf_P_Debug
dbg
Dwarf_P_Fde
fde
Dwarf_Unsigned
len
Dwarf_Ptr
ibytes
Dwarf_Error
error
fP
DE
The
function
f
CWdwarf_insert_fde_inst_bytes
fP
inserts
the
byte
array
pointed
at
by
f
CWibytes
fP
and
of
length
f
CWlen
fP
of
frame
instructions
into
the
fde
f
CWfde
fP
It
is
incompatible
with
f
CWdwarf_add_fde_inst
fP
do
not
use
both
functions
on
any
given
Dwarf_P_Debug
At
present
it
may
only
be
called
once
on
a
given
f
CWfde
fP
The
f
CWlen
fP
bytes
f
CWibytes
fP
may
be
constructed
in
any
way
but
the
assumption
is
they
were
copied
from
an
object
file
such
as
is
returned
by
the
libdwarf
consumer
function
f
CWdwarf_get_fde_instr_bytes
fP
It
returns
f
CWDW_DLV_OK
fP
on
success
and
f
CWDW_DLV_ERROR
fP
on
error
S
TC
CS
Copyright
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_STDDEF_H
include
stddef
h
endif
HAVE_STDDEF_H
ifdef
HAVE_STDINT_H
include
stdint
h
endif
HAVE_STDINT_H
include
libdwarf_private
h
include
dwarf
h
include
libdwarf
h
include
dwarf_base_types
h
include
dwarf_opaque
h
For
the
function
prototype
define
uint32_t
unsigned
int
Table
computed
by
David
Anderson
with
Mark
Adler
s
table
builder
logic
on
October
with
pattern
from
polynomial
static
const
uint32_t
crc32_table
The
following
is
essentially
identical
to
every
crc32
anyone
uses
up
to
trivial
differences
in
starting
conditions
The
algorithm
appears
on
https
en
wikipedia
org
wiki
Cyclic_redundancy_check
in
a
simple
logic
loop
written
in
no
actual
language
but
English
and
the
following
is
a
translation
into
C
Just
like
every
other
crc
calculation
unsigned
int
_dwarf_crc32
unsigned
int
crc
const
unsigned
char
buf
size_t
len
const
unsigned
char
end
crc
for
end
buf
len
buf
end
buf
crc
crc32_table
crc
buf
crc
return
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_abbrev
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
This
is
used
to
print
a
debug_abbrev
section
without
knowing
about
the
DIEs
that
use
the
abbrevs
dwarf_get_abbrev
and
in
dwarf_util
c
_dwarf_get_abbrev_for_code
When
we
have
a
simple
o
there
is
at
least
a
hope
of
iterating
through
the
abbrevs
meaningfully
without
knowing
a
CU
context
This
often
fails
or
gets
incorrect
info
because
there
is
no
guarantee
the
debug_abbrev
section
is
free
of
garbage
bytes
In
an
object
with
multiple
CU
TUs
the
output
is
difficult
impossible
to
usefully
interpret
In
a
dwp
Package
File
it
is
really
impossible
to
associate
abbrevs
with
a
CU
int
_dwarf_count_abbrev_entries
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_section_end
Dwarf_Unsigned
abbrev_count_out
Dwarf_Byte_Ptr
abbrev_ptr_out
Dwarf_Error
error
Dwarf_Unsigned
abbrev_count
Dwarf_Unsigned
attr_name
Dwarf_Unsigned
attr_form
Dwarf_Unsigned
implicit_const
UNUSEDARG
The
abbreviations
table
ends
with
an
entry
with
a
single
byte
of
zero
for
the
abbreviation
code
Padding
bytes
following
that
zero
are
allowed
but
here
we
simply
stop
looking
past
that
zero
abbrev
We
also
stop
looking
if
the
block
section
ends
though
the
DWARF2
and
later
standards
do
not
specifically
allow
section
block
end
to
terminate
an
abbreviations
list
do
DECODE_LEB128_UWORD_CK
abbrev_ptr
attr_name
dbg
error
abbrev_section_end
if
attr_name
DW_AT_hi_user
_dwarf_error
dbg
error
DW_DLE_ATTR_CORRUPT
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
abbrev_ptr
attr_form
dbg
error
abbrev_section_end
If
we
have
attr
form
as
fall
through
to
end
if
_dwarf_valid_form_we_know
attr_form
attr_name
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_UNKNOWN_FORM
Abbrev
form
DW_PR_DUx
attr_form
if
attr_name
dwarfstring_append_printf_u
DW_DLE_UNKNOWN_FORM
Abbrev
form
DW_PR_DUx
attr_form
dwarfstring_append_printf_u
with
attribute
DW_PR_DUx
attr_name
else
dwarfstring_append_printf_u
DW_DLE_UNKNOWN_FORM
really
unknown
attr
Abbrev
form
DW_PR_DUx
attr_form
dwarfstring_append_printf_u
with
attribute
DW_PR_DUx
attr_name
dwarfstring_append
so
abbreviations
unusable
_dwarf_error_string
dbg
error
DW_DLE_UNKNOWN_FORM
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
attr_form
DW_FORM_implicit_const
The
value
is
here
not
in
a
DIE
DECODE_LEB128_SWORD_CK
abbrev_ptr
implicit_const
dbg
error
abbrev_section_end
abbrev_count
while
abbrev_ptr
abbrev_section_end
attr_name
attr_form
We
counted
one
too
high
we
included
the
abbrev_count_out
abbrev_count
abbrev_ptr_out
abbrev_ptr
return
DW_DLV_OK
int
dwarf_get_abbrev
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Abbrev
returned_abbrev
Dwarf_Unsigned
length
Dwarf_Unsigned
abbr_count
Dwarf_Error
error
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_ptr_out
Dwarf_Byte_Ptr
abbrev_section_end
Dwarf_Abbrev
ret_abbrev
Dwarf_Unsigned
labbr_count
Dwarf_Unsigned
utmp
int
res
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
dbg
de_debug_abbrev
dss_data
Loads
abbrev
section
and
debug_info
as
we
do
those
together
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
if
offset
dbg
de_debug_abbrev
dss_size
return
DW_DLV_NO_ENTRY
ret_abbrev
Dwarf_Abbrev
_dwarf_get_alloc
dbg
DW_DLA_ABBREV
if
ret_abbrev
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
ret_abbrev
dab_dbg
dbg
if
returned_abbrev
abbr_count
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
_dwarf_error
dbg
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
abbr_count
if
length
length
abbrev_ptr
dbg
de_debug_abbrev
dss_data
offset
abbrev_section_end
dbg
de_debug_abbrev
dss_data
dbg
de_debug_abbrev
dss_size
if
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp
dbg
error
abbrev_section_end
endif
res
_dwarf_leb128_uword_wrapper
dbg
abbrev_section_end
error
if
res
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
return
res
ret_abbrev
dab_code
utmp
if
ret_abbrev
dab_code
returned_abbrev
ret_abbrev
abbr_count
if
length
length
return
DW_DLV_OK
if
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp
dbg
error
abbrev_section_end
endif
res
_dwarf_leb128_uword_wrapper
dbg
abbrev_section_end
error
if
res
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
return
res
if
utmp
DW_TAG_hi_user
return
_dwarf_format_TAG_err_msg
dbg
utmp
DW_DLE_TAG_CORRUPT
error
ret_abbrev
dab_tag
utmp
if
abbrev_ptr
abbrev_section_end
dwarfstring
m
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ABBREV_DECODE_ERROR
Ran
off
the
end
of
the
abbrev
section
reading
tag
starting
at
abbrev
section
offset
x
offset
_dwarf_error_string
dbg
error
DW_DLE_ABBREV_DECODE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
ret_abbrev
dab_has_child
abbrev_ptr
ret_abbrev
dab_abbrev_ptr
abbrev_ptr
ret_abbrev
dab_next_ptr
abbrev_ptr
ret_abbrev
dab_next_index
res
_dwarf_count_abbrev_entries
dbg
abbrev_ptr
abbrev_section_end
error
if
res
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
return
res
abbrev_ptr
abbrev_ptr_out
Global
section
offset
ret_abbrev
dab_goffset
offset
ret_abbrev
dab_count
labbr_count
if
abbrev_ptr
abbrev_section_end
dwarf_dealloc
dbg
ret_abbrev
DW_DLA_ABBREV
_dwarf_error_string
dbg
error
DW_DLE_ABBREV_DECODE_ERROR
DW_DLE_ABBREV_DECODE_ERROR
Ran
off
the
end
of
the
abbrev
section
reading
abbrev_entries
_dwarf_error
dbg
error
DW_DLE_ABBREV_DECODE_ERROR
return
DW_DLV_ERROR
if
length
length
abbrev_ptr
dbg
de_debug_abbrev
dss_data
offset
returned_abbrev
ret_abbrev
abbr_count
labbr_count
return
DW_DLV_OK
int
dwarf_get_abbrev_code
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
returned_code
Dwarf_Error
error
if
abbrev
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
returned_code
abbrev
dab_code
return
DW_DLV_OK
DWARF
defines
DW_TAG_hi_user
as
so
no
tag
should
be
over
bits
int
dwarf_get_abbrev_tag
Dwarf_Abbrev
abbrev
Dwarf_Half
returned_tag
Dwarf_Error
error
if
abbrev
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
returned_tag
abbrev
dab_tag
return
DW_DLV_OK
int
dwarf_get_abbrev_children_flag
Dwarf_Abbrev
abbrev
Dwarf_Signed
returned_flag
Dwarf_Error
error
if
abbrev
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
returned_flag
abbrev
dab_has_child
return
DW_DLV_OK
If
filter_outliers
is
non
zero
then
the
routine
will
return
DW_DLV_ERROR
if
the
leb
reading
generates
a
number
that
is
so
large
it
cannot
be
correct
If
filter_outliers
is
the
uleb
sleb
values
read
are
returned
even
if
the
values
are
unreasonable
This
is
a
useful
option
if
one
wishes
to
have
callers
examine
the
return
values
in
greater
detail
than
the
checking
here
provides
int
dwarf_get_abbrev_entry_b
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
indx
Dwarf_Bool
filter_outliers
Dwarf_Unsigned
returned_attr_num
Dwarf_Unsigned
returned_form
Dwarf_Signed
returned_implicitconst
Dwarf_Off
offset
Dwarf_Error
error
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_end
Dwarf_Byte_Ptr
mark_abbrev_ptr
Dwarf_Unsigned
attr
Dwarf_Unsigned
form
Dwarf_Unsigned
implicitconst
Dwarf_Debug
dbg
Dwarf_Signed
local_indx
Dwarf_Signed
indx
if
abbrev
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
if
abbrev
dab_code
return
DW_DLV_NO_ENTRY
if
abbrev
dab_dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
dbg
abbrev
dab_dbg
abbrev_ptr
abbrev
dab_abbrev_ptr
abbrev_end
dbg
de_debug_abbrev
dss_data
dbg
de_debug_abbrev
dss_size
if
Dwarf_Unsigned
local_indx
abbrev
dab_next_index
We
want
a
part
not
yet
scanned
so
we
can
start
closer
to
the
desired
value
abbrev_ptr
abbrev
dab_next_ptr
local_indx
abbrev
dab_next_index
for
attr
form
local_indx
abbrev_ptr
abbrev_end
attr
form
local_indx
mark_abbrev_ptr
abbrev_ptr
DECODE_LEB128_UWORD_CK
abbrev_ptr
attr
dbg
error
abbrev_end
if
filter_outliers
attr
DW_AT_hi_user
_dwarf_error
dbg
error
DW_DLE_ATTR_CORRUPT
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
abbrev_ptr
form
dbg
error
abbrev_end
if
filter_outliers
_dwarf_valid_form_we_know
form
attr
_dwarf_error
dbg
error
DW_DLE_UNKNOWN_FORM
return
DW_DLV_ERROR
if
form
DW_FORM_implicit_const
The
value
is
here
not
in
a
DIE
DECODE_LEB128_SWORD_CK
abbrev_ptr
implicitconst
dbg
error
abbrev_end
else
implicitconst
if
abbrev_ptr
abbrev_end
_dwarf_error_string
dbg
error
DW_DLE_ABBREV_DECODE_ERROR
DW_DLE_ABBREV_DECODE_ERROR
Ran
off
the
end
of
the
abbrev
section
reading
abbrev
entries
return
DW_DLV_ERROR
if
local_indx
return
DW_DLV_NO_ENTRY
if
returned_form
NULL
returned_form
form
if
offset
NULL
offset
mark_abbrev_ptr
dbg
de_debug_abbrev
dss_data
if
returned_attr_num
returned_attr_num
attr
if
returned_implicitconst
Callers
should
only
examine
implicit
const
value
if
the
form
is
DW_FORM_implicit_const
returned_implicitconst
implicitconst
abbrev
dab_next_ptr
abbrev_ptr
abbrev
dab_next_index
Dwarf_Unsigned
local_indx
return
DW_DLV_OK
This
function
is
not
entirely
safe
to
call
The
problem
is
that
the
DWARF
specification
does
not
insist
that
bytes
in
debug_abbrev
that
are
not
referenced
by
debug_info
or
debug_types
need
to
be
initialized
to
anything
specific
Any
garbage
bytes
may
cause
trouble
Not
all
compilers
linkers
leave
unreferenced
garbage
bytes
in
debug_abbrev
so
this
may
work
for
most
objects
In
case
of
error
could
return
a
bogus
value
there
is
no
documented
way
to
detect
error
int
dwarf_get_abbrev_count
Dwarf_Debug
dbg
Dwarf_Abbrev
ab
Dwarf_Unsigned
offset
Dwarf_Unsigned
length
Dwarf_Unsigned
attr_count
Dwarf_Unsigned
abbrev_count
int
abres
DW_DLV_OK
Dwarf_Error
err
while
abres
dwarf_get_abbrev
dbg
offset
DW_DLV_OK
abbrev_count
offset
length
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
if
err
dwarf_dealloc
dbg
err
DW_DLA_ERROR
err
return
abbrev_count
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
To
see
the
full
set
of
DW_DLA
types
and
nothing
else
try
grep
DW_DLA
dwarf_alloc
c
grep
include
config
h
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
stdio
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_alloc
h
These
files
are
included
to
get
the
sizes
of
structs
for
malloc
include
dwarf_util
h
include
dwarf_line
h
include
dwarf_global
h
include
dwarf_arange
h
include
dwarf_abbrev
h
include
dwarf_die_deliv
h
include
dwarf_frame
h
include
dwarf_loc
h
include
dwarf_funcs
h
include
dwarf_types
h
include
dwarf_vars
h
include
dwarf_weaks
h
include
dwarf_harmless
h
include
dwarf_tsearch
h
include
dwarf_gdbindex
h
include
dwarf_gnu_index
h
include
dwarf_xu_index
h
include
dwarf_macro5
h
include
dwarf_debug_names
h
include
dwarf_rnglists
h
include
dwarf_dsc
h
include
dwarfstring
h
include
dwarf_str_offsets
h
if
DEBUG
is
defined
a
lot
of
stdout
is
generated
here
undef
DEBUG
Some
allocations
are
simple
some
not
These
reduce
the
issue
of
determining
which
sort
of
thing
to
a
simple
test
See
ia_multiply_count
Usually
when
MULTIPLY_NO
is
set
the
count
is
so
MULTIPY_CT
would
work
as
well
define
MULTIPLY_NO
define
MULTIPLY_CT
define
MULTIPLY_SP
This
translates
into
de_alloc_hdr
into
a
per
instance
size
and
allows
room
for
a
constructor
destructor
pointer
Rearranging
the
DW_DLA
values
would
break
binary
compatibility
so
that
is
not
an
option
struct
ial_s
In
bytes
one
struct
instance
short
ia_struct_size
Not
a
count
but
a
MULTIPLY
_NO
_CT
_SP
value
short
ia_multiply_count
When
we
really
need
a
constructor
destructor
these
make
applying
such
quite
simple
int
specialconstructor
Dwarf_Debug
void
void
specialdestructor
void
Used
as
a
way
to
return
meaningful
errors
when
the
malloc
arena
is
exhausted
when
malloc
returns
NULL
Not
normally
used
New
in
December
struct
Dwarf_Error_s
_dwarf_failsafe_error
DW_DLE_FAILSAFE_ERRVAL
If
non
zero
the
default
de_alloc_tree
see
dwarf_alloc
c
is
used
normally
If
zero
then
dwarf
allocations
are
not
tracked
by
libdwarf
and
dwarf_finish
cannot
clean
up
any
per
Dwarf_Debug
allocations
the
caller
forgot
to
dealloc
static
signed
char
global_de_alloc_tree_on
ifdef
HAVE_GLOBAL_ALLOC_SUMS
static
Dwarf_Unsigned
global_allocation_count
static
Dwarf_Unsigned
global_allocation_total
static
Dwarf_Unsigned
global_de_alloc_tree_count
static
Dwarf_Unsigned
global_de_alloc_tree_total
static
Dwarf_Unsigned
global_de_alloc_tree_early_dealloc_count
static
Dwarf_Unsigned
global_de_alloc_tree_early_dealloc_size
endif
HAVE_GLOBAL_ALLOC_SUMS
void
_dwarf_alloc_tree_counts
Dwarf_Unsigned
allocount
UNUSEDARG
Dwarf_Unsigned
allosum
UNUSEDARG
Dwarf_Unsigned
treecount
UNUSEDARG
Dwarf_Unsigned
treesum
UNUSEDARG
Dwarf_Unsigned
earlydealloccount
UNUSEDARG
Dwarf_Unsigned
earlydeallocsize
UNUSEDARG
Dwarf_Unsigned
unused1
UNUSEDARG
Dwarf_Unsigned
unused2
UNUSEDARG
Dwarf_Unsigned
unused3
UNUSEDARG
ifdef
HAVE_GLOBAL_ALLOC_SUMS
allocount
global_allocation_count
allosum
global_allocation_total
treecount
global_de_alloc_tree_count
treesum
global_de_alloc_tree_total
earlydealloccount
global_de_alloc_tree_early_dealloc_count
earlydeallocsize
global_de_alloc_tree_early_dealloc_size
if
unused1
unused1
if
unused2
unused2
if
unused3
unused3
endif
HAVE_GLOBAL_ALLOC_SUMS
Defined
March
Allows
a
caller
to
avoid
most
tracking
by
the
de_alloc_tree
hash
table
if
called
with
v
of
zero
Returns
the
value
the
flag
was
before
this
call
int
dwarf_set_de_alloc_flag
int
v
int
ov
global_de_alloc_tree_on
global_de_alloc_tree_on
v
return
ov
void
_dwarf_error_destructor
void
m
Dwarf_Error
er
Dwarf_Error
m
dwarfstring
erm
dwarfstring
er
er_msg
if
erm
return
if
DEBUG
printf
libdwarfdetector
DEALLOC
Now
destruct
error
string
s
n
dwarfstring_string
erm
endif
dwarfstring_destructor
erm
free
erm
er
er_msg
return
To
do
destructors
we
need
some
extra
data
in
every
_dwarf_get_alloc
situation
Here
is
the
extra
we
malloc
for
a
prefix
struct
reserve_size_s
void
dummy_rsv1
void
dummy_rsv2
Here
is
how
we
use
the
extra
prefix
area
struct
reserve_data_s
void
rd_dbg
unsigned
short
rd_length
unsigned
short
rd_type
define
DW_RESERVE
sizeof
struct
reserve_size_s
static
const
struct
ial_s
alloc_instance_basics
ALLOC_AREA_INDEX_TABLE_MAX
none
MULTIPLY_NO
x1
DW_DLA_STRING
MULTIPLY_CT
DW_DLA_LOC
sizeof
Dwarf_Loc
MULTIPLY_NO
x3
DW_DLA_LOCDESC
sizeof
Dwarf_Locdesc
MULTIPLY_NO
DW_DLA_ELLIST
not
used
MULTIPLY_NO
DW_DLA_BOUNDS
not
used
MULTIPLY_NO
DW_DLA_BLOCK
sizeof
Dwarf_Block
MULTIPLY_NO
x7
DW_DLA_DEBUG
the
actual
dwarf_debug
structure
MULTIPLY_NO
x8
DW_DLA_DIE
sizeof
struct
Dwarf_Die_s
MULTIPLY_NO
x9
DW_DLA_LINE
sizeof
struct
Dwarf_Line_s
MULTIPLY_NO
DW_DLA_ATTR
sizeof
struct
Dwarf_Attribute_s
MULTIPLY_NO
DW_DLA_TYPE
not
used
MULTIPLY_NO
DW_DLA_SUBSCR
not
used
MULTIPLY_NO
DW_DLA_GLOBAL
sizeof
struct
Dwarf_Global_s
MULTIPLY_NO
DW_DLA_ERROR
sizeof
struct
Dwarf_Error_s
MULTIPLY_NO
_dwarf_error_destructor
DW_DLA_LIST
sizeof
Dwarf_Ptr
MULTIPLY_CT
DW_DLA_LINEBUF
not
used
MULTIPLY_NO
DW_DLA_ARANGE
sizeof
struct
Dwarf_Arange_s
MULTIPLY_NO
DW_DLA_ABBREV
sizeof
struct
Dwarf_Abbrev_s
MULTIPLY_NO
DW_DLA_FRAME_OP
sizeof
Dwarf_Frame_Op
MULTIPLY_NO
DW_DLA_CIE
sizeof
struct
Dwarf_Cie_s
MULTIPLY_NO
DW_DLA_FDE
sizeof
struct
Dwarf_Fde_s
MULTIPLY_NO
_dwarf_fde_destructor
DW_DLA_LOC_BLOCK
sizeof
Dwarf_Loc
MULTIPLY_CT
DW_DLA_FRAME_BLOCK
sizeof
Dwarf_Frame_Op
MULTIPLY_CT
DW_DLA_FUNC
UNUSED
sizeof
struct
Dwarf_Global_s
MULTIPLY_NO
DW_DLA_TYPENAME
UNUSED
sizeof
struct
Dwarf_Global_s
MULTIPLY_NO
DW_DLA_VAR
UNUSED
sizeof
struct
Dwarf_Global_s
MULTIPLY_NO
DW_DLA_WEAK
UNUSED
sizeof
struct
Dwarf_Global_s
MULTIPLY_NO
DW_DLA_ADDR
MULTIPLY_SP
DW_DLA_RANGES
sizeof
Dwarf_Ranges
MULTIPLY_CT
The
following
DW_DLA
data
types
are
known
only
inside
libdwarf
DW_DLA_ABBREV_LIST
sizeof
struct
Dwarf_Abbrev_List_s
MULTIPLY_NO
DW_DLA_CHAIN
sizeof
struct
Dwarf_Chain_s
MULTIPLY_NO
DW_DLA_CU_CONTEXT
sizeof
struct
Dwarf_CU_Context_s
MULTIPLY_NO
DW_DLA_FRAME
sizeof
struct
Dwarf_Frame_s
MULTIPLY_NO
_dwarf_frame_constructor
_dwarf_frame_destructor
DW_DLA_GLOBAL_CONTEXT
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_FILE_ENTRY
sizeof
struct
Dwarf_File_Entry_s
MULTIPLY_NO
DW_DLA_LINE_CONTEXT
sizeof
struct
Dwarf_Line_Context_s
MULTIPLY_NO
_dwarf_line_context_constructor
_dwarf_line_context_destructor
DW_DLA_LOC_CHAIN
sizeof
struct
Dwarf_Loc_Chain_s
MULTIPLY_NO
DW_DLA_HASH_TABLE
sizeof
struct
Dwarf_Hash_Table_s
MULTIPLY_NO
The
following
really
use
Global
struct
used
to
be
unique
struct
per
type
but
now
merged
The
opaque
types
are
visible
in
the
interface
The
types
for
DW_DLA_FUNC
DW_DLA_TYPENAME
DW_DLA_VAR
DW_DLA_WEAK
also
use
the
global
types
DW_DLA_FUNC_CONTEXT
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_TYPENAME_CONTEXT
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_VAR_CONTEXT
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_WEAK_CONTEXT
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_PUBTYPES_CONTEXT
DWARF3
sizeof
struct
Dwarf_Global_Context_s
MULTIPLY_NO
DW_DLA_HASH_TABLE_ENTRY
sizeof
struct
Dwarf_Hash_Table_Entry_s
MULTIPLY_CT
reserved
sizeof
int
MULTIPLY_NO
reserved
for
future
use
sizeof
int
MULTIPLY_NO
reserved
for
future
use
sizeof
int
MULTIPLY_NO
reserved
for
future
internal
use
sizeof
int
MULTIPLY_NO
reserved
for
future
internal
use
sizeof
int
MULTIPLY_NO
reserved
for
future
internal
use
sizeof
int
MULTIPLY_NO
reserved
for
future
internal
use
sizeof
int
MULTIPLY_NO
reserved
for
future
internal
use
sizeof
int
MULTIPLY_NO
Used
starting
July
DW_DLA_GNU_INDEX_HEAD
sizeof
struct
Dwarf_Gnu_Index_Head_s
MULTIPLY_NO
_dwarf_gnu_index_head_destructor
Used
starting
May
DW_DLA_RNGLISTS_HEAD
sizeof
struct
Dwarf_Rnglists_Head_s
MULTIPLY_NO
_dwarf_rnglists_head_destructor
now
we
have
types
that
are
public
New
in
June
Gdb
sizeof
struct
Dwarf_Gdbindex_s
MULTIPLY_NO
New
in
July
DWARF5
DebugFission
dwp
file
sections
debug_cu_index
and
debug_tu_index
sizeof
struct
Dwarf_Xu_Index_Header_s
MULTIPLY_NO
These
required
by
new
features
in
DWARF5
Also
usable
for
DWARF2
DW_DLA_LOC_BLOCK_C
DWARF5
sizeof
struct
Dwarf_Loc_Expr_Op_s
MULTIPLY_CT
DW_DLA_LOCDESC_C
sizeof
struct
Dwarf_Locdesc_c_s
MULTIPLY_CT
_dwarf_locdesc_c_constructor
DW_DLA_LOC_HEAD_C
sizeof
struct
Dwarf_Loc_Head_c_s
MULTIPLY_NO
_dwarf_loclists_head_destructor
DW_DLA_MACRO_CONTEXT
sizeof
struct
Dwarf_Macro_Context_s
MULTIPLY_NO
_dwarf_macro_constructor
_dwarf_macro_destructor
DW_DLA_CHAIN_2
sizeof
struct
Dwarf_Chain_o
MULTIPLY_NO
DW_DLA_DSC_HEAD
sizeof
struct
Dwarf_Dsc_Head_s
MULTIPLY_NO
_dwarf_dsc_destructor
DW_DLA_DNAMES_HEAD
sizeof
struct
Dwarf_Dnames_Head_s
MULTIPLY_NO
_dwarf_debugnames_destructor
DW_DLA_STR_OFFSETS
sizeof
struct
Dwarf_Str_Offsets_Table_s
MULTIPLY_NO
We
are
simply
using
the
incoming
pointer
as
the
key
pointer
static
DW_TSHASHTYPE
simple_value_hashfunc
const
void
keyp
DW_TSHASHTYPE
up
DW_TSHASHTYPE
uintptr_t
keyp
return
up
We
did
alloc
something
but
not
a
fixed
length
thing
Instead
it
starts
with
some
special
data
we
noted
The
incoming
pointer
is
to
the
caller
data
we
destruct
based
on
caller
but
find
the
special
extra
data
in
a
prefix
area
static
void
tdestroy_free_node
void
nodep
char
m
char
nodep
char
malloc_addr
m
DW_RESERVE
struct
reserve_data_s
reserve
struct
reserve_data_s
malloc_addr
unsigned
type
reserve
rd_type
if
type
ALLOC_AREA_INDEX_TABLE_MAX
Internal
error
corrupted
data
return
if
reserve
rd_dbg
Unused
corrupted?
node
in
the
tree
Should
never
happen
return
if
reserve
rd_type
Unused
corrupted?
node
in
the
tree
Should
never
happen
return
if
alloc_instance_basics
type
specialdestructor
alloc_instance_basics
type
specialdestructor
m
free
malloc_addr
The
sort
of
hash
table
entries
result
in
very
simple
helper
functions
static
int
simple_compare_function
const
void
l
const
void
r
DW_TSHASHTYPE
lp
DW_TSHASHTYPE
uintptr_t
l
DW_TSHASHTYPE
rp
DW_TSHASHTYPE
uintptr_t
r
if
lp
rp
return
if
lp
rp
return
return
This
function
returns
a
pointer
to
a
region
of
memory
For
alloc_types
that
are
not
strings
or
lists
of
pointers
only
struct
can
be
requested
at
a
time
This
is
indicated
by
an
input
count
of
For
strings
count
equals
the
length
of
the
string
it
will
contain
i
e
it
the
length
of
the
string
plus
for
the
terminating
null
For
lists
of
pointers
count
is
equal
to
the
number
of
pointers
For
DW_DLA_FRAME_BLOCK
DW_DLA_RANGES
and
DW_DLA_LOC_BLOCK
allocation
types
also
count
is
the
count
of
the
number
of
structs
needed
This
function
cannot
be
used
to
allocate
a
Dwarf_Debug_s
struct
char
_dwarf_get_alloc
Dwarf_Debug
dbg
Dwarf_Small
alloc_type
Dwarf_Unsigned
count
char
alloc_mem
Dwarf_Signed
basesize
Dwarf_Signed
size
unsigned
int
type
alloc_type
short
action
if
dbg
NULL
if
DEBUG
printf
libdwarfdetector
ALLOC
dbg
null
ret
NULL
type
x
size
lu
line
d
s
n
unsigned
alloc_type
unsigned
long
size
__LINE__
__FILE__
endif
return
NULL
if
type
ALLOC_AREA_INDEX_TABLE_MAX
internal
error
if
DEBUG
printf
libdwarfdetector
ALLOC
type
bad
ret
null
ret
NULL
type
x
size
lu
line
d
s
n
unsigned
alloc_type
unsigned
long
size
__LINE__
__FILE__
endif
return
NULL
basesize
alloc_instance_basics
alloc_type
ia_struct_size
action
alloc_instance_basics
alloc_type
ia_multiply_count
if
action
MULTIPLY_NO
Usually
count
is
but
do
not
assume
it
size
basesize
else
if
action
MULTIPLY_CT
size
basesize
count
else
MULTIPLY_SP
DW_DLA_ADDR
count
largest
size
size
count
sizeof
Dwarf_Addr
sizeof
Dwarf_Off
sizeof
Dwarf_Addr
sizeof
Dwarf_Off
size
DW_RESERVE
alloc_mem
malloc
size
if
alloc_mem
return
NULL
char
ret_mem
alloc_mem
DW_RESERVE
void
key
ret_mem
struct
reserve_data_s
r
struct
reserve_data_s
alloc_mem
void
result
memset
alloc_mem
size
We
are
not
actually
using
rd_dbg
we
are
using
rd_type
r
rd_dbg
dbg
r
rd_type
alloc_type
r
rd_length
size
if
alloc_instance_basics
type
specialconstructor
int
res
alloc_instance_basics
type
specialconstructor
dbg
ret_mem
if
res
DW_DLV_OK
We
leak
what
we
allocated
in
_dwarf_find_memory
when
constructor
fails
if
DEBUG
printf
libdwarfdetector
ALLOC
constructor
fails
ret
NULL
type
x
size
lu
line
d
s
n
unsigned
alloc_type
unsigned
long
size
__LINE__
__FILE__
endif
return
NULL
See
global
flag
If
zero
then
caller
chooses
not
to
track
allocations
so
dwarf_finish
is
unable
to
free
anything
the
caller
omitted
to
dealloc
Normally
the
global
flag
is
non
zero
ifdef
HAVE_GLOBAL_ALLOC_SUMS
global_allocation_count
global_allocation_total
size
endif
HAVE_GLOBAL_ALLOC_SUMS
As
of
March
it
s
not
necessary
to
test
for
alloc
type
but
instead
only
call
tsearch
if
de_alloc_tree_on
if
global_de_alloc_tree_on
ifdef
HAVE_GLOBAL_ALLOC_SUMS
global_de_alloc_tree_total
size
global_de_alloc_tree_count
endif
HAVE_GLOBAL_ALLOC_SUMS
result
dwarf_tsearch
void
key
de_alloc_tree
simple_compare_function
if
result
Something
badly
wrong
Out
of
memory
pretend
all
is
well
if
DEBUG
printf
libdwarfdetector
ALLOC
ret
lx
type
x
size
lu
line
d
s
n
unsigned
long
ret_mem
unsigned
alloc_type
unsigned
long
size
__LINE__
__FILE__
endif
return
ret_mem
This
was
once
a
long
list
of
tests
using
dss_data
and
dss_size
to
see
if
space
was
inside
a
debug
section
This
tfind
approach
removes
that
maintenance
headache
static
int
string_is_in_debug_section
Dwarf_Debug
dbg
void
space
See
dwarf_line
c
dwarf_srcfiles
for
one
way
we
can
wind
up
with
a
DW_DLA_STRING
string
that
may
or
may
not
be
malloc
ed
by
_dwarf_get_alloc
dwarf_formstring
for
example
returns
strings
which
point
into
debug_info
or
debug_types
but
dwarf_dealloc
is
never
supposed
to
be
applied
to
strings
dwarf_formstring
returns
Lots
of
calls
returning
strings
have
always
been
documented
as
requiring
dwarf_dealloc
DW_DLA_STRING
when
the
code
just
returns
a
pointer
to
a
portion
of
a
loaded
section
It
is
too
late
to
change
the
documentation
void
result
result
dwarf_tfind
void
space
de_alloc_tree
simple_compare_function
if
result
Not
in
the
tree
so
not
malloc
ed
Nothing
to
delete
return
TRUE
We
found
the
address
in
the
tree
so
it
is
NOT
part
of
debug_info
or
any
other
dwarf
section
but
is
space
malloc
d
in
_dwarf_get_alloc
return
FALSE
These
wrappers
for
dwarf_dealloc
enable
type
checking
at
call
points
void
dwarf_dealloc_error
Dwarf_Debug
dbg
Dwarf_Error
err
dwarf_dealloc
dbg
err
DW_DLA_ERROR
void
dwarf_dealloc_die
Dwarf_Die
die
Dwarf_Debug
dbg
Dwarf_CU_Context
context
if
die
ifdef
DEBUG
printf
DEALLOC
die
does
nothing
die
NULL
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
return
context
die
di_cu_context
if
context
ifdef
DEBUG
printf
DEALLOC
die
does
nothing
context
NULL
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
return
dbg
context
cc_dbg
dwarf_dealloc
dbg
die
DW_DLA_DIE
void
dwarf_dealloc_attribute
Dwarf_Attribute
attr
Dwarf_Debug
dbg
if
attr
ifdef
DEBUG
printf
DEALLOC
does
nothing
attr
is
NULL
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
return
dbg
attr
ar_dbg
dwarf_dealloc
dbg
attr
DW_DLA_ATTR
This
function
is
used
to
deallocate
a
region
of
memory
that
was
obtained
by
a
call
to
_dwarf_get_alloc
Note
that
though
dwarf_dealloc
is
a
public
function
_dwarf_get_alloc
isn
t
For
lists
typically
arrays
of
pointers
it
is
assumed
that
the
space
was
allocated
by
a
direct
call
to
malloc
and
so
a
straight
free
is
done
This
is
also
the
case
for
variable
length
blocks
such
as
DW_DLA_FRAME_BLOCK
and
DW_DLA_LOC_BLOCK
and
DW_DLA_RANGES
For
strings
the
pointer
might
point
to
a
string
in
debug_info
or
debug_string
After
this
is
checked
and
if
found
not
to
be
the
case
a
free
is
done
again
on
the
assumption
that
a
malloc
was
used
to
obtain
the
space
This
function
does
not
return
anything
The
_dwarf_error_destructor
will
be
called
to
free
the
er_msg
string
if
this
is
a
Dwarf_Error
just
before
the
Dwarf_Error
is
freed
here
See
specialdestructor
below
void
dwarf_dealloc
Dwarf_Debug
dbg
Dwarf_Ptr
space
Dwarf_Unsigned
alloc_type
unsigned
int
type
char
malloc_addr
struct
reserve_data_s
r
if
space
ifdef
DEBUG
printf
DEALLOC
does
nothing
space
NULL
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
return
if
dbg
App
error
or
an
app
that
failed
in
a
dwarf_init
or
dwarf_elf_init
call
ifdef
DEBUG
printf
DEALLOC
dbg
NULL
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
if
dbg
dbg
de_alloc_tree
If
it
s
a
string
in
debug_info
etc
doing
char
space
DW_RESERVE
is
totally
bogus
if
alloc_type
DW_DLA_STRING
string_is_in_debug_section
dbg
space
A
string
pointer
may
point
into
debug_info
or
debug_string
etc
So
must
not
be
freed
And
strings
have
no
need
of
a
specialdestructor
Mostly
a
historical
mistake
here
Corrected
in
libdwarf
March
ifdef
DEBUG
printf
DEALLOC
string
in
section
no
dealloc
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
return
Otherwise
it
might
be
allocated
string
so
it
is
ok
do
the
char
space
DW_RESERVE
If
it
s
a
DW_DLA_STRING
case
and
erroneous
the
following
pointer
operations
might
result
in
a
coredump
if
the
pointer
is
to
the
beginning
of
a
string
section
If
not
DW_DLA_STRING
no
correctly
written
caller
could
coredump
here
malloc_addr
char
space
DW_RESERVE
r
struct
reserve_data_s
malloc_addr
if
dbg
dbg
r
rd_dbg
Mixed
up
or
originally
a
no_dbg
alloc
ifdef
DEBUG
printf
DEALLOC
find
was
NULL
dbg
lx
rd_dbg
lx
space
lx
line
d
s
n
unsigned
long
dbg
unsigned
long
r
rd_dbg
unsigned
long
space
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
if
dbg
alloc_type
r
rd_type
Something
is
mixed
up
ifdef
DEBUG
printf
DEALLOC
does
nothing
type
lx
rd_type
lx
space
lx
line
d
s
n
unsigned
long
alloc_type
unsigned
long
r
rd_type
unsigned
long
space
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
return
if
alloc_type
DW_DLA_ERROR
Dwarf_Error
ep
Dwarf_Error
space
if
ep
er_static_alloc
DE_STATIC
This
is
special
malloc
arena
was
exhausted
or
a
NULL
dbg
was
used
for
the
error
because
the
real
dbg
was
unavailable
There
is
nothing
to
delete
really
Set
er_errval
to
signal
that
the
space
was
dealloc
d
_dwarf_failsafe_error
er_errval
DW_DLE_FAILSAFE_ERRVAL
_dwarf_error_destructor
ep
ifdef
DEBUG
printf
DEALLOC
does
nothing
DE_STATIC
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
return
if
ep
er_static_alloc
DE_MALLOC
This
is
special
we
had
no
arena
but
have
a
full
special
area
as
normal
ifdef
DEBUG
printf
DEALLOC
does
free
DE_MALLOC
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
DEBUG
if
_dwarf_error_destructor
ep
free
space
return
endif
Was
normal
alloc
use
normal
dealloc
DW_DLA_ERROR
has
a
specialdestructor
type
alloc_type
if
DEBUG
if
dbg
r
rd_dbg
printf
DEALLOC
dbg
rd_dbg
going
ahead
line
d
s
n
__LINE__
__FILE__
fflush
stdout
endif
if
DEBUG
printf
libdwarfdetector
DEALLOC
ret
lx
type
x
size
lu
line
d
s
n
unsigned
long
space
unsigned
type
unsigned
long
r
rd_length
__LINE__
__FILE__
endif
if
type
ALLOC_AREA_INDEX_TABLE_MAX
internal
or
user
app
error
ifdef
DEBUG
printf
DEALLOC
does
nothing
type
too
big
lu
line
d
s
n
unsigned
long
type
__LINE__
__FILE__
endif
DEBUG
return
ifdef
HAVE_GLOBAL_ALLOC_SUMS
global_de_alloc_tree_early_dealloc_count
global_de_alloc_tree_early_dealloc_size
r
rd_length
endif
HAVE_GLOBAL_ALLOC_SUMS
if
alloc_instance_basics
type
specialdestructor
alloc_instance_basics
type
specialdestructor
space
if
dbg
dbg
de_alloc_tree
The
space
pointer
we
get
points
after
the
reserve
space
The
key
is
space
and
address
to
free
is
just
a
few
bytes
before
space
void
key
space
dwarf_tdelete
key
de_alloc_tree
simple_compare_function
If
dwarf_tdelete
returns
NULL
it
might
mean
a
tree
is
empty
b
If
hashsearch
then
a
single
chain
might
now
be
empty
so
we
do
not
know
of
a
parent
node
c
We
did
not
find
that
key
we
did
nothing
In
any
case
we
simply
don
t
worry
about
it
Not
Supposed
To
Happen
r
rd_dbg
void
r
rd_length
r
rd_type
free
malloc_addr
return
Allocates
space
for
a
Dwarf_Debug_s
struct
since
one
does
not
exist
Dwarf_Debug
_dwarf_get_debug
void
Dwarf_Debug
dbg
dbg
Dwarf_Debug
malloc
sizeof
struct
Dwarf_Debug_s
if
dbg
NULL
return
NULL
memset
dbg
sizeof
struct
Dwarf_Debug_s
Set
up
for
a
dwarf_tsearch
hash
table
Leaving
initialization
on
so
we
can
track
DW_DLA_STRING
even
when
global_de_alloc_tree_on
is
zero
if
global_de_alloc_tree_on
dwarf_initialize_search_hash
de_alloc_tree
simple_value_hashfunc
return
dbg
This
function
prints
out
the
statistics
collected
on
allocation
of
memory
chunks
No
longer
used
void
dwarf_print_memory_stats
Dwarf_Debug
dbg
UNUSEDARG
In
the
rela
relocation
case
or
in
case
of
compressed
sections
we
might
have
malloc
d
space
to
ensure
it
is
read
write
or
to
decompress
it
respectively
or
both
In
that
case
free
the
space
static
void
malloc_section_free
struct
Dwarf_Section_s
sec
if
sec
dss_data_was_malloc
free
sec
dss_data
sec
dss_data
sec
dss_data_was_malloc
static
void
freecontextlist
Dwarf_Debug
dbg
Dwarf_Debug_InfoTypes
dis
Dwarf_CU_Context
context
Dwarf_CU_Context
nextcontext
for
context
dis
de_cu_context_list
context
context
nextcontext
Dwarf_Hash_Table
hash_table
hash_table
context
cc_abbrev_hash_table
_dwarf_free_abbrev_hash_table_contents
dbg
hash_table
hash_table
tb_entries
nextcontext
context
cc_next
context
cc_next
See
also
local_dealloc_cu_context
in
dwarf_die_deliv
c
dwarf_dealloc
dbg
hash_table
DW_DLA_HASH_TABLE
context
cc_abbrev_hash_table
dwarf_dealloc
dbg
context
DW_DLA_CU_CONTEXT
dis
de_cu_context_list
Used
to
free
all
space
allocated
for
this
Dwarf_Debug
The
caller
should
assume
that
the
Dwarf_Debug
pointer
itself
is
no
longer
valid
upon
return
from
this
function
NEVER
returns
DW_DLV_ERROR
In
case
of
difficulty
this
function
simply
returns
quietly
int
_dwarf_free_all_of_one_debug
Dwarf_Debug
dbg
unsigned
g
if
dbg
NULL
return
DW_DLV_NO_ENTRY
To
do
complete
validation
that
we
have
no
surprising
missing
or
erroneous
deallocs
it
is
advisable
to
do
the
dwarf_deallocs
here
that
are
not
things
the
user
can
otherwise
request
Housecleaning
if
dbg
de_cu_hashindex_data
dwarf_xu_header_free
dbg
de_cu_hashindex_data
dbg
de_cu_hashindex_data
if
dbg
de_tu_hashindex_data
dwarf_xu_header_free
dbg
de_tu_hashindex_data
dbg
de_tu_hashindex_data
if
dbg
de_printf_callback_null_device_handle
fclose
dbg
de_printf_callback_null_device_handle
dbg
de_printf_callback_null_device_handle
freecontextlist
dbg
de_info_reading
freecontextlist
dbg
de_types_reading
Housecleaning
done
Now
really
free
all
the
space
malloc_section_free
de_debug_info
malloc_section_free
de_debug_types
malloc_section_free
de_debug_abbrev
malloc_section_free
de_debug_line
malloc_section_free
de_debug_line_str
malloc_section_free
de_debug_loc
malloc_section_free
de_debug_aranges
malloc_section_free
de_debug_macinfo
malloc_section_free
de_debug_macro
malloc_section_free
de_debug_names
malloc_section_free
de_debug_pubnames
malloc_section_free
de_debug_str
malloc_section_free
de_debug_sup
malloc_section_free
de_debug_frame
malloc_section_free
de_debug_frame_eh_gnu
malloc_section_free
de_debug_pubtypes
malloc_section_free
de_debug_funcnames
malloc_section_free
de_debug_typenames
malloc_section_free
de_debug_varnames
malloc_section_free
de_debug_weaknames
malloc_section_free
de_debug_ranges
malloc_section_free
de_debug_str_offsets
malloc_section_free
de_debug_addr
malloc_section_free
de_debug_gdbindex
malloc_section_free
de_debug_cu_index
malloc_section_free
de_debug_tu_index
malloc_section_free
de_debug_loclists
malloc_section_free
de_debug_rnglists
dwarf_harmless_cleanout
de_harmless_errors
_dwarf_dealloc_rnglists_context
dbg
_dwarf_dealloc_loclists_context
dbg
if
dbg
de_printf_callback
dp_buffer
dbg
de_printf_callback
dp_buffer_user_provided
free
dbg
de_printf_callback
dp_buffer
_dwarf_destroy_group_map
dbg
de_alloc_tree
might
be
NULL
if
global_de_alloc_tree_on
is
zero
if
dbg
de_alloc_tree
dwarf_tdestroy
dbg
de_alloc_tree
tdestroy_free_node
dbg
de_alloc_tree
first
walk
the
search
and
free
contents
Now
do
the
search
tree
itself
if
dbg
de_tied_data
td_tied_search
dwarf_tdestroy
dbg
de_tied_data
td_tied_search
_dwarf_tied_destroy_free_node
dbg
de_tied_data
td_tied_search
free
void
dbg
de_path
dbg
de_path
for
g
g
dbg
de_gnu_global_path_count
g
free
char
dbg
de_gnu_global_paths
g
dbg
de_gnu_global_paths
g
free
void
dbg
de_gnu_global_paths
dbg
de_gnu_global_paths
dbg
de_gnu_global_path_count
memset
dbg
sizeof
dbg
Prevent
accidental
use
later
free
dbg
return
DW_DLV_OK
A
special
case
we
have
no
dbg
no
alloc
header
etc
So
create
something
out
of
thin
air
that
we
can
recognize
in
dwarf_dealloc
Something
with
the
prefix
prefix
space
hidden
from
caller
Only
applies
to
DW_DLA_ERROR
and
making
up
an
error
record
The
allocated
space
simply
leaks
struct
Dwarf_Error_s
_dwarf_special_no_dbg_error_malloc
void
Dwarf_Error
e
Dwarf_Unsigned
len
sizeof
struct
Dwarf_Error_s
DW_RESERVE
struct
reserve_data_s
base
char
mem
char
malloc
len
if
mem
return
memset
mem
len
base
struct
reserve_data_s
mem
base
rd_dbg
base
rd_length
sizeof
struct
Dwarf_Error_s
base
rd_type
DW_DLA_ERROR
e
Dwarf_Error
mem
DW_RESERVE
e
er_static_alloc
DE_MALLOC
return
e
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_arange
h
include
dwarf_global
h
for
_dwarf_fixup_
include
dwarfstring
h
static
void
free_aranges_chain
Dwarf_Debug
dbg
Dwarf_Chain
head
Dwarf_Chain
cur
head
Dwarf_Chain
next
if
head
return
next
head
ch_next
for
cur
cur
next
void
item
cur
ch_item
int
type
cur
ch_itemtype
next
cur
ch_next
if
item
type
dwarf_dealloc
dbg
item
type
cur
ch_item
dwarf_dealloc
dbg
cur
DW_DLA_CHAIN
Common
code
for
two
user
visible
routines
to
share
Errors
here
result
in
memory
leaks
but
errors
here
are
serious
making
aranges
unusable
so
we
assume
callers
will
not
repeat
the
error
often
or
mind
the
leaks
static
int
dwarf_get_aranges_list
Dwarf_Debug
dbg
Dwarf_Chain
chain_out
Dwarf_Signed
chain_count_out
Dwarf_Error
error
Sweeps
through
the
arange
Dwarf_Small
arange_ptr
Dwarf_Small
arange_ptr_start
Start
of
arange
header
Used
for
rounding
offset
of
arange_ptr
to
twice
the
tuple
size
Libdwarf
requirement
Dwarf_Small
header_ptr
Version
of
debug_aranges
header
Dwarf_Unsigned
version
Offset
of
current
set
of
aranges
into
debug_info
Dwarf_Off
info_offset
Size
in
bytes
of
addresses
in
target
Dwarf_Small
address_size
Size
in
bytes
of
segment
offsets
in
target
Dwarf_Small
segment_size
Count
of
total
number
of
aranges
Dwarf_Signed
arange_count
Dwarf_Arange
arange
Dwarf_Unsigned
section_size
Dwarf_Byte_Ptr
arange_end_section
Used
to
chain
Dwarf_Aranges
structs
Dwarf_Chain
curr_chain
NULL
Dwarf_Chain
prev_chain
NULL
Dwarf_Chain
head_chain
NULL
if
dbg
de_debug_aranges
dss_size
return
DW_DLV_NO_ENTRY
arange_ptr
dbg
de_debug_aranges
dss_data
arange_ptr_start
arange_ptr
section_size
dbg
de_debug_aranges
dss_size
arange_end_section
arange_ptr
section_size
do
Length
of
current
set
of
aranges
This
is
local
length
which
begins
just
after
the
length
field
itself
Dwarf_Unsigned
area_length
Dwarf_Small
remainder
Dwarf_Unsigned
range_entry_size
int
local_length_size
int
local_extension_size
Dwarf_Small
end_this_arange
int
res
header_ptr
arange_ptr
if
header_ptr
arange_end_section
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
res
_dwarf_read_area_length_ck_wrapper
dbg
section_size
arange_end_section
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
has
been
incremented
appropriately
past
the
length
field
by
READ_AREA_LENGTH
if
area_length
dbg
de_debug_aranges
dss_size
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
if
area_length
local_length_size
local_extension_size
dbg
de_debug_aranges
dss_size
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
end_this_arange
arange_ptr
area_length
if
end_this_arange
arange_end_section
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
if
area_length
We
read
bytes
of
zero
so
area
length
zero
Keep
scanning
First
seen
Nov
in
GNU
cc
in
windows
dll
continue
res
_dwarf_read_unaligned_ck_wrapper
dbg
arange_ptr
DWARF_HALF_SIZE
end_this_arange
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
DWARF_HALF_SIZE
if
arange_ptr
end_this_arange
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
if
version
DW_ARANGES_VERSION2
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_VERSION_STAMP_ERROR
return
DW_DLV_ERROR
res
_dwarf_read_unaligned_ck_wrapper
dbg
arange_ptr
local_length_size
end_this_arange
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
local_length_size
if
arange_ptr
end_this_arange
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGES_HEADER_ERROR
return
DW_DLV_ERROR
This
applies
to
debug_info
only
not
to
debug_types
if
info_offset
dbg
de_debug_info
dss_size
FIX_UP_OFFSET_IRIX_BUG
dbg
info_offset
arange
info
offset
a
if
info_offset
dbg
de_debug_info
dss_size
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGE_OFFSET_BAD
return
DW_DLV_ERROR
address_size
Dwarf_Small
arange_ptr
if
address_size
sizeof
Dwarf_Addr
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ADDRESS_SIZE_ERROR
return
DW_DLV_ERROR
if
address_size
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ADDRESS_SIZE_ZERO
return
DW_DLV_ERROR
It
is
not
an
error
if
the
sizes
differ
Unusual
but
not
an
error
arange_ptr
arange_ptr
sizeof
Dwarf_Small
The
following
deref
means
we
better
check
the
pointer
for
off
end
if
arange_ptr
end_this_arange
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGE_OFFSET_BAD
return
DW_DLV_ERROR
Even
DWARF2
had
a
segment_size
field
here
meaning
size
in
bytes
of
a
segment
descriptor
on
the
target
system
segment_size
Dwarf_Small
arange_ptr
if
segment_size
sizeof
Dwarf_Addr
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_SEGMENT_SIZE_BAD
return
DW_DLV_ERROR
arange_ptr
arange_ptr
sizeof
Dwarf_Small
Code
below
will
check
for
end_this_arange
as
appropriate
if
arange_ptr
end_this_arange
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGE_OFFSET_BAD
return
DW_DLV_ERROR
range_entry_size
address_size
segment_size
Round
arange_ptr
offset
to
next
multiple
of
address_size
remainder
Dwarf_Unsigned
arange_ptr
header_ptr
range_entry_size
if
remainder
arange_ptr
arange_ptr
address_size
remainder
do
Dwarf_Addr
range_address
Dwarf_Unsigned
segment_selector
Dwarf_Unsigned
range_length
For
segmented
address
spaces
the
first
field
to
read
is
a
segment
selector
new
in
DWARF4
The
version
number
DID
NOT
CHANGE
from
which
is
quite
surprising
Also
surprising
since
the
segment_size
was
always
there
in
the
table
header
We
want
to
test
cu_version
here
but
currently
with
no
way
to
do
that
So
we
just
hope
no
one
using
segment_selectors
really
FIXME
if
segment_size
Only
applies
if
cu_version
res
_dwarf_read_unaligned_ck_wrapper
dbg
arange_ptr
segment_size
end_this_arange
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
address_size
res
_dwarf_read_unaligned_ck_wrapper
dbg
arange_ptr
address_size
end_this_arange
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
address_size
res
_dwarf_read_unaligned_ck_wrapper
dbg
arange_ptr
address_size
end_this_arange
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_ptr
address_size
We
used
to
suppress
all
zero
entries
but
now
we
return
all
aranges
entries
so
we
show
the
entire
content
March
arange
Dwarf_Arange
_dwarf_get_alloc
dbg
DW_DLA_ARANGE
if
arange
NULL
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
arange
ar_segment_selector
segment_selector
arange
ar_segment_selector_size
segment_size
arange
ar_address
range_address
arange
ar_length
range_length
arange
ar_info_offset
info_offset
arange
ar_dbg
dbg
arange_count
curr_chain
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_chain
NULL
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_chain
ch_item
arange
curr_chain
ch_itemtype
DW_DLA_ARANGE
if
head_chain
NULL
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
The
current
set
of
ranges
is
terminated
by
range_address
and
range_length
but
that
does
not
necessarily
terminate
the
ranges
for
this
CU
There
can
be
multiple
sets
in
that
DWARF
does
not
explicitly
forbid
multiple
sets
DWARF2
section
We
stop
short
to
avoid
overrun
of
the
end
of
the
CU
while
end_this_arange
arange_ptr
range_entry_size
A
compiler
could
emit
some
padding
bytes
here
dwarf2
dwarf4
sec
does
not
clearly
make
extra
padding
bytes
illegal
if
end_this_arange
arange_ptr
Dwarf_Unsigned
pad_count
arange_ptr
end_this_arange
Dwarf_Unsigned
offset
arange_ptr
arange_ptr_start
dwarfstring
aramsg
dwarfstring_constructor
Safe
Length
strictly
limited
dwarfstring_append_printf_u
DW_DLE_ARANGE_LENGTH_BAD
DW_PR_XZEROS
DW_PR_DUx
pad_count
dwarfstring_append_printf_u
pad
bytes
at
offset
DW_PR_XZEROS
DW_PR_DUx
in
debug_aranges
offset
dwarf_insert_harmless_error
dbg
dwarfstring_string
dwarfstring_destructor
For
most
compilers
arange_ptr
end_this_arange
at
this
point
But
not
if
there
were
padding
bytes
arange_ptr
end_this_arange
while
arange_ptr
arange_end_section
if
arange_ptr
arange_end_section
free_aranges_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ARANGE_DECODE_ERROR
return
DW_DLV_ERROR
chain_out
head_chain
chain_count_out
arange_count
return
DW_DLV_OK
This
function
returns
the
count
of
the
number
of
aranges
in
the
debug_aranges
section
It
sets
aranges
to
point
to
a
block
of
Dwarf_Arange
s
describing
the
arange
s
It
returns
DW_DLV_ERROR
on
error
Must
be
identical
in
most
aspects
to
dwarf_get_aranges_addr_offsets
int
dwarf_get_aranges
Dwarf_Debug
dbg
Dwarf_Arange
aranges
Dwarf_Signed
returned_count
Dwarf_Error
error
Count
of
total
number
of
aranges
Dwarf_Signed
arange_count
Dwarf_Arange
arange_block
Used
to
chain
Dwarf_Aranges
structs
Dwarf_Chain
curr_chain
NULL
Dwarf_Chain
prev_chain
NULL
Dwarf_Chain
head_chain
NULL
Dwarf_Signed
i
int
res
DW_DLV_ERROR
BEGIN
CODE
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_aranges
error
if
res
DW_DLV_OK
return
res
aranges
points
in
to
info
so
if
info
needs
expanding
we
have
to
load
it
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
res
dwarf_get_aranges_list
dbg
error
if
res
DW_DLV_OK
free_aranges_chain
dbg
head_chain
return
res
arange_block
Dwarf_Arange
_dwarf_get_alloc
dbg
DW_DLA_LIST
arange_count
if
arange_block
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
free_aranges_chain
dbg
head_chain
return
DW_DLV_ERROR
See
also
free_aranges_chain
above
curr_chain
head_chain
for
i
i
arange_count
i
Copies
pointers
No
dealloc
of
ch_item
arange_block
i
curr_chain
ch_item
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
aranges
arange_block
returned_count
arange_count
return
DW_DLV_OK
This
function
returns
DW_DLV_OK
if
it
succeeds
and
DW_DLV_ERR
or
DW_DLV_OK
otherwise
count
is
set
to
the
number
of
addresses
in
the
debug_aranges
section
For
each
address
the
corresponding
element
in
an
array
is
set
to
the
address
itself
aranges
and
the
section
offset
offsets
Must
be
identical
in
most
aspects
to
dwarf_get_aranges
int
_dwarf_get_aranges_addr_offsets
Dwarf_Debug
dbg
Dwarf_Addr
addrs
Dwarf_Off
offsets
Dwarf_Signed
count
Dwarf_Error
error
Dwarf_Signed
i
Used
to
chain
Dwarf_Aranges
structs
Dwarf_Chain
curr_chain
NULL
Dwarf_Chain
prev_chain
NULL
Dwarf_Chain
head_chain
NULL
Dwarf_Signed
arange_count
Dwarf_Addr
arange_addrs
Dwarf_Off
arange_offsets
int
res
DW_DLV_ERROR
BEGIN
CODE
if
error
NULL
error
NULL
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_aranges
error
if
res
DW_DLV_OK
return
res
aranges
points
in
to
info
so
if
info
needs
expanding
we
have
to
load
it
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
res
dwarf_get_aranges_list
dbg
error
if
res
DW_DLV_OK
return
res
arange_addrs
Dwarf_Addr
_dwarf_get_alloc
dbg
DW_DLA_ADDR
arange_count
if
arange_addrs
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
arange_offsets
Dwarf_Off
_dwarf_get_alloc
dbg
DW_DLA_ADDR
arange_count
if
arange_offsets
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_chain
head_chain
for
i
i
arange_count
i
Dwarf_Arange
ar
curr_chain
ch_item
int
itemtype
curr_chain
ch_itemtype
curr_chain
ch_item
arange_addrs
i
ar
ar_address
arange_offsets
i
ar
ar_info_offset
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
if
ar
itemtype
dwarf_dealloc
dbg
ar
itemtype
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
count
arange_count
offsets
arange_offsets
addrs
arange_addrs
return
DW_DLV_OK
This
function
takes
a
pointer
to
a
block
of
Dwarf_Arange
s
and
a
count
of
the
length
of
the
block
It
checks
if
the
given
address
is
within
the
range
of
an
address
range
in
the
block
If
yes
it
returns
the
appropriate
Dwarf_Arange
Otherwise
it
returns
DW_DLV_ERROR
int
dwarf_get_arange
Dwarf_Arange
aranges
Dwarf_Unsigned
arange_count
Dwarf_Addr
address
Dwarf_Arange
returned_arange
Dwarf_Error
error
Dwarf_Arange
curr_arange
Dwarf_Unsigned
i
if
aranges
NULL
_dwarf_error
NULL
error
DW_DLE_ARANGES_NULL
return
DW_DLV_ERROR
for
i
i
arange_count
i
curr_arange
aranges
i
if
address
curr_arange
ar_address
address
curr_arange
ar_address
curr_arange
ar_length
returned_arange
curr_arange
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
This
function
takes
an
Dwarf_Arange
and
returns
the
offset
of
the
first
die
in
the
compilation
unit
that
the
arange
belongs
to
Returns
DW_DLV_ERROR
on
error
For
an
arange
the
cu_die
can
only
be
from
debug_info
not
debug_types
it
seems
int
dwarf_get_cu_die_offset
Dwarf_Arange
arange
Dwarf_Off
returned_offset
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Unsigned
headerlen
int
cres
if
arange
NULL
_dwarf_error
NULL
error
DW_DLE_ARANGE_NULL
return
DW_DLV_ERROR
dbg
arange
ar_dbg
offset
arange
ar_info_offset
This
applies
to
debug_info
only
not
to
debug_types
if
dbg
de_debug_info
dss_data
int
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
cres
_dwarf_length_of_cu_header
dbg
offset
true
error
if
cres
DW_DLV_OK
return
cres
returned_offset
headerlen
offset
return
DW_DLV_OK
This
function
takes
an
Dwarf_Arange
and
returns
the
offset
of
the
CU
header
in
the
compilation
unit
that
the
arange
belongs
to
Returns
DW_DLV_ERROR
on
error
Ensures
debug_info
loaded
so
the
cu_offset
is
meaningful
int
dwarf_get_arange_cu_header_offset
Dwarf_Arange
arange
Dwarf_Off
cu_header_offset_returned
Dwarf_Error
error
Dwarf_Debug
dbg
if
arange
NULL
_dwarf_error
NULL
error
DW_DLE_ARANGE_NULL
return
DW_DLV_ERROR
dbg
arange
ar_dbg
This
applies
to
debug_info
only
not
to
debug_types
Like
dwarf_get_arange_info_b
this
ensures
debug_info
loaded
the
cu_header
is
in
debug_info
and
will
be
used
else
we
would
not
call
dwarf_get_arange_cu_header_offset
if
dbg
de_debug_info
dss_data
int
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
cu_header_offset_returned
arange
ar_info_offset
return
DW_DLV_OK
This
function
takes
a
Dwarf_Arange
and
returns
true
if
it
is
not
NULL
It
also
stores
the
start
address
of
the
range
in
start
the
length
of
the
range
in
length
and
the
offset
of
the
first
die
in
the
compilation
unit
in
cu_die_offset
It
returns
false
on
error
If
cu_die_offset
returned
ensures
debug_info
loaded
so
the
cu_die_offset
is
meaningful
New
for
DWARF4
entries
may
have
segment
information
segment
is
only
meaningful
if
segment_entry_size
is
non
zero
int
dwarf_get_arange_info_b
Dwarf_Arange
arange
Dwarf_Unsigned
segment
Dwarf_Unsigned
segment_entry_size
Dwarf_Addr
start
Dwarf_Unsigned
length
Dwarf_Off
cu_die_offset
Dwarf_Error
error
if
arange
NULL
_dwarf_error
NULL
error
DW_DLE_ARANGE_NULL
return
DW_DLV_ERROR
if
segment
NULL
segment
arange
ar_segment_selector
if
segment_entry_size
NULL
segment_entry_size
arange
ar_segment_selector_size
if
start
NULL
start
arange
ar_address
if
length
NULL
length
arange
ar_length
if
cu_die_offset
NULL
Dwarf_Debug
dbg
arange
ar_dbg
Dwarf_Off
offset
arange
ar_info_offset
Dwarf_Unsigned
headerlen
int
cres
This
applies
to
debug_info
only
not
to
debug_types
if
dbg
de_debug_info
dss_data
int
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
cres
_dwarf_length_of_cu_header
dbg
offset
true
error
if
cres
DW_DLV_OK
return
cres
cu_die_offset
offset
headerlen
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
free
endif
HAVE_STDLIB_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
off_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
endif
HAVE_SYS_STAT_H
include
fcntl
h
ifdef
_WIN32
include
windows
h
Want
to
have
SEEK_CUR
and
SEEK_SET
defined
include
io
h
typedef
SSIZE_T
ssize_t
Windows
does
not
have
POSIX
ssize_t
elif
defined
HAVE_UNISTD_H
include
unistd
h
endif
_WIN32
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
dwarf_incl
h
include
dwarf_error
h
unsigned
int
dwarf_basic_crc32
const
unsigned
char
buf
unsigned
long
len
unsigned
int
init
return
_dwarf_crc32
init
buf
len
Returns
DW_DLV_OK
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
crc32
used
for
debuglink
crc
calculation
Caller
passes
pointer
to
array
of
unsighed
char
and
if
this
returns
DW_DLV_OK
that
is
filled
in
int
dwarf_crc32
Dwarf_Debug
dbg
unsigned
char
crcbuf
Dwarf_Error
error
off_t
size_left
off_t
fsize
off_t
lsval
ssize_t
readlen
unsigned
char
readbuf
ssize_t
readval
unsigned
int
tcrc
unsigned
int
init
int
fd
if
dbg
_dwarf_error_string
dbg
error
DW_DLE_DBG_NULL
DW_DLE_DBG_NULL
Bad
call
to
dwarf_crc32
return
DW_DLV_ERROR
if
crcbuf
return
DW_DLV_NO_ENTRY
if
dbg
de_owns_fd
return
DW_DLV_NO_ENTRY
fd
dbg
de_fd
if
fd
return
DW_DLV_NO_ENTRY
fd
dbg
de_fd
if
dbg
de_filesize
fsize
size_left
dbg
de_filesize
else
fsize
size_left
lseek
fd
SEEK_END
if
fsize
off_t
_dwarf_error_string
dbg
error
DW_DLE_SEEK_ERROR
DW_DLE_SEEK_ERROR
dwarf_crc32
seek
to
end
fails
return
DW_DLV_ERROR
if
fsize
off_t
Not
a
real
object
file
A
random
length
check
return
DW_DLV_NO_ENTRY
lsval
lseek
fd
SEEK_SET
if
lsval
_dwarf_error_string
dbg
error
DW_DLE_SEEK_ERROR
DW_DLE_SEEK_ERROR
dwarf_crc32
seek
to
start
fails
return
DW_DLV_ERROR
readbuf
unsigned
char
malloc
readlen
if
readbuf
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
dwarf_crc32
read
buffer
alloc
fails
return
DW_DLV_ERROR
while
size_left
if
size_left
readlen
readlen
size_left
readval
read
fd
readbuf
readlen
if
readval
ssize_t
readlen
_dwarf_error_string
dbg
error
DW_DLE_READ_ERROR
DW_DLE_READ_ERROR
dwarf_crc32
read
fails
free
readbuf
return
DW_DLV_ERROR
tcrc
_dwarf_crc32
init
readbuf
readlen
init
tcrc
size_left
readlen
endianness
issues?
free
readbuf
memcpy
crcbuf
void
return
DW_DLV_OK
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
provides
access
to
the
DWARF5
debug_names
section
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_global
h
include
dwarf_debug_names
h
include
dwarfstring
h
freedabs
attempts
to
do
some
cleanup
in
the
face
of
an
error
static
void
freedabs
struct
Dwarf_D_Abbrev_s
dab
struct
Dwarf_D_Abbrev_s
tmp
for
dab
dab
tmp
tmp
dab
da_next
free
dab
Encapsulates
DECODE_LEB128_UWORD_CK
so
the
caller
can
free
resources
in
case
of
problems
static
int
read_uword_ab
Dwarf_Small
lp
Dwarf_Unsigned
out_p
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Small
lpend
Dwarf_Small
inptr
lp
Dwarf_Unsigned
out
The
macro
updates
inptr
DECODE_LEB128_UWORD_CK
inptr
out
dbg
err
lpend
lp
inptr
out_p
out
return
DW_DLV_OK
static
int
fill_in_abbrevs_table
struct
Dwarf_Dnames_index_header_s
dn
Dwarf_Error
error
Dwarf_Small
abdata
dn
din_abbreviations
Dwarf_Unsigned
ablen
dn
din_abbrev_table_size
Dwarf_Small
tabend
abdata
ablen
Dwarf_Small
abcur
Dwarf_Unsigned
code
Dwarf_Unsigned
tag
int
foundabend
FALSE
unsigned
abcount
struct
Dwarf_D_Abbrev_s
firstdab
struct
Dwarf_D_Abbrev_s
lastdab
struct
Dwarf_D_Abbrev_s
curdab
Dwarf_Debug
dbg
dn
din_dbg
for
abcur
abdata
abcur
tabend
Dwarf_Unsigned
idx
Dwarf_Unsigned
form
Dwarf_Small
inner
unsigned
idxcount
int
res
res
read_uword_ab
dbg
error
tabend
if
res
DW_DLV_OK
freedabs
firstdab
return
res
if
code
foundabend
TRUE
break
res
read_uword_ab
dbg
error
tabend
if
res
DW_DLV_OK
freedabs
firstdab
return
res
inner
abcur
curdab
struct
Dwarf_D_Abbrev_s
calloc
sizeof
struct
Dwarf_D_Abbrev_s
if
curdab
freedabs
firstdab
firstdab
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curdab
da_tag
tag
curdab
da_abbrev_code
code
abcount
for
res
read_uword_ab
dbg
error
tabend
if
res
DW_DLV_OK
free
curdab
freedabs
firstdab
firstdab
return
res
res
read_uword_ab
dbg
error
tabend
if
res
DW_DLV_OK
free
curdab
freedabs
firstdab
firstdab
return
res
if
idx
form
break
if
idxcount
ABB_PAIRS_MAX
free
curdab
freedabs
firstdab
firstdab
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_ABBREV_OVERFLOW
return
DW_DLV_ERROR
curdab
da_pairs
idxcount
ap_index
idx
curdab
da_pairs
idxcount
ap_form
form
idxcount
curdab
da_pairs_count
idxcount
abcur
inner
if
firstdab
firstdab
curdab
lastdab
curdab
else
Add
new
on
the
end
last
lastdab
da_next
curdab
if
foundabend
freedabs
firstdab
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_ABBREV_CORRUPTION
return
DW_DLV_OK
unsigned
ct
struct
Dwarf_D_Abbrev_s
tmpa
dn
din_abbrev_list
struct
Dwarf_D_Abbrev_s
calloc
abcount
sizeof
struct
Dwarf_D_Abbrev_s
if
dn
din_abbrev_list
freedabs
firstdab
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dn
din_abbrev_list_count
abcount
tmpa
firstdab
for
ct
tmpa
ct
abcount
ct
struct
Dwarf_D_Abbrev_s
tmpb
tmpa
da_next
da_next
no
longer
means
anything
dn
din_abbrev_list
ct
tmpa
dn
din_abbrev_list
ct
da_next
tmpa
tmpb
freedabs
firstdab
tmpa
firstdab
lastdab
Now
the
list
has
turned
into
an
array
We
can
ignore
the
list
aspect
return
DW_DLV_OK
static
int
get_inhdr_cur
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Error
error
Dwarf_Debug
dbg
if
dn
_dwarf_error
NULL
error
DW_DLE_DEBUG_NAMES_NULL_POINTER
return
DW_DLV_ERROR
dbg
dn
dn_dbg
if
index_number
dn
dn_inhdr_count
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
return
DW_DLV_ERROR
cur
dn
dn_inhdr_first
index_number
return
DW_DLV_OK
static
int
read_uword_val
Dwarf_Debug
dbg
Dwarf_Small
ptr_in
Dwarf_Small
endptr
int
errcode
Dwarf_Unsigned
val_out
Dwarf_Unsigned
area_length
Dwarf_Error
error
Dwarf_Unsigned
val
Dwarf_Small
ptr
ptr_in
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
ptr
DWARF_32BIT_SIZE
error
endptr
ptr
DWARF_32BIT_SIZE
if
ptr
endptr
_dwarf_error
dbg
error
errcode
return
DW_DLV_ERROR
Some
of
the
fields
are
not
length
fields
but
if
non
zero
the
size
will
be
longer
than
the
value
so
we
do
the
following
overall
sanity
check
to
avoid
overflows
if
val
area_length
_dwarf_error
dbg
error
errcode
return
DW_DLV_ERROR
val_out
val
ptr_in
ptr
return
DW_DLV_OK
We
do
not
alter
the
dn
data
here
static
int
read_a_name_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
section_offset
Dwarf_Small
curptr_in
Dwarf_Small
end_section
Dwarf_Unsigned
remaining_section_size
struct
Dwarf_Dnames_index_header_s
index_header_out
Dwarf_Error
error
Dwarf_Unsigned
area_length
int
local_length_size
int
local_extension_size
Dwarf_Small
past_length
Dwarf_Small
end_dnames
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
comp_unit_count
Dwarf_Unsigned
local_type_unit_count
Dwarf_Unsigned
foreign_type_unit_count
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
name_count
Dwarf_Unsigned
abbrev_table_size
bytes
Dwarf_Unsigned
augmentation_string_size
bytes
int
res
const
char
str_utf8
Dwarf_Small
curptr
curptr_in
struct
Dwarf_Dnames_index_header_s
di_header
Dwarf_Debug
dbg
dn
dn_dbg
READ_AREA_LENGTH_CK
dbg
area_length
Dwarf_Unsigned
curptr
local_length_size
local_extension_size
error
remaining_section_size
end_section
curptr
now
points
past
the
length
field
past_length
curptr
Two
stage
length
test
so
overflow
is
caught
if
area_length
remaining_section_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
if
area_length
local_length_size
local_extension_size
remaining_section_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
end_dnames
curptr
area_length
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
curptr
DWARF_HALF_SIZE
error
end_dnames
curptr
DWARF_HALF_SIZE
if
curptr
end_dnames
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
if
version
DWARF_DNAMES_VERSION5
_dwarf_error
dbg
error
DW_DLE_VERSION_STAMP_ERROR
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
padding
Dwarf_Half
curptr
DWARF_HALF_SIZE
error
end_dnames
curptr
DWARF_HALF_SIZE
if
curptr
end_dnames
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
if
padding
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
res
read_uword_val
dbg
end_dnames
DW_DLE_DEBUG_NAMES_HEADER_ERROR
area_length
error
if
res
DW_DLV_OK
return
res
str_utf8
const
char
curptr
curptr
augmentation_string_size
if
curptr
end_dnames
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
struct
Dwarf_Dnames_index_header_s
calloc
sizeof
di_header
if
di_header
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
di_header
din_dbg
dbg
di_header
din_section_offset
section_offset
di_header
din_indextable_data
past_length
di_header
din_indextable_length
area_length
di_header
din_version
version
di_header
din_comp_unit_count
comp_unit_count
di_header
din_local_type_unit_count
local_type_unit_count
di_header
din_foreign_type_unit_count
foreign_type_unit_count
di_header
din_bucket_count
bucket_count
di_header
din_name_count
name_count
di_header
din_abbrev_table_size
abbrev_table_size
di_header
din_augmentation_string_size
augmentation_string_size
di_header
din_augmentation_string
calloc
augmentation_string_size
strncpy
di_header
din_augmentation_string
str_utf8
augmentation_string_size
This
deals
with
a
zero
length
string
too
Dwarf_Unsigned
len
augmentation_string_size
char
cp
char
cpend
Dwarf_Bool
foundnull
FALSE
cp
di_header
din_augmentation_string
cpend
cp
len
for
cp
cpend
cp
if
cp
foundnull
TRUE
break
if
foundnull
Force
a
NUL
terminator
in
the
extra
byte
we
calloc
d
cp
len
else
Ensure
that
there
is
no
corruption
in
the
padding
for
cp
cpend
cp
if
cp
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_PAD_NON_ZERO
return
DW_DLV_ERROR
di_header
din_cu_list
curptr
curptr
dbg
de_length_size
comp_unit_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_local_tu_list
curptr
curptr
dbg
de_length_size
local_type_unit_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_foreign_tu_list
curptr
curptr
sizeof
Dwarf_Sig8
foreign_type_unit_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_buckets
curptr
curptr
DWARF_32BIT_SIZE
bucket_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_hash_table
curptr
curptr
sizeof
Dwarf_Sig8
name_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_string_offsets
curptr
curptr
DWARF_32BIT_SIZE
name_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_entry_offsets
curptr
curptr
DWARF_32BIT_SIZE
name_count
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_abbreviations
curptr
curptr
abbrev_table_size
if
curptr
end_dnames
free
di_header
din_augmentation_string
free
di_header
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_HEADER_ERROR
return
DW_DLV_ERROR
di_header
din_entry_pool
curptr
di_header
din_offset_size
local_length_size
di_header
din_entry_pool_size
end_dnames
curptr
curptr_in
curptr
index_header_out
di_header
res
fill_in_abbrevs_table
di_header
error
if
res
DW_DLV_OK
free
di_header
din_augmentation_string
free
di_header
return
res
return
DW_DLV_OK
define
FAKE_LAST_USED
static
void
free_inhdr_content
struct
Dwarf_Dnames_index_header_s
f
free
f
din_augmentation_string
free
f
din_abbrev_list
static
void
free_inhdr_list
struct
Dwarf_Dnames_index_header_s
f
struct
Dwarf_Dnames_index_header_s
tmp
for
f
f
tmp
tmp
f
din_next
free_inhdr_content
f
free
f
There
may
be
one
debug
index
for
an
entire
object
file
for
multiple
CUs
or
there
can
be
individual
indexes
for
some
CUs
see
DWARF5
Per_CU
versus
Per
Module
Indexes
int
dwarf_debugnames_header
Dwarf_Debug
dbg
Dwarf_Dnames_Head
dn_out
Dwarf_Unsigned
dn_count_out
Dwarf_Error
error
Dwarf_Unsigned
remaining
Dwarf_Dnames_Head
dn_header
Dwarf_Unsigned
section_size
Dwarf_Small
start_section
Dwarf_Small
end_section
Dwarf_Small
curptr
struct
Dwarf_Dnames_index_header_s
inhdr_last
struct
Dwarf_Dnames_index_header_s
inhdr_first
unsigned
inhdr_count
int
res
if
dbg
_dwarf_error
dbg
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_names
error
if
res
DW_DLV_OK
return
res
section_size
dbg
de_debug_names
dss_size
if
section_size
return
DW_DLV_NO_ENTRY
start_section
dbg
de_debug_names
dss_data
curptr
start_section
end_section
start_section
section_size
remaining
section_size
dn_header
Dwarf_Dnames_Head
_dwarf_get_alloc
dbg
DW_DLA_DNAMES_HEAD
if
dn_header
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
dwarf_get_alloc
of
a
Dwarf_Dnames
head
record
failed
return
DW_DLV_ERROR
dn_header
dn_section_data
start_section
dn_header
dn_section_size
section_size
dn_header
dn_section_end
start_section
section_size
dn_header
dn_dbg
dbg
for
curptr
end_section
struct
Dwarf_Dnames_index_header_s
index_header
Dwarf_Small
curptr_start
curptr
Dwarf_Unsigned
usedspace
Dwarf_Unsigned
section_offset
curptr
start_section
res
read_a_name_index
dn_header
section_offset
end_section
remaining
error
if
res
DW_DLV_ERROR
free_inhdr_list
inhdr_first
dwarf_dealloc
dbg
dn_header
DW_DLA_DNAMES_HEAD
return
res
if
res
DW_DLV_NO_ENTRY
Impossible
A
bug
Or
possibly
a
bunch
of
zero
pad?
free_inhdr_list
inhdr_first
dwarf_dealloc
dbg
dn_header
DW_DLA_DNAMES_HEAD
break
Add
the
new
one
to
the
list
if
inhdr_first
inhdr_count
inhdr_first
index_header
inhdr_last
index_header
else
struct
Dwarf_Dnames_index_header_s
tmp
inhdr_last
inhdr_last
index_header
tmp
din_next
index_header
inhdr_count
usedspace
curptr
curptr_start
remaining
usedspace
if
remaining
No
more
in
here
just
padding
Check
for
zero
in
padding
if
curptr
remaining
end_section
free_inhdr_list
inhdr_first
dwarf_dealloc
dbg
dn_header
DW_DLA_DNAMES_HEAD
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_OFF_END
return
DW_DLV_ERROR
for
curptr
end_section
curptr
if
curptr
One
could
argue
this
is
a
harmless
error
but
for
now
assume
it
is
real
corruption
free_inhdr_list
inhdr_first
dwarf_dealloc
dbg
dn_header
DW_DLA_DNAMES_HEAD
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_PAD_NON_ZERO
return
DW_DLV_ERROR
struct
Dwarf_Dnames_index_header_s
cur
int
n
dn_header
dn_inhdr_first
struct
Dwarf_Dnames_index_header_s
calloc
inhdr_count
sizeof
struct
Dwarf_Dnames_index_header_s
if
dn_header
dn_inhdr_first
free_inhdr_list
inhdr_first
dwarf_dealloc
dbg
dn_header
DW_DLA_DNAMES_HEAD
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
calloc
of
a
Dwarf_Dnames
index
header
failed
return
DW_DLV_ERROR
for
n
cur
inhdr_first
cur
n
We
are
copying
these
structs
so
do
not
free
them
at
this
time
struct
Dwarf_Dnames_index_header_s
tmp
cur
din_next
dn_header
dn_inhdr_first
n
cur
cur
tmp
dn_out
dn_header
dn_count_out
inhdr_count
return
DW_DLV_OK
int
dwarf_debugnames_sizes
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
section_offset
Dwarf_Unsigned
version
Dwarf_Unsigned
offset_size
or
The
counts
are
entry
counts
not
bye
sizes
Dwarf_Unsigned
comp_unit_count
Dwarf_Unsigned
local_type_unit_count
Dwarf_Unsigned
foreign_type_unit_count
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
name_count
The
following
are
counted
in
bytes
Dwarf_Unsigned
indextable_overall_length
Dwarf_Unsigned
abbrev_table_size
Dwarf_Unsigned
entry_pool_size
Dwarf_Unsigned
augmentation_string_size
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
if
section_offset
section_offset
cur
din_section_offset
if
version
version
cur
din_version
if
offset_size
offset_size
cur
din_offset_size
if
comp_unit_count
comp_unit_count
cur
din_comp_unit_count
if
local_type_unit_count
local_type_unit_count
cur
din_local_type_unit_count
if
foreign_type_unit_count
foreign_type_unit_count
cur
din_foreign_type_unit_count
if
bucket_count
bucket_count
cur
din_bucket_count
if
name_count
name_count
cur
din_name_count
if
abbrev_table_size
abbrev_table_size
cur
din_abbrev_table_size
if
entry_pool_size
entry_pool_size
cur
din_entry_pool_size
if
augmentation_string_size
augmentation_string_size
cur
din_augmentation_string_size
if
indextable_overall_length
indextable_overall_length
cur
din_indextable_length
return
DW_DLV_OK
int
dwarf_debugnames_cu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
if
offset_number
cur
din_comp_unit_count
if
offset_count
offset_count
cur
din_comp_unit_count
return
DW_DLV_NO_ENTRY
if
offset
Dwarf_Unsigned
offsetval
Dwarf_Small
ptr
cur
din_cu_list
offset_number
cur
din_offset_size
Dwarf_Small
endptr
cur
din_local_tu_list
READ_UNALIGNED_CK
dbg
offsetval
Dwarf_Unsigned
ptr
cur
din_offset_size
error
endptr
offset
offsetval
if
offset_count
offset_count
cur
din_comp_unit_count
return
DW_DLV_OK
int
dwarf_debugnames_local_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
if
offset_number
cur
din_local_type_unit_count
if
offset_count
offset_count
cur
din_local_type_unit_count
return
DW_DLV_NO_ENTRY
if
offset
Dwarf_Unsigned
offsetval
Dwarf_Small
ptr
cur
din_local_tu_list
offset_number
cur
din_offset_size
Dwarf_Small
endptr
cur
din_foreign_tu_list
READ_UNALIGNED_CK
dbg
offsetval
Dwarf_Unsigned
ptr
cur
din_offset_size
error
endptr
offset
offsetval
if
offset_count
offset_count
cur
din_local_type_unit_count
return
DW_DLV_OK
Here
the
sig_number
ranges
from
local_type_unit_count
to
local_type_unit_count
foreign_type_unit_count
because
the
foreign
indices
are
a
continuation
of
the
local
tu
indices
int
dwarf_debugnames_foreign_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
sig_number
these
index
starting
at
local_type_unit_count
Dwarf_Unsigned
sig_minimum
Dwarf_Unsigned
sig_count
Dwarf_Sig8
signature
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
unsigned
legal_low
unsigned
legal_high
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
legal_low
cur
din_local_type_unit_count
legal_high
legal_low
cur
din_foreign_type_unit_count
if
sig_number
legal_low
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
return
DW_DLV_ERROR
if
sig_number
legal_high
if
sig_minimum
sig_minimum
legal_low
if
sig_count
sig_count
cur
din_foreign_type_unit_count
return
DW_DLV_NO_ENTRY
if
signature
Dwarf_Small
ptr
cur
din_foreign_tu_list
sig_number
cur
din_offset_size
Dwarf_Small
endptr
cur
din_hash_table
if
ptr
sizeof
Dwarf_Sig8
endptr
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
return
DW_DLV_ERROR
memcpy
signature
ptr
sizeof
Dwarf_Sig8
if
sig_minimum
sig_minimum
legal_low
if
sig_count
sig_count
cur
din_foreign_type_unit_count
return
DW_DLV_OK
The
hash
table
is
composed
of
the
buckets
table
and
the
hashes
table
If
there
is
no
buckets
table
bucket_count
the
hashes
part
still
exists
int
dwarf_debugnames_bucket
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
bucket_number
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
index_of_name_entry
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
if
bucket_number
cur
din_bucket_count
if
bucket_count
bucket_count
cur
din_bucket_count
return
DW_DLV_NO_ENTRY
if
index_of_name_entry
Dwarf_Unsigned
offsetval
Dwarf_Small
ptr
cur
din_buckets
bucket_number
DWARF_32BIT_SIZE
Dwarf_Small
endptr
cur
din_hash_table
READ_UNALIGNED_CK
dbg
offsetval
Dwarf_Unsigned
ptr
DWARF_32BIT_SIZE
error
endptr
index_of_name_entry
offsetval
if
bucket_count
bucket_count
cur
din_bucket_count
return
DW_DLV_OK
Access
to
the
debug_names
name
table
int
dwarf_debugnames_name
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
name_entry
Dwarf_Unsigned
names_count
Dwarf_Sig8
signature
Dwarf_Unsigned
offset_to_debug_str
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
if
name_entry
cur
din_name_count
if
names_count
names_count
cur
din_bucket_count
return
DW_DLV_NO_ENTRY
if
signature
Dwarf_Small
ptr
cur
din_hash_table
name_entry
sizeof
Dwarf_Sig8
Dwarf_Small
endptr
cur
din_string_offsets
if
ptr
sizeof
Dwarf_Sig8
endptr
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
return
DW_DLV_ERROR
memcpy
signature
ptr
sizeof
Dwarf_Sig8
if
offset_to_debug_str
Dwarf_Unsigned
offsetval
Dwarf_Small
ptr
cur
din_string_offsets
name_entry
DWARF_32BIT_SIZE
Dwarf_Small
endptr
cur
din_abbreviations
READ_UNALIGNED_CK
dbg
offsetval
Dwarf_Unsigned
ptr
DWARF_32BIT_SIZE
error
endptr
offset_to_debug_str
offsetval
if
offset_in_entrypool
Dwarf_Unsigned
offsetval
Dwarf_Small
ptr
cur
din_entry_offsets
name_entry
DWARF_32BIT_SIZE
Dwarf_Small
endptr
cur
din_abbreviations
READ_UNALIGNED_CK
dbg
offsetval
Dwarf_Unsigned
ptr
DWARF_32BIT_SIZE
error
endptr
offset_in_entrypool
offsetval
if
names_count
names_count
cur
din_name_count
return
DW_DLV_OK
If
abbrev_code
returned
is
zero
there
is
no
tag
returned
and
we
are
at
the
end
of
the
entry
pool
set
for
this
name
entry
abbrev
code
tag
nameindexattr
form
repeat
like
the
above
This
provides
a
way
to
print
the
abbrev
table
by
indexing
from
int
dwarf_debugnames_abbrev_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
The
number
of
valid
abbrev_entry
values
to
number_of_abbrev
Dwarf_Unsigned
number_of_abbrev
The
number
of
attr
form
pairs
not
counting
the
trailing
pair
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
struct
Dwarf_D_Abbrev_s
abbrev
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
if
abbrev_entry
cur
din_abbrev_list_count
if
number_of_abbrev
number_of_abbrev
cur
din_abbrev_list_count
return
DW_DLV_NO_ENTRY
abbrev
cur
din_abbrev_list
abbrev_entry
if
abbrev_code
abbrev_code
abbrev
da_abbrev_code
if
tag
tag
abbrev
da_tag
if
number_of_abbrev
number_of_abbrev
cur
din_abbrev_list_count
if
number_of_attr_form_entries
number_of_attr_form_entries
abbrev
da_pairs_count
return
DW_DLV_OK
static
int
_dwarf_internal_abbrev_by_code
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
number_of_attr_form_entries
unsigned
n
struct
Dwarf_D_Abbrev_s
abbrev
abbrev
cur
din_abbrev_list
for
n
n
cur
din_abbrev_list_count
n
abbrev
if
abbrev_code
abbrev
da_abbrev_code
if
tag
tag
abbrev
da_tag
if
index_of_abbrev
index_of_abbrev
n
if
number_of_attr_form_entries
number_of_attr_form_entries
abbrev
da_pairs_count
return
DW_DLV_OK
Something
is
wrong
not
found
return
DW_DLV_NO_ENTRY
Access
the
abbrev
by
abbrev
code
instead
of
index
int
dwarf_debugnames_abbrev_by_code
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
The
number
of
this
code
tag
as
an
array
index
Dwarf_Unsigned
index_of_abbrev
The
number
of
attr
form
pairs
not
counting
the
trailing
pair
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
res
_dwarf_internal_abbrev_by_code
cur
abbrev_code
tag
index_of_abbrev
number_of_attr_form_entries
return
res
int
dwarf_debugnames_abbrev_form_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry_index
Dwarf_Unsigned
abbrev_form_index
Dwarf_Unsigned
name_index_attr
Dwarf_Unsigned
form
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
struct
Dwarf_D_Abbrev_s
abbrev
struct
abbrev_pair_s
ap
int
res
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
if
abbrev_entry_index
cur
din_abbrev_list_count
if
number_of_attr_form_entries
number_of_attr_form_entries
cur
din_bucket_count
return
DW_DLV_NO_ENTRY
abbrev
cur
din_abbrev_list
abbrev_entry_index
if
abbrev_form_index
abbrev
da_pairs_count
return
DW_DLV_NO_ENTRY
ap
abbrev
da_pairs
abbrev_entry_index
if
name_index_attr
name_index_attr
ap
ap_index
if
form
form
ap
ap_form
if
number_of_attr_form_entries
number_of_attr_form_entries
abbrev
da_pairs_count
return
DW_DLV_OK
This
combined
with
dwarf_debugnames_entrypool_values
lets
one
examine
as
much
or
as
little
of
an
entrypool
as
one
wants
to
by
alternately
calling
these
two
functions
int
dwarf_debugnames_entrypool
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
value_count
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_of_initial_value
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
Dwarf_Debug
dbg
int
res
Dwarf_Small
entrypool
Dwarf_Small
endentrypool
Dwarf_Unsigned
abcode
Dwarf_Unsigned
leblen
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
if
offset_in_entrypool
cur
din_entry_pool_size
_dwarf_error
NULL
error
DW_DLE_DEBUG_NAMES_ENTRYPOOL_OFFSET
return
DW_DLV_ERROR
endentrypool
cur
din_entry_pool
cur
din_entry_pool_size
entrypool
cur
din_entry_pool
offset_in_entrypool
DECODE_LEB128_UWORD_LEN_CK
entrypool
abcode
leblen
dbg
error
endentrypool
res
_dwarf_internal_abbrev_by_code
cur
abcode
tag
index_of_abbrev
value_count
if
res
DW_DLV_OK
Never
DW_DLV_ERROR
so
far
return
res
offset_of_initial_value
offset_in_entrypool
leblen
abbrev_code
abcode
return
DW_DLV_OK
Caller
knowing
array
size
needed
passes
in
arrays
it
allocates
of
for
idx
form
offset
size
values
and
signature
values
Caller
must
examine
idx
number
and
form
to
decide
for
each
array
element
whether
the
offset
or
the
signature
contains
the
value
So
this
returns
all
the
values
for
the
abbrev
code
And
points
via
offset_of_next
to
the
next
abbrev
code
While
an
array
of
structs
would
be
easier
for
the
caller
to
allocate
than
parallel
arrays
public
structs
have
turned
out
to
be
difficult
to
work
with
as
interfaces
as
formats
change
over
time
int
dwarf_debugnames_entrypool_values
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_in_entrypool_of_values
Dwarf_Unsigned
array_dw_idx_number
Dwarf_Unsigned
array_form
Dwarf_Unsigned
array_of_offsets
Dwarf_Sig8
array_of_signatures
offset
of
the
next
entrypool
entry
Dwarf_Unsigned
offset_of_next_entrypool
Dwarf_Error
error
struct
Dwarf_Dnames_index_header_s
cur
struct
Dwarf_D_Abbrev_s
abbrev
Dwarf_Debug
dbg
unsigned
n
int
res
Dwarf_Unsigned
abcount
Dwarf_Unsigned
pooloffset
offset_in_entrypool_of_values
Dwarf_Small
endpool
Dwarf_Small
poolptr
res
get_inhdr_cur
dn
index_number
error
if
res
DW_DLV_OK
return
res
dbg
dn
dn_dbg
endpool
cur
din_entry_pool
cur
din_entry_pool_size
if
index_of_abbrev
cur
din_abbrev_list_count
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_ABBREV_CORRUPTION
return
DW_DLV_ERROR
poolptr
cur
din_entry_pool
offset_in_entrypool_of_values
abbrev
cur
din_abbrev_list
index_of_abbrev
abcount
cur
din_abbrev_list_count
for
n
n
abcount
n
struct
abbrev_pair_s
abp
abbrev
da_pairs
n
unsigned
idxtype
abp
ap_index
unsigned
form
abp
ap_form
array_dw_idx_number
n
idxtype
array_form
n
form
if
form
DW_FORM_data8
idxtype
DW_IDX_type_hash
if
poolptr
sizeof
Dwarf_Sig8
endpool
_dwarf_error
dbg
error
DW_DLE_DEBUG_NAMES_ENTRYPOOL_OFFSET
return
DW_DLV_ERROR
memcpy
array_of_signatures
n
poolptr
sizeof
Dwarf_Sig8
poolptr
sizeof
Dwarf_Sig8
pooloffset
sizeof
Dwarf_Sig8
continue
else
if
_dwarf_allow_formudata
form
Dwarf_Unsigned
val
Dwarf_Unsigned
bytesread
res
_dwarf_formudata_internal
dbg
form
poolptr
endpool
error
if
res
DW_DLV_OK
return
res
poolptr
bytesread
pooloffset
bytesread
array_of_offsets
n
val
continue
There
is
some
mistake
omission
in
our
code
here
or
in
the
data
dwarfstring
m
const
char
name
unknown
form
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_NAMES_UNHANDLED_FORM
Form
x
form
dwarf_get_FORM_name
form
dwarfstring_append_printf_s
s
is
not
currently
supported
in
debug_names
char
name
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_NAMES_UNHANDLED_FORM
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
offset_of_next_entrypool
pooloffset
return
DW_DLV_OK
Frees
any
Dwarf_Dnames_Head_s
data
that
is
directly
mallocd
void
_dwarf_debugnames_destructor
void
m
struct
Dwarf_Dnames_Head_s
h
struct
Dwarf_Dnames_Head_s
m
struct
Dwarf_Dnames_index_header_s
cur
unsigned
n
cur
h
dn_inhdr_first
for
n
h
dn_inhdr_count
n
cur
free_inhdr_content
cur
free
h
dn_inhdr_first
h
dn_inhdr_first
h
dn_inhdr_count
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
provides
access
to
the
DWARF5
debug_sup
section
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_global
h
include
dwarfstring
h
static
void
get_sup_fields
Dwarf_Debug
dbg
struct
Dwarf_Section_s
sec_out
if
dbg
return
sec_out
de_debug_sup
static
int
load_sup
Dwarf_Debug
dbg
Dwarf_Error
error
struct
Dwarf_Section_s
sec
int
res
get_sup_fields
dbg
res
_dwarf_load_section
dbg
sec
error
return
res
New
for
DWARF5
in
July
int
dwarf_get_debug_sup
Dwarf_Debug
dbg
Dwarf_Half
version_out
Dwarf_Small
is_supplementary_out
char
filename_out
Dwarf_Unsigned
checksum_len_out
Dwarf_Small
checksum_out
Dwarf_Error
error
Dwarf_Unsigned
version
Dwarf_Small
is_supp
char
filename
Dwarf_Unsigned
checksum_len
Dwarf_Small
checksum_ptr
int
res
Dwarf_Small
data
Dwarf_Small
enddata
Dwarf_Unsigned
size
res
load_sup
dbg
error
if
res
DW_DLV_OK
return
res
data
dbg
de_debug_sup
dss_data
size
dbg
de_debug_sup
dss_size
if
dbg
de_filesize
size
dbg
de_filesize
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_SUP_ERROR
debug_sup
section
size
x
bigger
than
file
size
Corrupt
size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_SUP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
enddata
data
size
res
_dwarf_read_unaligned_ck_wrapper
dbg
data
DWARF_HALF_SIZE
enddata
error
data
DWARF_HALF_SIZE
if
data
enddata
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_SUP_ERROR
debug_sup
section
size
x
too
small
to
be
correct
Corrupt
size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_SUP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
is_supp
Dwarf_Small
data
data
res
_dwarf_check_string_valid
dbg
data
data
enddata
DW_DLE_DEBUG_SUP_STRING_ERROR
error
if
res
DW_DLV_OK
return
res
filename
char
data
data
strlen
char
data
res
_dwarf_leb128_uword_wrapper
dbg
enddata
error
if
res
DW_DLV_OK
return
res
if
checksum_len
size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_SUP_ERROR
debug_sup
checksum
length
x
too
large
to
be
correct
Corrupt
checksum_len
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_SUP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
data
checksum_len
enddata
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_SUP_ERROR
debug_sup
checksum
length
x
runs
off
the
end
of
the
section
Corrupt
data
checksum_len
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_SUP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
checksum_ptr
data
if
version_out
version_out
version
if
is_supp
is_supplementary_out
is_supp
if
filename_out
filename_out
filename
if
checksum_len_out
checksum_len_out
checksum_len
if
checksum_out
checksum_out
checksum_ptr
return
DW_DLV_OK
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
stdio
h
ifdef
HAVE_MALLOC_H
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STDDEF_H
include
stddef
h
ptrdiff_t
endif
HAVE_STDDEF_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
ifdef
HAVE_ELF_H
include
elf
h
endif
HAVE_ELF_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_UNISTD_H
include
unistd
h
getcwd
endif
HAVE_UNISTD_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_debuglink
h
ifndef
O_BINARY
define
O_BINARY
endif
O_BINARY
define
MINBUFLEN
if
_WIN32
define
NULL_DEVICE_NAME
NUL
else
define
NULL_DEVICE_NAME
dev
null
endif
_WIN32
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
static
int
extract_buildid
Dwarf_Debug
dbg
struct
Dwarf_Section_s
pbuildid
unsigned
type_returned
char
owner_name_returned
unsigned
char
build_id_returned
unsigned
build_id_length_returned
Dwarf_Error
error
struct
joins_s
dwarfstring
js_dirname
dwarfstring
js_basenamesimple
dwarfstring
js_basesimpledebug
dwarfstring
js_binname
dwarfstring
js_cwd
dwarfstring
js_originalfullpath
dwarfstring
js_linkstring
dwarfstring
js_tmp2
dwarfstring
js_tmp3
dwarfstring
js_buildid
dwarfstring
js_buildid_filename
static
void
construct_js
struct
joins_s
js
memset
js
sizeof
struct
joins_s
dwarfstring_constructor
js_dirname
dwarfstring_constructor
js_basenamesimple
dwarfstring_constructor
js_basesimpledebug
dwarfstring_constructor
js_cwd
dwarfstring_constructor
js_originalfullpath
dwarfstring_constructor
js_linkstring
dwarfstring_constructor
js_tmp2
dwarfstring_constructor
js_tmp3
dwarfstring_constructor
js_buildid
dwarfstring_constructor
js_buildid_filename
static
void
destruct_js
struct
joins_s
js
dwarfstring_destructor
js_dirname
dwarfstring_destructor
js_basenamesimple
dwarfstring_destructor
js_basesimpledebug
dwarfstring_destructor
js_cwd
dwarfstring_destructor
js_originalfullpath
dwarfstring_destructor
js_linkstring
dwarfstring_destructor
js_tmp2
dwarfstring_destructor
js_tmp3
dwarfstring_destructor
js_buildid
dwarfstring_destructor
js_buildid_filename
static
char
joinchar
static
char
joinstr
if
defined
_WIN32
static
char
joincharw
Large
enough
it
is
unlikely
dwarfstring
will
ever
do
a
malloc
here
Windows
paths
usually
characters
static
char
winbuf
static
void
transformtoposix
dwarfstring
out
char
in
char
cp
in
for
cp
cp
if
cp
joincharw
dwarfstring_append_length
out
joinstr
else
dwarfstring_append_length
out
cp
endif
_WIN32
ASSERT
the
target
chars
already
have
the
transformtoposix
done
int
_dwarf_pathjoinl
dwarfstring
target
dwarfstring
input
char
inputs
dwarfstring_string
input
char
targ
dwarfstring_string
target
size_t
targlen
if
defined
_WIN32
dwarfstring
winput
dwarfstring_constructor_static
winbuf
sizeof
winbuf
transformtoposix
inputs
targlen
dwarfstring_strlen
target
inputs
dwarfstring_string
if
targlen
dwarfstring_append
target
inputs
return
DW_DLV_OK
else
_Windows
targlen
dwarfstring_strlen
target
endif
_WIN32
if
targlen
dwarfstring_append
target
inputs
return
DW_DLV_OK
targ
dwarfstring_string
target
if
targ
targlen
joinchar
if
inputs
joinchar
dwarfstring_append
target
joinstr
dwarfstring_append
target
inputs
else
dwarfstring_append
target
inputs
else
if
inputs
joinchar
dwarfstring_append
target
inputs
else
dwarfstring_append
target
inputs
if
defined
_WIN32
dwarfstring_destructor
endif
_WIN32
return
DW_DLV_OK
ASSERT
the
last
character
in
s
is
not
a
static
size_t
mydirlen
char
s
char
cp
char
lastjoinchar
size_t
count
for
cp
s
cp
cp
count
if
cp
joinchar
lastjoinchar
cp
if
lastjoinchar
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
sizetoendjoin
lastjoinchar
s
lastjoinchar
s
count
the
last
join
as
mydirlen
if
sizetoendjoin
impossible
return
return
sizetoendjoin
return
struct
dwarfstring_list_s
dwarfstring
dl_string
struct
dwarfstring_list_s
dl_next
static
void
dwarfstring_list_constructor
struct
dwarfstring_list_s
l
dwarfstring_constructor
dl_string
l
dl_next
static
int
dwarfstring_list_add_new
struct
dwarfstring_list_s
base_entry
struct
dwarfstring_list_s
prev
dwarfstring
input
struct
dwarfstring_list_s
new_out
int
errcode
struct
dwarfstring_list_s
next
if
prev
next
struct
dwarfstring_list_s
malloc
sizeof
struct
dwarfstring_list_s
if
next
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dwarfstring_list_constructor
next
else
next
base_entry
dwarfstring_append
dl_string
dwarfstring_string
input
if
prev
prev
dl_next
next
new_out
next
return
DW_DLV_OK
destructs
passed
in
entry
does
not
free
it
and
all
those
on
the
dl_next
list
those
are
freed
static
void
dwarfstring_list_destructor
struct
dwarfstring_list_s
l
struct
dwarfstring_list_s
curl
l
struct
dwarfstring_list_s
nextl
l
nextl
curl
dl_next
dwarfstring_destructor
dl_string
curl
dl_next
curl
nextl
for
curl
curl
nextl
nextl
curl
dl_next
dwarfstring_destructor
dl_string
curl
dl_next
free
curl
static
void
prepare_linked_name
dwarfstring
out
dwarfstring
dirname
dwarfstring
extradir
dwarfstring
linkname
dwarfstring_append
out
dwarfstring_string
dirname
if
extradir
_dwarf_pathjoinl
out
extradir
_dwarf_pathjoinl
out
linkname
static
void
build_buildid_filename
dwarfstring
target
unsigned
buildid_length
unsigned
char
buildid
dwarfstring
tmp
unsigned
bu
unsigned
char
cp
dwarfstring_constructor
dwarfstring_append
build
id
dwarfstring_append
joinstr
cp
buildid
for
bu
bu
buildid_length
bu
cp
dwarfstring_append_printf_u
cp
if
bu
dwarfstring_append
_dwarf_pathjoinl
target
dwarfstring_append
target
debug
dwarfstring_destructor
return
if
static
void
dump_bytes
const
char
msg
unsigned
char
start
unsigned
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
If
the
compiler
or
the
builder
of
the
object
file
being
read
has
made
a
mistake
it
is
possible
for
a
constructed
name
to
match
the
original
file
path
yet
we
do
not
want
to
add
that
to
the
search
path
static
int
duplicatedpath
dwarfstring
l
dwarfstring
r
if
strcmp
dwarfstring_string
l
dwarfstring_string
r
return
FALSE
Oops
somebody
made
a
mistake
return
TRUE
New
September
Access
to
the
GNU
section
named
gnu_debuglink
See
https
sourceware
org
gdb
onlinedocs
gdb
Separate
Debug
Files
html
The
default
global
path
was
set
to
usr
lib
debug
by
set_global_paths_init
called
at
libdwarf
object
init
time
So
there
is
always
the
default
global
path
present
int
_dwarf_construct_linkedto_path
char
global_prefixes_in
unsigned
length_global_prefixes_in
char
pathname_in
char
link_string_in
from
debug
link
dwarfstring
link_string_fullpath_out
UNUSEDARG
unsigned
char
crc_in
from
debug_link
bytes
unsigned
char
buildid
from
gnu
buildid
unsigned
buildid_length
from
gnu
buildid
char
paths_out
unsigned
paths_out_length
int
errcode
char
depath
pathname_in
int
res
struct
joins_s
joind
size_t
dirnamelen
struct
dwarfstring_list_s
base_dwlist
struct
dwarfstring_list_s
last_entry
unsigned
global_prefix_number
dwarfstring_list_constructor
construct_js
dirnamelen
mydirlen
depath
if
dirnamelen
Original
dirname
before
cwd
if
needed
dwarfstring_append_length
js_tmp2
depath
dirnamelen
if
depath
joinchar
Meaning
a
b
or
b
not
a
b
or
b
so
we
apply
cwd
char
buffer
unsigned
buflen
sizeof
buffer
char
wdret
buffer
wdret
getcwd
buffer
buflen
if
wdret
printf
getcwd
issue
Do
nothing
line
d
s
n
__LINE__
__FILE__
dwarfstring_list_destructor
destruct_js
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dwarfstring_append
js_cwd
buffer
dwarfstring_append
js_dirname
buffer
_dwarf_pathjoinl
js_dirname
js_tmp2
buffer
else
else
leave
js_cwd
empty
dwarfstring_append
js_dirname
dwarfstring_string
js_tmp2
Creating
a
real
basename
No
slashes
dwarfstring_append
js_basenamesimple
depath
dirnamelen
dwarfstring_append
js_basesimpledebug
dwarfstring_string
js_basenamesimple
dwarfstring_append
js_basesimpledebug
debug
build_buildid_filename
js_buildid_filename
buildid_length
buildid
dwarfstring_reset
js_tmp2
Now
js_dirname
js_basenamesimple
are
reflecting
a
full
path
saves
the
full
path
to
the
original
executable
dwarfstring_append
js_originalfullpath
dwarfstring_string
js_dirname
_dwarf_pathjoinl
js_originalfullpath
js_basenamesimple
js_originalfullpath
is
a
true
full
path
to
the
object
we
started
with
as
input
First
do
the
build
id
method
if
it
applies
at
all
for
global_prefix_number
buildid_length
global_prefix_number
length_global_prefixes_in
global_prefix_number
char
prefix
struct
dwarfstring_list_s
now_last
prefix
global_prefixes_in
global_prefix_number
dwarfstring_reset
js_buildid
dwarfstring_append
js_buildid
prefix
_dwarf_pathjoinl
js_buildid
js_buildid_filename
res
dwarfstring_list_add_new
last_entry
js_buildid
errcode
if
res
DW_DLV_OK
dwarfstring_list_destructor
destruct_js
return
res
last_entry
now_last
end
loop
on
global
prefix
numbers
end
of
the
build
id
name
finding
Now
for
the
debug
link
method
of
finding
debug
files
if
link_string_in
First
try
dir
of
executable
struct
dwarfstring_list_s
now_last
dwarfstring_append
js_linkstring
link_string_in
dwarfstring_reset
js_tmp3
dwarfstring_reset
js_tmp2
prepare_linked_name
js_tmp3
js_dirname
js_linkstring
dwarfstring_append
link_string_fullpath_out
dwarfstring_string
js_tmp3
if
duplicatedpath
js_originalfullpath
js_tmp3
res
dwarfstring_list_add_new
last_entry
js_tmp3
errcode
if
res
DW_DLV_OK
dwarfstring_list_destructor
destruct_js
return
res
last_entry
now_last
dwarfstring_reset
js_tmp2
dwarfstring_reset
js_tmp3
dwarfstring_append
js_tmp3
debug
prepare_linked_name
js_tmp2
js_dirname
js_tmp3
js_linkstring
if
duplicatedpath
js_originalfullpath
js_tmp2
res
dwarfstring_list_add_new
last_entry
js_tmp2
errcode
if
res
DW_DLV_OK
dwarfstring_list_destructor
destruct_js
return
res
last_entry
now_last
Now
look
in
the
global
locations
for
global_prefix_number
global_prefix_number
length_global_prefixes_in
global_prefix_number
char
prefix
global_prefixes_in
global_prefix_number
dwarfstring_reset
js_tmp2
dwarfstring_reset
js_tmp3
dwarfstring_append
js_tmp2
prefix
prepare_linked_name
js_tmp3
js_tmp2
js_dirname
js_linkstring
if
duplicatedpath
js_originalfullpath
js_tmp3
res
dwarfstring_list_add_new
last_entry
js_tmp3
errcode
if
res
DW_DLV_OK
dwarfstring_list_destructor
destruct_js
return
res
last_entry
now_last
Now
malloc
space
for
the
pointer
array
and
the
strings
they
point
at
so
a
simple
free
by
our
caller
will
clean
up
everything
Copy
the
data
from
base_dwlist
to
the
new
area
struct
dwarfstring_list_s
cur
char
resultfullstring
unsigned
long
count
unsigned
long
pointerarraysize
unsigned
long
sumstringlengths
unsigned
long
totalareasize
unsigned
long
setptrindex
unsigned
long
setstrindex
cur
for
cur
cur
cur
dl_next
count
pointerarraysize
sizeof
void
sumstringlengths
dwarfstring_strlen
dl_string
Make
a
final
null
pointer
in
the
pointer
array
pointerarraysize
sizeof
void
totalareasize
pointerarraysize
sumstringlengths
resultfullstring
char
malloc
totalareasize
setstrindex
pointerarraysize
if
resultfullstring
dwarfstring_list_destructor
destruct_js
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
resultfullstring
totalareasize
cur
for
cur
cur
cur
dl_next
setptrindex
char
iptr
char
char
resultfullstring
setptrindex
sizeof
void
char
sptr
char
resultfullstring
setstrindex
strcpy
sptr
dwarfstring_string
dl_string
setstrindex
dwarfstring_strlen
dl_string
iptr
sptr
paths_out
resultfullstring
paths_out_length
count
dwarfstring_list_destructor
destruct_js
return
DW_DLV_OK
static
int
extract_debuglink
Dwarf_Debug
dbg
struct
Dwarf_Section_s
pdebuglink
char
name_returned
static
storage
do
not
free
unsigned
char
crc_returned
crc
do
not
free
Dwarf_Error
error
Dwarf_Small
ptr
Dwarf_Small
endptr
unsigned
namelen
unsigned
m
unsigned
incr
Dwarf_Small
crcptr
int
res
DW_DLV_ERROR
Dwarf_Unsigned
secsize
if
pdebuglink
dss_data
res
_dwarf_load_section
dbg
pdebuglink
error
if
res
DW_DLV_OK
return
res
secsize
pdebuglink
dss_size
ptr
pdebuglink
dss_data
endptr
ptr
secsize
res
_dwarf_check_string_valid
dbg
ptr
ptr
endptr
DW_DLE_FORM_STRING_BAD_STRING
error
if
res
DW_DLV_OK
return
res
namelen
unsigned
strlen
const
char
ptr
m
namelen
if
m
incr
m
crcptr
unsigned
char
ptr
namelen
incr
if
crcptr
unsigned
char
endptr
_dwarf_error
dbg
error
DW_DLE_CORRUPT_GNU_DEBUGLINK
return
DW_DLV_ERROR
name_returned
char
ptr
crc_returned
crcptr
return
DW_DLV_OK
The
definition
of
note
gnu
buildid
contents
also
used
for
other
GNU
note
gnu
sections
too
struct
buildid_s
char
bu_ownernamesize
char
bu_buildidsize
char
bu_type
char
bu_owner
static
int
extract_buildid
Dwarf_Debug
dbg
struct
Dwarf_Section_s
pbuildid
unsigned
type_returned
char
owner_name_returned
unsigned
char
build_id_returned
unsigned
build_id_length_returned
Dwarf_Error
error
Dwarf_Small
ptr
Dwarf_Small
endptr
int
res
DW_DLV_ERROR
struct
buildid_s
bu
Dwarf_Unsigned
namesize
Dwarf_Unsigned
descrsize
Dwarf_Unsigned
type
Dwarf_Unsigned
finalsize
Dwarf_Unsigned
secsize
if
pbuildid
dss_data
res
_dwarf_load_section
dbg
pbuildid
error
if
res
DW_DLV_OK
return
res
secsize
pbuildid
dss_size
ptr
pbuildid
dss_data
if
secsize
sizeof
struct
buildid_s
_dwarf_error
dbg
error
DW_DLE_CORRUPT_NOTE_GNU_DEBUGID
return
DW_DLV_ERROR
endptr
ptr
secsize
We
hold
gh_content
till
all
is
closed
as
we
return
pointers
into
it
if
all
goes
well
bu
struct
buildid_s
ptr
ASNAR
dbg
de_copy_word
namesize
bu
bu_ownernamesize
ASNAR
dbg
de_copy_word
descrsize
bu
bu_buildidsize
ASNAR
dbg
de_copy_word
type
bu
bu_type
if
descrsize
_dwarf_error
dbg
error
DW_DLE_CORRUPT_NOTE_GNU_DEBUGID
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
dbg
Dwarf_Small
bu_owner
Dwarf_Small
bu_owner
endptr
DW_DLE_CORRUPT_GNU_DEBUGID_STRING
error
if
res
DW_DLV_OK
return
res
if
strlen
bu
bu_owner
namesize
_dwarf_error
dbg
error
DW_DLE_CORRUPT_GNU_DEBUGID_STRING
return
res
finalsize
sizeof
struct
buildid_s
namesize
descrsize
if
finalsize
secsize
_dwarf_error
dbg
error
DW_DLE_CORRUPT_GNU_DEBUGID_SIZE
return
DW_DLV_ERROR
type_returned
type
owner_name_returned
bu_owner
build_id_length_returned
descrsize
build_id_returned
unsigned
char
ptr
sizeof
struct
buildid_s
namesize
return
DW_DLV_OK
Caller
frees
space
returned
by
debuglink_fillpath_returned
and
The
following
return
pointers
into
the
dbg
itself
and
are
only
valid
while
that
dbg
is
open
debuglink_path_returned
crc_returned
buildid_owner_name_returned
buildid_returned
int
dwarf_gnu_debuglink
Dwarf_Debug
dbg
char
debuglink_path_returned
do
not
free
unsigned
char
crc_returned
char
debuglink_fullpath_returned
caller
frees
unsigned
debuglink_fullpath_length_returned
unsigned
buildid_type_returned
char
buildid_owner_name_returned
unsigned
char
buildid_returned
unsigned
buildid_length_returned
char
paths_returned
unsigned
paths_count_returned
Dwarf_Error
error
dwarfstring
debuglink_fullpath
int
linkres
DW_DLV_ERROR
int
res
DW_DLV_ERROR
char
pathname
int
buildidres
int
errcode
struct
Dwarf_Section_s
pdebuglink
struct
Dwarf_Section_s
pbuildid
if
dbg
_dwarf_error
dbg
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
dbg
de_gnu_debuglink
dss_size
pdebuglink
de_gnu_debuglink
if
dbg
de_note_gnu_buildid
dss_size
pbuildid
de_note_gnu_buildid
if
pdebuglink
pbuildid
return
DW_DLV_NO_ENTRY
if
pdebuglink
linkres
extract_debuglink
dbg
pdebuglink
debuglink_path_returned
crc_returned
error
if
linkres
DW_DLV_ERROR
return
linkres
if
pbuildid
buildidres
extract_buildid
dbg
pbuildid
buildid_type_returned
buildid_owner_name_returned
buildid_returned
buildid_length_returned
error
if
buildidres
DW_DLV_ERROR
return
buildidres
dwarfstring_constructor
pathname
char
dbg
de_path
if
pathname
paths_returned
res
_dwarf_construct_linkedto_path
char
dbg
de_gnu_global_paths
dbg
de_gnu_global_path_count
pathname
debuglink_path_returned
crc_returned
buildid_returned
buildid_length_returned
paths_returned
paths_count_returned
if
res
DW_DLV_OK
dwarfstring_destructor
return
res
if
dwarfstring_strlen
debuglink_fullpath_returned
strdup
dwarfstring_string
debuglink_fullpath_length_returned
dwarfstring_strlen
else
if
paths_count_returned
paths_count_returned
dwarfstring_destructor
return
DW_DLV_OK
This
should
be
rarely
called
and
most
likely
only
once
at
dbg
init
time
from
dwarf_generic_init
c
see
set_global_paths_init
Maybe
once
or
twice
later
int
dwarf_add_debuglink_global_path
Dwarf_Debug
dbg
const
char
pathname
Dwarf_Error
error
unsigned
glpath_count_in
unsigned
glpath_count_out
const
char
glpaths
const
char
path1
glpath_count_in
dbg
de_gnu_global_path_count
glpath_count_out
glpath_count_in
glpaths
const
char
malloc
sizeof
char
glpath_count_out
if
glpaths
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
if
glpath_count_in
memcpy
glpaths
dbg
de_gnu_global_paths
sizeof
char
glpath_count_in
path1
strdup
pathname
if
path1
free
glpaths
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
free
char
dbg
de_gnu_global_paths
glpaths
glpath_count_in
path1
dbg
de_gnu_global_paths
const
char
glpaths
dbg
de_gnu_global_path_count
glpath_count_out
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDINT_H
include
stdint
h
for
uintptr_t
endif
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_str_offsets
h
include
dwarfstring
h
include
dwarf_die_deliv
h
These
are
sanity
checks
not
rules
define
MINIMUM_ADDRESS_SIZE
define
MAXIMUM_ADDRESS_SIZE
static
void
assign_correct_unit_type
Dwarf_CU_Context
cu_context
static
int
find_cu_die_base_fields
Dwarf_Debug
dbg
Dwarf_CU_Context
cucon
Dwarf_Die
cudie
Dwarf_Error
error
static
int
_dwarf_siblingof_internal
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_CU_Context
context
Dwarf_Bool
is_info
Dwarf_Die
caller_ret_die
Dwarf_Error
error
see
cuandunit
txt
for
an
overview
of
the
DWARF5
split
dwarf
sections
and
values
and
the
DWARF4
GNU
cc
version
of
a
draft
version
of
DWARF5
quite
different
from
the
final
DWARF5
static
struct
Dwarf_Sig8_s
dwarfsig8zero
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
msg
for
cur
end
cur
printf
cur
printf
n
endif
New
October
Enables
client
code
to
know
if
it
is
a
debug_info
or
debug_types
context
Dwarf_Bool
dwarf_get_die_infotypes_flag
Dwarf_Die
die
return
die
di_is_info
For
a
given
Dwarf_Debug
dbg
this
function
checks
if
a
CU
that
includes
the
given
offset
has
been
read
or
not
If
yes
it
returns
the
Dwarf_CU_Context
for
the
CU
Otherwise
it
returns
NULL
Being
an
internal
routine
it
is
assumed
that
a
valid
dbg
is
passed
This
is
a
sequential
search
May
be
too
slow
If
debug_info
and
debug_abbrev
not
loaded
this
will
wind
up
returning
NULL
So
no
need
to
load
before
calling
this
static
Dwarf_CU_Context
_dwarf_find_CU_Context
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_CU_Context
cu_context
Dwarf_Debug_InfoTypes
dis
is_info?
de_info_reading
de_types_reading
if
offset
dis
de_last_offset
return
NULL
if
dis
de_cu_context
NULL
dis
de_cu_context
cc_next
NULL
dis
de_cu_context
cc_next
cc_debug_offset
offset
return
dis
de_cu_context
cc_next
if
dis
de_cu_context
NULL
dis
de_cu_context
cc_debug_offset
offset
for
cu_context
dis
de_cu_context
cu_context
NULL
cu_context
cu_context
cc_next
if
offset
cu_context
cc_debug_offset
offset
cu_context
cc_debug_offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
return
cu_context
for
cu_context
dis
de_cu_context_list
cu_context
NULL
cu_context
cu_context
cc_next
if
offset
cu_context
cc_debug_offset
offset
cu_context
cc_debug_offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
return
cu_context
return
NULL
int
dwarf_get_debugfission_for_die
Dwarf_Die
die
struct
Dwarf_Debug_Fission_Per_CU_s
fission_out
Dwarf_Error
error
Dwarf_CU_Context
context
Dwarf_Debug
dbg
struct
Dwarf_Debug_Fission_Per_CU_s
percu
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dbg
context
cc_dbg
if
_dwarf_file_has_debug_fission_index
dbg
return
DW_DLV_NO_ENTRY
Logic
should
work
for
DW4
and
DW5
if
context
cc_unit_type
DW_UT_type||
context
cc_unit_type
DW_UT_split_type
if
_dwarf_file_has_debug_fission_tu_index
dbg
return
DW_DLV_NO_ENTRY
else
if
context
cc_unit_type
DW_UT_split_compile
if
_dwarf_file_has_debug_fission_cu_index
dbg
return
DW_DLV_NO_ENTRY
percu
cc_dwp_offsets
if
percu
pcu_type
return
DW_DLV_NO_ENTRY
fission_out
percu
return
DW_DLV_OK
static
Dwarf_Bool
is_unknown_UT_value
int
ut
switch
ut
case
DW_UT_compile
case
DW_UT_type
case
DW_UT_partial
return
FALSE
case
DW_UT_skeleton
case
DW_UT_split_compile
case
DW_UT_split_type
return
FALSE
return
TRUE
ASSERT
whichone
is
a
DW_SECT
macro
value
Dwarf_Unsigned
_dwarf_get_dwp_extra_offset
struct
Dwarf_Debug_Fission_Per_CU_s
dwp
unsigned
whichone
Dwarf_Unsigned
size
Dwarf_Unsigned
sectoff
if
dwp
pcu_type
return
sectoff
dwp
pcu_offset
whichone
size
dwp
pcu_size
whichone
return
sectoff
_dwarf_get_fission_addition_die
returns
DW_DLV_OK
etc
int
_dwarf_get_fission_addition_die
Dwarf_Die
die
int
dw_sect_index
Dwarf_Unsigned
offset
Dwarf_Unsigned
size
Dwarf_Error
error
We
do
not
yet
know
the
DIE
hash
so
we
cannot
use
it
to
identify
the
offset
Dwarf_CU_Context
context
Dwarf_Unsigned
dwpadd
Dwarf_Unsigned
dwpsize
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dwpadd
_dwarf_get_dwp_extra_offset
cc_dwp_offsets
dw_sect_index
offset
dwpadd
size
dwpsize
return
DW_DLV_OK
Not
sure
if
this
is
the
only
way
to
be
sure
early
on
in
reading
a
compile
unit
static
int
section_name_ends_with_dwo
const
char
name
int
lenstr
int
dotpos
if
name
return
FALSE
lenstr
strlen
name
if
lenstr
return
FALSE
dotpos
lenstr
if
strcmp
name
dotpos
dwo
return
FALSE
return
TRUE
void
_dwarf_create_address_size_dwarf_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
addrsize
int
errcode
const
char
errname
dwarfstring
m
const
char
bites
bytes
if
addrsize
bites
byte
dwarfstring_constructor
dwarfstring_append
char
errname
dwarfstring_append_printf_u
Address
size
of
u
addrsize
dwarfstring_append_printf_s
s
is
not
supported
Corrupt
DWARF
char
bites
_dwarf_error_string
dbg
error
errcode
dwarfstring_string
dwarfstring_destructor
New
January
static
int
_dwarf_read_cu_version_and_abbrev_offset
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Bool
is_info
UNUSEDARG
unsigned
group_number
unsigned
offset_size
or
Dwarf_CU_Context
cu_context
end_data
used
for
sanity
checking
Dwarf_Small
end_data
Dwarf_Unsigned
bytes_read_out
Dwarf_Error
error
Dwarf_Small
data_start
data
Dwarf_Small
dataptr
data
int
unit_type
Dwarf_Ubyte
addrsize
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
version
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
dataptr
DWARF_HALF_SIZE
error
end_data
dataptr
DWARF_HALF_SIZE
if
version
DW_CU_VERSION5
Dwarf_Ubyte
unit_typeb
READ_UNALIGNED_CK
dbg
unit_typeb
Dwarf_Ubyte
dataptr
sizeof
unit_typeb
error
end_data
dataptr
sizeof
unit_typeb
unit_type
unit_typeb
We
do
not
need
is_info
flag
in
DWARF5
if
is_unknown_UT_value
unit_type
DWARF5
object
file
is
corrupt
Invalid
value
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_CU_UT_TYPE_ERROR
we
do
not
know
the
CU
header
unit_type
x
unit_type
dwarfstring_append_printf_u
u
so
cannot
process
this
compilation_unit
A
valid
type
unit_type
dwarfstring_append
would
be
DW_UT_compile
for
example
_dwarf_error_string
dbg
error
DW_DLE_CU_UT_TYPE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
addrsize
unsigned
char
dataptr
sizeof
addrsize
error
end_data
dataptr
sizeof
char
READ_UNALIGNED_CK
dbg
abbrev_offset
Dwarf_Unsigned
dataptr
offset_size
error
end_data
dataptr
offset_size
else
if
version
DW_CU_VERSION2
version
DW_CU_VERSION3
version
DW_CU_VERSION4
DWARF2
READ_UNALIGNED_CK
dbg
abbrev_offset
Dwarf_Unsigned
dataptr
offset_size
error
end_data
dataptr
offset_size
READ_UNALIGNED_CK
dbg
addrsize
Dwarf_Ubyte
dataptr
sizeof
addrsize
error
end_data
dataptr
sizeof
addrsize
This
is
an
initial
approximation
of
unit_type
For
DW4
we
will
refine
this
after
we
have
built
the
CU
header
by
reading
CU_die
unit_type
is_info?DW_UT_compile
DW_UT_type
else
_dwarf_error
dbg
error
DW_DLE_VERSION_STAMP_ERROR
return
DW_DLV_ERROR
cu_context
cc_version_stamp
version
cu_context
cc_unit_type
unit_type
cu_context
cc_address_size
addrsize
cu_context
cc_abbrev_offset
abbrev_offset
if
addrsize
_dwarf_error
dbg
error
DW_DLE_ADDRESS_SIZE_ZERO
return
DW_DLV_ERROR
if
addrsize
MINIMUM_ADDRESS_SIZE
addrsize
MAXIMUM_ADDRESS_SIZE
_dwarf_create_address_size_dwarf_error
dbg
error
addrsize
DW_DLE_ADDRESS_SIZE_ERROR
DW_DLE_ADDRESS_SIZE_ERROR
return
DW_DLV_ERROR
if
addrsize
sizeof
Dwarf_Addr
_dwarf_create_address_size_dwarf_error
dbg
error
addrsize
DW_DLE_ADDRESS_SIZE_ERROR
DW_DLE_ADDRESS_SIZE_ERROR
not
representable
in
Dwarf_Addr
field
return
DW_DLV_ERROR
We
are
ignoring
this
Can
get
it
from
DWARF5
cu_context
cc_segment_selector_size
bytes_read_out
dataptr
data_start
return
DW_DLV_OK
debug_info
dwo
debug_types
dwo
the
latter
only
DWARF4
static
int
read_info_area_length_and_check
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
offset
Dwarf_Byte_Ptr
cu_ptr_io
Dwarf_Unsigned
section_size
Dwarf_Byte_Ptr
section_end_ptr
Dwarf_Unsigned
max_cu_global_offset_out
Dwarf_Error
error
Dwarf_Byte_Ptr
cu_ptr
int
local_length_size
int
local_extension_size
Dwarf_Unsigned
max_cu_global_offset
Dwarf_Unsigned
length
cu_ptr
cu_ptr_io
READ_AREA_LENGTH
updates
cu_ptr
for
consumed
bytes
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
cu_ptr
local_length_size
local_extension_size
error
section_size
section_end_ptr
if
length
return
DW_DLV_NO_ENTRY
cu_context
cc_length_size
local_length_size
cu_context
cc_extension_size
local_extension_size
cu_context
cc_length
length
This
is
a
bare
minimum
not
the
real
max
offset
A
preliminary
sanity
check
max_cu_global_offset
offset
length
local_extension_size
local_length_size
if
length
section_size
_dwarf_error
dbg
error
DW_DLE_CU_LENGTH_ERROR
return
DW_DLV_ERROR
if
max_cu_global_offset
section_size
_dwarf_error
dbg
error
DW_DLE_CU_LENGTH_ERROR
return
DW_DLV_ERROR
cu_ptr_io
cu_ptr
max_cu_global_offset_out
max_cu_global_offset
return
DW_DLV_OK
In
DWARF4
GNU
dwp
there
is
a
problem
We
cannot
read
the
CU
die
and
it
s
DW_AT_GNU_dwo_id
until
we
know
the
section
offsets
from
the
index
files
Hence
we
do
not
know
how
to
search
the
index
files
by
key
So
search
by
offset
There
is
no
such
problem
in
DWARF5
We
have
not
yet
corrected
the
unit_type
so
for
DWARF4
we
check
for
simpler
unit
types
static
int
fill_in_dwp_offsets_if_present
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Sig8
signaturedata
Dwarf_Off
offset
Dwarf_Error
error
Dwarf_Half
unit_type
cu_context
cc_unit_type
const
char
typename
Dwarf_Half
ver
cu_context
cc_version_stamp
if
unit_type
DW_UT_split_type
ver
DW_CU_VERSION4
unit_type
DW_UT_type
typename
tu
if
_dwarf_file_has_debug_fission_tu_index
dbg
nothing
to
do
return
DW_DLV_OK
else
if
unit_type
DW_UT_split_compile
ver
DW_CU_VERSION4
unit_type
DW_UT_compile
typename
cu
if
_dwarf_file_has_debug_fission_cu_index
dbg
nothing
to
do
return
DW_DLV_OK
else
nothing
to
do
return
DW_DLV_OK
if
cu_context
cc_signature_present
int
resdf
resdf
dwarf_get_debugfission_for_key
dbg
signaturedata
typename
cc_dwp_offsets
error
if
resdf
DW_DLV_ERROR
return
resdf
else
if
resdf
DW_DLV_NO_ENTRY
_dwarf_error_string
dbg
error
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
dwarf_get_debugfission_for_key
returned
DW_DLV_NO_ENTRY
something
is
wrong
return
DW_DLV_ERROR
else
int
resdf
resdf
_dwarf_get_debugfission_for_offset
dbg
offset
typename
cc_dwp_offsets
error
if
resdf
DW_DLV_ERROR
return
resdf
else
if
resdf
DW_DLV_NO_ENTRY
_dwarf_error_string
dbg
error
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
dwarf_get_debugfission_for_offset
returned
DW_DLV_NO_ENTRY
something
is
wrong
return
DW_DLV_ERROR
cu_context
cc_signature
cu_context
cc_dwp_offsets
pcu_hash
cu_context
cc_signature_present
TRUE
return
DW_DLV_OK
static
int
finish_cu_context_via_cudie_inner
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Error
error
DW4
Look
for
DW_AT_dwo_id
and
DW_AT_low_pc
and
more
if
there
is
one
pick
up
the
hash
DW5
hash
in
skeleton
CU
die
Also
pick
up
cc_str_offset_base
and
any
other
base
values
Dwarf_Die
cudie
int
resdwo
Must
call
the
internal
siblingof
so
we
do
not
depend
on
the
dbg
de_cu_context
used
by
and
for
dwarf_cu_header_
calls
resdwo
_dwarf_siblingof_internal
dbg
NULL
cu_context
cu_context
cc_is_info
error
if
resdwo
DW_DLV_OK
Dwarf_Half
cutag
int
resdwob
resdwob
find_cu_die_base_fields
dbg
cu_context
cudie
error
if
resdwob
DW_DLV_NO_ENTRY
The
CU
die
has
no
children
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
cudie
cu_context
cc_cu_die_has_children
FALSE
return
DW_DLV_OK
else
if
resdwob
DW_DLV_ERROR
Not
applicable
or
an
error
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
cudie
return
resdwob
resdwob
dwarf_tag
cudie
error
if
resdwob
DW_DLV_OK
cu_context
cc_cu_die_tag
cutag
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
return
resdwob
else
if
resdwo
DW_DLV_NO_ENTRY
no
cudie
Empty
CU
return
DW_DLV_OK
else
no
cudie
Error
return
resdwo
return
DW_DLV_OK
static
void
local_dealloc_cu_context
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Hash_Table
hash_table
if
context
return
hash_table
context
cc_abbrev_hash_table
if
hash_table
_dwarf_free_abbrev_hash_table_contents
dbg
hash_table
hash_table
tb_entries
dwarf_dealloc
dbg
hash_table
DW_DLA_HASH_TABLE
context
cc_abbrev_hash_table
dwarf_dealloc
dbg
context
DW_DLA_CU_CONTEXT
static
void
report_local_unit_type_error
Dwarf_Debug
dbg
int
unit_type
const
char
msg
Dwarf_Error
err
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_CU_UT_TYPE_VALUE
s
char
msg
dwarfstring_append_printf_u
the
compilation
unit
unit_type
is
x
which
is
unknown
to
libdwarf
Corrupt
DWARF
unit_type
_dwarf_error_string
dbg
err
DW_DLE_CU_UT_TYPE_VALUE
dwarfstring_string
dwarfstring_destructor
This
function
is
used
to
create
a
CU
Context
for
a
compilation
unit
that
begins
at
offset
in
debug_info
The
CU
Context
is
attached
to
the
list
of
CU
Contexts
for
this
dbg
It
is
assumed
that
the
CU
at
offset
has
not
been
read
before
and
so
do
not
call
this
routine
before
making
sure
of
this
with
_dwarf_find_CU_Context
Returns
NULL
on
error
As
always
being
an
internal
routine
assumes
a
good
dbg
The
offset
argument
is
global
offset
the
offset
in
the
section
irrespective
of
CUs
The
offset
has
the
DWP
Package
File
offset
built
in
as
it
comes
from
the
actual
section
max_cu_local_offset
is
a
local
offset
in
this
CU
So
zero
of
this
field
is
immediately
following
the
length
field
of
the
CU
header
so
max_cu_local_offset
is
identical
to
the
CU
length
field
max_cu_global_offset
is
the
offset
one
past
the
end
of
this
entire
CU
static
int
_dwarf_make_CU_Context
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_CU_Context
context_out
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
length
Dwarf_Unsigned
typeoffset
Dwarf_Sig8
signaturedata
Dwarf_Unsigned
types_extra_len
Dwarf_Unsigned
max_cu_local_offset
Dwarf_Unsigned
max_cu_global_offset
Dwarf_Byte_Ptr
cu_ptr
Dwarf_Byte_Ptr
section_end_ptr
int
local_length_size
Dwarf_Unsigned
bytes_read
const
char
secname
Dwarf_Debug_InfoTypes
dis
struct
Dwarf_Section_s
secdp
Dwarf_Unsigned
section_size
int
unit_type
int
version
Dwarf_Small
dataptr
int
res
if
is_info
secname
dbg
de_debug_info
dss_name
dis
de_info_reading
secdp
de_debug_info
else
secname
dbg
de_debug_types
dss_name
dis
de_types_reading
secdp
de_debug_types
section_size
secdp
dss_size
signaturedata
dwarfsig8zero
cu_context
Dwarf_CU_Context
_dwarf_get_alloc
dbg
DW_DLA_CU_CONTEXT
if
cu_context
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
cu_context
cc_dbg
dbg
cu_context
cc_is_info
is_info
dataptr
is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
Preliminary
sanity
checking
if
dataptr
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_INFO_HEADER_ERROR
return
DW_DLV_ERROR
if
offset
section_size
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_INFO_HEADER_ERROR
return
DW_DLV_ERROR
if
offset
section_size
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_INFO_HEADER_ERROR
return
DW_DLV_ERROR
section_end_ptr
dataptr
section_size
cu_ptr
Dwarf_Byte_Ptr
dataptr
offset
if
section_name_ends_with_dwo
secname
cu_context
cc_is_dwo
TRUE
res
read_info_area_length_and_check
dbg
cu_context
offset
section_size
section_end_ptr
error
if
res
DW_DLV_OK
local_dealloc_cu_context
dbg
cu_context
return
res
local_length_size
cu_context
cc_length_size
length
cu_context
cc_length
max_cu_local_offset
length
res
_dwarf_read_cu_version_and_abbrev_offset
dbg
cu_ptr
is_info
dbg
de_groupnumber
local_length_size
cu_context
section_end_ptr
error
if
res
DW_DLV_OK
local_dealloc_cu_context
dbg
cu_context
return
res
version
cu_context
cc_version_stamp
cu_ptr
bytes_read
unit_type
cu_context
cc_unit_type
if
cu_ptr
section_end_ptr
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_INFO_HEADER_ERROR
return
DW_DLV_ERROR
In
a
dwp
context
the
abbrev_offset
is
still
incomplete
We
need
to
add
in
the
base
from
the
debug_cu_index
or
debug_tu_index
Done
below
At
this
point
for
DW4
the
unit_type
is
not
fully
correct
as
we
don
t
know
if
it
is
a
skeleton
or
a
split_compile
or
split_type
if
version
DW_CU_VERSION5
version
DW_CU_VERSION4
DW4
DW5
header
fields
depending
on
UT
type
See
DW5
section
x
DW4
data
is
a
GNU
extension
of
DW4
switch
unit_type
case
DW_UT_split_type
case
DW_UT_type
types_extra_len
sizeof
Dwarf_Sig8
local_length_size
type_offset
size
break
case
DW_UT_skeleton
case
DW_UT_split_compile
types_extra_len
sizeof
Dwarf_Sig8
break
case
DW_UT_compile
No
additional
fields
case
DW_UT_partial
No
additional
fields
break
default
Data
corruption
in
libdwarf?
report_local_unit_type_error
dbg
unit_type
DW4
or
DW5
error
local_dealloc_cu_context
dbg
cu_context
return
DW_DLV_ERROR
Compare
the
space
following
the
length
field
to
the
bytes
in
the
CU
header
if
length
CU_VERSION_STAMP_SIZE
is
local_length_size
for
debug_abbrev
offset
CU_ADDRESS_SIZE_SIZE
is
and
finally
size
of
the
rest
of
the
header
types_extra_len
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_CU_LENGTH_ERROR
return
DW_DLV_ERROR
Now
we
can
read
the
fields
with
some
confidence
we
know
the
fields
of
the
header
are
inside
the
section
cu_context
cc_unit_type
unit_type
switch
unit_type
case
DW_UT_split_type
case
DW_UT_type
int
tres
ASSERT
DW_CU_VERSION4
or
DW_CU_VERSION5
determined
by
logic
above
Now
read
the
debug_types
extra
header
fields
of
the
signature
bytes
and
the
typeoffset
This
can
be
in
executable
ordinary
object
as
in
Type
Unit
there
was
no
dwo
in
DWARF4
memcpy
cu_ptr
sizeof
signaturedata
cu_ptr
sizeof
signaturedata
tres
_dwarf_read_unaligned_ck_wrapper
dbg
cu_ptr
local_length_size
section_end_ptr
error
if
tres
DW_DLV_OK
local_dealloc_cu_context
dbg
cu_context
return
tres
cu_context
cc_signature
signaturedata
cu_context
cc_signature_present
TRUE
cu_context
cc_signature_offset
typeoffset
if
typeoffset
max_cu_local_offset
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_DEBUG_TYPEOFFSET_BAD
return
DW_DLV_ERROR
break
case
DW_UT_skeleton
case
DW_UT_split_compile
These
unit
types
make
a
pair
and
paired
units
have
identical
signature
memcpy
cu_ptr
sizeof
signaturedata
cu_context
cc_signature
signaturedata
cu_context
cc_signature_present
TRUE
break
The
following
with
no
additional
fields
case
DW_UT_compile
case
DW_UT_partial
break
default
Data
corruption
in
libdwarf?
report_local_unit_type_error
dbg
unit_type
error
local_dealloc_cu_context
dbg
cu_context
return
DW_DLV_ERROR
cu_context
cc_abbrev_hash_table
Dwarf_Hash_Table
_dwarf_get_alloc
dbg
DW_DLA_HASH_TABLE
if
cu_context
cc_abbrev_hash_table
NULL
local_dealloc_cu_context
dbg
cu_context
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
cu_context
cc_debug_offset
offset
This
is
recording
an
overall
section
value
for
later
sanity
checking
dis
de_last_offset
max_cu_global_offset
context_out
cu_context
return
DW_DLV_OK
static
int
reloc_incomplete
int
res
Dwarf_Error
err
int
e
if
res
DW_DLV_OK
return
FALSE
if
res
DW_DLV_NO_ENTRY
return
FALSE
e
dwarf_errno
err
switch
e
case
DW_DLE_RELOC_MISMATCH_INDEX
case
DW_DLE_RELOC_MISMATCH_RELOC_INDEX
case
DW_DLE_RELOC_MISMATCH_STRTAB_INDEX
case
DW_DLE_RELOC_SECTION_MISMATCH
case
DW_DLE_RELOC_SECTION_MISSING_INDEX
case
DW_DLE_RELOC_SECTION_LENGTH_ODD
case
DW_DLE_RELOC_SECTION_PTR_NULL
case
DW_DLE_RELOC_SECTION_MALLOC_FAIL
case
DW_DLE_SEEK_OFF_END
case
DW_DLE_RELOC_INVALID
case
DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD
return
TRUE
return
FALSE
Returns
offset
of
next
compilation
unit
thru
next_cu_offset
pointer
It
sequentially
moves
from
one
cu
to
the
next
The
current
cu
is
recorded
internally
by
libdwarf
int
dwarf_next_cu_header_d
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_offset
Dwarf_Half
header_cu_type
Dwarf_Error
error
Faking
has_signature
to
do
nothing
Dwarf_Bool
has_signature
int
res
res
_dwarf_next_cu_header_internal
dbg
is_info
cu_header_length
version_stamp
abbrev_offset
address_size
offset_size
extension_size
signature
has_signature
typeoffset
next_cu_offset
header_cu_type
error
return
res
static
void
local_attrlist_dealloc
Dwarf_Debug
dbg
Dwarf_Signed
atcount
Dwarf_Attribute
alist
Dwarf_Signed
i
for
i
atcount
i
dwarf_dealloc
dbg
alist
i
DW_DLA_ATTR
dwarf_dealloc
dbg
alist
DW_DLA_LIST
For
a
DWP
DWO
the
base
fields
of
a
CU
are
inherited
from
the
skeleton
DWARF5
section
Split
Full
Compilation
Unit
Entries
static
int
find_cu_die_base_fields
Dwarf_Debug
dbg
Dwarf_CU_Context
cucon
Dwarf_Die
cudie
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Attribute
alist
Dwarf_Signed
atcount
unsigned
version_stamp
int
alres
Dwarf_Signed
i
Dwarf_Signed
low_pc_attrnum
Dwarf_Signed
at_addr_base_attrnum
cu_context
cudie
di_cu_context
version_stamp
cu_context
cc_version_stamp
alres
dwarf_attrlist
cudie
error
if
alres
DW_DLV_OK
Something
is
badly
wrong
No
attrlist
return
alres
DW_AT_dwo_id
and
or
DW_AT_GNU_dwo_id
are
only
found
in
some
experimental
DWARF4
Even
DWARF3
use
DW_AT_low_pc
as
base
address
DWARF5
changed
CU
header
contents
to
make
this
attribute
unnecessary
DW_AT_GNU_odr_signature
is
the
same
format
but
is
in
a
different
namespace
so
not
appropriate
here
for
i
i
atcount
i
Dwarf_Half
attrnum
Dwarf_Half
form
int
ares
int
ares2
Dwarf_Attribute
attr
alist
i
ares
dwarf_whatattr
attr
error
if
ares
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
ares2
dwarf_whatform
attr
error
if
ares2
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
We
are
not
returning
on
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
here
Such
will
be
caught
later
Lets
finish
a
CU
die
scan
and
finish
the
cu_context
if
ares
DW_DLV_OK
ares2
DW_DLV_OK
switch
form
case
DW_FORM_strx
case
DW_FORM_strx1
case
DW_FORM_strx2
case
DW_FORM_strx3
case
DW_FORM_strx4
cucon
cc_at_strx_present
TRUE
switch
attrnum
case
DW_AT_dwo_id
case
DW_AT_GNU_dwo_id
Dwarf_Sig8
signature
This
is
for
DWARF4
with
an
early
non
standard
version
of
split
dwarf
Not
DWARF5
int
sres
if
version_stamp
DW_CU_VERSION4
Not
supposed
to
happen
local_attrlist_dealloc
dbg
atcount
alist
_dwarf_error
dbg
error
DW_DLE_IMPROPER_DWO_ID
return
DW_DLV_ERROR
signature
dwarfsig8zero
sres
dwarf_formsig8_const
attr
error
if
sres
DW_DLV_OK
if
cucon
cc_signature_present
cucon
cc_signature
signature
cucon
cc_signature_present
TRUE
else
Something
wrong
Two
styles
of
sig?
Can
happen
with
DWARF4
debug
fission
extension
DWO_id
if
memcmp
cc_signature
sizeof
signature
The
two
sigs
do
not
match
const
char
m
DW_DLE_SIGNATURE_MISMATCH
DWARF4
extension
fission
signature
and
DW_AT_GNU_dwo_id
do
not
match
ignoring
DW_AT
_GNU
_dwo_id
dwarf_insert_harmless_error
dbg
char
m
else
Something
is
badly
wrong
local_attrlist_dealloc
dbg
atcount
alist
return
sres
Something
is
badly
wrong
break
If
in
debug_rnglists
for
a
CU
the
applicable
range
has
no
base
address
this
attribute
provides
a
base
address
If
this
is
indexed
doing
this
now
would
lead
to
an
infinite
recursion
So
wait
till
all
the
other
fields
seen
case
DW_AT_low_pc
low_pc_attrnum
i
break
The
offset
is
of
the
first
offset
in
debug_str_offsets
that
is
the
string
table
for
this
CU
case
DW_AT_str_offsets_base
int
udres
udres
dwarf_global_formref
attr
cc_str_offsets_base
error
if
udres
DW_DLV_OK
cucon
cc_str_offsets_base_present
TRUE
else
local_attrlist_dealloc
dbg
atcount
alist
Something
is
badly
wrong
return
udres
break
offset
in
debug_loclists
of
the
offsets
table
applicable
to
this
CU
case
DW_AT_loclists_base
int
udres
udres
dwarf_global_formref
attr
cc_loclists_base
error
if
udres
DW_DLV_OK
cucon
cc_loclists_base_present
TRUE
else
local_attrlist_dealloc
dbg
atcount
alist
Something
is
badly
wrong
return
udres
break
Base
offset
in
debug_addr
of
the
addr
table
for
this
CU
DWARF5
and
possibly
GNU
DWARF4
case
DW_AT_addr_base
case
DW_AT_GNU_addr_base
int
udres
at_addr_base_attrnum
i
udres
dwarf_global_formref
attr
cc_addr_base
error
if
udres
DW_DLV_OK
cucon
cc_addr_base_present
TRUE
else
local_attrlist_dealloc
dbg
atcount
alist
Something
is
badly
wrong
return
udres
break
case
DW_AT_GNU_ranges_base
The
DW4
ranges
base
was
never
used
in
GNU
but
did
get
emitted
in
skeletons
http
llvm
n5
nabble
com
DebugInfo
DW
AT
GNU
ranges
base
in
non
fission
td64194
html
But
we
accept
it
anyway
offset
in
debug_rnglists
of
the
offsets
table
applicable
to
this
CU
Note
that
this
base
applies
when
referencing
from
the
dwp
but
NOT
when
referencing
from
the
a
out
int
udres
udres
dwarf_global_formref
attr
cc_ranges_base
error
if
udres
DW_DLV_OK
cucon
cc_ranges_base_present
TRUE
else
local_attrlist_dealloc
dbg
atcount
alist
Something
is
badly
wrong
return
udres
break
case
DW_AT_rnglists_base
int
udres
udres
dwarf_global_formref
attr
cc_rnglists_base
error
if
udres
DW_DLV_OK
cucon
cc_rnglists_base_present
TRUE
else
local_attrlist_dealloc
dbg
atcount
alist
Something
is
badly
wrong
return
udres
break
A
signature
found
in
a
DWARF5
skeleton
compilation
unit
case
DW_AT_GNU_dwo_name
case
DW_AT_dwo_name
int
dnres
dnres
dwarf_formstring
attr
cc_dwo_name
error
if
dnres
DW_DLV_OK
local_attrlist_dealloc
dbg
atcount
alist
return
dnres
cucon
cc_dwo_name_present
TRUE
break
default
do
nothing
not
an
attribute
we
need
to
deal
with
here
break
if
low_pc_attrnum
int
lres
Dwarf_Attribute
attr
alist
low_pc_attrnum
Dwarf_Half
form
If
the
form
is
indexed
we
better
have
seen
DW_AT_addr_base
lres
dwarf_whatform
attr
error
if
lres
DW_DLV_OK
local_attrlist_dealloc
dbg
atcount
alist
return
lres
if
dwarf_addr_form_is_indexed
form
if
at_addr_base_attrnum
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_ATTR_NO_CU_CONTEXT
The
DW_AT_low_pc
CU_DIE
uses
an
indexed
attribute
yet
DW_AT_addr_base
is
not
in
the
CU
DIE
_dwarf_error_string
dbg
error
DW_DLE_ATTR_NO_CU_CONTEXT
dwarfstring_string
dwarfstring_destructor
local_attrlist_dealloc
dbg
atcount
alist
return
DW_DLV_ERROR
lres
dwarf_formaddr
attr
cc_low_pc
error
if
lres
DW_DLV_OK
cucon
cc_low_pc_present
TRUE
else
Something
is
badly
wrong
local_attrlist_dealloc
dbg
atcount
alist
return
lres
local_attrlist_dealloc
dbg
atcount
alist
alist
atcount
int
chres
Dwarf_Half
flag
always
winds
up
with
cc_cu_die_has_children
set
intentionally
to
something
cucon
cc_cu_die_has_children
TRUE
chres
dwarf_die_abbrev_children_flag
cudie
If
chres
is
not
DW_DLV_OK
the
assumption
of
children
remains
true
if
chres
DW_DLV_OK
cucon
cc_cu_die_has_children
flag
return
DW_DLV_OK
Called
only
for
DWARF4
static
void
assign_correct_unit_type
Dwarf_CU_Context
cu_context
Dwarf_Half
tag
cu_context
cc_cu_die_tag
if
cu_context
cc_cu_die_has_children
if
cu_context
cc_signature_present
if
tag
DW_TAG_compile_unit
tag
DW_TAG_type_unit
cu_context
cc_unit_type
DW_UT_skeleton
else
if
cu_context
cc_signature_present
if
tag
DW_TAG_compile_unit
cu_context
cc_unit_type
DW_UT_split_compile
else
if
tag
DW_TAG_type_unit
cu_context
cc_unit_type
DW_UT_split_type
static
int
finish_up_cu_context_from_cudie
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_CU_Context
cu_context
Dwarf_Error
error
int
version
cu_context
cc_version_stamp
Dwarf_Sig8
signaturedata
int
res
signaturedata
dwarfsig8zero
signaturedata
cu_context
cc_signature
Loads
and
initializes
the
dwarf
debug_cu_index
and
debug_tu_index
split
dwarf
package
file
sections
res
fill_in_dwp_offsets_if_present
dbg
cu_context
offset
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_OK
return
res
if
cu_context
cc_dwp_offsets
pcu_type
Dwarf_Unsigned
absize
Dwarf_Unsigned
aboff
aboff
_dwarf_get_dwp_extra_offset
cc_dwp_offsets
DW_SECT_ABBREV
cu_context
cc_abbrev_offset
aboff
if
cu_context
cc_abbrev_offset
dbg
de_debug_abbrev
dss_size
_dwarf_error
dbg
error
DW_DLE_ABBREV_OFFSET_ERROR
return
DW_DLV_ERROR
Now
we
can
read
the
CU
die
and
determine
the
correct
DW_UT_
type
for
DWARF4
and
some
offset
base
fields
for
DW4
fission
and
DW5
and
even
DW3
and
DW4
and
some
non
std
DW2
res
finish_cu_context_via_cudie_inner
dbg
cu_context
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_OK
return
res
if
version
DW_CU_VERSION4
assign_correct_unit_type
cu_context
if
cu_context
cc_signature_present
Initially
just
for
DW_SECT_STR_OFFSETS
finds
the
section
offset
of
the
contribution
which
is
not
the
same
as
the
table
offset
res
_dwarf_find_all_offsets_via_fission
dbg
cu_context
error
if
res
DW_DLV_ERROR
something
seriously
wrong
return
res
return
DW_DLV_OK
CU_Contexts
do
not
overlap
cu_context
we
see
here
is
not
in
the
list
we
are
updating
See
_dwarf_find_CU_Context
Invariant
cc_debug_offset
in
strictly
ascending
order
in
the
list
static
void
insert_into_cu_context_list
Dwarf_Debug_InfoTypes
dis
Dwarf_CU_Context
icu_context
Dwarf_Unsigned
ioffset
icu_context
cc_debug_offset
Dwarf_Unsigned
eoffset
Dwarf_Unsigned
hoffset
Dwarf_Unsigned
coffset
Dwarf_CU_Context
next
Dwarf_CU_Context
past
Dwarf_CU_Context
cur
Add
the
context
into
the
section
context
list
This
is
the
one
and
only
place
where
it
is
saved
for
re
use
and
eventual
dealloc
if
dis
de_cu_context_list
First
cu
encountered
dis
de_cu_context_list
icu_context
dis
de_cu_context_list_end
icu_context
return
eoffset
dis
de_cu_context_list_end
cc_debug_offset
if
eoffset
ioffset
Normal
case
add
at
end
dis
de_cu_context_list_end
cc_next
icu_context
dis
de_cu_context_list_end
icu_context
return
hoffset
dis
de_cu_context_list
cc_debug_offset
if
hoffset
ioffset
insert
as
new
head
Unusual
next
dis
de_cu_context_list
dis
de_cu_context_list
icu_context
dis
de_cu_context_list
cc_next
next
No
need
to
touch
de_cu_context_list_end
return
cur
dis
de_cu_context_list
past
Insert
in
middle
somewhere
Neither
at
start
nor
end
ASSERT
cur
non
null
ASSERT
past
non
null
past
cur
cur
cur
cc_next
for
cur
cur
next
next
cur
cc_next
coffset
cur
cc_debug_offset
if
coffset
ioffset
Insert
before
cur
using
past
ASSERT
past
non
null
past
cc_next
icu_context
icu_context
cc_next
cur
return
past
cur
Impossible
for
end
coffset
ie
eoffset
ioffset
NOTREACHED
return
Dwarf_Unsigned
_dwarf_calculate_next_cu_context_offset
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
next_cu_offset
next_cu_offset
cu_context
cc_debug_offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
return
next_cu_offset
int
_dwarf_create_a_new_cu_context_record_on_list
Dwarf_Debug
dbg
Dwarf_Debug_InfoTypes
dis
Dwarf_Bool
is_info
Dwarf_Unsigned
section_size
Dwarf_Unsigned
new_cu_offset
Dwarf_CU_Context
context_out
Dwarf_Error
error
int
res
Dwarf_CU_Context
cu_context
if
new_cu_offset
_dwarf_length_of_cu_header_simple
dbg
is_info
section_size
_dwarf_error
dbg
error
DW_DLE_OFFSET_BAD
return
DW_DLV_ERROR
res
_dwarf_make_CU_Context
dbg
new_cu_offset
is_info
error
if
res
DW_DLV_OK
return
res
The
called
func
does
not
dealloc
cu_context
in
case
of
error
so
we
do
it
here
res
finish_up_cu_context_from_cudie
dbg
new_cu_offset
cu_context
error
if
res
DW_DLV_ERROR
local_dealloc_cu_context
dbg
cu_context
return
res
if
res
DW_DLV_NO_ENTRY
local_dealloc_cu_context
dbg
cu_context
return
res
Add
the
new
cu_context
to
a
list
of
contexts
insert_into_cu_context_list
dis
cu_context
context_out
cu_context
return
DW_DLV_OK
int
_dwarf_load_die_containing_section
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
error
Dwarf_Error
err2
int
resd
is_info?
_dwarf_load_debug_info
dbg
_dwarf_load_debug_types
dbg
if
resd
DW_DLV_ERROR
if
reloc_incomplete
resd
err2
We
will
assume
all
is
ok
though
it
is
not
Relocation
errors
need
not
be
fatal
char
msg_buf
char
dwerrmsg
char
msgprefix
Relocations
did
not
complete
successfully
but
we
are
ignoring
error
size_t
totallen
size_t
prefixlen
dwerrmsg
dwarf_errmsg
err2
prefixlen
strlen
msgprefix
totallen
prefixlen
strlen
dwerrmsg
if
totallen
sizeof
msg_buf
Impossible
unless
something
corrupted
Provide
a
shorter
dwerrmsg
strcpy
msg_buf
Error
corrupted
dwarf
message
table
else
strcpy
msg_buf
msgprefix
strcpy
msg_buf
prefixlen
dwerrmsg
dwarf_insert_harmless_error
dbg
msg_buf
Fall
thru
to
use
the
newly
loaded
section
even
though
it
might
not
be
adequately
relocated
dwarf_dealloc_error
dbg
err2
if
error
error
return
DW_DLV_OK
if
error
error
err2
else
dwarf_dealloc_error
dbg
err2
return
DW_DLV_ERROR
return
resd
int
_dwarf_next_cu_header_internal
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature_out
Dwarf_Bool
has_signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_offset
header_type
DW_UT_compile
DW_UT_partial
DW_UT_type
returned
through
the
pointer
A
new
item
in
DWARF5
synthesized
for
earlier
DWARF
CUs
TUs
Dwarf_Half
header_type
Dwarf_Error
error
Offset
for
current
and
new
CU
Dwarf_Unsigned
new_offset
CU
Context
for
current
CU
Dwarf_CU_Context
cu_context
Dwarf_Debug_InfoTypes
dis
Dwarf_Unsigned
section_size
Dwarf_Small
dataptr
struct
Dwarf_Section_s
secdp
int
res
BEGIN
CODE
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
is_info
dis
de_info_reading
dataptr
dbg
de_debug_info
dss_data
secdp
de_debug_info
else
dis
de_types_reading
dataptr
dbg
de_debug_types
dss_data
secdp
de_debug_types
if
dataptr
res
_dwarf_load_die_containing_section
dbg
is_info
error
if
res
DW_DLV_OK
return
res
if
Get
offset
into
debug_info
of
next
CU
If
dbg
has
no
context
this
has
to
be
the
first
one
if
dis
de_cu_context
Dwarf_Small
dataptr
is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
new_offset
if
dataptr
Dwarf_Error
err2
int
resd
is_info?
_dwarf_load_debug_info
dbg
_dwarf_load_debug_types
dbg
if
resd
DW_DLV_OK
if
reloc_incomplete
resd
err2
We
will
assume
all
is
ok
though
it
is
not
Relocation
errors
need
not
be
fatal
char
msg_buf
char
dwerrmsg
char
msgprefix
Relocations
did
not
complete
successfully
but
we
are
ignoring
error
size_t
totallen
size_t
prefixlen
dwerrmsg
dwarf_errmsg
err2
prefixlen
strlen
msgprefix
totallen
prefixlen
strlen
dwerrmsg
if
totallen
sizeof
msg_buf
Impossible
unless
something
corrupted
Provide
a
shorter
dwerrmsg
strcpy
msg_buf
Error
corrupted
dwarf
message
table
else
strcpy
msg_buf
msgprefix
strcpy
msg_buf
prefixlen
dwerrmsg
dwarf_insert_harmless_error
dbg
msg_buf
Fall
thru
to
use
the
newly
loaded
section
even
though
it
might
not
be
adequately
relocated
if
resd
DW_DLV_ERROR
dwarf_dealloc_error
dbg
err2
err2
else
if
error
error
err2
err2
There
is
nothing
here
or
what
is
here
is
damaged
return
resd
endif
if
dis
de_cu_context
We
are
leaving
new_offset
zero
We
are
at
the
start
of
a
section
new_offset
else
new_offset
_dwarf_calculate_next_cu_context_offset
dis
de_cu_context
Check
that
there
is
room
in
debug_info
beyond
the
new
offset
for
at
least
a
new
cu
header
If
not
return
DW_DLV_NO_ENTRY
to
indicate
end
of
debug_info
section
and
reset
de_cu_debug_info_offset
to
enable
looping
back
through
the
cu
s
section_size
secdp
dss_size
if
new_offset
_dwarf_length_of_cu_header_simple
dbg
is_info
section_size
dis
de_cu_context
NULL
return
DW_DLV_NO_ENTRY
Check
if
this
CU
has
been
read
before
cu_context
_dwarf_find_CU_Context
dbg
new_offset
is_info
If
not
make
CU
Context
for
it
if
cu_context
res
_dwarf_create_a_new_cu_context_record_on_list
dbg
dis
is_info
section_size
new_offset
error
if
res
DW_DLV_OK
return
res
Next
assignment
is
what
makes
_dwarf_next_cu_header
with
no
offset
presented
work
to
march
through
all
the
CUs
in
order
Other
places
creating
a
cu_context
do
not
set
de_cu_context
dis
de_cu_context
cu_context
if
cu_header_length
cu_header_length
cu_context
cc_length
if
version_stamp
version_stamp
cu_context
cc_version_stamp
if
abbrev_offset
abbrev_offset
cu_context
cc_abbrev_offset
if
address_size
address_size
cu_context
cc_address_size
if
offset_size
offset_size
cu_context
cc_length_size
if
extension_size
extension_size
cu_context
cc_extension_size
if
header_type
header_type
cu_context
cc_unit_type
if
typeoffset
typeoffset
cu_context
cc_signature_offset
if
signature_out
signature_out
cu_context
cc_signature
if
has_signature
has_signature
cu_context
cc_signature_present
Determine
the
offset
of
the
next
CU
new_offset
new_offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
Allowing
null
argument
starting
April
if
next_cu_offset
next_cu_offset
new_offset
Dwarf_Debug
tieddbg
int
tres
tieddbg
dbg
de_tied_data
td_tied_object
if
tieddbg
tres
_dwarf_merge_all_base_attrs_of_cu_die
dbg
cu_context
tieddbg
error
if
tres
DW_DLV_ERROR
We
ll
assume
any
errors
will
be
discovered
later
Lets
get
our
CU_context
finished
dwarf_dealloc_error
dbg
error
error
return
DW_DLV_OK
This
involves
data
in
a
split
dwarf
or
package
file
Given
hash
signature
return
the
CU_die
of
the
applicable
CU
The
hash
is
assumed
to
be
from
somewhere
For
DWARF
From
a
skeleton
DIE
DW_AT_GNU_dwo_id
cu
case
or
From
a
DW_FORM_ref_sig8
tu
case
For
DWARF5
From
dwo_id
in
a
skeleton
CU
header
DW_UT_skeleton
From
a
DW_FORM_ref_sig8
tu
case
If
tu
request
the
CU_die
of
of
the
type
unit
Works
on
either
a
dwp
package
file
or
a
dwo
object
If
cu
request
the
CU_die
of
the
compilation
unit
Works
on
either
a
dwp
package
file
or
a
dwo
object
If
the
hash
passed
is
not
present
returns
DW_DLV_NO_ENTRY
but
read
the
next
two
paragraphs
for
more
detail
If
a
dwp
package
file
with
the
hash
signature
is
present
in
the
applicable
index
but
no
matching
compilation
unit
can
be
found
it
returns
DW_DLV_ERROR
If
a
dwo
object
there
is
no
index
and
we
look
at
the
compilation
units
possibly
all
of
them
If
not
present
then
we
return
DW_DLV_NO_ENTRY
The
returned_die
is
a
CU
DIE
if
the
sig_type
is
cu
The
returned_die
is
a
type
DIE
if
the
sig_type
is
tu
Perhaps
both
should
return
CU
die
New
April
int
dwarf_die_from_hash_signature
Dwarf_Debug
dbg
Dwarf_Sig8
hash_sig
const
char
sig_type
tu
or
cu
Dwarf_Die
returned_die
Dwarf_Error
error
Dwarf_Bool
is_type_unit
FALSE
int
sres
sres
_dwarf_load_debug_info
dbg
error
if
sres
DW_DLV_ERROR
return
sres
sres
_dwarf_load_debug_types
dbg
error
if
sres
DW_DLV_ERROR
return
sres
if
strcmp
sig_type
tu
is_type_unit
TRUE
else
if
strcmp
sig_type
cu
is_type_unit
FALSE
else
_dwarf_error
dbg
error
DW_DLE_SIG_TYPE_WRONG_STRING
return
DW_DLV_ERROR
if
_dwarf_file_has_debug_fission_index
dbg
This
is
a
dwp
package
file
int
fisres
Dwarf_Bool
is_info2
Dwarf_Off
cu_header_off
Dwarf_Off
cu_size
Dwarf_Off
cu_die_off
Dwarf_Off
typeoffset
Dwarf_Die
cudie
Dwarf_Die
typedie
Dwarf_CU_Context
context
Dwarf_Debug_Fission_Per_CU
fiss
memset
sizeof
fiss
fisres
dwarf_get_debugfission_for_key
dbg
hash_sig
sig_type
error
if
fisres
DW_DLV_OK
return
fisres
Found
it
if
is_type_unit
DW4
has
debug_types
so
look
in
debug_types
Else
look
in
debug_info
is_info2
dbg
de_debug_types
dss_size?FALSE
TRUE
else
is_info2
TRUE
cu_header_off
_dwarf_get_dwp_extra_offset
is_info2?DW_SECT_INFO
DW_SECT_TYPES
fisres
dwarf_get_cu_die_offset_given_cu_header_offset_b
dbg
cu_header_off
is_info2
error
if
fisres
DW_DLV_OK
return
fisres
fisres
dwarf_offdie_b
dbg
cu_die_off
is_info2
error
if
fisres
DW_DLV_OK
return
fisres
if
is_type_unit
returned_die
cudie
return
DW_DLV_OK
context
cudie
di_cu_context
typeoffset
context
cc_signature_offset
typeoffset
cu_header_off
fisres
dwarf_offdie_b
dbg
typeoffset
is_info2
error
if
fisres
DW_DLV_OK
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
return
fisres
returned_die
typedie
dwarf_dealloc
dbg
cudie
DW_DLA_DIE
return
DW_DLV_OK
Look
thru
all
the
CUs
there
is
no
DWP
tu
cu
index
There
will
be
COMDAT
sections
for
the
type
TUs
DW_UT_type
A
single
non
comdat
for
the
DW_UT_compile
FIXME
DW_DLE_DEBUG_FISSION_INCOMPLETE
_dwarf_error
dbg
error
DW_DLE_DEBUG_FISSION_INCOMPLETE
return
DW_DLV_ERROR
static
int
dwarf_ptr_CU_offset
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
di_ptr
Dwarf_Bool
is_info
Dwarf_Off
cu_off
Dwarf_Debug
dbg
cu_context
cc_dbg
Dwarf_Small
dataptr
is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
cu_off
di_ptr
dataptr
return
DW_DLV_OK
if
FOR
DEBUGGING
Just
for
debug
purposes
void
print_sib_offset
Dwarf_Die
sibling
Dwarf_Off
sib_off
Dwarf_Error
error
dwarf_dieoffset
sibling
fprintf
stderr
SIB
OFF
DW_PR_XZEROS
DW_PR_DUx
sib_off
void
print_ptr_offset
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
di_ptr
Dwarf_Off
ptr_off
dwarf_ptr_CU_offset
cu_context
di_ptr
fprintf
stderr
PTR
OFF
DW_PR_XZEROS
DW_PR_DUx
ptr_off
endif
Validate
the
sibling
DIE
This
only
makes
sense
to
call
if
the
sibling
s
DIEs
have
been
travsersed
and
dwarf_child
called
on
each
so
that
the
last
DIE
dwarf_child
saw
was
the
last
Essentially
ensuring
that
after
such
traversal
that
we
are
in
the
same
place
a
sibling
attribute
would
identify
In
case
we
return
DW_DLV_ERROR
the
global
offset
of
the
last
DIE
traversed
by
dwarf_child
is
returned
through
offset
It
is
essentially
guaranteed
that
dbg
de_last_die
is
a
stale
DIE
pointer
of
a
deallocated
DIE
when
we
get
here
It
must
not
be
used
as
a
DIE
pointer
here
just
as
a
sort
of
anonymous
pointer
that
we
just
check
against
NULL
There
is
a
subtle?
dependence
on
the
fact
that
when
we
call
this
the
last
dwarf_child
call
would
have
been
for
this
sibling
Meaning
that
this
works
in
a
depth
first
traversal
even
though
there
is
no
stack
of
de_last_die
values
The
check
for
dbg
de_last_die
just
ensures
sanity
If
one
is
switching
between
normal
debug_frame
and
eh_frame
traversing
them
in
tandem
let
us
say
in
a
single
Dwarf_Debug
this
validator
makes
no
sense
It
works
if
one
processes
a
debug_frame
entirely
and
then
an
eh_frame
or
vice
versa
though
Use
caution
int
dwarf_validate_die_sibling
Dwarf_Die
sibling
Dwarf_Off
offset
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Debug_InfoTypes
dis
CHECK_DIE
sibling
DW_DLV_ERROR
dbg
sibling
di_cu_context
cc_dbg
dis
sibling
di_is_info?
de_info_reading
de_types_reading
offset
if
dis
de_last_die
dis
de_last_di_ptr
if
sibling
di_debug_ptr
dis
de_last_di_ptr
return
DW_DLV_OK
Calculate
global
offset
used
for
error
reporting
dwarf_ptr_CU_offset
sibling
di_cu_context
dis
de_last_di_ptr
sibling
di_is_info
offset
return
DW_DLV_ERROR
This
function
does
two
slightly
different
things
depending
on
the
input
flag
want_AT_sibling
If
this
flag
is
true
it
checks
if
the
input
die
has
a
DW_AT_sibling
attribute
If
it
does
it
returns
a
pointer
to
the
start
of
the
sibling
die
in
the
debug_info
section
Otherwise
it
behaves
the
same
as
the
want_AT_sibling
false
case
If
the
want_AT_sibling
flag
is
false
it
returns
a
pointer
to
the
immediately
adjacent
die
in
the
debug_info
section
Die_info_end
points
to
the
end
of
the
debug_info
portion
for
the
cu
the
die
belongs
to
It
is
used
to
check
that
the
search
for
the
next
die
does
not
cross
the
end
of
the
current
cu
Cu_info_start
points
to
the
start
of
the
debug_info
portion
for
the
current
cu
and
is
used
to
add
to
the
offset
for
DW_AT_sibling
attributes
Finally
has_die_child
is
a
pointer
to
a
Dwarf_Bool
that
is
set
true
if
the
present
die
has
children
false
otherwise
However
in
case
want_AT_child
is
true
and
the
die
has
a
DW_AT_sibling
attribute
has_die_child
is
set
false
to
indicate
that
the
children
are
being
skipped
die_info_end
points
to
the
last
byte
of
the
cu
static
int
_dwarf_next_die_info_ptr
Dwarf_Byte_Ptr
die_info_ptr
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
die_info_end
Dwarf_Byte_Ptr
cu_info_start
Dwarf_Bool
want_AT_sibling
Dwarf_Bool
has_die_child
Dwarf_Byte_Ptr
next_die_ptr_out
Dwarf_Error
error
Dwarf_Byte_Ptr
info_ptr
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Unsigned
abbrev_code
Dwarf_Abbrev_List
abbrev_list
Dwarf_Half
attr
Dwarf_Half
attr_form
Dwarf_Unsigned
offset
Dwarf_Unsigned
utmp
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
abbrev_end
int
lres
Dwarf_Unsigned
highest_code
dbg
cu_context
cc_dbg
info_ptr
die_info_ptr
DECODE_LEB128_UWORD_CK
info_ptr
utmp
dbg
error
die_info_end
abbrev_code
Dwarf_Unsigned
utmp
if
abbrev_code
Should
never
happen
Tested
before
we
got
here
_dwarf_error
dbg
error
DW_DLE_NEXT_DIE_PTR_NULL
return
DW_DLV_ERROR
lres
_dwarf_get_abbrev_for_code
cu_context
abbrev_code
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_NEXT_DIE_NO_ABBREV_LIST
There
is
no
abbrev
present
for
code
u
in
this
compilation
unit
abbrev_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_NEXT_DIE_NO_ABBREV_LIST
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
dbg
cu_context
cc_dbg
has_die_child
abbrev_list
abl_has_child
abbrev_ptr
abbrev_list
abl_abbrev_ptr
abbrev_end
_dwarf_calculate_abbrev_section_end_ptr
cu_context
do
Dwarf_Unsigned
utmp2
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp2
dbg
error
abbrev_end
if
utmp2
DW_AT_hi_user
_dwarf_error
dbg
error
DW_DLE_ATTR_CORRUPT
return
DW_DLV_ERROR
attr
Dwarf_Half
utmp2
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp2
dbg
error
abbrev_end
if
_dwarf_valid_form_we_know
utmp2
attr
_dwarf_error
dbg
error
DW_DLE_UNKNOWN_FORM
return
DW_DLV_ERROR
attr_form
Dwarf_Half
utmp2
if
attr_form
DW_FORM_indirect
Dwarf_Unsigned
utmp6
DECODE_LEB128_UWORD
updates
info_ptr
DECODE_LEB128_UWORD_CK
info_ptr
utmp6
dbg
error
die_info_end
attr_form
Dwarf_Half
utmp6
if
attr_form
DW_FORM_implicit_const
UNUSEDARG
Dwarf_Signed
cval
DECODE_LEB128_SWORD_CK
abbrev_ptr
cval
dbg
error
abbrev_end
if
want_AT_sibling
attr
DW_AT_sibling
switch
attr_form
case
DW_FORM_ref1
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
info_ptr
sizeof
Dwarf_Small
error
die_info_end
break
case
DW_FORM_ref2
READ_UNALIGNED
does
not
update
info_ptr
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
info_ptr
DWARF_HALF_SIZE
error
die_info_end
break
case
DW_FORM_ref4
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
info_ptr
DWARF_32BIT_SIZE
error
die_info_end
break
case
DW_FORM_ref8
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
info_ptr
DWARF_64BIT_SIZE
error
die_info_end
break
case
DW_FORM_ref_udata
DECODE_LEB128_UWORD_CK
info_ptr
offset
dbg
error
die_info_end
break
case
DW_FORM_ref_addr
Very
unusual
The
FORM
is
intended
to
refer
to
a
different
CU
but
a
different
CU
cannot
be
a
sibling
can
it?
We
could
ignore
this
and
treat
as
if
no
DW_AT_sibling
present
Or
derive
the
offset
from
it
and
if
it
is
in
the
same
CU
use
it
directly
The
offset
here
is
supposed
to
be
a
global
offset
so
adding
cu_info_start
is
wrong
to
any
offset
we
find
here
unless
cu_info_start
is
zero
Lets
pretend
there
is
no
DW_AT_sibling
attribute
goto
no_sibling_attr
default
_dwarf_error
dbg
error
DW_DLE_NEXT_DIE_WRONG_FORM
return
DW_DLV_ERROR
Reset
has_die_child
to
indicate
children
skipped
has_die_child
false
A
value
beyond
die_info_end
indicates
an
error
Exactly
at
die_info_end
means
past
cu
end
and
simply
means
we
are
at
the
end
do
not
return
error
Higher
level
will
detect
that
we
are
at
the
end
Care
required
here
Offset
can
be
garbage
Dwarf_Unsigned
plen
ptrdiff_t
is
generated
but
not
named
plen
die_info_end
cu_info_start
die_info_end
cu_info_start
if
offset
plen
Error
case
bad
DWARF
_dwarf_error
dbg
error
DW_DLE_SIBLING_OFFSET_WRONG
return
DW_DLV_ERROR
At
or
before
end
of
cu
next_die_ptr_out
cu_info_start
offset
return
DW_DLV_OK
no_sibling_attr
if
attr_form
attr_form
DW_FORM_implicit_const
int
res
Dwarf_Unsigned
sizeofval
Dwarf_Unsigned
ssize
res
_dwarf_get_size_of_val
cu_context
cc_dbg
attr_form
cu_context
cc_version_stamp
cu_context
cc_address_size
info_ptr
cu_context
cc_length_size
die_info_end
error
if
res
DW_DLV_OK
return
res
It
is
ok
for
info_ptr
die_info_end
as
we
will
test
later
before
using
a
too
large
info_ptr
ptrdiff_t
is
generated
but
not
named
ssize
die_info_end
info_ptr
die_info_end
info_ptr
if
sizeofval
ssize
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_NEXT_DIE_PAST_END
the
DIE
value
just
checked
is
u
bytes
long
and
that
would
extend
past
the
end
of
the
section
sizeofval
_dwarf_error_string
dbg
error
DW_DLE_NEXT_DIE_PAST_END
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
info_ptr
sizeofval
if
info_ptr
die_info_end
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_NEXT_DIE_PAST_END
the
DIE
value
just
checked
is
u
bytes
long
and
puts
us
past
the
end
of
the
section
sizeofval
dwarfstring_append_printf_u
which
is
x
Dwarf_Unsigned
uintptr_t
die_info_end
_dwarf_error_string
dbg
error
DW_DLE_NEXT_DIE_PAST_END
dwarfstring_string
dwarfstring_destructor
More
than
one
past
end
indicates
a
bug
somewhere
likely
bad
dwarf
generation
return
DW_DLV_ERROR
while
attr
attr_form
next_die_ptr_out
info_ptr
return
DW_DLV_OK
Multiple
TAGs
are
in
fact
compile
units
Allow
them
all
Return
non
zero
if
a
CU
tag
Else
return
static
int
is_cu_tag
int
t
if
t
DW_TAG_compile_unit
t
DW_TAG_partial_unit
t
DW_TAG_skeleton_unit
t
DW_TAG_type_unit
return
return
Given
a
Dwarf_Debug
dbg
and
a
Dwarf_Die
die
it
returns
a
Dwarf_Die
for
the
sibling
of
die
In
case
die
is
NULL
it
returns
thru
ptr
a
Dwarf_Die
for
the
first
die
in
the
current
cu
in
dbg
Returns
DW_DLV_ERROR
on
error
It
is
assumed
that
every
sibling
chain
including
those
with
only
one
element
is
terminated
with
a
NULL
die
except
a
chain
with
only
a
NULL
die
The
algorithm
moves
from
one
die
to
the
adjacent
one
It
returns
when
the
depth
of
children
it
sees
equals
the
number
of
sibling
chain
terminations
A
single
count
child_depth
is
used
to
track
the
depth
of
children
and
sibling
terminations
encountered
Child_depth
is
incremented
when
a
die
has
the
Has
Child
flag
set
unless
the
child
happens
to
be
a
NULL
die
Child_depth
is
decremented
when
a
die
has
Has
Child
false
and
the
adjacent
die
is
NULL
Algorithm
returns
when
child_depth
is
NOTE
Do
not
modify
input
die
since
it
is
used
at
the
end
This
is
the
correct
form
On
calling
with
die
NULL
we
cannot
tell
if
this
is
debug_info
or
debug_types
so
we
must
be
informed
int
dwarf_siblingof_b
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Bool
is_info
Dwarf_Die
caller_ret_die
Dwarf_Error
error
int
res
Dwarf_Debug_InfoTypes
dis
dis
is_info?
de_info_reading
de_types_reading
res
_dwarf_siblingof_internal
dbg
die
die?die
di_cu_context
dis
de_cu_context
is_info
caller_ret_die
error
return
res
static
int
_dwarf_siblingof_internal
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_CU_Context
context
Dwarf_Bool
is_info
Dwarf_Die
caller_ret_die
Dwarf_Error
error
Dwarf_Die
ret_die
Dwarf_Byte_Ptr
die_info_ptr
Dwarf_Byte_Ptr
cu_info_start
die_info_end
points
past
end
of
die
once
set
Dwarf_Byte_Ptr
die_info_end
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
utmp
Dwarf_Unsigned
highest_code
int
lres
int
dieres
Since
die
may
be
NULL
we
rely
on
the
input
argument
Dwarf_Small
dataptr
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
dataptr
is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
if
die
NULL
Find
root
die
of
cu
die_info_end
is
untouched
here
need
not
be
set
in
this
branch
Dwarf_Off
off2
Dwarf_Unsigned
headerlen
int
cres
If
we
ve
not
loaded
debug_info
context
will
be
NULL
if
context
local_dealloc_cu_context
dbg
context
return
DW_DLV_ERROR
off2
context
cc_debug_offset
cu_info_start
dataptr
off2
cres
_dwarf_length_of_cu_header
dbg
off2
is_info
error
if
cres
DW_DLV_OK
return
cres
die_info_ptr
cu_info_start
headerlen
die_info_end
_dwarf_calculate_info_section_end_ptr
context
Recording
the
CU
die
pointer
so
we
can
later
access
for
special
FORMs
relating
to
debug_str_offsets
and
debug_addr
context
cc_cu_die_offset_present
TRUE
context
cc_cu_die_global_sec_offset
off2
headerlen
else
Find
sibling
die
Dwarf_Bool
has_child
false
Dwarf_Signed
child_depth
We
cannot
have
a
legal
die
unless
debug_info
was
loaded
so
no
need
to
load
debug_info
here
CHECK_DIE
die
DW_DLV_ERROR
die_info_ptr
die
di_debug_ptr
if
die_info_ptr
return
DW_DLV_NO_ENTRY
context
die
di_cu_context
cu_info_start
dataptr
context
cc_debug_offset
die_info_end
_dwarf_calculate_info_section_end_ptr
context
if
die_info_ptr
return
DW_DLV_NO_ENTRY
child_depth
do
int
res2
Dwarf_Byte_Ptr
die_info_ptr2
res2
_dwarf_next_die_info_ptr
die_info_ptr
context
die_info_end
cu_info_start
true
error
if
res2
DW_DLV_OK
return
res2
if
die_info_ptr2
die_info_ptr
There
is
something
very
wrong
our
die
value
decreased
Bad
DWARF
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_NEXT_DIE_LOW_ERROR
Somehow
the
next
die
pointer
x
Dwarf_Unsigned
uintptr_t
die_info_ptr2
dwarfstring_append_printf_u
points
before
the
current
die
pointer
x
so
an
overflow
of
some
sort
happened
Dwarf_Unsigned
uintptr_t
die_info_ptr
_dwarf_error_string
dbg
error
DW_DLE_NEXT_DIE_LOW_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
die_info_ptr2
die_info_end
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_NEXT_DIE_PAST_END
the
next
DIE
at
x
Dwarf_Unsigned
uintptr_t
die_info_ptr2
dwarfstring_append_printf_u
would
be
past
the
end
of
the
section
x
which
is
an
error
Dwarf_Unsigned
uintptr_t
die_info_end
_dwarf_error_string
dbg
error
DW_DLE_NEXT_DIE_PAST_END
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
die_info_ptr
die_info_ptr2
die_info_end
is
one
past
end
Do
not
read
it
A
test
for
die_info_end
would
work
as
well
but
perhaps
reads
more
like
the
meaning
if
die_info_ptr
die_info_end
if
die_info_ptr
has_child
die_info_ptr
has_child
false
die_info_ptr
can
be
one
past
end
if
die_info_ptr
die_info_end
die_info_ptr
We
are
at
the
end
of
a
sibling
list
get
back
to
the
next
containing
sibling
list
looking
for
a
libling
list
with
more
on
it
for
if
child_depth
Meaning
there
is
no
outer
list
so
stop
break
if
die_info_ptr
die_info_end
September
do
not
deref
if
we
are
past
end
If
we
are
at
end
at
this
point
it
means
the
sibling
list
inside
this
CU
is
not
properly
terminated
August
We
used
to
declare
an
error
DW_DLE_SIBLING_LIST_IMPROPER
but
now
we
just
silently
declare
this
is
the
end
of
the
list
Each
level
of
a
sibling
nest
should
have
a
single
NUL
byte
but
here
things
are
wrong
the
DWARF
is
corrupt
return
DW_DLV_NO_ENTRY
if
die_info_ptr
We
have
a
real
sibling
break
Move
out
one
DIE
level
Move
past
NUL
byte
marking
end
of
this
sibling
list
child_depth
die_info_ptr
else
child_depth
has_child
child_depth
child_depth
while
child_depth
die_info_ptr
die_info_end
is
really
a
bug
possibly
in
dwarf
generation
but
we
are
past
end
no
more
DIEs
here
whereas
die_info_ptr
die_info_end
means
one
past
end
no
more
DIEs
here
if
die_info_ptr
die_info_end
return
DW_DLV_NO_ENTRY
if
die_info_ptr
return
DW_DLV_NO_ENTRY
ret_die
Dwarf_Die
_dwarf_get_alloc
dbg
DW_DLA_DIE
if
ret_die
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
ret_die
di_is_info
is_info
ret_die
di_debug_ptr
die_info_ptr
ret_die
di_cu_context
die
NULL
context
die
di_cu_context
dieres
_dwarf_leb128_uword_wrapper
dbg
die_info_end
error
if
dieres
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
return
dieres
if
die_info_ptr
die_info_end
We
managed
to
go
past
the
end
of
the
CU
Something
is
badly
wrong
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
_dwarf_error
dbg
error
DW_DLE_ABBREV_DECODE_ERROR
return
DW_DLV_ERROR
abbrev_code
Dwarf_Unsigned
utmp
if
abbrev_code
Zero
means
a
null
DIE
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
return
DW_DLV_NO_ENTRY
ret_die
di_abbrev_code
abbrev_code
lres
_dwarf_get_abbrev_for_code
ret_die
di_cu_context
abbrev_code
di_abbrev_list
error
if
lres
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DIE_ABBREV_LIST_NULL
There
is
no
abbrev
present
for
code
u
in
this
compilation
unit
abbrev_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_DIE_ABBREV_LIST_NULL
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
die
NULL
is_cu_tag
ret_die
di_abbrev_list
abl_tag
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
_dwarf_error
dbg
error
DW_DLE_FIRST_DIE_NOT_CU
return
DW_DLV_ERROR
caller_ret_die
ret_die
return
DW_DLV_OK
int
dwarf_child
Dwarf_Die
die
Dwarf_Die
caller_ret_die
Dwarf_Error
error
Dwarf_Byte_Ptr
die_info_ptr
Dwarf_Byte_Ptr
die_info_ptr2
die_info_end
points
one
past
end
of
die
area
Dwarf_Byte_Ptr
die_info_end
Dwarf_Die
ret_die
Dwarf_Bool
has_die_child
Dwarf_Debug
dbg
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
utmp
Dwarf_Debug_InfoTypes
dis
int
res
Dwarf_CU_Context
context
int
lres
Dwarf_Unsigned
highest_code
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
dis
die
di_is_info?
de_info_reading
de_types_reading
die_info_ptr
die
di_debug_ptr
We
are
saving
a
DIE
pointer
here
but
the
pointer
will
not
be
presumed
live
later
when
it
is
tested
dis
de_last_die
die
dis
de_last_di_ptr
die_info_ptr
NULL
die
has
no
child
if
die_info_ptr
return
DW_DLV_NO_ENTRY
context
die
di_cu_context
die_info_end
_dwarf_calculate_info_section_end_ptr
context
res
_dwarf_next_die_info_ptr
die_info_ptr
die
di_cu_context
die_info_end
NULL
false
error
if
res
DW_DLV_OK
return
res
if
die_info_ptr
die_info_end
return
DW_DLV_NO_ENTRY
die_info_ptr
die_info_ptr2
dis
de_last_di_ptr
die_info_ptr
if
has_die_child
Look
for
end
of
sibling
chain
while
dis
de_last_di_ptr
die_info_end
if
dis
de_last_di_ptr
break
dis
de_last_di_ptr
return
DW_DLV_NO_ENTRY
ret_die
Dwarf_Die
_dwarf_get_alloc
dbg
DW_DLA_DIE
if
ret_die
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
ret_die
di_debug_ptr
die_info_ptr
ret_die
di_cu_context
die
di_cu_context
ret_die
di_is_info
die
di_is_info
DECODE_LEB128_UWORD_CK
die_info_ptr
utmp
dbg
error
die_info_end
abbrev_code
Dwarf_Unsigned
utmp
dis
de_last_di_ptr
die_info_ptr
if
abbrev_code
Look
for
end
of
sibling
chain
while
dis
de_last_di_ptr
die_info_end
if
dis
de_last_di_ptr
break
dis
de_last_di_ptr
We
have
arrived
at
a
null
DIE
at
the
end
of
a
CU
or
the
end
of
a
list
of
siblings
caller_ret_die
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
ret_die
return
DW_DLV_NO_ENTRY
ret_die
di_abbrev_code
abbrev_code
lres
_dwarf_get_abbrev_for_code
die
di_cu_context
abbrev_code
di_abbrev_list
error
if
lres
DW_DLV_ERROR
dwarf_dealloc
dbg
ret_die
DW_DLA_DIE
ret_die
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarfstring_constructor
dwarf_dealloc_die
ret_die
ret_die
dwarfstring_append_printf_u
DW_DLE_ABBREV_MISSING
the
abbrev
code
not
found
in
dwarf_child
is
u
abbrev_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_ABBREV_MISSING
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
caller_ret_die
ret_die
return
DW_DLV_OK
Given
a
global
not
cu_relative
die
offset
this
returns
a
pointer
to
a
DIE
thru
new_die
It
is
up
to
the
caller
to
do
a
dwarf_dealloc
dbg
new_die
DW_DLE_DIE
The
old
form
only
works
with
debug_info
The
new
_b
form
works
with
debug_info
or
debug_types
int
dwarf_offdie_b
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Die
new_die
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Small
dataptr
Dwarf_Off
new_cu_offset
Dwarf_Die
die
Dwarf_Byte_Ptr
info_ptr
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
utmp
int
lres
Dwarf_Debug_InfoTypes
dis
Dwarf_Byte_Ptr
die_info_end
Dwarf_Unsigned
highest_code
struct
Dwarf_Section_s
secdp
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
is_info
dis
de_info_reading
secdp
de_debug_info
dataptr
dbg
de_debug_info
dss_data
else
dis
de_types_reading
secdp
de_debug_types
dataptr
dbg
de_debug_types
dss_data
if
dataptr
lres
_dwarf_load_die_containing_section
dbg
is_info
error
if
lres
DW_DLV_OK
return
lres
cu_context
_dwarf_find_CU_Context
dbg
offset
is_info
if
cu_context
NULL
Dwarf_Unsigned
section_size
if
dis
de_cu_context_list_end
NULL
new_cu_offset
_dwarf_calculate_next_cu_context_offset
dis
de_cu_context_list_end
Else
new_cu_offset
remains
no
CUs
on
list
a
fresh
section
setup
section_size
secdp
dss_size
do
lres
_dwarf_create_a_new_cu_context_record_on_list
dbg
dis
is_info
section_size
new_cu_offset
error
if
lres
DW_DLV_OK
return
lres
new_cu_offset
_dwarf_calculate_next_cu_context_offset
cu_context
Not
setting
dis
de_cu_context
leave
that
unchanged
while
offset
new_cu_offset
We
have
a
cu_context
for
this
offset
die_info_end
_dwarf_calculate_info_section_end_ptr
cu_context
die
Dwarf_Die
_dwarf_get_alloc
dbg
DW_DLA_DIE
if
die
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
die
di_cu_context
cu_context
die
di_is_info
is_info
dataptr
above
might
be
stale
if
we
loaded
a
section
above
So
access
dss_data
here
if
is_info
info_ptr
offset
dbg
de_debug_info
dss_data
else
info_ptr
offset
dbg
de_debug_types
dss_data
die
di_debug_ptr
info_ptr
lres
_dwarf_leb128_uword_wrapper
dbg
die_info_end
error
if
lres
DW_DLV_OK
dwarf_dealloc_die
die
return
lres
abbrev_code
utmp
if
abbrev_code
we
are
at
a
null
DIE
or
there
is
a
bug
dwarf_dealloc_die
die
die
return
DW_DLV_NO_ENTRY
die
di_abbrev_code
abbrev_code
lres
_dwarf_get_abbrev_for_code
cu_context
abbrev_code
di_abbrev_list
error
if
lres
DW_DLV_ERROR
dwarf_dealloc_die
die
die
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarf_dealloc_die
die
die
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DIE_ABBREV_LIST_NULL
There
is
no
abbrev
present
for
code
u
in
this
compilation
unit
when
calling
dwarf_offdie_b
abbrev_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_DIE_ABBREV_LIST_NULL
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
new_die
die
return
DW_DLV_OK
New
March
Lets
one
cross
check
the
abbreviations
section
and
the
DIE
information
presented
by
dwarfdump
i
G
v
int
dwarf_die_abbrev_global_offset
Dwarf_Die
die
Dwarf_Off
abbrev_goffset
Dwarf_Unsigned
abbrev_count
Dwarf_Error
error
Dwarf_Abbrev_List
dal
Dwarf_Debug
dbg
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
dal
die
di_abbrev_list
if
dal
_dwarf_error
dbg
error
DW_DLE_DWARF_ABBREV_NULL
return
DW_DLV_ERROR
abbrev_goffset
dal
abl_goffset
abbrev_count
dal
abl_count
return
DW_DLV_OK
New
August
Because
some
real
compressed
sections
have
zdebug
instead
of
debug
as
the
leading
characters
actual_sec_name_out
points
to
a
static
string
so
so
not
free
it
int
dwarf_get_real_section_name
Dwarf_Debug
dbg
const
char
std_section_name
const
char
actual_sec_name_out
Dwarf_Small
marked_zcompressed
zdebug
Dwarf_Small
marked_zlib_compressed
ZLIB
string
Dwarf_Small
marked_shf_compressed
SHF_COMPRESSED
Dwarf_Unsigned
compressed_length
Dwarf_Unsigned
uncompressed_length
Dwarf_Error
error
unsigned
i
char
tbuf
unsigned
std_sec_name_len
strlen
std_section_name
tbuf
std_section_name
never
has
the
dwo
on
the
end
so
allow
for
that
and
allow
one
arbitrarily
more
if
std_sec_name_len
sizeof
tbuf
strcpy
tbuf
std_section_name
strcpy
tbuf
std_sec_name_len
dwo
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
for
i
i
dbg
de_debug_sections_total_entries
i
struct
Dwarf_dbg_sect_s
sdata
de_debug_sections
i
struct
Dwarf_Section_s
section
sdata
ds_secdata
const
char
std
section
dss_standard_name
if
strcmp
std
std_section_name
strcmp
std
tbuf
const
char
used
section
dss_name
actual_sec_name_out
used
if
sdata
ds_have_zdebug
marked_zcompressed
TRUE
if
section
dss_ZLIB_compressed
marked_zlib_compressed
TRUE
if
uncompressed_length
uncompressed_length
section
dss_uncompressed_length
if
compressed_length
compressed_length
section
dss_compressed_length
if
section
dss_shf_compressed
marked_shf_compressed
TRUE
if
uncompressed_length
uncompressed_length
section
dss_uncompressed_length
if
compressed_length
compressed_length
section
dss_compressed_length
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
This
is
useful
when
printing
DIE
data
The
string
pointer
returned
must
not
be
freed
With
non
elf
objects
it
is
possible
the
string
returned
might
be
empty
or
NULL
so
callers
should
be
prepared
for
that
kind
of
return
int
dwarf_get_die_section_name
Dwarf_Debug
dbg
Dwarf_Bool
is_info
const
char
sec_name
Dwarf_Error
error
struct
Dwarf_Section_s
sec
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
is_info
sec
de_debug_info
else
sec
de_debug_types
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
sec_name
sec
dss_name
return
DW_DLV_OK
This
one
assumes
is_info
not
known
to
caller
but
a
DIE
is
known
int
dwarf_get_die_section_name_b
Dwarf_Die
die
const
char
sec_name
Dwarf_Error
error
Dwarf_CU_Context
context
Dwarf_Bool
is_info
Dwarf_Debug
dbg
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dbg
context
cc_dbg
is_info
context
cc_is_info
return
dwarf_get_die_section_name
dbg
is_info
sec_name
error
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_dsc
h
When
called
with
ary
and
arraycount
this
just
counts
the
elements
found
Otherwise
it
records
the
values
in
ary
and
recounts
The
arraycount
pointer
must
be
passed
in
non
null
always
static
int
get_dsc_leb_entries
Dwarf_Debug
dbg
Dwarf_Small
blockpointer
Dwarf_Unsigned
blocklen
int
dounsigned
struct
Dwarf_Dsc_Entry_s
ary
size_t
arraycount
Dwarf_Error
error
Dwarf_Small
p
blockpointer
Dwarf_Small
endp
blockpointer
blocklen
size_t
larraycount
size_t
iarraycount
arraycount
if
ary
if
iarraycount
Internal
botch
calling
this
static
function
_dwarf_error
dbg
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
else
if
iarraycount
Internal
botch
calling
this
static
function
_dwarf_error
dbg
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
if
dounsigned
while
p
endp
Dwarf_Unsigned
dsc
Dwarf_Unsigned
low
Dwarf_Unsigned
high
Dwarf_Unsigned
leblen
UNUSEDARG
if
ary
larraycount
iarraycount
_dwarf_error
dbg
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_LEN_CK
p
dsc
leblen
dbg
error
endp
if
dsc
DECODE_LEB128_UWORD_LEN_CK
p
low
leblen
dbg
error
endp
else
DECODE_LEB128_UWORD_LEN_CK
p
low
leblen
dbg
error
endp
DECODE_LEB128_UWORD_LEN_CK
p
high
leblen
dbg
error
endp
if
ary
struct
Dwarf_Dsc_Entry_s
arye
ary
larraycount
type
reads
the
same
as
uleb
and
leb
because
it
is
only
zero
or
one
arye
dsc_type
dsc
arye
dsc_low_u
low
arye
dsc_high_u
high
larraycount
else
while
p
endp
Dwarf_Signed
dsc
Dwarf_Signed
low
Dwarf_Signed
high
Dwarf_Unsigned
leblen
UNUSEDARG
if
ary
larraycount
iarraycount
_dwarf_error
dbg
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
DECODE_LEB128_SWORD_LEN_CK
p
dsc
leblen
dbg
error
endp
if
dsc
DECODE_LEB128_SWORD_LEN_CK
p
low
leblen
dbg
error
endp
else
DECODE_LEB128_SWORD_LEN_CK
p
low
leblen
dbg
error
endp
DECODE_LEB128_SWORD_LEN_CK
p
high
leblen
dbg
error
endp
if
ary
struct
Dwarf_Dsc_Entry_s
arye
ary
larraycount
type
reads
the
same
as
uleb
and
leb
because
it
is
only
zero
or
one
arye
dsc_type
Dwarf_Unsigned
dsc
arye
dsc_low_s
low
arye
dsc_high_s
high
larraycount
if
ary
Just
verify
this
recount
matches
original
if
iarraycount
larraycount
_dwarf_error
dbg
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
else
This
matters
for
first
call
with
ary
and
iarraycount
as
we
are
generating
the
count
arraycount
larraycount
return
DW_DLV_OK
int
dwarf_discr_list
Dwarf_Debug
dbg
Dwarf_Small
blockpointer
Dwarf_Unsigned
blocklen
Dwarf_Dsc_Head
dsc_head_out
Dwarf_Unsigned
dsc_array_length_out
Dwarf_Error
error
Dwarf_Dsc_Head
h
int
res
size_t
arraycount
struct
Dwarf_Dsc_Entry_s
ary
Dwarf_Small
dscblockp
Dwarf_Unsigned
dscblocklen
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
blocklen
return
DW_DLV_NO_ENTRY
dscblockp
Dwarf_Small
calloc
blocklen
sizeof
Dwarf_Small
if
dscblockp
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dscblocklen
blocklen
memcpy
dscblockp
blockpointer
blocklen
res
get_dsc_leb_entries
dbg
dscblockp
dscblocklen
TRUE
or
FALSE
here
is
not
important
the
arraycount
returned
to
us
will
be
identical
either
way
FALSE
error
if
res
DW_DLV_OK
free
dscblockp
return
res
h
Dwarf_Dsc_Head
_dwarf_get_alloc
dbg
DW_DLA_DSC_HEAD
if
h
free
dscblockp
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
h
dsh_block
dscblockp
h
dsh_block_len
dscblocklen
h
dsh_debug
dbg
Now
the
destructor
for
h
will
deal
with
block
malloc
space
ary
struct
Dwarf_Dsc_Entry_s
calloc
arraycount
sizeof
struct
Dwarf_Dsc_Entry_s
if
ary
dwarf_dealloc
dbg
h
DW_DLA_DSC_HEAD
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
h
dsh_count
arraycount
h
dsh_array
ary
h
dsh_set_unsigned
h
dsh_set_signed
dsc_head_out
h
dsc_array_length_out
arraycount
return
DW_DLV_OK
NEW
September
Allows
easy
access
to
DW_AT_discr_list
entry
Callers
must
know
which
is
the
appropriate
one
of
the
following
two
interfaces
though
both
will
work
int
dwarf_discr_entry_u
Dwarf_Dsc_Head
dsh
Dwarf_Unsigned
entrynum
Dwarf_Half
out_type
Dwarf_Unsigned
out_discr_low
Dwarf_Unsigned
out_discr_high
Dwarf_Error
error
UNUSEDARG
struct
Dwarf_Dsc_Entry_s
dse
if
entrynum
dsh
dsh_count
return
DW_DLV_NO_ENTRY
if
dsh
dsh_set_unsigned
int
res
int
dounsigned
size_t
count
dsh
dsh_count
res
get_dsc_leb_entries
dsh
dsh_debug
dsh
dsh_block
dsh
dsh_block_len
dounsigned
dsh
dsh_array
error
if
res
DW_DLV_OK
return
res
dsh
dsh_set_unsigned
TRUE
if
dsh
dsh_array
_dwarf_error
dsh
dsh_debug
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
dse
dsh
dsh_array
entrynum
out_type
dse
dsc_type
out_discr_low
dse
dsc_low_u
out_discr_high
dse
dsc_high_u
return
DW_DLV_OK
NEW
September
Allows
easy
access
to
DW_AT_discr_list
entry
int
dwarf_discr_entry_s
Dwarf_Dsc_Head
dsh
Dwarf_Unsigned
entrynum
Dwarf_Half
out_type
Dwarf_Signed
out_discr_low
Dwarf_Signed
out_discr_high
Dwarf_Error
error
UNUSEDARG
struct
Dwarf_Dsc_Entry_s
dse
if
entrynum
dsh
dsh_count
return
DW_DLV_NO_ENTRY
if
dsh
dsh_set_signed
int
res
int
dounsigned
size_t
count
dsh
dsh_count
res
get_dsc_leb_entries
dsh
dsh_debug
dsh
dsh_block
dsh
dsh_block_len
dounsigned
dsh
dsh_array
error
if
res
DW_DLV_OK
return
res
dsh
dsh_set_signed
TRUE
if
dsh
dsh_array
_dwarf_error
dsh
dsh_debug
error
DW_DLE_DISCR_ARRAY_ERROR
return
DW_DLV_ERROR
dse
dsh
dsh_array
entrynum
out_type
dse
dsc_type
out_discr_low
dse
dsc_low_s
out_discr_high
dse
dsc_high_s
return
DW_DLV_OK
void
_dwarf_dsc_destructor
void
m
Dwarf_Dsc_Head
h
Dwarf_Dsc_Head
m
free
h
dsh_array
h
dsh_array
free
h
dsh_block
h
dsh_block
h
dsh_count
Copyright
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
reads
elf
headers
and
creates
generic
elf
structures
containing
the
Elf
headers
These
two
enums
used
for
type
safety
in
passing
values
See
dwarf_elfread
h
enum
RelocRela
enum
RelocOffsetSize
dwarf_elfread
c
calls
_dwarf_load_elf_relx
intfc
i
enum
RelocRela
errcode
calls
_dwarf_elf_load_a_relx_batch
ep
enum
RelocRela
enum
RelocOffsetSize
errcode
which
calls
generic_rel_from_rela32
ep
gsh
relp
grel
or
calls
generic_rel_from_rela64
ep
gsh
relp
grel
or
calls
generic_rel_from_rel32
ep
gsh
relp
grel
or
calls
generic_rel_from_rel64
ep
gsh
relp
grel
include
config
h
include
stdio
h
ifdef
HAVE_STRING_H
include
string
h
For
memcpy
etc
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
stddef
h
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
for
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
for
open
ifdef
_WIN32
include
io
h
lseek
read
close
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf_private
h
include
dwarf
h
include
libdwarf
h
include
dwarf_base_types
h
include
dwarf_opaque
h
include
memcpy_swap
h
include
dwarf_elfstructs
h
include
dwarf_reading
h
include
dwarf_elf_defines
h
include
dwarf_elfread
h
include
dwarf_object_detector
h
include
dwarf_object_read_common
h
include
dwarf_util
h
ifndef
O_BINARY
define
O_BINARY
endif
O_BINARY
if
One
example
of
calling
this
place
just
before
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
dumpsizes
__LINE__
strsectlength
strpsh
gh_offset
ep
f_filesize
static
void
dumpsizes
int
line
Dwarf_Unsigned
s
Dwarf_Unsigned
o
Dwarf_Unsigned
fsz
Dwarf_Unsigned
tlen
s
o
printf
Size
Error
DEBUGONLY
sz
llx
off
llx
fsx
llx
sum
llx
line
d
n
s
o
fsz
tlen
line
endif
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
static
int
_dwarf_load_elf_section_is_dwarf
const
char
sname
int
is_rela
int
is_rel
is_rel
FALSE
is_rela
FALSE
if
_dwarf_ignorethissection
sname
return
FALSE
if
strncmp
sname
rel
if
strncmp
sname
rela
is_rela
TRUE
return
TRUE
if
strncmp
sname
rel
is_rela
TRUE
return
TRUE
Else
something
is
goofy
Impossible
return
FALSE
if
strncmp
sname
debug_
return
TRUE
if
strncmp
sname
zdebug_
return
TRUE
if
strcmp
sname
eh_frame
return
TRUE
if
strncmp
sname
gdb_index
return
TRUE
return
FALSE
static
int
is_empty_section
Dwarf_Unsigned
type
if
type
SHT_NOBITS
return
TRUE
if
type
SHT_NULL
return
TRUE
return
FALSE
if
int
dwarf_construct_elf_access_path
const
char
path
dwarf_elf_object_access_internals_t
mp
int
errcode
int
fd
int
res
dwarf_elf_object_access_internals_t
mymp
fd
open
path
O_RDONLY|O_BINARY
if
fd
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
res
dwarf_construct_elf_access
fd
path
errcode
if
res
DW_DLV_OK
close
fd
return
res
mymp
f_destruct_close_fd
TRUE
mp
mymp
return
res
endif
Here
path
is
not
essential
Pass
in
with
if
unknown
int
dwarf_construct_elf_access
int
fd
const
char
path
dwarf_elf_object_access_internals_t
mp
int
errcode
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
dwarf_elf_object_access_internals_t
mfp
int
res
res
dwarf_object_detector_fd
fd
errcode
if
res
DW_DLV_OK
return
res
mfp
calloc
sizeof
dwarf_elf_object_access_internals_t
if
mfp
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
For
non
libelf
Elf
call
it
F
Libelf
Elf
uses
E
mfp
f_ident
F
mfp
f_ident
mfp
f_fd
fd
mfp
f_destruct_close_fd
FALSE
mfp
f_is_64bit
offsetsize
FALSE
mfp
f_filesize
filesize
mfp
f_offsetsize
offsetsize
mfp
f_pointersize
offsetsize
mfp
f_endian
endian
mfp
f_ftype
ftype
mfp
f_path
strdup
path
mp
mfp
return
DW_DLV_OK
Caller
must
zero
the
passed
in
pointer
after
this
returns
to
remind
the
caller
to
avoid
use
of
the
pointer
int
dwarf_destruct_elf_access
dwarf_elf_object_access_internals_t
ep
int
errcode
UNUSEDARG
struct
generic_shdr
shp
Dwarf_Unsigned
shcount
Dwarf_Unsigned
i
free
ep
f_ehdr
shp
ep
f_shdr
shcount
ep
f_loc_shdr
g_count
for
i
i
shcount
i
shp
free
shp
gh_rels
shp
gh_rels
free
shp
gh_content
shp
gh_content
free
shp
gh_sht_group_array
shp
gh_sht_group_array
shp
gh_sht_group_array_count
free
ep
f_shdr
free
ep
f_phdr
free
ep
f_elf_shstrings_data
free
ep
f_dynamic
free
ep
f_symtab_sect_strings
free
ep
f_dynsym_sect_strings
free
ep
f_symtab
free
ep
f_dynsym
if
TRUE
close
f_fd
on
destruct
if
ep
f_destruct_close_fd
close
ep
f_fd
ep
f_ident
X
free
ep
f_path
free
ep
return
DW_DLV_OK
static
int
generic_ehdr_from_32
dwarf_elf_object_access_internals_t
ep
struct
generic_ehdr
ehdr
dw_elf32_ehdr
e
int
errcode
UNUSEDARG
int
i
for
i
i
EI_NIDENT
i
ehdr
ge_ident
i
e
e_ident
i
ASNAR
ep
f_copy_word
ehdr
ge_type
e
e_type
ASNAR
ep
f_copy_word
ehdr
ge_machine
e
e_machine
ASNAR
ep
f_copy_word
ehdr
ge_version
e
e_version
ASNAR
ep
f_copy_word
ehdr
ge_entry
e
e_entry
ASNAR
ep
f_copy_word
ehdr
ge_phoff
e
e_phoff
ASNAR
ep
f_copy_word
ehdr
ge_shoff
e
e_shoff
ASNAR
ep
f_copy_word
ehdr
ge_flags
e
e_flags
ASNAR
ep
f_copy_word
ehdr
ge_ehsize
e
e_ehsize
ASNAR
ep
f_copy_word
ehdr
ge_phentsize
e
e_phentsize
ASNAR
ep
f_copy_word
ehdr
ge_phnum
e
e_phnum
ASNAR
ep
f_copy_word
ehdr
ge_shentsize
e
e_shentsize
ASNAR
ep
f_copy_word
ehdr
ge_shnum
e
e_shnum
ASNAR
ep
f_copy_word
ehdr
ge_shstrndx
e
e_shstrndx
ep
f_machine
ehdr
ge_machine
ep
f_ehdr
ehdr
ep
f_loc_ehdr
g_name
Elf
File
Header
ep
f_loc_ehdr
g_offset
ep
f_loc_ehdr
g_count
ep
f_loc_ehdr
g_entrysize
sizeof
dw_elf32_ehdr
ep
f_loc_ehdr
g_totalsize
sizeof
dw_elf32_ehdr
return
DW_DLV_OK
static
int
generic_ehdr_from_64
dwarf_elf_object_access_internals_t
ep
struct
generic_ehdr
ehdr
dw_elf64_ehdr
e
int
errcode
UNUSEDARG
int
i
for
i
i
EI_NIDENT
i
ehdr
ge_ident
i
e
e_ident
i
ASNAR
ep
f_copy_word
ehdr
ge_type
e
e_type
ASNAR
ep
f_copy_word
ehdr
ge_machine
e
e_machine
ASNAR
ep
f_copy_word
ehdr
ge_version
e
e_version
ASNAR
ep
f_copy_word
ehdr
ge_entry
e
e_entry
ASNAR
ep
f_copy_word
ehdr
ge_phoff
e
e_phoff
ASNAR
ep
f_copy_word
ehdr
ge_shoff
e
e_shoff
ASNAR
ep
f_copy_word
ehdr
ge_flags
e
e_flags
ASNAR
ep
f_copy_word
ehdr
ge_ehsize
e
e_ehsize
ASNAR
ep
f_copy_word
ehdr
ge_phentsize
e
e_phentsize
ASNAR
ep
f_copy_word
ehdr
ge_phnum
e
e_phnum
ASNAR
ep
f_copy_word
ehdr
ge_shentsize
e
e_shentsize
ASNAR
ep
f_copy_word
ehdr
ge_shnum
e
e_shnum
ASNAR
ep
f_copy_word
ehdr
ge_shstrndx
e
e_shstrndx
ep
f_machine
ehdr
ge_machine
ep
f_ehdr
ehdr
ep
f_loc_ehdr
g_name
Elf
File
Header
ep
f_loc_ehdr
g_offset
ep
f_loc_ehdr
g_count
ep
f_loc_ehdr
g_entrysize
sizeof
dw_elf64_ehdr
ep
f_loc_ehdr
g_totalsize
sizeof
dw_elf64_ehdr
return
DW_DLV_OK
if
not
used
static
int
generic_phdr_from_phdr32
dwarf_elf_object_access_internals_t
ep
struct
generic_phdr
phdr_out
Dwarf_Unsigned
count_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
dw_elf32_phdr
pph
dw_elf32_phdr
orig_pph
struct
generic_phdr
gphdr
struct
generic_phdr
orig_gphdr
Dwarf_Unsigned
i
int
res
count_out
pph
dw_elf32_phdr
calloc
count
entsize
if
pph
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gphdr
struct
generic_phdr
calloc
count
sizeof
gphdr
if
gphdr
free
pph
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
orig_pph
pph
orig_gphdr
gphdr
res
RRMOA
ep
f_fd
pph
offset
count
entsize
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
pph
free
gphdr
return
res
for
i
i
count
i
pph
gphdr
ASNAR
ep
f_copy_word
gphdr
gp_type
pph
p_type
ASNAR
ep
f_copy_word
gphdr
gp_offset
pph
p_offset
ASNAR
ep
f_copy_word
gphdr
gp_vaddr
pph
p_vaddr
ASNAR
ep
f_copy_word
gphdr
gp_paddr
pph
p_paddr
ASNAR
ep
f_copy_word
gphdr
gp_filesz
pph
p_filesz
ASNAR
ep
f_copy_word
gphdr
gp_memsz
pph
p_memsz
ASNAR
ep
f_copy_word
gphdr
gp_flags
pph
p_flags
ASNAR
ep
f_copy_word
gphdr
gp_align
pph
p_align
free
orig_pph
phdr_out
orig_gphdr
count_out
count
ep
f_phdr
orig_gphdr
ep
f_loc_phdr
g_name
Program
Header
ep
f_loc_phdr
g_offset
offset
ep
f_loc_phdr
g_count
count
ep
f_loc_phdr
g_entrysize
sizeof
dw_elf32_phdr
ep
f_loc_phdr
g_totalsize
sizeof
dw_elf32_phdr
count
return
DW_DLV_OK
static
int
generic_phdr_from_phdr64
dwarf_elf_object_access_internals_t
ep
struct
generic_phdr
phdr_out
Dwarf_Unsigned
count_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
dw_elf64_phdr
pph
dw_elf64_phdr
orig_pph
struct
generic_phdr
gphdr
struct
generic_phdr
orig_gphdr
int
res
Dwarf_Unsigned
i
count_out
pph
dw_elf64_phdr
calloc
count
entsize
if
pph
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gphdr
struct
generic_phdr
calloc
count
sizeof
gphdr
if
gphdr
free
pph
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
orig_pph
pph
orig_gphdr
gphdr
res
RRMOA
ep
f_fd
pph
offset
count
entsize
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
pph
free
gphdr
return
res
for
i
i
count
i
pph
gphdr
ASNAR
ep
f_copy_word
gphdr
gp_type
pph
p_type
ASNAR
ep
f_copy_word
gphdr
gp_offset
pph
p_offset
ASNAR
ep
f_copy_word
gphdr
gp_vaddr
pph
p_vaddr
ASNAR
ep
f_copy_word
gphdr
gp_paddr
pph
p_paddr
ASNAR
ep
f_copy_word
gphdr
gp_filesz
pph
p_filesz
ASNAR
ep
f_copy_word
gphdr
gp_memsz
pph
p_memsz
ASNAR
ep
f_copy_word
gphdr
gp_flags
pph
p_flags
ASNAR
ep
f_copy_word
gphdr
gp_align
pph
p_align
free
orig_pph
phdr_out
orig_gphdr
count_out
count
ep
f_phdr
orig_gphdr
ep
f_loc_phdr
g_name
Program
Header
ep
f_loc_phdr
g_offset
offset
ep
f_loc_phdr
g_count
count
ep
f_loc_phdr
g_entrysize
sizeof
dw_elf64_phdr
ep
f_loc_phdr
g_totalsize
sizeof
dw_elf64_phdr
count
return
DW_DLV_OK
endif
not
used
static
int
generic_shdr_from_shdr32
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
count_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
dw_elf32_shdr
psh
dw_elf32_shdr
orig_psh
struct
generic_shdr
gshdr
struct
generic_shdr
orig_gshdr
Dwarf_Unsigned
i
int
res
count_out
psh
dw_elf32_shdr
calloc
count
entsize
if
psh
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gshdr
struct
generic_shdr
calloc
count
sizeof
gshdr
if
gshdr
free
psh
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
orig_psh
psh
orig_gshdr
gshdr
res
RRMOA
ep
f_fd
psh
offset
count
entsize
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
psh
free
gshdr
return
res
for
i
i
count
i
psh
gshdr
gshdr
gh_secnum
i
ASNAR
ep
f_copy_word
gshdr
gh_name
psh
sh_name
ASNAR
ep
f_copy_word
gshdr
gh_type
psh
sh_type
ASNAR
ep
f_copy_word
gshdr
gh_flags
psh
sh_flags
ASNAR
ep
f_copy_word
gshdr
gh_addr
psh
sh_addr
ASNAR
ep
f_copy_word
gshdr
gh_offset
psh
sh_offset
ASNAR
ep
f_copy_word
gshdr
gh_size
psh
sh_size
ASNAR
ep
f_copy_word
gshdr
gh_link
psh
sh_link
ASNAR
ep
f_copy_word
gshdr
gh_info
psh
sh_info
ASNAR
ep
f_copy_word
gshdr
gh_addralign
psh
sh_addralign
ASNAR
ep
f_copy_word
gshdr
gh_entsize
psh
sh_entsize
if
gshdr
gh_type
SHT_REL
gshdr
gh_type
SHT_RELA
gshdr
gh_reloc_target_secnum
gshdr
gh_info
free
orig_psh
count_out
count
ep
f_shdr
orig_gshdr
ep
f_loc_shdr
g_name
Section
Header
ep
f_loc_shdr
g_count
count
ep
f_loc_shdr
g_offset
offset
ep
f_loc_shdr
g_entrysize
sizeof
dw_elf32_shdr
ep
f_loc_shdr
g_totalsize
sizeof
dw_elf32_shdr
count
return
DW_DLV_OK
static
int
generic_shdr_from_shdr64
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
count_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
dw_elf64_shdr
psh
dw_elf64_shdr
orig_psh
struct
generic_shdr
gshdr
struct
generic_shdr
orig_gshdr
Dwarf_Unsigned
i
int
res
count_out
psh
dw_elf64_shdr
calloc
count
entsize
if
psh
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gshdr
struct
generic_shdr
calloc
count
sizeof
gshdr
if
gshdr
free
psh
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
orig_psh
psh
orig_gshdr
gshdr
res
RRMOA
ep
f_fd
psh
offset
count
entsize
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
psh
free
gshdr
return
res
for
i
i
count
i
psh
gshdr
gshdr
gh_secnum
i
ASNAR
ep
f_copy_word
gshdr
gh_name
psh
sh_name
ASNAR
ep
f_copy_word
gshdr
gh_type
psh
sh_type
ASNAR
ep
f_copy_word
gshdr
gh_flags
psh
sh_flags
ASNAR
ep
f_copy_word
gshdr
gh_addr
psh
sh_addr
ASNAR
ep
f_copy_word
gshdr
gh_offset
psh
sh_offset
ASNAR
ep
f_copy_word
gshdr
gh_size
psh
sh_size
ASNAR
ep
f_copy_word
gshdr
gh_link
psh
sh_link
ASNAR
ep
f_copy_word
gshdr
gh_info
psh
sh_info
ASNAR
ep
f_copy_word
gshdr
gh_addralign
psh
sh_addralign
ASNAR
ep
f_copy_word
gshdr
gh_entsize
psh
sh_entsize
if
gshdr
gh_type
SHT_REL
gshdr
gh_type
SHT_RELA
gshdr
gh_reloc_target_secnum
gshdr
gh_info
free
orig_psh
count_out
count
ep
f_shdr
orig_gshdr
ep
f_loc_shdr
g_name
Section
Header
ep
f_loc_shdr
g_count
count
ep
f_loc_shdr
g_offset
offset
ep
f_loc_shdr
g_entrysize
sizeof
dw_elf64_shdr
ep
f_loc_shdr
g_totalsize
sizeof
dw_elf64_shdr
count
return
DW_DLV_OK
static
int
dwarf_generic_elf_load_symbols32
dwarf_elf_object_access_internals_t
ep
struct
generic_symentry
gsym_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
size
Dwarf_Unsigned
count_out
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
dw_elf32_sym
psym
dw_elf32_sym
orig_psym
struct
generic_symentry
gsym
struct
generic_symentry
orig_gsym
int
res
ecount
long
size
sizeof
dw_elf32_sym
size2
ecount
sizeof
dw_elf32_sym
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
psym
calloc
ecount
sizeof
dw_elf32_sym
if
psym
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gsym
calloc
ecount
sizeof
struct
generic_symentry
if
gsym
free
psym
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
psym
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
psym
free
gsym
return
res
orig_psym
psym
orig_gsym
gsym
for
i
i
ecount
i
psym
gsym
Dwarf_Unsigned
bind
Dwarf_Unsigned
type
ASNAR
ep
f_copy_word
gsym
gs_name
psym
st_name
ASNAR
ep
f_copy_word
gsym
gs_value
psym
st_value
ASNAR
ep
f_copy_word
gsym
gs_size
psym
st_size
ASNAR
ep
f_copy_word
gsym
gs_info
psym
st_info
ASNAR
ep
f_copy_word
gsym
gs_other
psym
st_other
ASNAR
ep
f_copy_word
gsym
gs_shndx
psym
st_shndx
bind
gsym
gs_info
type
gsym
gs_info
gsym
gs_bind
bind
gsym
gs_type
type
count_out
ecount
gsym_out
orig_gsym
free
orig_psym
return
DW_DLV_OK
static
int
dwarf_generic_elf_load_symbols64
dwarf_elf_object_access_internals_t
ep
struct
generic_symentry
gsym_out
Dwarf_Unsigned
offset
Dwarf_Unsigned
size
Dwarf_Unsigned
count_out
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
dw_elf64_sym
psym
dw_elf64_sym
orig_psym
struct
generic_symentry
gsym
struct
generic_symentry
orig_gsym
int
res
ecount
long
size
sizeof
dw_elf64_sym
size2
ecount
sizeof
dw_elf64_sym
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
psym
calloc
ecount
sizeof
dw_elf64_sym
if
psym
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
gsym
calloc
ecount
sizeof
struct
generic_symentry
if
gsym
free
psym
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
psym
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
psym
free
gsym
errcode
DW_DLE_ALLOC_FAIL
return
res
orig_psym
psym
orig_gsym
gsym
for
i
i
ecount
i
psym
gsym
Dwarf_Unsigned
bind
Dwarf_Unsigned
type
ASNAR
ep
f_copy_word
gsym
gs_name
psym
st_name
ASNAR
ep
f_copy_word
gsym
gs_value
psym
st_value
ASNAR
ep
f_copy_word
gsym
gs_size
psym
st_size
ASNAR
ep
f_copy_word
gsym
gs_info
psym
st_info
ASNAR
ep
f_copy_word
gsym
gs_other
psym
st_other
ASNAR
ep
f_copy_word
gsym
gs_shndx
psym
st_shndx
bind
gsym
gs_info
type
gsym
gs_info
gsym
gs_bind
bind
gsym
gs_type
type
count_out
ecount
gsym_out
orig_gsym
free
orig_psym
return
DW_DLV_OK
static
int
dwarf_generic_elf_load_symbols
dwarf_elf_object_access_internals_t
ep
int
secnum
struct
generic_shdr
psh
struct
generic_symentry
gsym_out
Dwarf_Unsigned
count_out
int
errcode
int
res
struct
generic_symentry
gsym
Dwarf_Unsigned
count
if
secnum
return
DW_DLV_NO_ENTRY
if
psh
gh_size
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
if
ep
f_offsetsize
res
dwarf_generic_elf_load_symbols32
ep
psh
gh_offset
psh
gh_size
errcode
else
if
ep
f_offsetsize
res
dwarf_generic_elf_load_symbols64
ep
psh
gh_offset
psh
gh_size
errcode
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
if
res
DW_DLV_OK
gsym_out
gsym
count_out
count
return
res
if
int
dwarf_load_elf_dynsym_symbols
dwarf_elf_object_access_internals_t
ep
int
errcode
int
res
struct
generic_symentry
gsym
Dwarf_Unsigned
count
Dwarf_Unsigned
secnum
ep
f_dynsym_sect_index
struct
generic_shdr
psh
if
secnum
return
DW_DLV_NO_ENTRY
psh
ep
f_shdr
secnum
if
we
ever
use
this
gh_size
big?
res
dwarf_generic_elf_load_symbols
ep
secnum
psh
errcode
if
res
DW_DLV_OK
ep
f_dynsym
gsym
ep
f_loc_dynsym
g_count
count
return
res
endif
int
_dwarf_load_elf_symtab_symbols
dwarf_elf_object_access_internals_t
ep
int
errcode
int
res
struct
generic_symentry
gsym
Dwarf_Unsigned
count
Dwarf_Unsigned
secnum
ep
f_symtab_sect_index
struct
generic_shdr
psh
if
secnum
return
DW_DLV_NO_ENTRY
psh
ep
f_shdr
secnum
if
psh
gh_size
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
res
dwarf_generic_elf_load_symbols
ep
secnum
psh
errcode
if
res
DW_DLV_OK
ep
f_symtab
gsym
ep
f_loc_symtab
g_count
count
return
res
static
int
generic_rel_from_rela32
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gsh
dw_elf32_rela
relp
struct
generic_rela
grel
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size
gsh
gh_size
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
ecount
size
sizeof
dw_elf32_rela
size2
ecount
sizeof
dw_elf32_rela
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
for
i
i
ecount
i
relp
grel
ASNAR
ep
f_copy_word
grel
gr_offset
relp
r_offset
ASNAR
ep
f_copy_word
grel
gr_info
relp
r_info
addend
signed
ASNAR
ep
f_copy_word
grel
gr_addend
relp
r_addend
SIGN_EXTEND
grel
gr_addend
sizeof
relp
r_addend
grel
gr_sym
grel
gr_info
ELF32_R_SYM
grel
gr_type
grel
gr_info
grel
gr_is_rela
TRUE
return
DW_DLV_OK
static
int
generic_rel_from_rela64
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gsh
dw_elf64_rela
relp
struct
generic_rela
grel
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size
gsh
gh_size
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
int
objlittleendian
ep
f_endian
DW_OBJECT_LSB
int
ismips64
ep
f_machine
EM_MIPS
int
issparcv9
ep
f_machine
EM_SPARCV9
ecount
size
sizeof
dw_elf64_rela
size2
ecount
sizeof
dw_elf64_rela
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
for
i
i
ecount
i
relp
grel
ASNAR
ep
f_copy_word
grel
gr_offset
relp
r_offset
ASNAR
ep
f_copy_word
grel
gr_info
relp
r_info
ASNAR
ep
f_copy_word
grel
gr_addend
relp
r_addend
SIGN_EXTEND
grel
gr_addend
sizeof
relp
r_addend
if
ismips64
objlittleendian
char
realsym
memcpy
realsym
r_info
sizeof
realsym
ASNAR
ep
f_copy_word
grel
gr_sym
realsym
grel
gr_type
relp
r_info
grel
gr_type2
relp
r_info
grel
gr_type3
relp
r_info
else
if
issparcv9
Always
Big
Endian?
char
realsym
memcpy
realsym
r_info
sizeof
realsym
ASNAR
ep
f_copy_word
grel
gr_sym
realsym
grel
gr_type
relp
r_info
else
grel
gr_sym
grel
gr_info
grel
gr_type
grel
gr_info
grel
gr_is_rela
TRUE
return
DW_DLV_OK
static
int
generic_rel_from_rel32
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gsh
dw_elf32_rel
relp
struct
generic_rela
grel
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size
gsh
gh_size
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
ecount
size
sizeof
dw_elf32_rel
size2
ecount
sizeof
dw_elf32_rel
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
for
i
i
ecount
i
relp
grel
ASNAR
ep
f_copy_word
grel
gr_offset
relp
r_offset
ASNAR
ep
f_copy_word
grel
gr_info
relp
r_info
grel
gr_addend
Unused
for
plain
rel
grel
gr_sym
grel
gr_info
ELF32_R_SYM
grel
gr_is_rela
FALSE
grel
gr_type
grel
gr_info
return
DW_DLV_OK
static
int
generic_rel_from_rel64
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gsh
dw_elf64_rel
relp
struct
generic_rela
grel
int
errcode
Dwarf_Unsigned
ecount
Dwarf_Unsigned
size
gsh
gh_size
Dwarf_Unsigned
size2
Dwarf_Unsigned
i
int
objlittleendian
ep
f_endian
DW_OBJECT_LSB
int
ismips64
ep
f_machine
EM_MIPS
int
issparcv9
ep
f_machine
EM_SPARCV9
ecount
size
sizeof
dw_elf64_rel
size2
ecount
sizeof
dw_elf64_rel
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
for
i
i
ecount
i
relp
grel
ASNAR
ep
f_copy_word
grel
gr_offset
relp
r_offset
ASNAR
ep
f_copy_word
grel
gr_info
relp
r_info
grel
gr_addend
Unused
for
plain
rel
if
ismips64
objlittleendian
char
realsym
memcpy
realsym
r_info
sizeof
realsym
ASNAR
ep
f_copy_word
grel
gr_sym
realsym
grel
gr_type
relp
r_info
grel
gr_type2
relp
r_info
grel
gr_type3
relp
r_info
else
if
issparcv9
Always
Big
Endian?
char
realsym
memcpy
realsym
r_info
sizeof
realsym
ASNAR
ep
f_copy_word
grel
gr_sym
realsym
grel
gr_type
relp
r_info
else
grel
gr_sym
grel
gr_info
grel
gr_type
grel
gr_info
grel
gr_is_rela
FALSE
return
DW_DLV_OK
if
int
dwarf_load_elf_dynstr
dwarf_elf_object_access_internals_t
ep
int
errcode
struct
generic_shdr
strpsh
int
res
Dwarf_Unsigned
strsectindex
Dwarf_Unsigned
strsectlength
if
ep
f_dynsym_sect_strings_sect_index
return
DW_DLV_NO_ENTRY
strsectindex
ep
f_dynsym_sect_strings_sect_index
strsectlength
ep
f_dynsym_sect_strings_max
strpsh
ep
f_shdr
strsectindex
Alloc
an
extra
byte
as
a
guaranteed
NUL
byte
at
the
end
of
the
strings
in
case
the
section
is
corrupted
and
lacks
a
NUL
at
end
ep
f_dynsym_sect_strings
calloc
strsectlength
if
ep
f_dynsym_sect_strings
ep
f_dynsym_sect_strings
ep
f_dynsym_sect_strings_max
ep
f_dynsym_sect_strings_sect_index
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
ep
f_dynsym_sect_strings
strpsh
gh_offset
strsectlength
ep
f_filesize
errcode
if
res
DW_DLV_OK
ep
f_dynsym_sect_strings
ep
f_dynsym_sect_strings_max
ep
f_dynsym_sect_strings_sect_index
return
res
return
DW_DLV_OK
endif
int
_dwarf_load_elf_symstr
dwarf_elf_object_access_internals_t
ep
int
errcode
struct
generic_shdr
strpsh
int
res
Dwarf_Unsigned
strsectindex
Dwarf_Unsigned
strsectlength
if
ep
f_symtab_sect_strings_sect_index
return
DW_DLV_NO_ENTRY
strsectindex
ep
f_symtab_sect_strings_sect_index
strsectlength
ep
f_symtab_sect_strings_max
strpsh
ep
f_shdr
strsectindex
Alloc
an
extra
byte
as
a
guaranteed
NUL
byte
at
the
end
of
the
strings
in
case
the
section
is
corrupted
and
lacks
a
NUL
at
end
if
strsectlength
ep
f_filesize
strpsh
gh_offset
ep
f_filesize
strsectlength
strpsh
gh_offset
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
return
DW_DLV_ERROR
ep
f_symtab_sect_strings
calloc
strsectlength
if
ep
f_symtab_sect_strings
ep
f_symtab_sect_strings
ep
f_symtab_sect_strings_max
ep
f_symtab_sect_strings_sect_index
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
ep
f_symtab_sect_strings
strpsh
gh_offset
strsectlength
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
ep
f_symtab_sect_strings
ep
f_symtab_sect_strings
ep
f_symtab_sect_strings_max
ep
f_symtab_sect_strings_sect_index
return
res
return
DW_DLV_OK
static
int
_dwarf_elf_load_sectstrings
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
stringsection
int
errcode
int
res
struct
generic_shdr
psh
Dwarf_Unsigned
secoffset
ep
f_elf_shstrings_length
if
stringsection
ep
f_ehdr
ge_shnum
errcode
DW_DLE_SECTION_INDEX_BAD
return
DW_DLV_ERROR
psh
ep
f_shdr
stringsection
secoffset
psh
gh_offset
if
is_empty_section
psh
gh_type
errcode
DW_DLE_ELF_STRING_SECTION_MISSING
return
DW_DLV_ERROR
if
secoffset
ep
f_filesize
psh
gh_size
ep
f_filesize
secoffset
psh
gh_size
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
return
DW_DLV_ERROR
if
psh
gh_size
ep
f_elf_shstrings_max
free
ep
f_elf_shstrings_data
ep
f_elf_shstrings_data
char
malloc
psh
gh_size
ep
f_elf_shstrings_max
psh
gh_size
if
ep
f_elf_shstrings_data
ep
f_elf_shstrings_max
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
ep
f_elf_shstrings_length
psh
gh_size
res
RRMOA
ep
f_fd
ep
f_elf_shstrings_data
secoffset
psh
gh_size
ep
f_filesize
errcode
return
res
static
int
elf_load_sectheaders32
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
Dwarf_Unsigned
generic_count
int
res
if
count
return
DW_DLV_NO_ENTRY
if
entsize
sizeof
dw_elf32_shdr
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
if
offset
ep
f_filesize
entsize
count
ep
f_filesize
count
entsize
offset
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
return
DW_DLV_ERROR
res
generic_shdr_from_shdr32
ep
offset
entsize
count
errcode
if
res
DW_DLV_OK
return
res
if
generic_count
count
errcode
DW_DLE_ELF_SECTION_COUNT_MISMATCH
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
elf_load_sectheaders64
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
offset
Dwarf_Unsigned
entsize
Dwarf_Unsigned
count
int
errcode
Dwarf_Unsigned
generic_count
int
res
if
count
return
DW_DLV_NO_ENTRY
if
entsize
sizeof
dw_elf64_shdr
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
if
offset
ep
f_filesize
entsize
count
ep
f_filesize
count
entsize
offset
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
return
DW_DLV_ERROR
res
generic_shdr_from_shdr64
ep
offset
entsize
count
errcode
if
res
DW_DLV_OK
return
res
if
generic_count
count
errcode
DW_DLE_ELF_SECTION_COUNT_MISMATCH
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
_dwarf_elf_load_a_relx_batch
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gsh
struct
generic_rela
grel_out
Dwarf_Unsigned
count_out
enum
RelocRela
localrela
enum
RelocOffsetSize
localoffsize
int
errcode
Dwarf_Unsigned
count
Dwarf_Unsigned
size
Dwarf_Unsigned
size2
Dwarf_Unsigned
sizeg
Dwarf_Unsigned
offset
int
res
Dwarf_Unsigned
object_reclen
struct
generic_rela
grel
ASSERT
Caller
guarantees
localoffsetsize
is
a
valid
or
ASSERT
Caller
guarantees
localrela
is
one
of
the
valid
values
or
offset
gsh
gh_offset
size
gsh
gh_size
if
size
return
DW_DLV_NO_ENTRY
if
offset
ep
f_filesize
size
ep
f_filesize
size
offset
ep
f_filesize
errcode
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
return
DW_DLV_ERROR
if
localoffsize
RelocOffset32
if
localrela
RelocIsRela
object_reclen
sizeof
dw_elf32_rela
count
long
size
object_reclen
size2
count
object_reclen
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
else
object_reclen
sizeof
dw_elf32_rel
count
long
size
object_reclen
size2
count
object_reclen
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
else
if
localrela
RelocIsRela
object_reclen
sizeof
dw_elf64_rela
count
long
size
object_reclen
size2
count
object_reclen
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
else
object_reclen
sizeof
dw_elf64_rel
count
long
size
object_reclen
size2
count
object_reclen
if
size
size2
errcode
DW_DLE_SECTION_SIZE_ERROR
return
DW_DLV_ERROR
sizeg
count
sizeof
struct
generic_rela
grel
struct
generic_rela
malloc
sizeg
if
grel
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
if
localoffsize
RelocOffset32
if
localrela
RelocIsRela
dw_elf32_rela
relp
relp
dw_elf32_rela
malloc
size
if
relp
free
grel
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
relp
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
relp
free
grel
return
res
res
generic_rel_from_rela32
ep
gsh
relp
grel
errcode
free
relp
else
dw_elf32_rel
relp
relp
dw_elf32_rel
malloc
size
if
relp
free
grel
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
relp
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
relp
free
grel
return
res
res
generic_rel_from_rel32
ep
gsh
relp
grel
errcode
free
relp
else
if
localrela
RelocIsRela
dw_elf64_rela
relp
relp
dw_elf64_rela
malloc
size
if
relp
free
grel
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
relp
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
relp
free
grel
return
res
res
generic_rel_from_rela64
ep
gsh
relp
grel
errcode
free
relp
else
dw_elf64_rel
relp
relp
dw_elf64_rel
malloc
size
if
relp
free
grel
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
relp
offset
size
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
relp
free
grel
return
res
res
generic_rel_from_rel64
ep
gsh
relp
grel
errcode
free
relp
if
res
DW_DLV_OK
gsh
gh_relcount
count
gsh
gh_rels
grel
count_out
count
grel_out
grel
return
res
Some
sort
of
issue
count_out
free
grel
return
res
Is
this
rel
rela
section
related
to
dwarf
at
all?
set
oksecnum
zero
if
not
Else
set
targ
secnum
Never
returns
DW_DLV_NO_ENTRY
static
int
this_rel_is_a_section_dwarf_related
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
gshdr
unsigned
oksecnum_out
int
errcode
unsigned
oksecnum
struct
generic_shdr
gstarg
if
gshdr
gh_type
SHT_RELA
gshdr
gh_type
SHT_REL
oksecnum_out
return
DW_DLV_OK
oksecnum
gshdr
gh_reloc_target_secnum
if
oksecnum
ep
f_loc_shdr
g_count
oksecnum_out
errcode
DW_DLE_ELF_SECTION_ERROR
return
DW_DLV_ERROR
gstarg
ep
f_shdr
oksecnum
if
gstarg
gh_is_dwarf
oksecnum_out
no
reloc
needed
return
DW_DLV_OK
oksecnum_out
oksecnum
return
DW_DLV_OK
Secnum
here
is
the
secnum
of
rela
Not
the
target
of
the
relocations
This
also
loads
rel
int
_dwarf_load_elf_relx
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
secnum
enum
RelocRela
localr
int
errcode
struct
generic_shdr
gshdr
Dwarf_Unsigned
seccount
unsigned
offsetsize
struct
generic_rela
grp
Dwarf_Unsigned
count_read
int
res
unsigned
oksec
enum
RelocOffsetSize
localoffsize
RelocOffset32
ASSERT
Caller
guarantees
localr
is
a
valid
RelocRela
if
ep
errcode
DW_DLE_INTERNAL_NULL_POINTER
return
DW_DLV_ERROR
offsetsize
ep
f_offsetsize
seccount
ep
f_loc_shdr
g_count
if
secnum
seccount
errcode
DW_DLE_ELF_SECTION_ERROR
return
DW_DLV_ERROR
gshdr
ep
f_shdr
secnum
if
is_empty_section
gshdr
gh_type
return
DW_DLV_NO_ENTRY
res
this_rel_is_a_section_dwarf_related
ep
gshdr
errcode
if
res
DW_DLV_ERROR
return
res
if
oksec
return
DW_DLV_OK
We
will
actually
read
these
relocations
if
offsetsize
localoffsize
RelocOffset64
else
if
offsetsize
localoffsize
RelocOffset32
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
ASSERT
localoffsize
is
now
a
valid
enum
value
one
of
the
two
defined
res
_dwarf_elf_load_a_relx_batch
ep
gshdr
localr
localoffsize
errcode
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
gshdr
gh_rels
grp
gshdr
gh_relcount
count_read
return
DW_DLV_OK
static
int
validate_section_name_string
Dwarf_Unsigned
section_length
Dwarf_Unsigned
string_loc_index
const
char
strings_start
int
errcode
const
char
endpoint
strings_start
section_length
const
char
cur
if
section_length
string_loc_index
errcode
DW_DLE_SECTION_STRING_OFFSET_BAD
return
DW_DLV_ERROR
cur
string_loc_index
strings_start
for
cur
endpoint
cur
if
cur
return
DW_DLV_OK
errcode
DW_DLE_SECTION_STRING_OFFSET_BAD
return
DW_DLV_ERROR
static
int
_dwarf_elf_load_sect_namestring
dwarf_elf_object_access_internals_t
ep
int
errcode
struct
generic_shdr
gshdr
Dwarf_Unsigned
generic_count
Dwarf_Unsigned
i
const
char
stringsecbase
stringsecbase
ep
f_elf_shstrings_data
gshdr
ep
f_shdr
generic_count
ep
f_loc_shdr
g_count
for
i
i
generic_count
i
gshdr
const
char
namestr
Invalid
sh_name
value
Corrupt
Elf
int
res
res
validate_section_name_string
ep
f_elf_shstrings_length
gshdr
gh_name
stringsecbase
errcode
if
res
DW_DLV_OK
gshdr
gh_namestring
namestr
return
res
gshdr
gh_namestring
stringsecbase
gshdr
gh_name
return
DW_DLV_OK
static
int
elf_load_elf_header32
dwarf_elf_object_access_internals_t
ep
int
errcode
int
res
dw_elf32_ehdr
ehdr32
struct
generic_ehdr
ehdr
res
RRMOA
ep
f_fd
sizeof
ehdr32
ep
f_filesize
errcode
if
res
DW_DLV_OK
return
res
ehdr
struct
generic_ehdr
calloc
sizeof
struct
generic_ehdr
if
ehdr
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
generic_ehdr_from_32
ep
ehdr
errcode
return
res
static
int
elf_load_elf_header64
dwarf_elf_object_access_internals_t
ep
int
errcode
int
res
dw_elf64_ehdr
ehdr64
struct
generic_ehdr
ehdr
res
RRMOA
ep
f_fd
sizeof
ehdr64
ep
f_filesize
errcode
if
res
DW_DLV_OK
return
res
ehdr
struct
generic_ehdr
calloc
sizeof
struct
generic_ehdr
if
ehdr
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
generic_ehdr_from_64
ep
ehdr
errcode
return
res
static
int
validate_struct_sizes
ifdef
HAVE_ELF_H
int
errcode
else
int
errcode
UNUSEDARG
endif
ifdef
HAVE_ELF_H
This
is
a
sanity
check
when
we
have
an
elf
h
to
check
against
if
sizeof
Elf32_Ehdr
sizeof
dw_elf32_ehdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Ehdr
sizeof
dw_elf64_ehdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf32_Shdr
sizeof
dw_elf32_shdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Shdr
sizeof
dw_elf64_shdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf32_Phdr
sizeof
dw_elf32_phdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Phdr
sizeof
dw_elf64_phdr
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf32_Rel
sizeof
dw_elf32_rel
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Rel
sizeof
dw_elf64_rel
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf32_Rela
sizeof
dw_elf32_rela
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Rela
sizeof
dw_elf64_rela
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf32_Sym
sizeof
dw_elf32_sym
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
if
sizeof
Elf64_Sym
sizeof
dw_elf64_sym
errcode
DW_DLE_BAD_TYPE_SIZE
return
DW_DLV_ERROR
endif
HAVE_ELF_H
return
DW_DLV_OK
int
_dwarf_load_elf_header
dwarf_elf_object_access_internals_t
ep
int
errcode
unsigned
offsetsize
ep
f_offsetsize
int
res
res
validate_struct_sizes
errcode
if
res
DW_DLV_OK
return
res
if
offsetsize
res
elf_load_elf_header32
ep
errcode
else
if
offsetsize
if
sizeof
Dwarf_Unsigned
errcode
DW_DLE_INTEGER_TOO_SMALL
return
DW_DLV_ERROR
res
elf_load_elf_header64
ep
errcode
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
return
res
static
int
validate_links
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
knownsect
Dwarf_Unsigned
string_sect
int
errcode
struct
generic_shdr
pshk
if
knownsect
return
DW_DLV_OK
if
string_sect
errcode
DW_DLE_ELF_STRING_SECTION_ERROR
return
DW_DLV_ERROR
pshk
ep
f_shdr
knownsect
if
string_sect
pshk
gh_link
errcode
DW_DLE_ELF_SECTION_LINK_ERROR
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
string_endswith
const
char
n
const
char
q
unsigned
long
len
strlen
n
unsigned
long
qlen
strlen
q
const
char
startpt
if
len
qlen
return
FALSE
startpt
n
len
qlen
if
strcmp
startpt
q
return
FALSE
return
TRUE
We
are
allowing
either
SHT_GROUP
or
group
to
indicate
a
group
section
but
really
one
should
have
both
or
neither
static
int
elf_sht_groupsec
Dwarf_Unsigned
type
const
char
sname
ARM
compilers
name
SHT
group
__ARM_grp
long
name
here
not
group
if
type
SHT_GROUP
strcmp
sname
group
return
TRUE
return
FALSE
static
int
elf_flagmatches
Dwarf_Unsigned
flagsword
Dwarf_Unsigned
flag
if
flagsword&flag
flag
return
TRUE
return
FALSE
For
SHT_GROUP
sections
static
int
read_gs_section_group
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
psh
int
errcode
Dwarf_Unsigned
i
int
res
if
psh
gh_sht_group_array
Dwarf_Unsigned
seclen
psh
gh_size
char
data
char
dp
Dwarf_Unsigned
grouparray
char
dblock
Dwarf_Unsigned
va
Dwarf_Unsigned
count
int
foundone
if
seclen
DWARF_32BIT_SIZE
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
data
malloc
seclen
if
data
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dp
data
if
psh
gh_entsize
DWARF_32BIT_SIZE
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
free
data
return
DW_DLV_ERROR
if
psh
gh_entsize
free
data
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
count
seclen
psh
gh_entsize
if
count
ep
f_loc_shdr
g_count
Impossible
free
data
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
res
RRMOA
ep
f_fd
data
psh
gh_offset
seclen
ep
f_filesize
errcode
if
res
DW_DLV_OK
free
data
return
res
grouparray
malloc
count
sizeof
Dwarf_Unsigned
if
grouparray
free
data
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memcpy
dblock
dp
DWARF_32BIT_SIZE
ASNAR
memcpy
va
dblock
There
is
ambiguity
on
the
endianness
of
this
stuff
if
va
va
Could
be
corrupted
elf
object
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
free
data
free
grouparray
return
DW_DLV_ERROR
grouparray
dp
dp
DWARF_32BIT_SIZE
for
i
i
count
i
dp
DWARF_32BIT_SIZE
Dwarf_Unsigned
gseca
Dwarf_Unsigned
gsecb
struct
generic_shdr
targpsh
memcpy
dblock
dp
DWARF_32BIT_SIZE
ASNAR
memcpy
gseca
dblock
ASNAR
_dwarf_memcpy_swap_bytes
gsecb
dblock
if
gseca
free
data
free
grouparray
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
grouparray
i
gseca
if
gseca
ep
f_loc_shdr
g_count
Might
be
confused
endianness
by
the
compiler
generating
the
SHT_GROUP
This
is
pretty
horrible
if
gsecb
ep
f_loc_shdr
g_count
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
free
data
free
grouparray
return
DW_DLV_ERROR
Ok
Yes
ugly
gseca
gsecb
grouparray
i
gseca
targpsh
ep
f_shdr
gseca
if
targpsh
gh_section_group_number
multi
assignment
to
groups
Oops
free
data
free
grouparray
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
targpsh
gh_section_group_number
ep
f_sg_next_group_number
foundone
if
foundone
ep
f_sg_next_group_number
ep
f_sht_group_type_section_count
free
data
psh
gh_sht_group_array
grouparray
psh
gh_sht_group_array_count
count
return
DW_DLV_OK
Does
related
things
A
Counts
the
number
of
SHT_GROUP
and
for
each
builds
an
array
of
the
sections
in
the
group
which
we
expect
are
all
DWARF
related
and
sets
the
group
number
in
each
mentioned
section
B
Counts
the
number
of
SHF_GROUP
flags
C
If
gnu
groups
ensure
all
the
DWARF
sections
marked
with
right
group
based
on
A
we
will
mark
unmarked
as
group
DW_GROUPNUMBER_BASE
D
If
arm
groups
SHT_GROUP
zero
SHF_GROUP
non
zero
Check
the
relocations
of
all
SHF_GROUP
section
FIXME
algorithm
needed
If
SHT_GROUP
and
SHF_GROUP
this
is
GNU
groups
If
no
SHT_GROUP
and
have
SHF_GROUP
this
is
arm
cc
groups
and
we
must
use
relocation
information
to
identify
the
group
members
It
seems
impossible
for
an
object
to
have
both
dwo
sections
and
SHF_GROUP
or
SHT_GROUP
but
we
do
not
rule
that
out
here
static
int
_dwarf_elf_setup_all_section_groups
dwarf_elf_object_access_internals_t
ep
int
errcode
struct
generic_shdr
psh
Dwarf_Unsigned
i
Dwarf_Unsigned
count
int
res
count
ep
f_loc_shdr
g_count
psh
ep
f_shdr
Does
step
A
and
step
B
for
i
i
count
psh
i
const
char
name
psh
gh_namestring
if
is_empty_section
psh
gh_type
No
data
here
continue
if
elf_sht_groupsec
psh
gh_type
name
Step
B
if
elf_flagmatches
psh
gh_flags
SHF_GROUP
ep
f_shf_group_flag_section_count
continue
Looks
like
a
section
group
Do
Step
A
res
read_gs_section_group
ep
psh
errcode
if
res
DW_DLV_OK
return
res
Any
sections
not
marked
above
or
here
are
in
grep
DW_GROUPNUMBER_BASE
Section
C
psh
ep
f_shdr
for
i
i
count
psh
i
const
char
name
psh
gh_namestring
int
is_rel
FALSE
int
is_rela
FALSE
if
is_empty_section
psh
gh_type
No
data
here
continue
if
elf_sht_groupsec
psh
gh_type
name
continue
Not
a
section
group
if
string_endswith
name
dwo
if
psh
gh_section_group_number
multi
assignment
to
groups
Oops
errcode
DW_DLE_ELF_SECTION_GROUP_ERROR
return
DW_DLV_ERROR
psh
gh_is_dwarf
TRUE
psh
gh_section_group_number
DW_GROUPNUMBER_DWO
ep
f_dwo_group_section_count
else
if
_dwarf_load_elf_section_is_dwarf
name
if
psh
gh_section_group_number
psh
gh_section_group_number
DW_GROUPNUMBER_BASE
psh
gh_is_dwarf
TRUE
else
Do
nothing
if
ep
f_sht_group_type_section_count
Not
ARM
Done
if
ep
f_shf_group_flag_section_count
Nothing
more
to
do
return
DW_DLV_OK
return
DW_DLV_OK
static
int
_dwarf_elf_find_sym_sections
dwarf_elf_object_access_internals_t
ep
int
errcode
struct
generic_shdr
psh
Dwarf_Unsigned
i
Dwarf_Unsigned
count
int
res
count
ep
f_loc_shdr
g_count
psh
ep
f_shdr
for
i
i
count
psh
i
const
char
name
psh
gh_namestring
if
is_empty_section
psh
gh_type
No
data
here
continue
if
strcmp
name
dynsym
ep
f_dynsym_sect_index
i
ep
f_loc_dynsym
g_offset
psh
gh_offset
else
if
strcmp
name
dynstr
ep
f_dynsym_sect_strings_sect_index
i
ep
f_dynsym_sect_strings_max
psh
gh_size
else
if
strcmp
name
symtab
ep
f_symtab_sect_index
i
ep
f_loc_symtab
g_offset
psh
gh_offset
else
if
strcmp
name
strtab
ep
f_symtab_sect_strings_sect_index
i
ep
f_symtab_sect_strings_max
psh
gh_size
else
if
strcmp
name
dynamic
ep
f_dynamic_sect_index
i
ep
f_loc_dynamic
g_offset
psh
gh_offset
if
res
validate_links
ep
ep
f_dynsym_sect_index
ep
f_dynsym_sect_strings_sect_index
errcode
if
res
DW_DLV_OK
return
res
endif
res
validate_links
ep
ep
f_symtab_sect_index
ep
f_symtab_sect_strings_sect_index
errcode
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
int
_dwarf_load_elf_sectheaders
dwarf_elf_object_access_internals_t
ep
int
errcode
int
res
if
ep
f_offsetsize
res
elf_load_sectheaders32
ep
ep
f_ehdr
ge_shoff
ep
f_ehdr
ge_shentsize
ep
f_ehdr
ge_shnum
errcode
else
if
ep
f_offsetsize
res
elf_load_sectheaders64
ep
ep
f_ehdr
ge_shoff
ep
f_ehdr
ge_shentsize
ep
f_ehdr
ge_shnum
errcode
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
if
res
DW_DLV_OK
return
res
res
_dwarf_elf_load_sectstrings
ep
ep
f_ehdr
ge_shstrndx
errcode
if
res
DW_DLV_OK
return
res
res
_dwarf_elf_load_sect_namestring
ep
errcode
if
res
DW_DLV_OK
return
res
res
_dwarf_elf_find_sym_sections
ep
errcode
if
res
DW_DLV_OK
return
res
res
_dwarf_elf_setup_all_section_groups
ep
errcode
return
res
Copyright
c
David
Anderson
All
rights
reserved
cc
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
stdio
h
include
dwarf_elf_defines
h
include
dwarf_elf_rel_detector
h
unsigned
_dwarf_is_32bit_abs_reloc
unsigned
int
type
unsigned
machine
unsigned
r
switch
machine
if
defined
EM_MIPS
defined
R_MIPS_32
case
EM_MIPS
r
if
defined
R_MIPS_32
type
R_MIPS_32
endif
if
defined
R_MIPS_TLS_DTPREL32
type
R_MIPS_TLS_DTPREL32
endif
DTPREL32
break
endif
MIPS
case
if
defined
EM_SPARC32PLUS
defined
R_SPARC_UA32
case
EM_SPARC32PLUS
r
if
defined
R_SPARC_UA32
type
R_SPARC_UA32
endif
if
defined
R_SPARC_TLS_DTPOFF32
type
R_SPARC_TLS_DTPOFF32
endif
break
endif
if
defined
EM_SPARCV9
defined
R_SPARC_UA32
case
EM_SPARCV9
r
type
R_SPARC_UA32
break
endif
if
defined
EM_SPARC
defined
R_SPARC_UA32
case
EM_SPARC
r
if
defined
R_SPARC_UA32
type
R_SPARC_UA32
endif
if
R_SPARC_TLS_DTPOFF32
type
R_SPARC_TLS_DTPOFF32
endif
break
endif
EM_SPARC
if
defined
EM_386
defined
R_386_32
defined
R_386_PC32
case
EM_386
r
if
defined
R_386_32
type
R_386_32
endif
if
defined
R_386_GOTPC
type
R_386_GOTPC
endif
if
defined
R_386_PC32
type
R_386_PC32
endif
if
defined
R_386_TLS_LDO_32
type
R_386_TLS_LDO_32
endif
if
defined
R_386_TLS_DTPOFF32
type
R_386_TLS_DTPOFF32
endif
break
endif
EM_386
if
defined
EM_SH
defined
R_SH_DIR32
case
EM_SH
r
if
defined
R_SH_DIR32
type
R_SH_DIR32
endif
if
defined
R_SH_DTPOFF32
type
R_SH_TLS_DTPOFF32
endif
break
endif
SH
if
defined
EM_IA_64
defined
R_IA64_SECREL32LSB
case
EM_IA_64
r
if
defined
R_IA64_SECREL32LSB
type
R_IA64_SECREL32LSB
endif
if
defined
R_IA64_DIR32LSB
type
R_IA64_DIR32LSB
endif
if
defined
R_IA64_DTPREL32LSB
type
R_IA64_DTPREL32LSB
endif
break
endif
EM_IA_64
if
defined
EM_ARM
defined
R_ARM_ABS32
case
EM_ARM
case
EM_AARCH64
r
if
defined
R_ARM_ABS32
type
R_ARM_ABS32
endif
if
defined
R_AARCH64_ABS32
type
R_AARCH64_ABS32
endif
if
defined
R_ARM_TLS_LDO32
type
R_ARM_TLS_LDO32
endif
break
endif
EM_ARM
On
FreeBSD
xR_PPC64_ADDR32
not
defined
so
we
use
the
xR_PPC_
names
which
have
the
proper
value
Our
headers
have
xR_PPC64_ADDR64
xR_PPC_ADDR32
so
we
use
this
one
xR_PPC64_ADDR32
R_PPC_ADDR32
xR_PPC64_DTPREL32
which
may
be
wrong
unavailable
xR_PPC64_DTPREL64
xR_PPC_DTPREL32
if
defined
EM_PPC64
defined
R_PPC_ADDR32
case
EM_PPC64
r
if
defined
R_PPC_ADDR32
type
R_PPC_ADDR32
endif
if
defined
R_PPC64_DTPREL32
type
R_PPC64_DTPREL32
endif
break
endif
EM_PPC64
if
defined
EM_PPC
defined
R_PPC_ADDR32
case
EM_PPC
r
if
defined
R_PPC_ADDR32
type
R_PPC_ADDR32
endif
if
defined
R_PPC_DTPREL32
type
R_PPC_DTPREL32
endif
break
endif
EM_PPC
if
defined
EM_S390
defined
R_390_32
case
EM_S390
r
if
defined
R_390_32
type
R_390_32
endif
if
defined
R_390_TLS_LDO32
type
R_390_TLS_LDO32
endif
break
endif
EM_S390
if
defined
EM_X86_64
defined
R_X86_64_32
defined
R_X86_64_PC32
defined
R_X86_64_DTPOFF32
if
defined
EM_K10M
case
EM_K10M
endif
if
defined
EM_L10M
case
EM_L10M
endif
case
EM_X86_64
r
if
defined
R_X86_64_PC32
type
R_X86_64_PC32
endif
if
defined
R_X86_64_32
type
R_X86_64_32
endif
if
defined
R_X86_64_DTPOFF32
type
R_X86_64_DTPOFF32
endif
break
endif
EM_X86_64
case
EM_QUALCOMM_DSP6
r
type
R_QUALCOMM_REL32
break
return
r
unsigned
_dwarf_is_64bit_abs_reloc
unsigned
int
type
unsigned
machine
unsigned
r
switch
machine
if
defined
EM_MIPS
defined
R_MIPS_64
case
EM_MIPS
r
if
defined
R_MIPS_64
type
R_MIPS_64
endif
if
defined
R_MIPS_32
type
R_MIPS_32
endif
if
defined
R_MIPS_TLS_DTPREL64
type
R_MIPS_TLS_DTPREL64
endif
break
endif
EM_MIPS
if
defined
EM_SPARC32PLUS
defined
R_SPARC_UA64
case
EM_SPARC32PLUS
r
type
R_SPARC_UA64
break
endif
if
defined
EM_SPARCV9
defined
R_SPARC_UA64
case
EM_SPARCV9
r
if
defined
R_SPARC_UA64
type
R_SPARC_UA64
endif
if
defined
R_SPARC_TLS_DTPOFF64
type
R_SPARC_TLS_DTPOFF64
endif
break
endif
if
defined
EM_SPARC
defined
R_SPARC_UA64
case
EM_SPARC
r
if
defined
R_SPARC_UA64
type
R_SPARC_UA64
endif
if
defined
R_SPARC_TLS_DTPOFF64
type
R_SPARC_TLS_DTPOFF64
endif
break
endif
EM_SPARC
if
defined
EM_IA_64
defined
R_IA64_SECREL64LSB
case
EM_IA_64
r
if
defined
R_IA64_SECREL64LSB
type
R_IA64_SECREL64LSB
endif
if
defined
R_IA64_SECREL32LSB
type
R_IA64_SECREL32LSB
endif
if
defined
R_IA64_DIR64LSB
type
R_IA64_DIR64LSB
endif
if
defined
R_IA64_DTPREL64LSB
type
R_IA64_DTPREL64LSB
endif
if
defined
R_IA64_REL32LSB
type
R_IA64_REL32LSB
endif
break
endif
EM_IA_64
if
defined
EM_PPC64
defined
R_PPC64_ADDR64
case
EM_PPC64
r
if
defined
R_PPC64_ADDR64
type
R_PPC64_ADDR64
endif
if
defined
R_PPC64_DTPREL64
type
R_PPC64_DTPREL64
endif
break
endif
EM_PPC64
if
defined
EM_S390
defined
R_390_64
case
EM_S390
r
if
defined
R_390_64
type
R_390_64
endif
if
defined
R_390_TLS_LDO64
type
R_390_TLS_LDO64
endif
break
endif
EM_390
if
defined
EM_X86_64
defined
R_X86_64_64
if
defined
EM_K10M
case
EM_K10M
endif
if
defined
EM_L10M
case
EM_L10M
endif
case
EM_X86_64
r
if
defined
R_X86_64_64
type
R_X86_64_64
endif
if
defined
R_X86_64_PC64
type
R_X86_64_PC64
endif
if
defined
R_X86_64_DTPOFF32
type
R_X86_64_DTPOFF64
endif
break
endif
EM_X86_64
if
defined
EM_AARCH64
defined
R_AARCH64_ABS64
case
EM_AARCH64
r
if
defined
R_AARCH64_ABS64
type
R_AARCH64_ABS64
endif
break
endif
EM_AARCH64
return
r
Copyright
c
David
Anderson
All
rights
reserved
cc
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
file
reads
the
parts
of
an
Elf
file
appropriate
to
reading
DWARF
debugging
data
Overview
_dwarf_elf_nlsetup
Does
all
elf
setup
calls
_dwarf_elf_access_init
calls
_dwarf_elf_object_access_internals_init
Creates
internals
record
M
dwarf_elf_object_access_internals_t
Sets
flags
data
in
internals
record
Loads
elf
object
data
needed
later
Sets
methods
struct
to
access
elf
object
calls
_dwarf_object_init_b
Creates
Dwarf_Debug
independent
of
any
elf
code
Sets
internals
record
into
dbg
_dwarf_destruct_elf_nlaccess
This
frees
the
elf
internals
record
created
in
_dwarf_elf_object_access_internals_init
in
case
of
errors
during
setup
or
when
dwarf_finish
is
called
Works
safely
for
partially
or
fully
set
up
elf
internals
record
Other
than
in
_dwarf_elf_nlsetup
the
elf
code
knows
nothing
about
Dwarf_Debug
and
the
rest
of
libdwarf
knows
nothing
about
the
content
of
the
object
type
specific
for
Elf
here
internals
record
include
config
h
include
stdio
h
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
open
include
time
h
ifdef
_WIN32
include
io
h
lseek
read
close
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf
h
include
libdwarf_private
h
include
dwarf_base_types
h
include
dwarf_opaque
h
include
dwarf_error
h
for
_dwarf_error
declaration
include
dwarf_reading
h
include
memcpy_swap
h
include
dwarf_object_read_common
h
include
dwarf_object_detector
h
include
dwarf_elfstructs
h
include
dwarf_elf_defines
h
include
dwarf_elf_rel_detector
h
include
dwarf_elfread
h
ifndef
TYP
define
TYP
n
l
char
n
l
endif
TYPE
ifdef
WORDS_BIGENDIAN
define
READ_UNALIGNED_SAFE
dbg
dest
source
length
do
Dwarf_Unsigned
_ltmp
dbg
de_copy_word
char
sizeof
_ltmp
length
source
length
dest
_ltmp
while
define
WRITE_UNALIGNED_LOCAL
dbg
dest
source
srclength
len_out
dbg
de_copy_word
dest
char
source
srclength
len_out
len_out
else
LITTLE
ENDIAN
define
READ_UNALIGNED_SAFE
dbg
dest
source
srclength
do
Dwarf_Unsigned
_ltmp
dbg
de_copy_word
char
source
srclength
dest
_ltmp
while
define
WRITE_UNALIGNED_LOCAL
dbg
dest
source
srclength
len_out
dbg
de_copy_word
dest
char
source
len_out
endif
ENDIAN
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
static
int
_dwarf_elf_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
static
Dwarf_Endianness
elf_get_nolibelf_byte_order
void
obj
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
return
elf
f_endian
static
Dwarf_Small
elf_get_nolibelf_length_size
void
obj
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
return
elf
f_offsetsize
static
Dwarf_Small
elf_get_nolibelf_pointer_size
void
obj
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
return
elf
f_pointersize
static
Dwarf_Unsigned
elf_get_nolibelf_section_count
void
obj
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
return
elf
f_loc_shdr
g_count
static
int
elf_get_nolibelf_section_info
void
obj
Dwarf_Half
section_index
Dwarf_Obj_Access_Section
return_section
int
error
UNUSEDARG
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
if
section_index
elf
f_loc_shdr
g_count
struct
generic_shdr
sp
sp
elf
f_shdr
section_index
return_section
addr
sp
gh_addr
return_section
type
sp
gh_type
return_section
size
sp
gh_size
return_section
name
sp
gh_namestring
return_section
link
sp
gh_link
return_section
info
sp
gh_info
return_section
entrysize
sp
gh_entsize
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
elf_load_nolibelf_section
void
obj
Dwarf_Half
section_index
Dwarf_Small
return_data
int
error
dwarf_elf_object_access_internals_t
elf
dwarf_elf_object_access_internals_t
obj
if
section_index
section_index
elf
f_loc_shdr
g_count
int
res
struct
generic_shdr
sp
elf
f_shdr
section_index
if
sp
gh_content
return_data
Dwarf_Small
sp
gh_content
return
DW_DLV_OK
if
sp
gh_size
return
DW_DLV_NO_ENTRY
Guarding
against
bad
values
and
against
overflow
if
sp
gh_size
elf
f_filesize
sp
gh_offset
elf
f_filesize
sp
gh_size
sp
gh_offset
elf
f_filesize
error
DW_DLE_ELF_SECTION_ERROR
return
DW_DLV_ERROR
sp
gh_content
malloc
size_t
sp
gh_size
if
sp
gh_content
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
elf
f_fd
sp
gh_content
off_t
sp
gh_offset
size_t
sp
gh_size
off_t
elf
f_filesize
error
if
res
DW_DLV_OK
free
sp
gh_content
sp
gh_content
return
res
return_data
Dwarf_Small
sp
gh_content
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
_dwarf_get_elf_flags_func_nl
void
obj_in
Dwarf_Half
section_index
Dwarf_Unsigned
flags_out
Dwarf_Unsigned
addralign_out
int
error
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
shp
ep
dwarf_elf_object_access_internals_t
obj_in
if
section_index
Nothing
to
do
Empty
section
return
DW_DLV_OK
if
section_index
ep
f_loc_shdr
g_count
error
DW_DLE_SECTION_INDEX_BAD
return
DW_DLV_ERROR
shp
ep
f_shdr
section_index
flags_out
shp
gh_flags
addralign_out
shp
gh_addralign
return
DW_DLV_OK
define
MATCH_REL_SEC
i_
s_
r_
if
i_
s_
dss_index
r_
return
DW_DLV_OK
static
int
find_section_to_relocate
Dwarf_Debug
dbg
Dwarf_Half
section_index
struct
Dwarf_Section_s
relocatablesec
int
error
MATCH_REL_SEC
section_index
dbg
de_debug_info
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_abbrev
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_line
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_loc
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_aranges
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_macinfo
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_pubnames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_ranges
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_frame
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_frame_eh_gnu
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_pubtypes
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_funcnames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_typenames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_varnames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_weaknames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_types
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_macro
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_rnglists
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_loclists
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_aranges
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_sup
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_str_offsets
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_addr
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_gnu_pubnames
relocatablesec
MATCH_REL_SEC
section_index
dbg
de_debug_gnu_pubtypes
relocatablesec
dbg
de_debug_tu_index
reloctablesec
dbg
de_debug_cu_index
reloctablesec
dbg
de_debug_gdbindex
reloctablesec
dbg
de_debug_str
syms
de_elf_symtab
syms
de_elf_strtab
syms
error
DW_DLE_RELOC_SECTION_MISMATCH
return
DW_DLV_ERROR
Returns
DW_DLV_OK
if
it
works
else
DW_DLV_ERROR
The
caller
may
decide
to
ignore
the
errors
or
report
them
static
int
update_entry
Dwarf_Debug
dbg
dwarf_elf_object_access_internals_t
obj
struct
generic_rela
rela
Dwarf_Small
target_section
Dwarf_Unsigned
target_section_size
int
error
unsigned
int
type
unsigned
int
sym_idx
Dwarf_Unsigned
offset
Dwarf_Signed
addend
Dwarf_Unsigned
reloc_size
Dwarf_Half
machine
obj
f_machine
struct
generic_symentry
symp
int
is_rela
rela
gr_is_rela
offset
rela
gr_offset
addend
rela
gr_addend
type
unsigned
int
rela
gr_type
sym_idx
unsigned
int
rela
gr_sym
if
sym_idx
obj
f_loc_symtab
g_count
error
DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD
return
DW_DLV_ERROR
symp
obj
f_symtab
sym_idx
if
offset
target_section_size
If
offset
really
big
any
add
will
overflow
So
lets
stop
early
if
offset
is
corrupt
error
DW_DLE_RELOC_INVALID
return
DW_DLV_ERROR
Determine
relocation
size
if
_dwarf_is_32bit_abs_reloc
type
machine
reloc_size
else
if
_dwarf_is_64bit_abs_reloc
type
machine
reloc_size
else
if
machine
EM_X86_64
type
R_X86_64_NONE
There
is
nothing
to
do
return
DW_DLV_OK
else
error
DW_DLE_RELOC_SECTION_RELOC_TARGET_SIZE_UNKNOWN
return
DW_DLV_ERROR
if
offset
reloc_size
offset
Another
check
for
overflow
error
DW_DLE_RELOC_INVALID
return
DW_DLV_ERROR
if
offset
reloc_size
target_section_size
error
DW_DLE_RELOC_INVALID
return
DW_DLV_ERROR
Assuming
we
do
not
need
to
do
a
READ_UNALIGNED
here
at
target_section
offset
and
add
its
value
to
outval
Some
ABIs
say
no
read
for
example
MIPS
but
if
some
do
then
which
ones?
rel
addend
is
or
rela
Dwarf_Small
targ
target_section
offset
Dwarf_Unsigned
presentval
Dwarf_Unsigned
outval
if
is_rela
READ_UNALIGNED_SAFE
dbg
presentval
targ
reloc_size
There
is
no
addend
in
rel
Normally
presentval
is
correct
and
st_value
will
be
zero
But
a
few
compilers
have
presentval
zero
and
st_value
set
outval
presentval
symp
gs_value
addend
WRITE_UNALIGNED_LOCAL
dbg
targ
sizeof
outval
reloc_size
return
DW_DLV_OK
Somewhat
arbitrarily
we
attempt
to
apply
all
the
relocations
we
can
and
still
notify
the
caller
of
at
least
one
error
if
we
found
any
errors
static
int
apply_rela_entries
Dwarf_Debug
dbg
Section_index
of
the
relocation
section
rela
entries
Dwarf_Half
r_section_index
dwarf_elf_object_access_internals_t
obj
relocatablesec
is
the
debug_info
etc
in
Dwarf_Debug
struct
Dwarf_Section_s
relocatablesec
int
error
int
return_res
DW_DLV_OK
struct
generic_shdr
rels_shp
Dwarf_Unsigned
relcount
Dwarf_Unsigned
i
if
r_section_index
obj
f_loc_shdr
g_count
error
DW_DLE_SECTION_INDEX_BAD
return
DW_DLV_ERROR
rels_shp
obj
f_shdr
r_section_index
relcount
rels_shp
gh_relcount
if
relcount
Nothing
to
do
return
DW_DLV_OK
if
rels_shp
gh_rels
something
wrong
error
DW_DLE_RELOCS_ERROR
return
DW_DLV_ERROR
for
i
i
relcount
i
int
res
update_entry
dbg
obj
rels_shp
gh_rels
i
relocatablesec
dss_data
relocatablesec
dss_size
error
if
res
DW_DLV_OK
We
try
to
keep
going
not
stop
return_res
res
return
return_res
Find
the
section
data
in
dbg
and
find
all
the
relevant
sections
Then
do
relocations
section_index
is
the
index
of
a
debug_info
for
example
so
we
have
to
find
the
section
s
with
relocations
targeting
section_index
Normally
there
is
exactly
one
such
though
static
int
elf_relocations_nolibelf
void
obj_in
Dwarf_Half
section_index
Dwarf_Debug
dbg
int
error
int
res
DW_DLV_ERROR
dwarf_elf_object_access_internals_t
obj
struct
Dwarf_Section_s
relocatablesec
unsigned
section_with_reloc_records
if
section_index
return
DW_DLV_NO_ENTRY
obj
dwarf_elf_object_access_internals_t
obj_in
The
section
to
relocate
must
already
be
loaded
into
memory
This
just
turns
section_index
into
a
pointer
to
a
de_debug_info
or
other
section
record
in
Dwarf_Debug
res
find_section_to_relocate
dbg
section_index
error
if
res
DW_DLV_OK
return
res
Now
we
know
the
Dwarf_Section_s
section
we
need
to
relocate
So
lets
find
the
rela
section
s
targeting
this
Sun
and
possibly
others
do
not
always
set
sh_link
in
debug_
sections
So
we
cannot
do
full
consistency
checks
FIXME
This
approach
assumes
there
is
only
one
relocation
section
applying
to
section
section_index
section_with_reloc_records
relocatablesec
dss_reloc_index
if
section_with_reloc_records
Something
is
wrong
error
DW_DLE_RELOC_SECTION_MISSING_INDEX
return
DW_DLV_ERROR
The
relocations
if
they
exist
have
been
loaded
The
symtab
was
already
loaded
if
obj
f_symtab
obj
f_symtab_sect_strings
error
DW_DLE_DEBUG_SYMTAB_ERR
return
DW_DLV_ERROR
if
obj
f_symtab_sect_index
relocatablesec
dss_reloc_link
Something
is
wrong
error
DW_DLE_RELOC_MISMATCH_RELOC_INDEX
return
DW_DLV_ERROR
We
have
all
the
data
we
need
in
memory
Now
we
apply
the
relocs
in
section_with_reloc_records
to
the
target
relocablesec
res
apply_rela_entries
dbg
section_with_reloc_records
obj
relocatablesec
error
return
res
void
_dwarf_destruct_elf_nlaccess
struct
Dwarf_Obj_Access_Interface_s
aip
dwarf_elf_object_access_internals_t
ep
struct
generic_shdr
shp
Dwarf_Unsigned
shcount
Dwarf_Unsigned
i
ep
dwarf_elf_object_access_internals_t
aip
object
free
ep
f_ehdr
shp
ep
f_shdr
shcount
ep
f_loc_shdr
g_count
for
i
i
shcount
i
shp
free
shp
gh_rels
shp
gh_rels
free
shp
gh_content
shp
gh_content
free
shp
gh_sht_group_array
shp
gh_sht_group_array
shp
gh_sht_group_array_count
free
ep
f_shdr
ep
f_loc_shdr
g_count
free
ep
f_phdr
free
ep
f_elf_shstrings_data
free
ep
f_dynamic
free
ep
f_symtab_sect_strings
free
ep
f_dynsym_sect_strings
free
ep
f_symtab
free
ep
f_dynsym
if
TRUE
close
f_fd
on
destruct
if
ep
f_destruct_close_fd
close
ep
f_fd
ep
f_ident
X
free
ep
f_path
free
ep
free
aip
int
_dwarf_elf_nlsetup
int
fd
char
true_path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Obj_Access_Interface
binary_interface
dwarf_elf_object_access_internals_t
intfc
int
res
DW_DLV_OK
int
localerrnum
res
_dwarf_elf_object_access_init
fd
ftype
endian
offsetsize
filesize
if
res
DW_DLV_OK
if
res
DW_DLV_NO_ENTRY
return
res
_dwarf_error
NULL
error
localerrnum
return
DW_DLV_ERROR
allocates
and
initializes
Dwarf_Debug
generic
code
res
dwarf_object_init_b
binary_interface
errhand
errarg
groupnumber
dbg
error
if
res
DW_DLV_OK
_dwarf_destruct_elf_nlaccess
binary_interface
return
res
intfc
binary_interface
object
intfc
f_path
strdup
true_path
return
res
dwarf_elf_access
method
table
for
use
with
non
libelf
See
also
the
methods
table
in
dwarf_elf_access
c
for
libelf
static
Dwarf_Obj_Access_Methods
const
elf_nlmethods
elf_get_nolibelf_section_info
elf_get_nolibelf_byte_order
elf_get_nolibelf_length_size
elf_get_nolibelf_pointer_size
elf_get_nolibelf_section_count
elf_load_nolibelf_section
elf_relocations_nolibelf
On
any
error
this
frees
internals
argument
static
int
_dwarf_elf_object_access_internals_init
dwarf_elf_object_access_internals_t
internals
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
int
errcode
dwarf_elf_object_access_internals_t
intfc
internals
Dwarf_Unsigned
i
struct
Dwarf_Obj_Access_Interface_s
localdoas
int
res
Must
malloc
as
_dwarf_destruct_elf_access
forces
that
due
to
other
uses
localdoas
struct
Dwarf_Obj_Access_Interface_s
malloc
sizeof
struct
Dwarf_Obj_Access_Interface_s
if
localdoas
free
internals
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
localdoas
sizeof
struct
Dwarf_Obj_Access_Interface_s
E
is
used
with
libelf
F
with
this
elf
reader
intfc
f_ident
F
intfc
f_ident
intfc
f_fd
fd
intfc
f_is_64bit
offsetsize
FALSE
intfc
f_offsetsize
offsetsize
intfc
f_pointersize
offsetsize
intfc
f_filesize
filesize
intfc
f_ftype
ftype
intfc
f_destruct_close_fd
FALSE
ifdef
WORDS_BIGENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
f_copy_word
_dwarf_memcpy_swap_bytes
intfc
f_endian
DW_OBJECT_LSB
else
intfc
f_copy_word
_dwarf_memcpy_noswap_bytes
intfc
f_endian
DW_OBJECT_MSB
else
LITTLE
ENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
f_copy_word
_dwarf_memcpy_noswap_bytes
intfc
f_endian
DW_OBJECT_LSB
else
intfc
f_copy_word
_dwarf_memcpy_swap_bytes
intfc
f_endian
DW_OBJECT_MSB
endif
LITTLE
BIG
ENDIAN
_dwarf_get_elf_flags_func_ptr
_dwarf_get_elf_flags_func_nl
The
following
sets
f_machine
res
_dwarf_load_elf_header
intfc
errcode
if
res
DW_DLV_OK
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_elf_nlaccess
localdoas
localdoas
return
res
Not
loading
progheaders
res
_dwarf_load_elf_sectheaders
intfc
errcode
if
res
DW_DLV_OK
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_elf_nlaccess
localdoas
localdoas
return
res
We
are
not
looking
at
symbol
strings
for
now
res
_dwarf_load_elf_symstr
intfc
errcode
if
res
DW_DLV_ERROR
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_elf_nlaccess
localdoas
localdoas
return
res
res
_dwarf_load_elf_symtab_symbols
intfc
errcode
if
res
DW_DLV_ERROR
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_elf_nlaccess
localdoas
localdoas
return
res
for
i
i
intfc
f_loc_shdr
g_count
i
struct
generic_shdr
shp
Dwarf_Unsigned
section_type
enum
RelocRela
localrel
RelocIsRela
shp
intfc
f_shdr
i
section_type
shp
gh_type
if
shp
gh_namestring
A
serious
error
which
we
ignore
here
as
it
will
be
caught
elsewhere
if
necessary
continue
else
if
section_type
SHT_REL
strncmp
rel
shp
gh_namestring
localrel
RelocIsRel
else
if
section_type
SHT_RELA
strncmp
rela
shp
gh_namestring
localrel
RelocIsRela
else
continue
ASSERT
local
rel
is
either
RelocIsRel
or
RelocIsRela
Never
any
other
value
Possibly
we
should
check
if
the
target
section
is
one
we
care
about
before
loading
rela
FIXME
res
_dwarf_load_elf_relx
intfc
i
localrel
errcode
if
res
DW_DLV_ERROR
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_elf_nlaccess
localdoas
localdoas
return
res
free
localdoas
localdoas
return
DW_DLV_OK
static
int
_dwarf_elf_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
int
res
dwarf_elf_object_access_internals_t
internals
Dwarf_Obj_Access_Interface
intfc
internals
malloc
sizeof
dwarf_elf_object_access_internals_t
if
internals
localerrnum
DW_DLE_ALLOC_FAIL
Impossible
case
we
hope
Give
up
return
DW_DLV_ERROR
memset
internals
sizeof
internals
res
_dwarf_elf_object_access_internals_init
internals
fd
ftype
endian
offsetsize
filesize
localerrnum
if
res
DW_DLV_OK
return
res
intfc
malloc
sizeof
Dwarf_Obj_Access_Interface
if
intfc
Impossible
case
we
hope
Give
up
free
internals
localerrnum
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Initialize
the
interface
struct
intfc
object
internals
intfc
methods
binary_interface
intfc
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
endif
HAVE_SYS_STAT_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarfstring
h
include
dwarf_error
h
undef
DEBUG
Array
to
hold
string
representation
of
errors
Any
time
a
define
is
added
to
the
list
in
libdwarf
h
a
string
should
be
added
to
this
Array
include
dwarf_errmsg_list
h
This
function
performs
error
handling
as
described
in
the
libdwarf
consumer
document
section
Dbg
is
the
Dwarf_debug
structure
being
processed
Error
is
a
pointer
to
the
pointer
to
the
error
descriptor
that
will
be
returned
Errval
is
an
error
code
listed
in
dwarf_error
h
If
the
malloc
arena
is
exhausted
we
return
a
pointer
to
a
special
static
error
record
This
special
singleton
is
mostly
ignored
by
dwarf_dealloc
Users
should
not
be
storing
Dwarf_Error
pointers
for
long
so
this
singleton
is
only
going
to
cause
confusion
when
callers
try
to
save
an
out
of
memory
Dwarf_Error
pointer
The
_dwarf_failsafe_error
is
intended
to
be
an
improvement
over
an
abort
call
The
failsafe
means
we
will
not
abort
due
to
a
Dwarf_Error
struct
creation
The
user
provides
an
explanatory
string
the
error
number
itself
explains
little
This
prepends
DW_DLE_USER_DECLARED_ERROR
to
the
caller
provided
string
New
in
April
Used
by
dwarfdump
in
a
few
circumstances
void
dwarf_error_creation
Dwarf_Debug
dbg
Dwarf_Error
err
char
errmsg
dwarfstring
m
if
dbg
return
dwarfstring_constructor
dwarfstring_append
DW_DLE_USER_DECLARED_ERROR
dwarfstring_append
errmsg
_dwarf_error_string
dbg
err
DW_DLE_USER_DECLARED_ERROR
dwarfstring_string
dwarfstring_destructor
void
_dwarf_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
errval
_dwarf_error_string
dbg
error
errval
void
_dwarf_error_string
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
errval
char
msg
Dwarf_Error
errptr
Allow
NULL
dbg
on
entry
since
sometimes
that
can
happen
and
we
want
to
report
the
upper
level
error
not
this
one
if
error
If
dbg
is
NULL
use
the
alternate
error
struct
However
this
will
overwrite
the
earlier
error
if
dbg
errptr
Dwarf_Error
_dwarf_get_alloc
dbg
DW_DLA_ERROR
if
errptr
errptr
errptr
er_static_alloc
DE_STATIC
else
errptr
er_static_alloc
DE_STANDARD
else
We
have
no
dbg
to
work
with
dwarf_init
failed
We
hack
up
a
special
area
errptr
_dwarf_special_no_dbg_error_malloc
if
errptr
errptr
errptr
er_static_alloc
DE_STATIC
ifdef
DEBUG
printf
libdwarfdetector
no
dbg
using
DE_STATIC
alloc
addr
lx
line
d
s
n
unsigned
long
errptr
__LINE__
__FILE__
endif
DEBUG
else
errptr
er_static_alloc
DE_MALLOC
ifdef
DEBUG
printf
libdwarfdetector
no
dbg
static
DE_MALLOC
alloc
addr
lx
line
d
s
n
unsigned
long
errptr
__LINE__
__FILE__
endif
DEBUG
errptr
er_errval
errval
if
msg
dwarfstring
em
ifdef
DEBUG
printf
libdwarfdetector
ALLOC
creating
error
string
s
errval
ld
errptr
lx
n
msg
long
errval
unsigned
long
errptr
endif
em
dwarfstring
calloc
sizeof
dwarfstring
if
em
dwarfstring_constructor
em
dwarfstring_append
em
msg
errptr
er_msg
void
em
error
errptr
return
if
dbg
dbg
de_errhand
NULL
errptr
Dwarf_Error
_dwarf_get_alloc
dbg
DW_DLA_ERROR
if
errptr
NULL
errptr
errptr
er_static_alloc
DE_STATIC
errptr
er_errval
errval
dbg
de_errhand
errptr
dbg
de_errarg
return
fflush
stdout
fprintf
stdout
nNow
abort
in
libdwarf
No
error
argument
or
handler
available
n
fflush
stdout
abort
Dwarf_Unsigned
dwarf_errno
Dwarf_Error
error
if
error
return
return
error
er_errval
char
dwarf_errmsg_by_number
Dwarf_Unsigned
errornum
if
errornum
Dwarf_Signed
sizeof
_dwarf_errmsgs
sizeof
char
return
Dwarf_Error
value
out
of
range
return
char
_dwarf_errmsgs
errornum
char
dwarf_errmsg
Dwarf_Error
error
if
error
return
Dwarf_Error
is
NULL
if
error
er_msg
return
dwarfstring_string
error
er_msg
return
dwarf_errmsg_by_number
error
er_errval
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
for
debugging
only
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
uintptr_t
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
static
int
_dwarf_find_CU_Context_given_sig
Dwarf_Debug
dbg
Dwarf_Sig8
sig_in
Dwarf_CU_Context
cu_context_out
Dwarf_Bool
is_info_out
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Bool
is_info
FALSE
int
loopcount
int
lres
Dwarf_Debug_InfoTypes
dis
struct
Dwarf_Section_s
secdp
Loop
once
with
is_info
once
with
is_info
Then
stop
for
loopcount
loopcount
Dwarf_CU_Context
prev_cu_context
Dwarf_Unsigned
section_size
Dwarf_Unsigned
new_cu_offset
is_info
is_info
if
is_info
dis
de_info_reading
secdp
de_debug_info
else
dis
de_types_reading
secdp
de_debug_types
lres
_dwarf_load_die_containing_section
dbg
is_info
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
continue
Lets
see
if
we
already
have
the
CU
we
need
for
cu_context
dis
de_cu_context_list
cu_context
cu_context
cu_context
cc_next
prev_cu_context
cu_context
if
memcmp
sig_in
cc_signature
sizeof
Dwarf_Sig8
continue
if
cu_context
cc_unit_type
DW_UT_split_type||
cu_context
cc_unit_type
DW_UT_type
cu_context_out
cu_context
is_info_out
cu_context
cc_is_info
return
DW_DLV_OK
if
prev_cu_context
Dwarf_CU_Context
lcu_context
prev_cu_context
new_cu_offset
_dwarf_calculate_next_cu_context_offset
lcu_context
else
new_cu_offset
section_size
secdp
dss_size
for
new_cu_offset
section_size
new_cu_offset
_dwarf_calculate_next_cu_context_offset
cu_context
if
lres
_dwarf_load_die_containing_section
dbg
is_info
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
continue
endif
lres
_dwarf_create_a_new_cu_context_record_on_list
dbg
dis
is_info
section_size
new_cu_offset
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
break
if
memcmp
sig_in
cc_signature
sizeof
Dwarf_Sig8
continue
if
cu_context
cc_unit_type
DW_UT_split_type||
cu_context
cc_unit_type
DW_UT_type
cu_context_out
cu_context
is_info_out
cu_context
cc_is_info
return
DW_DLV_OK
Loop
end
Not
found
return
DW_DLV_NO_ENTRY
We
will
search
to
find
a
CU
with
the
indicated
signature
The
attribute
leading
us
here
is
often
We
are
looking
for
a
DW_UT_split_type
or
DW_UT_type
CU
DW_AT_type
and
if
DWARF4
that
means
our
first
look
is
to
is_info
int
dwarf_find_die_given_sig8
Dwarf_Debug
dbg
Dwarf_Sig8
ref
Dwarf_Die
die_out
Dwarf_Bool
is_info
Dwarf_Error
error
int
res
Dwarf_Die
ndi
Dwarf_CU_Context
context
Dwarf_Bool
result_is_info
FALSE
Dwarf_Unsigned
dieoffset
res
_dwarf_find_CU_Context_given_sig
dbg
ref
error
if
res
DW_DLV_OK
return
res
dieoffset
context
cc_debug_offset
context
cc_signature_offset
res
dwarf_offdie_b
dbg
dieoffset
result_is_info
error
if
res
DW_DLV_OK
die_out
ndi
is_info
result_is_info
return
res
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_str_offsets
h
include
dwarf_loc
h
include
dwarf_rnglists
h
static
int
load_xu_loclists_into_cucontext
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
const
char
xu_type
UNUSEDARG
int
fsd_index
Dwarf_Error
error
UNUSEDARG
Dwarf_Unsigned
size
Dwarf_Unsigned
soff_hdroffset
Dwarf_Unsigned
soff_size
struct
Dwarf_Loclists_Context_s
localcontxt
Dwarf_Loclists_Context
buildhere
Dwarf_Unsigned
nextset
int
res
size
fsd
pcu_size
fsd_index
soff_hdroffset
fsd
pcu_offset
fsd_index
soff_size
dbg
de_debug_loclists
dss_size
if
soff_size
return
DW_DLV_NO_ENTRY
if
soff_hdroffset
soff_size
Something
is
badly
wrong
Ignore
it
here
return
DW_DLV_NO_ENTRY
memset
buildhere
sizeof
localcontxt
res
_dwarf_internal_read_loclists_header
dbg
soff_size
dbg
de_debug_loclists
dss_data
dbg
de_debug_loclists
dss_data
soff_size
soff_hdroffset
buildhere
error
if
res
DW_DLV_OK
return
res
cu_context
cc_loclists_base_present
TRUE
cu_context
cc_loclists_base_contr_size
size
cu_context
cc_loclists_base
buildhere
lc_offsets_off_in_sect
return
DW_DLV_OK
ASSERT
cc_str_offsets_base_present
FALSE
ASSERT
cc_str_offsets_header_length_present
FALSE
If
debug_cu_index
or
debug_tu_index
is
present
it
might
help
us
find
the
offset
for
this
CU
s
debug_str_offsets
static
int
load_xu_str_offsets_into_cucontext
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
const
char
xu_type
UNUSEDARG
int
fsd_index
Dwarf_Error
error
UNUSEDARG
Dwarf_Small
soff_secptr
Dwarf_Small
soff_hdrptr
Dwarf_Unsigned
soff_hdroffset
Dwarf_Unsigned
soff_size
Dwarf_Small
soff_eptr
int
res
res
_dwarf_load_section
dbg
de_debug_str_offsets
error
if
res
DW_DLV_OK
return
res
soff_hdroffset
fsd
pcu_offset
fsd_index
soff_secptr
dbg
de_debug_str_offsets
dss_data
soff_size
dbg
de_debug_str_offsets
dss_size
soff_eptr
soff_secptr
soff_size
soff_hdrptr
soff_secptr
soff_hdroffset
if
soff_hdroffset
soff_size
Something
is
badly
wrong
Ignore
it
here
return
DW_DLV_NO_ENTRY
Dwarf_Unsigned
length
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
header_length
res
_dwarf_read_str_offsets_header
dbg
soff_hdrptr
soff_size
soff_hdroffset
soff_eptr
cu_context
error
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
res
DW_DLV_NO_ENTRY
return
res
cu_context
cc_str_offsets_base_present
TRUE
cu_context
cc_str_offsets_header_length_present
TRUE
cu_context
cc_str_offsets_header_offset
soff_hdroffset
cu_context
cc_str_offsets_base
soff_hdroffset
header_length
cu_context
cc_str_offsets_header_length
header_length
cu_context
cc_str_offsets_offset_size
offset_size
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
load_xu_debug_macro_into_cucontext
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
const
char
xu_type
UNUSEDARG
int
fsd_index
Dwarf_Error
error
UNUSEDARG
Dwarf_Unsigned
size
Dwarf_Unsigned
soff_hdroffset
Dwarf_Unsigned
soff_size
int
res
res
_dwarf_load_section
dbg
de_debug_macro
error
if
res
DW_DLV_OK
return
res
size
fsd
pcu_size
fsd_index
soff_hdroffset
fsd
pcu_offset
fsd_index
soff_size
dbg
de_debug_macro
dss_size
if
soff_size
return
DW_DLV_NO_ENTRY
if
soff_hdroffset
soff_size
Something
is
badly
wrong
Ignore
it
here
return
DW_DLV_NO_ENTRY
Presently
assuming
that
DW_AT_macros
and
the
fission
entry
both
indicate
the
beginning
of
a
debug_macro
sectiom
macro
header
not
true
for
str_offsets
or
for
loclists
cu_context
cc_macro_base_present
TRUE
cu_context
cc_macro_base_contr_size
size
cu_context
cc_macro_base
soff_hdroffset
FIXME
cc_macro_header_length_present?
return
DW_DLV_OK
static
int
load_xu_rnglists_into_cucontext
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
const
char
xu_type
UNUSEDARG
int
fsd_index
Dwarf_Error
error
UNUSEDARG
Dwarf_Unsigned
size
Dwarf_Unsigned
soff_hdroffset
Dwarf_Unsigned
soff_size
struct
Dwarf_Rnglists_Context_s
builddata
Dwarf_Rnglists_Context
buildhere
Dwarf_Unsigned
nextoffset
int
res
res
_dwarf_load_section
dbg
de_debug_rnglists
error
if
res
DW_DLV_OK
return
res
size
fsd
pcu_size
fsd_index
soff_hdroffset
fsd
pcu_offset
fsd_index
soff_size
dbg
de_debug_rnglists
dss_size
if
soff_size
return
DW_DLV_NO_ENTRY
if
soff_hdroffset
soff_size
Something
is
badly
wrong
Ignore
it
here
return
DW_DLV_NO_ENTRY
memset
buildhere
sizeof
builddata
res
_dwarf_internal_read_rnglists_header
dbg
soff_size
dbg
de_debug_rnglists
dss_data
dbg
de_debug_rnglists
dss_data
soff_size
soff_hdroffset
buildhere
error
if
res
DW_DLV_OK
return
res
cu_context
cc_rnglists_base
buildhere
rc_offsets_off_in_sect
cu_context
cc_rnglists_base_present
TRUE
cu_context
cc_rnglists_base_contr_size
size
FIXME
cc_rnglists_header_length_present?
return
DW_DLV_OK
static
const
char
keylist
cu
tu
ASSERT
The
context
has
a
signature
_dwarf_make_CU_Context
calls
finish_up_cu_context_from_cudie
which
calls
us
here
Then
_dwarf_make_CU_Context
calls
_dwarf_merge_all_base_attrs_of_cu_die
if
there
is
a
tied
executable
object
known
int
_dwarf_find_all_offsets_via_fission
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Error
error
struct
Dwarf_Debug_Fission_Per_CU_s
fission_data
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
int
si
int
smax
int
fdres
int
res
fsd
for
si
si
smax
si
int
sec_index
memset
sizeof
fission_data
fdres
dwarf_get_debugfission_for_key
dbg
cc_signature
keylist
si
fsd
error
if
fdres
DW_DLV_NO_ENTRY
continue
if
fdres
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
continue
for
sec_index
sec_index
DW_FISSION_SECT_COUNT
sec_index
if
fsd
pcu_size
sec_index
continue
res
DW_DLV_OK
switch
sec_index
these
handled
elsewhere
such
as
by
_dwarf_get_dwp_extra_offset
_dwarf_get_fission_addition_die
case
DW_SECT_INFO
case
DW_SECT_ABBREV
case
DW_SECT_LINE
case
DW_SECT_LOCLISTS
res
load_xu_loclists_into_cucontext
dbg
cu_context
fsd
keylist
si
sec_index
error
break
case
DW_SECT_STR_OFFSETS
res
load_xu_str_offsets_into_cucontext
dbg
cu_context
fsd
keylist
si
sec_index
error
break
case
DW_SECT_MACRO
res
load_xu_debug_macro_into_cucontext
dbg
cu_context
fsd
keylist
si
sec_index
error
break
case
DW_SECT_RNGLISTS
res
load_xu_rnglists_into_cucontext
dbg
cu_context
fsd
keylist
si
sec_index
error
break
default
res
DW_DLV_OK
break
if
res
DW_DLV_ERROR
return
res
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarfstring
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_die_deliv
h
include
dwarf_str_offsets
h
include
dwarfstring
h
It
is
necessary
at
times
to
cause
errors
of
this
sort
in
determining
what
we
really
have
So
best
to
avoid
too
much
malloc
and
free
hence
the
static
constructor
dwarfstring
will
use
malloc
if
we
guess
too
small
for
the
size
of
mbuf
static
void
generate_form_error
Dwarf_Debug
dbg
Dwarf_Error
error
unsigned
form
int
err_code
const
char
errname
const
char
funcname
dwarfstring
m
char
mbuf
DWARFSTRING_ALLOC_SIZE
const
char
defaultname
unknown
form
dwarfstring_constructor_static
mbuf
sizeof
mbuf
dwarfstring_append
char
errname
dwarfstring_append
In
function
dwarfstring_append
char
funcname
dwarfstring_append_printf_u
on
seeing
form
x
form
dwarf_get_FORM_name
form
dwarfstring_append_printf_s
s
char
defaultname
_dwarf_error_string
dbg
error
err_code
dwarfstring_string
dwarfstring_destructor
This
code
was
repeated
many
times
now
it
is
all
in
one
place
static
int
get_attr_dbg
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Attribute
attr
Dwarf_Error
error
Dwarf_CU_Context
cup
if
attr
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NULL
return
DW_DLV_ERROR
cup
attr
ar_cu_context
if
cup
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NO_CU_CONTEXT
return
DW_DLV_ERROR
if
cup
cc_dbg
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_DBG_NULL
return
DW_DLV_ERROR
cu_context
cup
dbg
cup
cc_dbg
return
DW_DLV_OK
int
dwarf_hasform
Dwarf_Attribute
attr
Dwarf_Half
form
Dwarf_Bool
return_bool
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
return_bool
attr
ar_attribute_form
form
return
DW_DLV_OK
Not
often
called
we
do
not
worry
about
efficiency
here
The
dwarf_whatform
call
does
the
sanity
checks
for
us
int
dwarf_whatform_direct
Dwarf_Attribute
attr
Dwarf_Half
return_form
Dwarf_Error
error
int
res
dwarf_whatform
attr
return_form
error
if
res
DW_DLV_OK
return
res
return_form
attr
ar_attribute_form_direct
return
DW_DLV_OK
This
code
was
contributed
around
As
of
it
is
not
clear
that
Sun
Sparc
compilers
are
in
current
use
nor
whether
there
is
a
reason
to
make
reads
of
this
data
format
safe
from
corrupted
object
files
Pass
in
the
content
of
a
block
and
the
length
of
that
content
On
success
return
DW_DLV_OK
and
set
value_count
to
the
size
of
the
array
returned
through
value_array
int
dwarf_uncompress_integer_block_a
Dwarf_Debug
dbg
Dwarf_Unsigned
input_length_in_bytes
void
input_block
Dwarf_Unsigned
value_count
Dwarf_Signed
value_array
Dwarf_Error
error
Dwarf_Unsigned
output_length_in_units
Dwarf_Signed
output_block
unsigned
i
char
ptr
int
remain
Dwarf_Signed
array
Dwarf_Byte_Ptr
endptr
Dwarf_Byte_Ptr
input_block
input_length_in_bytes
output_length_in_units
remain
input_length_in_bytes
ptr
input_block
while
remain
Dwarf_Unsigned
len
Dwarf_Signed
value
int
rres
rres
dwarf_decode_signed_leb128
char
ptr
char
endptr
if
rres
DW_DLV_OK
_dwarf_error
NULL
error
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
ptr
len
remain
len
output_length_in_units
if
remain
_dwarf_error
NULL
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
output_block
Dwarf_Signed
_dwarf_get_alloc
dbg
DW_DLA_STRING
output_length_in_units
sizeof
Dwarf_Signed
if
output_block
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
array
output_block
remain
input_length_in_bytes
ptr
input_block
for
i
i
output_length_in_units
remain
i
Dwarf_Signed
num
Dwarf_Unsigned
len
int
sres
sres
dwarf_decode_signed_leb128
char
ptr
char
endptr
if
sres
DW_DLV_OK
dwarf_dealloc
dbg
output_block
DW_DLA_STRING
_dwarf_error
NULL
error
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
ptr
len
remain
len
array
i
num
if
remain
dwarf_dealloc
dbg
unsigned
char
output_block
DW_DLA_STRING
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
value_count
output_length_in_units
value_array
output_block
return
DW_DLV_OK
This
code
was
contributed
around
and
the
return
value
is
in
the
wrong
form
See
dwarf_uncompress_integer_block_a
above
As
of
it
is
not
clear
that
Sun
Sparc
compilers
are
in
current
use
nor
whether
there
is
a
reason
to
make
reads
of
this
data
format
safe
from
corrupted
object
files
void
dwarf_dealloc_uncompressed_block
Dwarf_Debug
dbg
void
space
dwarf_dealloc
dbg
space
DW_DLA_STRING
int
dwarf_whatform
Dwarf_Attribute
attr
Dwarf_Half
return_form
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
return_form
attr
ar_attribute_form
return
DW_DLV_OK
This
function
is
analogous
to
dwarf_whatform
It
returns
the
attribute
in
attr
instead
of
the
form
int
dwarf_whatattr
Dwarf_Attribute
attr
Dwarf_Half
return_attr
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
return_attr
attr
ar_attribute
return
DW_DLV_OK
Convert
an
offset
within
the
local
CU
into
a
section
relative
debug_info
or
debug_types
offset
See
dwarf_global_formref
and
dwarf_formref
for
additional
information
on
conversion
rules
int
dwarf_convert_to_global_offset
Dwarf_Attribute
attr
Dwarf_Off
offset
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
int
res
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
switch
attr
ar_attribute_form
case
DW_FORM_ref1
case
DW_FORM_ref2
case
DW_FORM_ref4
case
DW_FORM_ref8
case
DW_FORM_ref_udata
It
is
a
cu
local
offset
Convert
to
section
global
It
would
be
nice
to
put
some
code
to
check
legality
of
the
offset
cc_debug_offset
always
has
any
DWP
Package
File
offset
included
when
the
cu_context
created
so
there
is
no
extra
work
for
DWP
Globalize
the
offset
offset
cu_context
cc_debug_offset
break
case
DW_FORM_ref_addr
This
offset
is
defined
to
be
debug_info
global
already
so
use
this
value
unaltered
Since
a
DWP
package
file
is
not
relocated
there
is
no
way
that
this
reference
offset
to
an
address
in
any
other
CU
can
be
correct
for
a
DWP
Package
File
offset
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_BAD_REF_FORM
The
form
code
is
x
which
cannot
be
converted
to
a
global
offset
by
dwarf_convert_to_global_offset
attr
ar_attribute_form
_dwarf_error_string
dbg
error
DW_DLE_BAD_REF_FORM
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
ret_offset
offset
return
DW_DLV_OK
A
global
offset
cannot
be
returned
by
this
interface
see
dwarf_global_formref
DW_FORM_ref_addr
is
considered
an
incorrect
form
for
this
call
because
DW_FORM_ref_addr
is
a
global
offset
into
the
debug_info
section
For
the
same
reason
DW_FORM_data4
data8
are
not
returned
from
this
function
For
the
same
reason
DW_FORM_sec_offset
is
not
returned
from
this
function
DW_FORM_sec_offset
is
a
global
offset
to
various
sections
not
a
CU
relative
offset
DW_FORM_ref_addr
has
a
value
which
was
documented
in
DWARF2
as
address
size
but
which
was
always
an
offset
so
should
have
always
been
offset
size
wording
corrected
in
DWARF3
The
dwarfstd
org
FAQ
How
big
is
a
DW_FORM_ref_addr?
suggested
all
should
use
offset
size
but
that
suggestion
seems
to
have
been
ignored
in
favor
of
doing
what
the
DWARF2
and
standards
actually
say
November
ret_offset
is
always
set
now
Even
in
case
of
error
Set
to
zero
for
most
errors
but
for
DW_DLE_ATTR_FORM_OFFSET_BAD
ret_offset
is
set
to
the
bad
offset
DW_FORM_addrx
DW_FORM_strx
DW_FORM_rnglistx
DW_FORM_GNU_addr_index
DW_FORM_GNU_str_index
are
not
references
to
debug_info
debug_types
so
they
are
not
allowed
here
int
dwarf_formref
Dwarf_Attribute
attr
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
maximumoffset
int
res
DW_DLV_ERROR
Dwarf_Byte_Ptr
section_end
ret_offset
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
switch
attr
ar_attribute_form
case
DW_FORM_ref1
offset
Dwarf_Small
attr
ar_debug_ptr
break
case
DW_FORM_ref2
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_HALF_SIZE
error
section_end
break
case
DW_FORM_ref4
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
break
case
DW_FORM_ref8
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
break
case
DW_FORM_ref_udata
Dwarf_Byte_Ptr
ptr
attr
ar_debug_ptr
Dwarf_Unsigned
localoffset
DECODE_LEB128_UWORD_CK
ptr
localoffset
dbg
error
section_end
offset
localoffset
break
case
DW_FORM_ref_sig8
We
cannot
handle
this
here
The
reference
is
to
debug_types
not
a
debug_info
CU
local
offset
_dwarf_error
dbg
error
DW_DLE_REF_SIG8_NOT_HANDLED
return
DW_DLV_ERROR
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_BAD_REF_FORM
The
form
code
is
x
which
does
not
have
an
offset
for
dwarf_formref
to
return
attr
ar_attribute_form
_dwarf_error_string
dbg
error
DW_DLE_BAD_REF_FORM
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
Check
that
offset
is
within
current
cu
portion
of
debug_info
maximumoffset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
if
offset
maximumoffset
For
the
DW_TAG_compile_unit
is
legal
to
have
the
DW_AT_sibling
attribute
outside
the
current
cu
portion
of
debug_info
In
other
words
sibling
points
to
the
end
of
the
CU
It
is
used
for
precompiled
headers
The
valid
condition
will
be
offset
maximumoffset
Dwarf_Half
tag
int
tres
dwarf_tag
attr
ar_die
error
if
tres
DW_DLV_OK
if
tres
DW_DLV_NO_ENTRY
_dwarf_error
dbg
error
DW_DLE_NO_TAG_FOR_DIE
return
DW_DLV_ERROR
return
DW_DLV_ERROR
if
DW_TAG_compile_unit
tag
DW_AT_sibling
attr
ar_attribute
offset
maximumoffset
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_OFFSET_BAD
Return
the
incorrect
offset
for
better
error
reporting
ret_offset
offset
return
DW_DLV_ERROR
ret_offset
offset
return
DW_DLV_OK
static
int
_dwarf_formsig8_internal
Dwarf_Attribute
attr
int
formexpected
int
formerrnum
Dwarf_Sig8
returned_sig_bytes
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
field_end
Dwarf_Byte_Ptr
section_end
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
if
attr
ar_attribute_form
formexpected
_dwarf_error
dbg
error
formerrnum
return
DW_DLV_ERROR
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
field_end
attr
ar_debug_ptr
sizeof
Dwarf_Sig8
if
field_end
section_end
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_OFFSET_BAD
return
DW_DLV_ERROR
memcpy
returned_sig_bytes
attr
ar_debug_ptr
sizeof
Dwarf_Sig8
return
DW_DLV_OK
int
dwarf_formsig8_const
Dwarf_Attribute
attr
Dwarf_Sig8
returned_sig_bytes
Dwarf_Error
error
int
res
_dwarf_formsig8_internal
attr
DW_FORM_data8
DW_DLE_ATTR_FORM_NOT_DATA8
returned_sig_bytes
error
return
res
dwarf_formsig8
returns
in
the
caller
provided
byte
area
the
bytes
of
a
DW_FORM_ref_sig8
copying
the
bytes
directly
to
the
caller
Not
a
string
an
byte
MD5
hash
or
a
signature
This
function
is
new
in
DWARF4
libdwarf
and
used
in
more
places
in
DWARF5
int
dwarf_formsig8
Dwarf_Attribute
attr
Dwarf_Sig8
returned_sig_bytes
Dwarf_Error
error
int
res
_dwarf_formsig8_internal
attr
DW_FORM_ref_sig8
DW_DLE_BAD_REF_SIG8_FORM
returned_sig_bytes
error
return
res
Since
this
returns
section
relative
debug_info
offsets
this
can
represent
all
REFERENCE
forms
correctly
and
allows
all
applicable
forms
DW_FORM_ref_addr
has
a
value
which
was
documented
in
DWARF2
as
address
size
but
which
was
always
an
offset
so
should
have
always
been
offset
size
wording
corrected
in
DWARF3
gcc
and
Go
and
libdwarf
producer
code
define
the
length
of
the
value
of
DW_FORM_ref_addr
per
the
version
So
for
V2
it
is
address
size
and
V3
and
later
it
is
offset
size
See
the
DWARF4
document
for
the
cases
fitting
reference
forms
The
caller
must
determine
which
section
the
reference
points
to
The
function
added
in
November
dwarf_get_form_class
helps
in
this
regard
unlike
dwarf_formref
this
allows
references
to
sections
other
than
just
debug_info
debug_types
See
case
DW_FORM_sec_offset
case
DW_FORM_GNU_ref_alt
GNU
extension
case
DW_FORM_GNU_strp_alt
GNU
extension
case
DW_FORM_strp_sup
DWARF5
sup
string
section
case
DW_FORM_line_strp
DWARF5
debug_line_str
section
int
dwarf_global_formref
Dwarf_Attribute
attr
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_CU_Context
cu_context
Dwarf_Half
context_version
Dwarf_Byte_Ptr
section_end
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
context_version
cu_context
cc_version_stamp
switch
attr
ar_attribute_form
case
DW_FORM_ref1
offset
Dwarf_Small
attr
ar_debug_ptr
goto
fixoffset
case
DW_FORM_ref2
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_HALF_SIZE
error
section_end
goto
fixoffset
case
DW_FORM_ref4
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
goto
fixoffset
case
DW_FORM_ref8
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
goto
fixoffset
case
DW_FORM_ref_udata
Dwarf_Byte_Ptr
ptr
attr
ar_debug_ptr
Dwarf_Unsigned
localoffset
DECODE_LEB128_UWORD_CK
ptr
localoffset
dbg
error
section_end
offset
localoffset
fixoffset
we
have
a
local
offset
make
it
global
check
legality
of
offset
if
offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_OFFSET_BAD
return
DW_DLV_ERROR
globalize
the
offset
offset
cu_context
cc_debug_offset
break
The
DWARF2
document
did
not
make
clear
that
DW_FORM_data4
and
were
references
with
global
offsets
to
some
section
That
was
first
clearly
documented
in
DWARF3
In
DWARF4
these
two
forms
are
no
longer
references
case
DW_FORM_data4
if
context_version
DW_CU_VERSION4
_dwarf_error
dbg
error
DW_DLE_NOT_REF_FORM
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
The
offset
is
global
break
case
DW_FORM_data8
if
context_version
DW_CU_VERSION4
_dwarf_error
dbg
error
DW_DLE_NOT_REF_FORM
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
The
offset
is
global
break
case
DW_FORM_ref_addr
In
Dwarf
V2
DW_FORM_ref_addr
was
defined
as
address
size
even
though
it
is
a
debug_info
offset
Fixed
in
Dwarf
V3
to
be
offset
size
unsigned
length_size
if
context_version
length_size
cu_context
cc_address_size
else
length_size
cu_context
cc_length_size
if
length_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
else
if
length_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
else
_dwarf_error
dbg
error
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD
return
DW_DLV_ERROR
break
Index
into
debug_rnglists
debug_loclists
section
Return
the
index
itself
case
DW_FORM_loclistx
case
DW_FORM_rnglistx
unsigned
length_size
cu_context
cc_length_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
length_size
error
section_end
break
case
DW_FORM_sec_offset
case
DW_FORM_GNU_ref_alt
GNU
extension
case
DW_FORM_GNU_strp_alt
GNU
extension
case
DW_FORM_strp_sup
DWARF5
sup
string
section
case
DW_FORM_line_strp
DWARF5
debug_line_str
section
DW_FORM_sec_offset
first
exists
in
DWARF4
It
is
up
to
the
caller
to
know
what
the
offset
of
DW_FORM_sec_offset
DW_FORM_strp_sup
or
DW_FORM_GNU_strp_alt
etc
refer
to
the
offset
is
not
going
to
refer
to
debug_info
unsigned
length_size
cu_context
cc_length_size
if
length_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
else
if
length_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
else
_dwarf_error
dbg
error
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD
return
DW_DLV_ERROR
break
case
DW_FORM_ref_sig8
FIXME
We
cannot
handle
this
yet
The
reference
could
be
to
debug_types
and
this
function
only
returns
an
offset
in
debug_info
at
this
point
_dwarf_error
dbg
error
DW_DLE_REF_SIG8_NOT_HANDLED
return
DW_DLV_ERROR
default
dwarfstring
m
int
formcode
attr
ar_attribute_form
int
fcres
const
char
name
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_BAD_REF_FORM
The
form
code
is
x
formcode
fcres
dwarf_get_FORM_name
formcode
if
fcres
DW_DLV_OK
name
UnknownFormCode
dwarfstring_append_printf_s
s
char
name
_dwarf_error_string
dbg
error
DW_DLE_BAD_REF_FORM
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
We
do
not
know
what
section
the
offset
refers
to
so
we
have
no
way
to
check
it
for
correctness
ret_offset
offset
return
DW_DLV_OK
Part
of
DebugFission
So
a
consumer
can
get
the
index
when
the
object
with
the
actual
debug_addr
is
elsewhere
New
May
int
_dwarf_get_addr_index_itself
int
theform
Dwarf_Small
info_ptr
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
val_out
Dwarf_Error
error
Dwarf_Unsigned
index
Dwarf_Byte_Ptr
section_end
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
switch
theform
case
DW_FORM_GNU_addr_index
case
DW_FORM_addrx
DECODE_LEB128_UWORD_CK
info_ptr
index
dbg
error
section_end
break
case
DW_FORM_addrx1
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_addrx2
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_addrx3
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_addrx4
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
default
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_NOT_ADDR_INDEX
return
DW_DLV_ERROR
val_out
index
return
DW_DLV_OK
int
dwarf_get_debug_addr_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
int
theform
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
theform
attr
ar_attribute_form
if
dwarf_addr_form_is_indexed
theform
Dwarf_Unsigned
index
res
_dwarf_get_addr_index_itself
theform
attr
ar_debug_ptr
dbg
cu_context
error
return_index
index
return
res
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_NOT_ADDR_INDEX
return
DW_DLV_ERROR
static
int
dw_read_index_val_itself
Dwarf_Debug
dbg
unsigned
theform
Dwarf_Small
info_ptr
Dwarf_Small
section_end
Dwarf_Unsigned
return_index
Dwarf_Error
error
Dwarf_Unsigned
index
switch
theform
case
DW_FORM_strx
case
DW_FORM_GNU_str_index
DECODE_LEB128_UWORD_CK
info_ptr
index
dbg
error
section_end
break
case
DW_FORM_strx1
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_strx2
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_strx3
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
case
DW_FORM_strx4
READ_UNALIGNED_CK
dbg
index
Dwarf_Unsigned
info_ptr
error
section_end
break
default
_dwarf_error
dbg
error
DW_DLE_ATTR_FORM_NOT_STR_INDEX
return
DW_DLV_ERROR
return_index
index
return
DW_DLV_OK
Part
of
DebugFission
So
a
dwarf
dumper
application
can
get
the
index
and
print
it
for
the
user
A
convenience
function
New
May
Also
used
with
DWARF5
forms
int
dwarf_get_debug_str_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
int
theform
attr
ar_attribute_form
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
int
res
Dwarf_Byte_Ptr
section_end
Dwarf_Unsigned
index
Dwarf_Small
info_ptr
int
indxres
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
info_ptr
attr
ar_debug_ptr
indxres
dw_read_index_val_itself
dbg
theform
info_ptr
section_end
error
if
indxres
DW_DLV_OK
return_index
index
return
indxres
return
indxres
int
_dwarf_extract_data16
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Small
section_start
Dwarf_Small
section_end
Dwarf_Form_Data16
returned_val
Dwarf_Error
error
Dwarf_Small
data16end
data16end
data
sizeof
Dwarf_Form_Data16
if
data
section_start
section_end
data16end
_dwarf_error
dbg
error
DW_DLE_DATA16_OUTSIDE_SECTION
return
DW_DLV_ERROR
memcpy
returned_val
data
sizeof
Dwarf_Form_Data16
return
DW_DLV_OK
int
dwarf_formdata16
Dwarf_Attribute
attr
Dwarf_Form_Data16
returned_val
Dwarf_Error
error
Dwarf_Half
attrform
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
int
res
Dwarf_Small
section_end
Dwarf_Unsigned
section_length
Dwarf_Small
section_start
if
attr
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NULL
return
DW_DLV_ERROR
if
returned_val
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NULL
return
DW_DLV_ERROR
attrform
attr
ar_attribute_form
if
attrform
DW_FORM_data16
generate_form_error
dbg
error
attrform
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
dwarf_formdata16
return
DW_DLV_ERROR
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_start
_dwarf_calculate_info_section_start_ptr
cu_context
section_end
section_start
section_length
res
_dwarf_extract_data16
dbg
attr
ar_debug_ptr
section_start
section_end
returned_val
error
return
res
The
addrx
are
DWARF5
standard
The
GNU
form
is
non
standard
gcc
DWARF4
Dwarf_Bool
dwarf_addr_form_is_indexed
int
form
switch
form
case
DW_FORM_addrx
case
DW_FORM_addrx1
case
DW_FORM_addrx2
case
DW_FORM_addrx3
case
DW_FORM_addrx4
case
DW_FORM_GNU_addr_index
return
TRUE
return
FALSE
int
dwarf_formaddr
Dwarf_Attribute
attr
Dwarf_Addr
return_addr
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Addr
ret_addr
Dwarf_CU_Context
cu_context
Dwarf_Half
attrform
int
res
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
attrform
attr
ar_attribute_form
if
dwarf_addr_form_is_indexed
attrform
res
_dwarf_look_in_local_and_tied
attrform
cu_context
attr
ar_debug_ptr
return_addr
error
return
res
if
attrform
DW_FORM_addr
attrform
DW_FORM_ref_addr
Allowance
of
DW_FORM_ref_addr
was
a
mistake
The
value
returned
in
that
case
is
NOT
an
address
it
is
a
global
debug_info
offset
ie
not
CU
relative
offset
within
the
CU
in
debug_info
The
DWARF2
document
refers
to
it
as
an
address
misleadingly
in
sec
where
it
describes
the
reference
form
It
is
address
sized
so
that
the
linker
can
easily
update
it
but
it
is
a
reference
inside
the
debug_info
section
No
longer
allowed
Dwarf_Small
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
READ_UNALIGNED_CK
dbg
ret_addr
Dwarf_Addr
attr
ar_debug_ptr
cu_context
cc_address_size
error
section_end
return_addr
ret_addr
return
DW_DLV_OK
generate_form_error
dbg
error
attrform
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
dwarf_formaddr
return
DW_DLV_ERROR
int
dwarf_formflag
Dwarf_Attribute
attr
Dwarf_Bool
ret_bool
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
if
attr
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NULL
return
DW_DLV_ERROR
cu_context
attr
ar_cu_context
if
cu_context
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NO_CU_CONTEXT
return
DW_DLV_ERROR
dbg
cu_context
cc_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_DBG_NULL
return
DW_DLV_ERROR
if
attr
ar_attribute_form
DW_FORM_flag_present
Implicit
means
we
don
t
read
any
data
at
all
Just
the
existence
of
the
Form
does
it
DWARF4
ret_bool
return
DW_DLV_OK
if
attr
ar_attribute_form
DW_FORM_flag
ret_bool
Dwarf_Small
attr
ar_debug_ptr
return
DW_DLV_OK
generate_form_error
dbg
error
attr
ar_attribute_form
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
dwarf_formflat
return
DW_DLV_ERROR
Dwarf_Bool
_dwarf_allow_formudata
unsigned
form
switch
form
case
DW_FORM_data1
case
DW_FORM_data2
case
DW_FORM_data4
case
DW_FORM_data8
case
DW_FORM_udata
case
DW_FORM_loclistx
case
DW_FORM_rnglistx
return
TRUE
return
FALSE
If
the
form
is
DW_FORM_constx
and
the
debug_addr
section
is
missing
this
returns
DW_DLV_ERROR
and
the
error
number
in
the
Dwarf_Error
is
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
When
that
arises
a
consumer
should
call
dwarf_get_debug_addr_index
and
use
that
on
the
appropriate
debug_addr
section
in
the
executable
or
another
object
Since
this
accept
some
signed
values
callers
must
not
assume
a
DW_DLV_OK
means
the
value
is
unsigned
The
form
is
the
first
clue
here
If
DW_FORM_sdata
then
signed
Else
unknown
sign
or
is
unsigned
int
_dwarf_formudata_internal
Dwarf_Debug
dbg
Dwarf_Attribute
attr
unsigned
form
Dwarf_Byte_Ptr
data
Dwarf_Byte_Ptr
section_end
Dwarf_Unsigned
return_uval
Dwarf_Unsigned
bytes_read
Dwarf_Error
error
Dwarf_Unsigned
ret_value
switch
form
case
DW_FORM_data1
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
data
sizeof
Dwarf_Small
error
section_end
return_uval
ret_value
bytes_read
return
DW_DLV_OK
READ_UNALIGNED
does
the
right
thing
as
it
reads
the
right
number
bits
and
generates
host
order
So
we
can
just
assign
to
return_uval
case
DW_FORM_data2
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
data
DWARF_HALF_SIZE
error
section_end
return_uval
ret_value
bytes_read
return
DW_DLV_OK
case
DW_FORM_data4
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
data
DWARF_32BIT_SIZE
error
section_end
return_uval
ret_value
bytes_read
DWARF_32BIT_SIZE
return
DW_DLV_OK
case
DW_FORM_data8
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
data
DWARF_64BIT_SIZE
error
section_end
return_uval
ret_value
bytes_read
DWARF_64BIT_SIZE
return
DW_DLV_OK
break
real
udata
case
DW_FORM_loclistx
case
DW_FORM_rnglistx
case
DW_FORM_udata
Dwarf_Unsigned
leblen
DECODE_LEB128_UWORD_LEN_CK
data
ret_value
leblen
dbg
error
section_end
return_uval
ret_value
bytes_read
leblen
return
DW_DLV_OK
IRIX
bug
We
do
not
allow
reading
sdata
from
a
udata
value
Caller
can
retry
calling
sdata
default
break
if
attr
int
res
Dwarf_Signed
s
res
dwarf_formsdata
attr
error
if
res
DW_DLV_OK
return
res
if
s
_dwarf_error
dbg
error
DW_DLE_UDATA_VALUE_NEGATIVE
return
DW_DLV_ERROR
return_uval
Dwarf_Unsigned
s
bytes_read
return
DW_DLV_OK
generate_form_error
dbg
error
form
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
formudata
internal
function
return
DW_DLV_ERROR
int
dwarf_formudata
Dwarf_Attribute
attr
Dwarf_Unsigned
return_uval
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
section_end
Dwarf_Unsigned
bytes_read
Dwarf_Byte_Ptr
data
attr
ar_debug_ptr
unsigned
form
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
form
attr
ar_attribute_form
res
_dwarf_formudata_internal
dbg
attr
form
data
section_end
return_uval
error
return
res
int
dwarf_formsdata
Dwarf_Attribute
attr
Dwarf_Signed
return_sval
Dwarf_Error
error
Dwarf_Signed
ret_value
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Byte_Ptr
section_end
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
switch
attr
ar_attribute_form
case
DW_FORM_data1
if
attr
ar_debug_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_DIE_BAD
return
DW_DLV_ERROR
return_sval
Dwarf_Sbyte
attr
ar_debug_ptr
return
DW_DLV_OK
READ_UNALIGNED
does
not
sign
extend
So
we
have
to
use
a
cast
to
get
the
value
sign
extended
in
the
right
way
for
each
case
case
DW_FORM_data2
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Signed
attr
ar_debug_ptr
DWARF_HALF_SIZE
error
section_end
return_sval
Dwarf_Shalf
ret_value
return
DW_DLV_OK
case
DW_FORM_data4
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Signed
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
SIGN_EXTEND
ret_value
DWARF_32BIT_SIZE
return_sval
Dwarf_Signed
ret_value
return
DW_DLV_OK
case
DW_FORM_data8
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Signed
attr
ar_debug_ptr
DWARF_64BIT_SIZE
error
section_end
No
SIGN_EXTEND
needed
we
are
filling
all
bytes
already
return_sval
Dwarf_Signed
ret_value
return
DW_DLV_OK
DW_FORM_implicit_const
is
a
value
in
the
abbreviations
not
in
the
DIEs
case
DW_FORM_implicit_const
return_sval
attr
ar_implicit_const
return
DW_DLV_OK
case
DW_FORM_sdata
Dwarf_Byte_Ptr
tmp
attr
ar_debug_ptr
DECODE_LEB128_SWORD_CK
tmp
ret_value
dbg
error
section_end
return_sval
ret_value
return
DW_DLV_OK
IRIX
bug
We
do
not
allow
reading
sdata
from
a
udata
value
Caller
can
retry
calling
udata
default
break
generate_form_error
dbg
error
attr
ar_attribute_form
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
dwarf_formsdata
return
DW_DLV_ERROR
int
_dwarf_formblock_internal
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_CU_Context
cu_context
Dwarf_Block
return_block
Dwarf_Error
error
Dwarf_Small
section_start
Dwarf_Small
section_end
Dwarf_Unsigned
section_length
Dwarf_Unsigned
length
Dwarf_Small
data
section_end
_dwarf_calculate_info_section_end_ptr
cu_context
section_start
_dwarf_calculate_info_section_start_ptr
cu_context
switch
attr
ar_attribute_form
case
DW_FORM_block1
length
Dwarf_Small
attr
ar_debug_ptr
data
attr
ar_debug_ptr
sizeof
Dwarf_Small
break
case
DW_FORM_block2
READ_UNALIGNED_CK
dbg
length
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_HALF_SIZE
error
section_end
data
attr
ar_debug_ptr
DWARF_HALF_SIZE
break
case
DW_FORM_block4
READ_UNALIGNED_CK
dbg
length
Dwarf_Unsigned
attr
ar_debug_ptr
DWARF_32BIT_SIZE
error
section_end
data
attr
ar_debug_ptr
DWARF_32BIT_SIZE
break
case
DW_FORM_exprloc
case
DW_FORM_block
Dwarf_Byte_Ptr
tmp
attr
ar_debug_ptr
Dwarf_Unsigned
leblen
DECODE_LEB128_UWORD_LEN_CK
tmp
length
leblen
dbg
error
section_end
data
attr
ar_debug_ptr
leblen
break
default
generate_form_error
dbg
error
attr
ar_attribute_form
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
dwarf_formblock
return
DW_DLV_ERROR
We
have
the
data
Check
for
errors
if
length
section_length
Sanity
test
looking
for
wraparound
when
length
actually
added
in
it
would
not
be
caught
Test
could
be
just
but
ok
here
too
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
The
length
of
the
block
is
greater
than
the
section
length
Corrupt
Dwarf
return
DW_DLV_ERROR
if
attr
ar_debug_ptr
length
section_end
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
The
block
length
means
the
block
runs
off
the
end
of
the
section
length
Corrupt
Dwarf
return
DW_DLV_ERROR
if
data
section_end
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
The
block
content
is
past
the
end
of
the
section
Corrupt
Dwarf
_dwarf_error
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
return
DW_DLV_ERROR
if
data
length
section_end
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
The
end
of
the
block
content
is
past
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
return_block
bl_len
length
return_block
bl_data
data
This
struct
is
public
so
use
the
old
name
instead
of
what
we
now
would
call
it
bl_kind
return_block
bl_from_loclist
DW_LKIND_expression
return_block
bl_section_offset
data
section_start
return
DW_DLV_OK
int
dwarf_formblock
Dwarf_Attribute
attr
Dwarf_Block
return_block
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
Dwarf_Block
local_block
Dwarf_Block
out_block
int
res
memset
sizeof
local_block
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
res
_dwarf_formblock_internal
dbg
attr
cu_context
error
if
res
DW_DLV_OK
return
res
out_block
Dwarf_Block
_dwarf_get_alloc
dbg
DW_DLA_BLOCK
if
out_block
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
out_block
local_block
return_block
out_block
return
DW_DLV_OK
int
_dwarf_extract_string_offset_via_str_offsets
Dwarf_Debug
dbg
Dwarf_Small
data_ptr
Dwarf_Small
end_data_ptr
Dwarf_Half
attrnum
UNUSEDARG
Dwarf_Half
attrform
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
str_sect_offset_out
Dwarf_Error
error
Dwarf_Unsigned
index_to_offset_entry
Dwarf_Unsigned
offsetintable
Dwarf_Unsigned
end_offsetintable
Dwarf_Unsigned
indexoffset
Dwarf_Unsigned
baseoffset
int
res
int
idxres
Dwarf_Small
sof_start
Dwarf_Unsigned
sof_len
Dwarf_Small
sof_end
res
_dwarf_load_section
dbg
de_debug_str_offsets
error
if
res
DW_DLV_OK
return
res
If
this
is
a
dwp
we
look
there
but
I
suppose
we
could
also
look
for
the
section
in
the
tied
file
it
is
not
here
sof_start
dbg
de_debug_str_offsets
dss_data
sof_len
dbg
de_debug_str_offsets
dss_size
sof_end
sof_start
sof_len
idxres
dw_read_index_val_itself
dbg
attrform
data_ptr
end_data_ptr
error
if
idxres
DW_DLV_OK
return
idxres
if
cu_context
cc_str_offsets_base_present
baseoffset
cu_context
cc_str_offsets_base
indexoffset
index_to_offset_entry
cu_context
cc_length_size
baseoffset
cu_context
cc_str_offsets_base
if
baseoffset
if
cu_context
cc_version_stamp
DW_CU_VERSION5
A
base
offset
of
isnormally
never
correct
for
DWARF5
but
some
early
GNU
compilers
emitted
DWARF4
debug_str_offsets
so
lets
check
the
first
table
Dwarf_Small
ststart
dbg
de_debug_str_offsets
dss_data
Dwarf_Small
stend
Dwarf_Unsigned
stsize
dbg
de_debug_str_offsets
dss_size
Dwarf_Unsigned
length
Dwarf_Half
local_offset_size
Dwarf_Half
local_extension_size
Dwarf_Half
version
Dwarf_Half
padding
stend
ststart
stsize
res
_dwarf_trial_read_dwarf_five_hdr
dbg
ststart
stsize
stend
error
if
res
DW_DLV_OK
baseoffset
local_extension_size
local_offset_size
DWARF_HALF_SIZE
else
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
offsetintable
baseoffset
indexoffset
end_offsetintable
offsetintable
cu_context
cc_str_offsets_offset_size
The
offsets
table
is
a
series
of
offset
size
entries
The
case
in
the
test
applies
when
we
are
at
the
last
table
entry
so
is
not
an
error
hence
only
test
if
end_offsetintable
dbg
de_debug_str_offsets
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ATTR_FORM_SIZE_BAD
The
end
offset
of
a
debug_str_offsets
table
is
x
end_offsetintable
dwarfstring_append_printf_u
but
the
object
section
is
just
x
bytes
long
dbg
de_debug_str_offsets
dss_size
_dwarf_error_string
dbg
error
DW_DLE_ATTR_FORM_SIZE_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
Dwarf_Unsigned
offsettostr
baseoffset
offsetintable
Now
read
the
string
offset
from
the
offset
table
READ_UNALIGNED_CK
dbg
offsettostr
Dwarf_Unsigned
sof_start
offsetintable
cu_context
cc_length_size
error
sof_end
str_sect_offset_out
offsettostr
return
DW_DLV_OK
int
_dwarf_extract_local_debug_str_string_given_offset
Dwarf_Debug
dbg
unsigned
attrform
Dwarf_Unsigned
offset
char
return_str
Dwarf_Error
error
if
attrform
DW_FORM_strp
attrform
DW_FORM_line_strp
attrform
DW_FORM_GNU_str_index
attrform
DW_FORM_strx1
attrform
DW_FORM_strx2
attrform
DW_FORM_strx3
attrform
DW_FORM_strx4
attrform
DW_FORM_strx
The
offset
into
debug_str
or
debug_line_str
is
given
here
we
turn
that
into
a
pointer
Dwarf_Small
secend
Dwarf_Small
secbegin
Dwarf_Small
strbegin
Dwarf_Unsigned
secsize
int
errcode
const
char
errname
int
res
if
attrform
DW_FORM_line_strp
res
_dwarf_load_section
dbg
de_debug_line_str
error
if
res
DW_DLV_OK
return
res
errcode
DW_DLE_STRP_OFFSET_BAD
errname
DW_DLE_STRP_OFFSET_BAD
secsize
dbg
de_debug_line_str
dss_size
secbegin
dbg
de_debug_line_str
dss_data
strbegin
dbg
de_debug_line_str
dss_data
offset
secend
dbg
de_debug_line_str
dss_data
secsize
else
DW_FORM_strp
etc
res
_dwarf_load_section
dbg
de_debug_str
error
if
res
DW_DLV_OK
return
res
errcode
DW_DLE_STRING_OFFSET_BAD
errname
DW_DLE_STRING_OFFSET_BAD
secsize
dbg
de_debug_str
dss_size
secbegin
dbg
de_debug_str
dss_data
strbegin
dbg
de_debug_str
dss_data
offset
secend
dbg
de_debug_str
dss_data
secsize
if
offset
secsize
dwarfstring
m
const
char
name
unknownform
dwarf_get_FORM_name
attrform
dwarfstring_constructor
dwarfstring_append
char
errname
dwarfstring_append_printf_s
Form
s
char
name
dwarfstring_append_printf_u
string
offset
of
DW_PR_DUx
offset
dwarfstring_append_printf_u
is
larger
than
the
string
section
size
of
DW_PR_DUx
secsize
_dwarf_error_string
dbg
error
errcode
dwarfstring_string
dwarfstring_destructor
Badly
damaged
DWARF
here
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
dbg
secbegin
strbegin
secend
errcode
error
if
res
DW_DLV_OK
return
res
return_str
char
strbegin
return
DW_DLV_OK
generate_form_error
dbg
error
attrform
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_FORM_BAD
extract
debug_str
string
return
DW_DLV_ERROR
Contrary
to
pre
documentation
The
string
pointer
returned
thru
return_str
must
never
have
dwarf_dealloc
applied
to
it
Documentation
fixed
July
int
dwarf_formstring
Dwarf_Attribute
attr
char
return_str
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
int
res
DW_DLV_ERROR
Dwarf_Small
secdataptr
Dwarf_Small
secend
Dwarf_Unsigned
secdatalen
Dwarf_Small
infoptr
attr
ar_debug_ptr
Dwarf_Small
contextend
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
if
cu_context
cc_is_info
secdataptr
Dwarf_Small
dbg
de_debug_info
dss_data
secdatalen
dbg
de_debug_info
dss_size
else
secdataptr
Dwarf_Small
dbg
de_debug_types
dss_data
secdatalen
dbg
de_debug_types
dss_size
contextend
secdataptr
cu_context
cc_debug_offset
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
secend
secdataptr
secdatalen
if
contextend
secend
secend
contextend
switch
attr
ar_attribute_form
case
DW_FORM_string
Dwarf_Small
begin
attr
ar_debug_ptr
res
_dwarf_check_string_valid
dbg
secdataptr
begin
secend
DW_DLE_FORM_STRING_BAD_STRING
error
if
res
DW_DLV_OK
return
res
return_str
char
begin
return
DW_DLV_OK
case
DW_FORM_GNU_strp_alt
case
DW_FORM_strp_sup
Dwarf_Error
alterr
See
dwarfstd
org
issue
This
is
the
offset
in
the
debug_str
section
of
another
object
file
The
tied
file
notion
should
apply
It
is
not
clear
whether
both
a
supplementary
and
a
split
object
might
be
needed
at
the
same
time
hence
two
tied
files
simultaneously
Dwarf_Off
soffset
res
dwarf_global_formref
attr
error
if
res
DW_DLV_OK
return
res
res
_dwarf_get_string_from_tied
dbg
soffset
return_str
if
res
DW_DLV_ERROR
if
dwarf_errno
alterr
DW_DLE_NO_TIED_FILE_AVAILABLE
dwarf_dealloc
dbg
alterr
DW_DLA_ERROR
if
attr
ar_attribute_form
DW_FORM_GNU_strp_alt
return_str
char
DW_FORM_GNU_strp_alt
no
tied
file
else
return_str
char
DW_FORM_strp_sup
no
tied
file
return
DW_DLV_OK
if
error
error
alterr
return
res
if
res
DW_DLV_NO_ENTRY
if
attr
ar_attribute_form
DW_FORM_GNU_strp_alt
return_str
char
DW_FORM_GNU_strp_alt
no
tied
file
else
return_str
char
DW_FORM_strp_sup
no
tied
file
return
res
case
DW_FORM_GNU_str_index
case
DW_FORM_strx
case
DW_FORM_strx1
case
DW_FORM_strx2
case
DW_FORM_strx3
case
DW_FORM_strx4
Dwarf_Unsigned
offsettostr
res
_dwarf_extract_string_offset_via_str_offsets
dbg
infoptr
secend
attr
ar_attribute
attr
ar_attribute_form
cu_context
error
if
res
DW_DLV_OK
return
res
offset
offsettostr
break
case
DW_FORM_strp
case
DW_FORM_line_strp
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
infoptr
cu_context
cc_length_size
error
secend
break
default
_dwarf_error
dbg
error
DW_DLE_STRING_FORM_IMPROPER
return
DW_DLV_ERROR
Now
we
have
offset
so
read
the
string
from
debug_str
or
debug_line_str
res
_dwarf_extract_local_debug_str_string_given_offset
dbg
attr
ar_attribute_form
offset
return_str
error
return
res
int
_dwarf_get_string_from_tied
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
char
return_str
Dwarf_Error
error
Dwarf_Debug
tieddbg
Dwarf_Small
secend
Dwarf_Small
secbegin
Dwarf_Small
strbegin
int
res
DW_DLV_ERROR
Dwarf_Error
localerror
Attach
errors
to
dbg
not
tieddbg
tieddbg
dbg
de_tied_data
td_tied_object
if
tieddbg
_dwarf_error
dbg
error
DW_DLE_NO_TIED_FILE_AVAILABLE
return
DW_DLV_ERROR
The
offset
into
debug_str
is
set
res
_dwarf_load_section
tieddbg
de_debug_str
if
res
DW_DLV_ERROR
Dwarf_Unsigned
lerrno
dwarf_errno
localerror
dwarf_dealloc
tieddbg
localerror
DW_DLA_ERROR
_dwarf_error
dbg
error
lerrno
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
if
offset
tieddbg
de_debug_str
dss_size
Badly
damaged
DWARF
here
_dwarf_error
dbg
error
DW_DLE_NO_TIED_STRING_AVAILABLE
return
DW_DLV_ERROR
secbegin
tieddbg
de_debug_str
dss_data
strbegin
tieddbg
de_debug_str
dss_data
offset
secend
tieddbg
de_debug_str
dss_data
tieddbg
de_debug_str
dss_size
Ensure
the
offset
lies
within
the
debug_str
if
offset
tieddbg
de_debug_str
dss_size
_dwarf_error
dbg
error
DW_DLE_NO_TIED_STRING_AVAILABLE
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
tieddbg
secbegin
strbegin
secend
DW_DLE_NO_TIED_STRING_AVAILABLE
if
res
DW_DLV_ERROR
Dwarf_Unsigned
lerrno
dwarf_errno
localerror
dwarf_dealloc
tieddbg
localerror
DW_DLA_ERROR
_dwarf_error
dbg
error
lerrno
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
return_str
char
tieddbg
de_debug_str
dss_data
offset
return
DW_DLV_OK
int
dwarf_formexprloc
Dwarf_Attribute
attr
Dwarf_Unsigned
return_exprlen
Dwarf_Ptr
block_ptr
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
int
res
get_attr_dbg
attr
error
if
res
DW_DLV_OK
return
res
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_DBG_NULL
return
DW_DLV_ERROR
if
attr
ar_attribute_form
DW_FORM_exprloc
Dwarf_Die
die
Dwarf_Unsigned
leb_len
Dwarf_Byte_Ptr
section_start
Dwarf_Unsigned
section_len
Dwarf_Byte_Ptr
section_end
Dwarf_Byte_Ptr
info_ptr
Dwarf_Unsigned
exprlen
Dwarf_Small
addr
attr
ar_debug_ptr
info_ptr
addr
section_start
_dwarf_calculate_info_section_start_ptr
cu_context
section_end
section_start
section_len
DECODE_LEB128_UWORD_LEN_CK
info_ptr
exprlen
leb_len
dbg
error
section_end
if
exprlen
section_len
Corrupted
dwarf
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ATTR_OUTSIDE_SECTION
The
expression
length
is
u
exprlen
dwarfstring_append_printf_u
but
the
section
length
is
just
u
Corrupt
Dwarf
section_len
_dwarf_error_string
dbg
error
DW_DLE_ATTR_OUTSIDE_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
die
attr
ar_die
Is
the
block
entirely
in
the
section
or
is
there
bug
somewhere?
Here
the
final
addr
may
be
past
end
of
section
if
_dwarf_reference_outside_section
die
Dwarf_Small
addr
Dwarf_Small
addr
exprlen
leb_len
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ATTR_OUTSIDE_SECTION
The
expression
length
u
exprlen
dwarfstring_append_printf_u
plus
the
leb
value
length
of
u
leb_len
dwarfstring_append
runs
past
the
end
of
the
section
Corrupt
Dwarf
_dwarf_error_string
dbg
error
DW_DLE_ATTR_OUTSIDE_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return_exprlen
exprlen
block_ptr
addr
leb_len
return
DW_DLV_OK
dwarfstring
m
const
char
name
name
not
known
unsigned
mform
attr
ar_attribute_form
dwarfstring_constructor
dwarf_get_FORM_name
mform
dwarfstring_append_printf_u
DW_DLE_ATTR_EXPRLOC_FORM_BAD
The
form
is
x
mform
dwarfstring_append_printf_s
s
but
should
be
DW_FORM_exprloc
Corrupt
Dwarf
char
name
_dwarf_error_string
dbg
error
DW_DLE_ATTR_EXPRLOC_FORM_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
libdwarf
h
FORM_CLASS
is
created
by
libdwarf
it
is
not
a
part
of
Standard
Dwarf
Dwarf_Form_Class
attempts
to
allow
convenient
processing
of
FORMs
across
DWARF2
and
for
libdwarf
dwarfdump
and
other
clients
and
ensures
type
safe
referencing
int
dwarf_get_FORM_CLASS_name
enum
Dwarf_Form_Class
fc
const
char
s_out
switch
fc
case
DW_FORM_CLASS_UNKNOWN
s_out
DW_FORM_CLASS_UNKNOWN
return
DW_DLV_OK
case
DW_FORM_CLASS_ADDRESS
s_out
DW_FORM_CLASS_ADDRESS
return
DW_DLV_OK
case
DW_FORM_CLASS_BLOCK
s_out
DW_FORM_CLASS_BLOCK
return
DW_DLV_OK
case
DW_FORM_CLASS_CONSTANT
s_out
DW_FORM_CLASS_CONSTANT
return
DW_DLV_OK
case
DW_FORM_CLASS_EXPRLOC
s_out
DW_FORM_CLASS_EXPRLOC
return
DW_DLV_OK
case
DW_FORM_CLASS_FLAG
s_out
DW_FORM_CLASS_FLAG
return
DW_DLV_OK
case
DW_FORM_CLASS_LINEPTR
s_out
DW_FORM_CLASS_LINEPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_LOCLISTPTR
s_out
DW_FORM_CLASS_LOCLISTPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_MACPTR
s_out
DW_FORM_CLASS_MACPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_RANGELISTPTR
s_out
DW_FORM_CLASS_RANGELISTPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_REFERENCE
s_out
DW_FORM_CLASS_REFERENCE
return
DW_DLV_OK
case
DW_FORM_CLASS_STRING
s_out
DW_FORM_CLASS_STRING
return
DW_DLV_OK
case
DW_FORM_CLASS_FRAMEPTR
s_out
DW_FORM_CLASS_FRAMEPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_MACROPTR
s_out
DW_FORM_CLASS_MAXCROPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_ADDRPTR
s_out
DW_FORM_CLASS_ADDRPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_LOCLIST
s_out
DW_FORM_CLASS_LOCLIST
return
DW_DLV_OK
case
DW_FORM_CLASS_LOCLISTSPTR
s_out
DW_FORM_CLASS_LOCLISTSPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_RNGLIST
s_out
DW_FORM_CLASS_RNGLIST
return
DW_DLV_OK
case
DW_FORM_CLASS_RNGLISTSPTR
s_out
DW_FORM_CLASS_RNGLISTSPTR
return
DW_DLV_OK
case
DW_FORM_CLASS_STROFFSETSPTR
s_out
DW_FORM_CLASS_STROFFSETSPTR
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_frame
h
include
dwarf_arange
h
Using
Arange
as
a
way
to
build
a
list
define
FDE_NULL_CHECKS_AND_SET_DBG
fde
dbg
do
if
fde
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
dbg
fde
fd_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_DBG_NULL
return
DW_DLV_ERROR
while
define
MIN
a
b
a
b
a
b
if
FOR
DEBUGGING
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
Only
used
for
debugging
libdwarf
static
void
dump_frame_rule
char
msg
struct
Dwarf_Reg_Rule_s
reg_rule
endif
static
int
dwarf_initialize_fde_table
Dwarf_Debug
dbg
struct
Dwarf_Frame_s
fde_table
unsigned
table_real_data_size
Dwarf_Error
error
static
void
dwarf_free_fde_table
struct
Dwarf_Frame_s
fde_table
static
void
dwarf_init_reg_rules_ru
struct
Dwarf_Reg_Rule_s
base
unsigned
first
unsigned
last
int
initial_value
static
void
dwarf_init_reg_rules_dw3
struct
Dwarf_Regtable_Entry3_s
base
unsigned
first
unsigned
last
int
initial_value
int
dwarf_get_frame_section_name
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
struct
Dwarf_Section_s
sec
if
error
NULL
error
NULL
sec
de_debug_frame
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
sec_name
sec
dss_name
return
DW_DLV_OK
int
dwarf_get_frame_section_name_eh_gnu
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Error
error
struct
Dwarf_Section_s
sec
if
error
NULL
error
NULL
sec
de_debug_frame_eh_gnu
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
sec_name
sec
dss_name
return
DW_DLV_OK
This
function
is
the
heart
of
the
debug_frame
stuff
Don
t
even
think
of
reading
this
without
reading
both
the
Libdwarf
and
consumer
API
carefully
first
This
function
basically
executes
frame
instructions
contained
in
a
Cie
or
an
Fde
but
does
in
a
number
of
different
ways
depending
on
the
information
sought
Start_instr_ptr
points
to
the
first
byte
of
the
frame
instruction
stream
and
final_instr_ptr
to
the
to
the
first
byte
after
the
last
The
offsets
returned
in
the
frame
instructions
are
factored
That
is
they
need
to
be
multiplied
by
either
the
code_alignment_factor
or
the
data_alignment_factor
as
appropriate
to
obtain
the
actual
offset
This
makes
it
possible
to
expand
an
instruction
stream
without
the
corresponding
Cie
However
when
an
Fde
frame
instr
sequence
is
being
expanded
there
must
be
a
valid
Cie
with
a
pointer
to
an
initial
table
row
If
successful
returns
DW_DLV_OK
And
sets
returned_count
thru
the
pointer
if
make_instr
is
true
If
make_instr
is
false
returned_count
should
NOT
be
used
by
the
caller
returned_count
is
set
to
thru
the
pointer
by
this
routine
If
unsuccessful
returns
DW_DLV_ERROR
and
sets
returned_error
to
the
error
code
It
does
not
do
a
whole
lot
of
input
validation
being
a
private
function
Please
make
sure
inputs
are
valid
If
make_instr
is
true
it
makes
a
list
of
pointers
to
Dwarf_Frame_Op
structures
containing
the
frame
instructions
executed
A
pointer
to
this
list
is
returned
in
ret_frame_instr
Make_instr
is
true
only
when
a
list
of
frame
instructions
is
to
be
returned
In
this
case
since
we
are
not
interested
in
the
contents
of
the
table
the
input
Cie
can
be
NULL
This
is
the
only
case
where
the
input
Cie
can
be
NULL
If
search_pc
is
true
frame
instructions
are
executed
till
either
a
location
is
reached
that
is
greater
than
the
search_pc_val
provided
or
all
instructions
are
executed
At
this
point
the
last
row
of
the
table
generated
is
returned
in
a
structure
A
pointer
to
this
structure
is
supplied
in
table
This
function
is
also
used
to
create
the
initial
table
row
defined
by
a
Cie
In
this
case
the
Dwarf_Cie
pointer
cie
is
NULL
For
an
FDE
however
cie
points
to
the
associated
Cie
If
search_pc
is
true
and
has_more_rows
and
subsequent_pc
are
non
null
then
has_more_rows
is
set
true
if
there
are
instruction
bytes
following
the
detection
of
search_over
If
all
the
instruction
bytes
have
been
seen
then
has_more_rows
is
set
false
If
has_more_rows
is
true
then
subsequent_pc
is
set
to
the
pc
value
that
is
the
following
row
in
the
table
make_instr
make
list
of
frame
instr?
ret_frame_instr
Ptr
to
list
of
ptrs
to
frame
instrs
search_pc
Search
for
a
pc
value?
search_pc_val
Search
for
this
pc
value
initial_loc
Initial
code
location
value
start_instr_ptr
Ptr
to
start
of
frame
instrs
final_instr_ptr
Ptr
just
past
frame
instrs
table
Ptr
to
struct
with
last
row
cie
Ptr
to
Cie
used
by
the
Fde
Different
cies
may
have
distinct
address
sizes
so
the
cie
is
used
not
de_pointer_size
int
_dwarf_exec_frame_instr
Dwarf_Bool
make_instr
Dwarf_Frame_Op
ret_frame_instr
Dwarf_Bool
search_pc
Dwarf_Addr
search_pc_val
Dwarf_Addr
initial_loc
Dwarf_Small
start_instr_ptr
Dwarf_Small
final_instr_ptr
Dwarf_Frame
table
Dwarf_Cie
cie
Dwarf_Debug
dbg
Dwarf_Half
reg_num_of_cfa
Dwarf_Signed
returned_count
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
The
following
macro
depends
on
macreg
and
machigh_reg
both
being
unsigned
to
avoid
unintended
behavior
and
to
avoid
compiler
warnings
when
high
warning
levels
are
turned
on
define
ERROR_IF_REG_NUM_TOO_HIGH
macreg
machigh_reg
do
if
macreg
machigh_reg
SER
DW_DLE_DF_REG_NUM_TOO_HIGH
CONSTCOND
while
SER
SIMPLE_ERROR_RETURN
define
SER
code
free
localregtab
_dwarf_error
dbg
error
code
return
DW_DLV_ERROR
Sweeps
the
frame
instructions
Dwarf_Small
instr_ptr
Register
numbers
not
limited
to
just
thus
not
using
Dwarf_Small
typedef
unsigned
reg_num_type
Dwarf_Unsigned
factored_N_value
Dwarf_Signed
signed_factored_N_value
Dwarf_Addr
current_loc
initial_loc
code
location
pc
value
corresponding
to
the
frame
instructions
Starts
at
zero
when
the
caller
has
no
value
to
pass
in
Must
be
min
de_pointer_size
bytes
and
must
be
at
least
Dwarf_Unsigned
adv_loc
unsigned
reg_count
dbg
de_frame_reg_rules_entry_count
struct
Dwarf_Reg_Rule_s
localregtab
calloc
reg_count
sizeof
struct
Dwarf_Reg_Rule_s
struct
Dwarf_Reg_Rule_s
cfa_reg
This
is
used
to
end
executing
frame
instructions
Becomes
true
when
search_pc
is
true
and
current_loc
is
greater
than
search_pc_val
Dwarf_Bool
search_over
false
Dwarf_Addr
possible_subsequent_pc
Used
by
the
DW_FRAME_advance_loc
instr
to
hold
the
increment
in
pc
value
Dwarf_Addr
adv_pc
Dwarf_Half
address_size
cie
cie
ci_address_size
dbg
de_pointer_size
Counts
the
number
of
frame
instructions
executed
Dwarf_Unsigned
instr_count
These
contain
the
current
fields
of
the
current
frame
instruction
Dwarf_Small
fp_base_op
Dwarf_Small
fp_extended_op
reg_num_type
fp_register
The
value
in
fp_offset
may
be
signed
though
we
call
it
unsigned
This
works
ok
for
s
complement
arithmetic
Dwarf_Unsigned
fp_offset
Dwarf_Off
fp_instr_offset
Stack_table
points
to
the
row
Dwarf_Frame
ie
being
pushed
or
popped
by
a
remember
or
restore
instruction
Top_stack
points
to
the
top
of
the
stack
of
rows
Dwarf_Frame
stack_table
NULL
Dwarf_Frame
top_stack
NULL
These
are
used
only
when
make_instr
is
true
Curr_instr
is
a
pointer
to
the
current
frame
instruction
executed
Curr_instr_ptr
head_instr_list
and
curr_instr_list
are
used
to
form
a
chain
of
Dwarf_Frame_Op
structs
Dealloc_instr_ptr
is
used
to
deallocate
the
structs
used
to
form
the
chain
Head_instr_block
points
to
a
contiguous
list
of
pointers
to
the
Dwarf_Frame_Op
structs
executed
Dwarf_Frame_Op
curr_instr
Dwarf_Chain
curr_instr_item
Dwarf_Chain
head_instr_chain
NULL
Dwarf_Chain
tail_instr_chain
NULL
Dwarf_Frame_Op
head_instr_block
These
are
the
alignment_factors
taken
from
the
Cie
provided
When
no
input
Cie
is
provided
they
are
set
to
because
only
factored
offsets
are
required
Dwarf_Signed
code_alignment_factor
Dwarf_Signed
data_alignment_factor
This
flag
indicates
when
an
actual
alignment
factor
is
needed
So
if
a
frame
instruction
that
computes
an
offset
using
an
alignment
factor
is
encountered
when
this
flag
is
set
an
error
is
returned
because
the
Cie
did
not
have
a
valid
augmentation
Dwarf_Bool
need_augmentation
false
Dwarf_Unsigned
i
Initialize
first
row
from
associated
Cie
Using
temp
regs
explicitly
if
localregtab
SER
DW_DLE_ALLOC_FAIL
struct
Dwarf_Reg_Rule_s
t1reg
localregtab
if
cie
NULL
cie
ci_initial_table
NULL
unsigned
minregcount
unsigned
curreg
struct
Dwarf_Reg_Rule_s
t2reg
cie
ci_initial_table
fr_reg
if
reg_count
cie
ci_initial_table
fr_reg_count
Should
never
happen
it
makes
no
sense
to
have
the
table
sizes
change
There
is
no
real
allowance
for
the
set
of
registers
to
change
dynamically
in
a
single
Dwarf_Debug
except
the
size
can
be
set
near
initial
Dwarf_Debug
creation
time
SER
DW_DLE_FRAME_REGISTER_COUNT_MISMATCH
minregcount
MIN
reg_count
cie
ci_initial_table
fr_reg_count
for
curreg
minregcount
curreg
t1reg
t2reg
t1reg
t2reg
cfa_reg
cie
ci_initial_table
fr_cfa_rule
else
dwarf_init_reg_rules_ru
localregtab
reg_count
dbg
de_frame_rule_initial_value
dwarf_init_reg_rules_ru
dbg
de_frame_rule_initial_value
The
idea
here
is
that
the
code_alignment_factor
and
data_alignment_factor
which
are
needed
for
certain
instructions
are
valid
only
when
the
Cie
has
a
proper
augmentation
string
So
if
the
augmentation
is
not
right
only
Frame
instruction
can
be
read
if
cie
NULL
cie
ci_augmentation
NULL
code_alignment_factor
cie
ci_code_alignment_factor
data_alignment_factor
cie
ci_data_alignment_factor
else
need_augmentation
make_instr
instr_ptr
start_instr_ptr
while
instr_ptr
final_instr_ptr
search_over
Dwarf_Small
instr
Dwarf_Small
opcode
reg_num_type
reg_no
fp_instr_offset
instr_ptr
start_instr_ptr
instr
Dwarf_Small
instr_ptr
instr_ptr
sizeof
Dwarf_Small
fp_base_op
instr
if
instr
opcode
instr
is
really
extended
op
fp_extended_op
instr
else
opcode
instr
is
base
op
fp_extended_op
fp_register
fp_offset
switch
opcode
case
DW_CFA_advance_loc
base
op
fp_offset
adv_pc
instr
DW_FRAME_INSTR_OFFSET_MASK
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
adv_pc
adv_pc
code_alignment_factor
possible_subsequent_pc
current_loc
adv_pc
search_over
search_pc
possible_subsequent_pc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
if
search_over
current_loc
possible_subsequent_pc
break
case
DW_CFA_offset
base
op
int
adres
reg_no
reg_num_type
instr
DW_FRAME_INSTR_OFFSET_MASK
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
fp_register
reg_no
fp_offset
factored_N_value
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_no
ru_register
reg_num_of_cfa
localregtab
reg_no
ru_offset_or_block_len
factored_N_value
data_alignment_factor
break
case
DW_CFA_restore
base
op
reg_no
instr
DW_FRAME_INSTR_OFFSET_MASK
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
fp_register
reg_no
if
cie
NULL
cie
ci_initial_table
NULL
localregtab
reg_no
cie
ci_initial_table
fr_reg
reg_no
else
if
make_instr
SER
DW_DLE_DF_MAKE_INSTR_NO_INIT
break
case
DW_CFA_set_loc
Dwarf_Addr
new_loc
int
adres
adres
_dwarf_read_unaligned_ck_wrapper
dbg
instr_ptr
address_size
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
instr_ptr
address_size
if
new_loc
current_loc
Pre
relocation
or
before
current_loc
is
set
the
test
comparing
new_loc
and
current_loc
makes
no
sense
Testing
for
non
zero
above
is
a
way
fallible
to
check
that
current_loc
new_loc
are
already
relocated
if
new_loc
current_loc
Within
a
frame
address
must
increase
Seemingly
it
has
not
Seems
to
be
an
error
SER
DW_DLE_DF_NEW_LOC_LESS_OLD_LOC
search_over
search_pc
new_loc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
possible_subsequent_pc
new_loc
if
search_over
current_loc
possible_subsequent_pc
fp_offset
new_loc
break
case
DW_CFA_advance_loc1
int
adres
adres
_dwarf_read_unaligned_ck_wrapper
dbg
instr_ptr
sizeof
Dwarf_Small
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
instr_ptr
sizeof
Dwarf_Small
fp_offset
adv_loc
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
adv_loc
code_alignment_factor
possible_subsequent_pc
current_loc
adv_loc
search_over
search_pc
possible_subsequent_pc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
if
search_over
current_loc
possible_subsequent_pc
break
case
DW_CFA_advance_loc2
int
adres
adres
_dwarf_read_unaligned_ck_wrapper
dbg
instr_ptr
DWARF_HALF_SIZE
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
instr_ptr
DWARF_HALF_SIZE
fp_offset
adv_loc
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
adv_loc
code_alignment_factor
possible_subsequent_pc
current_loc
adv_loc
search_over
search_pc
possible_subsequent_pc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
if
search_over
current_loc
possible_subsequent_pc
break
case
DW_CFA_advance_loc4
int
adres
adres
_dwarf_read_unaligned_ck_wrapper
dbg
instr_ptr
DWARF_32BIT_SIZE
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
instr_ptr
DWARF_32BIT_SIZE
fp_offset
adv_loc
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
adv_loc
code_alignment_factor
possible_subsequent_pc
current_loc
adv_loc
search_over
search_pc
possible_subsequent_pc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
if
search_over
current_loc
possible_subsequent_pc
break
case
DW_CFA_MIPS_advance_loc8
int
adres
adres
_dwarf_read_unaligned_ck_wrapper
dbg
instr_ptr
DWARF_64BIT_SIZE
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
instr_ptr
DWARF_64BIT_SIZE
fp_offset
adv_loc
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
adv_loc
code_alignment_factor
possible_subsequent_pc
current_loc
adv_loc
search_over
search_pc
possible_subsequent_pc
search_pc_val
If
gone
past
pc
needed
retain
old
pc
if
search_over
current_loc
possible_subsequent_pc
break
case
DW_CFA_offset_extended
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_no
ru_register
reg_num_of_cfa
localregtab
reg_no
ru_offset_or_block_len
factored_N_value
data_alignment_factor
fp_register
reg_no
fp_offset
factored_N_value
break
case
DW_CFA_restore_extended
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
if
cie
NULL
cie
ci_initial_table
NULL
localregtab
reg_no
cie
ci_initial_table
fr_reg
reg_no
else
if
make_instr
SER
DW_DLE_DF_MAKE_INSTR_NO_INIT
fp_register
reg_no
break
case
DW_CFA_undefined
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_no
ru_register
dbg
de_frame_undefined_value_number
localregtab
reg_no
ru_offset_or_block_len
fp_register
reg_no
break
case
DW_CFA_same_value
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_no
ru_register
dbg
de_frame_same_value_number
localregtab
reg_no
ru_offset_or_block_len
fp_register
reg_no
break
case
DW_CFA_register
Dwarf_Unsigned
lreg
reg_num_type
reg_noA
reg_num_type
reg_noB
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_noA
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_noA
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_noB
reg_num_type
lreg
if
reg_noB
reg_count
SER
DW_DLE_DF_REG_NUM_TOO_HIGH
localregtab
reg_noA
ru_is_off
localregtab
reg_noA
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_noA
ru_register
reg_noB
localregtab
reg_noA
ru_offset_or_block_len
fp_register
reg_noA
fp_offset
reg_noB
break
case
DW_CFA_remember_state
stack_table
Dwarf_Frame
_dwarf_get_alloc
dbg
DW_DLA_FRAME
if
stack_table
NULL
SER
DW_DLE_DF_ALLOC_FAIL
for
i
i
reg_count
i
stack_table
fr_reg
i
localregtab
i
stack_table
fr_cfa_rule
cfa_reg
if
top_stack
NULL
stack_table
fr_next
top_stack
top_stack
stack_table
break
case
DW_CFA_restore_state
if
top_stack
NULL
SER
DW_DLE_DF_POP_EMPTY_STACK
stack_table
top_stack
top_stack
stack_table
fr_next
for
i
i
reg_count
i
localregtab
i
stack_table
fr_reg
i
cfa_reg
stack_table
fr_cfa_rule
dwarf_dealloc
dbg
stack_table
DW_DLA_FRAME
break
case
DW_CFA_def_cfa
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
cfa_reg
ru_is_off
cfa_reg
ru_value_type
DW_EXPR_OFFSET
cfa_reg
ru_register
reg_no
cfa_reg
ru_offset_or_block_len
factored_N_value
fp_register
reg_no
fp_offset
factored_N_value
break
case
DW_CFA_def_cfa_register
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
cfa_reg
ru_register
reg_no
Do
NOT
set
ru_offset_or_block_len
or
ru_is_off
here
See
dwarf2
spec
fp_register
reg_no
break
case
DW_CFA_def_cfa_offset
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
Do
set
ru_is_off
here
as
here
factored_N_value
counts
cfa_reg
ru_is_off
cfa_reg
ru_value_type
DW_EXPR_OFFSET
cfa_reg
ru_offset_or_block_len
factored_N_value
fp_offset
factored_N_value
break
This
is
for
Metaware
with
augmentation
string
HC
We
do
not
really
know
what
to
do
with
it
case
DW_CFA_METAWARE_info
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
Not
really
known
what
the
value
means
or
is
cfa_reg
ru_is_off
cfa_reg
ru_value_type
DW_EXPR_OFFSET
cfa_reg
ru_offset_or_block_len
factored_N_value
break
case
DW_CFA_nop
break
DWARF3
ops
begin
here
case
DW_CFA_def_cfa_expression
A
single
DW_FORM_block
representing
a
dwarf
expression
The
form
block
establishes
the
way
to
compute
the
CFA
Dwarf_Unsigned
block_len
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
cfa_reg
ru_is_off
arbitrary
cfa_reg
ru_value_type
DW_EXPR_EXPRESSION
cfa_reg
ru_offset_or_block_len
block_len
cfa_reg
ru_block
instr_ptr
fp_offset
Dwarf_Unsigned
uintptr_t
instr_ptr
instr_ptr
block_len
break
case
DW_CFA_expression
An
unsigned
leb128
value
is
the
first
operand
a
register
number
The
second
operand
is
single
DW_FORM_block
representing
a
dwarf
expression
The
evaluator
pushes
the
CFA
on
the
evaluation
stack
then
evaluates
the
expression
to
compute
the
value
of
the
register
contents
Dwarf_Unsigned
lreg
Dwarf_Unsigned
block_len
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
localregtab
lreg
ru_is_off
arbitrary
localregtab
lreg
ru_value_type
DW_EXPR_EXPRESSION
localregtab
lreg
ru_offset_or_block_len
block_len
localregtab
lreg
ru_block
instr_ptr
fp_offset
Dwarf_Unsigned
uintptr_t
instr_ptr
fp_register
reg_no
instr_ptr
block_len
break
case
DW_CFA_offset_extended_sf
The
first
operand
is
an
unsigned
leb128
register
number
The
second
is
a
signed
factored
offset
Identical
to
DW_CFA_offset_extended
except
the
second
operand
is
signed
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_sword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_OFFSET
localregtab
reg_no
ru_register
reg_num_of_cfa
localregtab
reg_no
ru_offset_or_block_len
signed_factored_N_value
data_alignment_factor
fp_register
reg_no
fp_offset
signed_factored_N_value
break
case
DW_CFA_def_cfa_sf
The
first
operand
is
an
unsigned
leb128
register
number
The
second
is
a
signed
leb128
factored
offset
Identical
to
DW_CFA_def_cfa
except
that
the
second
operand
is
signed
and
factored
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_sword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
cfa_reg
ru_is_off
cfa_reg
ru_value_type
DW_EXPR_OFFSET
cfa_reg
ru_register
reg_no
cfa_reg
ru_offset_or_block_len
signed_factored_N_value
data_alignment_factor
fp_register
reg_no
fp_offset
signed_factored_N_value
break
case
DW_CFA_def_cfa_offset_sf
The
operand
is
a
signed
leb128
operand
representing
a
factored
offset
Identical
to
DW_CFA_def_cfa_offset
excep
the
operand
is
signed
and
factored
int
adres
adres
_dwarf_leb128_sword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
Do
set
ru_is_off
here
as
here
factored_N_value
counts
cfa_reg
ru_is_off
cfa_reg
ru_value_type
DW_EXPR_OFFSET
cfa_reg
ru_offset_or_block_len
signed_factored_N_value
data_alignment_factor
fp_offset
signed_factored_N_value
break
case
DW_CFA_val_offset
The
first
operand
is
an
unsigned
leb128
register
number
The
second
is
a
factored
unsigned
offset
Makes
the
register
be
a
val_offset
N
rule
with
N
factored_offset
data_alignment_factor
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
Do
set
ru_is_off
here
as
here
factored_N_value
counts
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_register
reg_num_of_cfa
localregtab
reg_no
ru_value_type
DW_EXPR_VAL_OFFSET
localregtab
reg_no
ru_offset_or_block_len
factored_N_value
data_alignment_factor
fp_offset
factored_N_value
break
case
DW_CFA_val_offset_sf
The
first
operand
is
an
unsigned
leb128
register
number
The
second
is
a
factored
signed
offset
Makes
the
register
be
a
val_offset
N
rule
with
N
factored_offset
data_alignment_factor
Dwarf_Unsigned
lreg
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_sword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
if
need_augmentation
SER
DW_DLE_DF_NO_CIE_AUGMENTATION
Do
set
ru_is_off
here
as
here
factored_N_value
counts
localregtab
reg_no
ru_is_off
localregtab
reg_no
ru_value_type
DW_EXPR_VAL_OFFSET
localregtab
reg_no
ru_offset_or_block_len
signed_factored_N_value
data_alignment_factor
fp_offset
signed_factored_N_value
break
case
DW_CFA_val_expression
The
first
operand
is
an
unsigned
leb128
register
number
The
second
is
a
DW_FORM_block
representing
a
DWARF
expression
The
rule
for
the
register
number
becomes
a
val_expression
E
rule
Dwarf_Unsigned
lreg
Dwarf_Unsigned
block_len
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
reg_no
reg_num_type
lreg
ERROR_IF_REG_NUM_TOO_HIGH
reg_no
reg_count
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
localregtab
lreg
ru_is_off
arbitrary
localregtab
lreg
ru_value_type
DW_EXPR_VAL_EXPRESSION
localregtab
lreg
ru_offset_or_block_len
block_len
localregtab
lreg
ru_block
instr_ptr
fp_offset
Dwarf_Unsigned
uintptr_t
instr_ptr
instr_ptr
block_len
fp_register
reg_no
break
END
DWARF3
new
ops
ifdef
DW_CFA_GNU_window_save
case
DW_CFA_GNU_window_save
No
information
this
just
tells
unwinder
to
restore
the
window
registers
from
the
previous
frame
s
window
save
area
break
endif
ifdef
DW_CFA_GNU_args_size
Single
uleb128
is
the
current
arg
area
size
in
bytes
No
register
exists
yet
to
save
this
in
the
value
of
must
be
added
to
an
x86
register
to
get
the
correct
stack
pointer
https
lists
nongnu
org
archive
html
libunwind
devel
msg00004
html
https
refspecs
linuxfoundation
org
LSB_3
LSB
PDA
LSB
PDA
junk
dwarfext
html
case
DW_CFA_GNU_args_size
Dwarf_Unsigned
lreg
UNUSEDARG
int
adres
adres
_dwarf_leb128_uword_wrapper
dbg
final_instr_ptr
error
if
adres
DW_DLV_OK
free
localregtab
return
adres
We
have
nowhere
to
store
lreg
FIXME
This
is
the
total
size
of
arguments
pushed
on
the
stack
break
endif
default
ERROR
we
have
an
opcode
we
know
nothing
about
Memory
leak
here
but
an
error
like
this
is
not
supposed
to
happen
so
we
ignore
the
leak
These
used
to
be
ignored
now
we
notice
and
report
SER
DW_DLE_DF_FRAME_DECODING_ERROR
if
make_instr
instr_count
curr_instr
Dwarf_Frame_Op
_dwarf_get_alloc
dbg
DW_DLA_FRAME_OP
if
curr_instr
NULL
SER
DW_DLE_DF_ALLOC_FAIL
curr_instr
fp_base_op
fp_base_op
curr_instr
fp_extended_op
fp_extended_op
curr_instr
fp_register
fp_register
curr_instr
fp_offset
fp_offset
curr_instr
fp_instr_offset
fp_instr_offset
curr_instr_item
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_instr_item
NULL
SER
DW_DLE_DF_ALLOC_FAIL
curr_instr_item
ch_item
curr_instr
curr_instr_item
ch_itemtype
DW_DLA_FRAME_OP
if
head_instr_chain
NULL
head_instr_chain
tail_instr_chain
curr_instr_item
else
tail_instr_chain
ch_next
curr_instr_item
tail_instr_chain
curr_instr_item
If
frame
instruction
decoding
was
right
we
would
stop
exactly
at
final_instr_ptr
if
instr_ptr
final_instr_ptr
SER
DW_DLE_DF_FRAME_DECODING_ERROR
If
search_over
is
set
the
last
instr
was
an
advance_loc
so
we
are
not
done
with
rows
if
instr_ptr
final_instr_ptr
search_over
if
has_more_rows
has_more_rows
false
if
subsequent_pc
subsequent_pc
else
if
has_more_rows
has_more_rows
true
if
subsequent_pc
subsequent_pc
possible_subsequent_pc
Fill
in
the
actual
output
table
the
space
the
caller
passed
in
if
table
struct
Dwarf_Reg_Rule_s
t2reg
table
fr_reg
struct
Dwarf_Reg_Rule_s
t3reg
localregtab
unsigned
minregcount
MIN
table
fr_reg_count
reg_count
unsigned
curreg
table
fr_loc
current_loc
for
curreg
minregcount
curreg
t3reg
t2reg
t2reg
t3reg
CONSTCOND
Do
not
update
the
main
table
with
the
cfa_reg
Just
leave
cfa_reg
as
cfa_reg
table
fr_cfa_rule
cfa_reg
Dealloc
anything
remaining
on
stack
for
top_stack
NULL
stack_table
top_stack
top_stack
top_stack
fr_next
dwarf_dealloc
dbg
stack_table
DW_DLA_FRAME
if
make_instr
Allocate
array
of
Dwarf_Frame_Op
structs
head_instr_block
Dwarf_Frame_Op
_dwarf_get_alloc
dbg
DW_DLA_FRAME_BLOCK
instr_count
if
head_instr_block
NULL
SER
DW_DLE_DF_ALLOC_FAIL
Store
Dwarf_Frame_Op
instances
in
this
array
and
deallocate
the
structs
that
chain
the
Dwarf_Frame_Op
instances
curr_instr_item
head_instr_chain
for
i
i
instr_count
i
void
item
curr_instr_item
ch_item
int
itemtype
curr_instr_item
ch_itemtype
Dwarf_Chain
prev_instr
This
copies
the
structs
not
pointers
head_instr_block
i
Dwarf_Frame_Op
item
prev_instr
curr_instr_item
curr_instr_item
curr_instr_item
ch_next
Now
the
pointed
to
are
space
to
dealloc
dwarf_dealloc
dbg
item
itemtype
dwarf_dealloc
dbg
prev_instr
DW_DLA_CHAIN
ret_frame_instr
head_instr_block
returned_count
Dwarf_Signed
instr_count
else
returned_count
free
localregtab
return
DW_DLV_OK
undef
ERROR_IF_REG_NUM_TOO_HIGH
undef
SER
Depending
on
version
either
read
the
return
address
register
as
a
ubyte
or
as
an
leb
number
The
form
of
this
value
changed
for
DWARF3
int
_dwarf_get_return_address_reg
Dwarf_Small
frame_ptr
int
version
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
section_end
unsigned
long
size
Dwarf_Unsigned
return_address_register
Dwarf_Error
error
Dwarf_Unsigned
uvalue
Dwarf_Unsigned
leb128_length
if
version
if
frame_ptr
section_end
_dwarf_error
NULL
error
DW_DLE_DF_FRAME_DECODING_ERROR
return
DW_DLV_ERROR
size
uvalue
unsigned
char
frame_ptr
return_address_register
uvalue
return
DW_DLV_OK
DECODE_LEB128_UWORD_LEN_CK
frame_ptr
uvalue
leb128_length
dbg
error
section_end
size
leb128_length
return_address_register
uvalue
return
DW_DLV_OK
Trivial
consumer
function
int
dwarf_get_cie_of_fde
Dwarf_Fde
fde
Dwarf_Cie
cie_returned
Dwarf_Error
error
if
fde
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
cie_returned
fde
fd_cie
return
DW_DLV_OK
int
dwarf_get_cie_index
Dwarf_Cie
cie
Dwarf_Signed
indx
Dwarf_Error
error
if
cie
NULL
_dwarf_error
NULL
error
DW_DLE_CIE_NULL
return
DW_DLV_ERROR
indx
cie
ci_index
return
DW_DLV_OK
For
g
eh_frame
fde
and
cie
the
cie
id
is
different
as
the
definition
of
the
cie_id
in
an
fde
is
the
distance
back
from
the
address
of
the
value
to
the
cie
Or
if
this
is
a
true
cie
Non
standard
dwarf
designed
this
way
to
be
convenient
at
run
time
for
an
allocated
mapped
into
memory
as
part
of
the
running
image
section
int
dwarf_get_fde_list_eh
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_frame_eh_gnu
error
if
res
DW_DLV_OK
return
res
res
_dwarf_get_fde_list_internal
dbg
cie_data
cie_element_count
fde_data
fde_element_count
dbg
de_debug_frame_eh_gnu
dss_data
dbg
de_debug_frame_eh_gnu
dss_index
dbg
de_debug_frame_eh_gnu
dss_size
cie_id_value
use_gnu_cie_calc
error
return
res
For
standard
dwarf
debug_frame
cie_id
is
in
a
cie
and
is
the
section
offset
in
the
debug_frame
section
of
the
cie
otherwise
Standard
dwarf
int
dwarf_get_fde_list
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_frame
error
if
res
DW_DLV_OK
return
res
res
_dwarf_get_fde_list_internal
dbg
cie_data
cie_element_count
fde_data
fde_element_count
dbg
de_debug_frame
dss_data
dbg
de_debug_frame
dss_index
dbg
de_debug_frame
dss_size
DW_CIE_ID
use_gnu_cie_calc
error
return
res
Only
works
on
dwarf
sections
not
eh_frame
because
based
on
DW_AT_MIPS_fde
Given
a
Dwarf_Die
see
if
it
has
a
DW_AT_MIPS_fde
attribute
and
if
so
use
that
to
get
an
fde
offset
Then
create
a
Dwarf_Fde
to
return
thru
the
ret_fde
pointer
Also
creates
a
cie
pointed
at
from
the
Dwarf_Fde
int
dwarf_get_fde_for_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Fde
ret_fde
Dwarf_Error
error
Dwarf_Attribute
attr
Dwarf_Unsigned
fde_offset
Dwarf_Signed
signdval
Dwarf_Fde
new_fde
unsigned
char
fde_ptr
unsigned
char
fde_start_ptr
unsigned
char
fde_end_ptr
unsigned
char
cie_ptr
Dwarf_Unsigned
cie_id
Fields
for
the
current
Cie
being
read
int
res
int
resattr
int
sdatares
struct
cie_fde_prefix_s
prefix
struct
cie_fde_prefix_s
prefix_c
if
die
NULL
_dwarf_error
NULL
error
DW_DLE_DIE_NULL
return
DW_DLV_ERROR
resattr
dwarf_attr
die
DW_AT_MIPS_fde
error
if
resattr
DW_DLV_OK
return
resattr
why
is
this
formsdata?
FIX
sdatares
dwarf_formsdata
attr
error
if
sdatares
DW_DLV_OK
return
sdatares
res
_dwarf_load_section
dbg
de_debug_frame
error
if
res
DW_DLV_OK
return
res
fde_offset
signdval
fde_start_ptr
dbg
de_debug_frame
dss_data
fde_ptr
fde_start_ptr
fde_offset
fde_end_ptr
fde_start_ptr
dbg
de_debug_frame
dss_size
First
read
in
the
common
prefix
to
figure
out
what
we
are
to
do
with
this
entry
memset
sizeof
prefix_c
memset
sizeof
prefix
res
dwarf_read_cie_fde_prefix
dbg
fde_ptr
dbg
de_debug_frame
dss_data
dbg
de_debug_frame
dss_index
dbg
de_debug_frame
dss_size
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
fde_ptr
prefix
cf_addr_after_prefix
cie_id
prefix
cf_cie_id
Pass
NULL
not
section
pointer
for
argument
de_debug_frame
dss_data
has
no
eh_frame
relevance
res
dwarf_create_fde_from_after_start
dbg
fde_start_ptr
fde_ptr
fde_end_ptr
use_gnu_cie_calc
Dwarf_Cie
error
if
res
DW_DLV_ERROR
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
DW_DLV_OK
now
read
the
cie
corresponding
to
the
fde
cie_ptr
new_fde
fd_section_ptr
cie_id
res
dwarf_read_cie_fde_prefix
dbg
cie_ptr
dbg
de_debug_frame
dss_data
dbg
de_debug_frame
dss_index
dbg
de_debug_frame
dss_size
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
cie_ptr
prefix_c
cf_addr_after_prefix
cie_id
prefix_c
cf_cie_id
if
cie_id
Dwarf_Unsigned
DW_CIE_ID
int
res2
Dwarf_Cie
new_cie
Pass
NULL
not
section
pointer
for
argument
de_debug_frame
dss_data
has
no
eh_frame
relevance
res2
dwarf_create_cie_from_after_start
dbg
fde_start_ptr
cie_ptr
fde_end_ptr
cie_count
use_gnu_cie_calc
error
if
res2
DW_DLV_ERROR
dwarf_dealloc
dbg
new_fde
DW_DLA_FDE
return
res
else
if
res2
DW_DLV_NO_ENTRY
dwarf_dealloc
dbg
new_fde
DW_DLA_FDE
return
res
new_fde
fd_cie
new_cie
else
_dwarf_error
dbg
error
DW_DLE_NO_CIE_FOR_FDE
return
DW_DLV_ERROR
ret_fde
new_fde
return
DW_DLV_OK
A
dwarf
consumer
operation
see
the
consumer
library
documentation
int
dwarf_get_fde_range
Dwarf_Fde
fde
Dwarf_Addr
low_pc
Dwarf_Unsigned
func_length
Dwarf_Ptr
fde_bytes
Dwarf_Unsigned
fde_byte_length
Dwarf_Off
cie_offset
Dwarf_Signed
cie_index
Dwarf_Off
fde_offset
Dwarf_Error
error
Dwarf_Debug
dbg
if
fde
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
dbg
fde
fd_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_DBG_NULL
return
DW_DLV_ERROR
We
have
always
already
done
the
section
load
here
so
no
need
to
load
the
section
We
did
the
section
load
in
order
to
create
the
Dwarf_Fde
pointer
passed
in
here
if
low_pc
NULL
low_pc
fde
fd_initial_location
if
func_length
NULL
func_length
fde
fd_address_range
if
fde_bytes
NULL
fde_bytes
fde
fd_fde_start
if
fde_byte_length
NULL
fde_byte_length
fde
fd_length
if
cie_offset
NULL
cie_offset
fde
fd_cie_offset
if
cie_index
NULL
cie_index
fde
fd_cie_index
if
fde_offset
NULL
fde_offset
fde
fd_fde_start
fde
fd_section_ptr
return
DW_DLV_OK
IRIX
specific
function
The
exception
tables
have
C
destructor
information
and
are
at
present
undocumented
int
dwarf_get_fde_exception_info
Dwarf_Fde
fde
Dwarf_Signed
offset_into_exception_tables
Dwarf_Error
error
Dwarf_Debug
dbg
dbg
fde
fd_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_DBG_NULL
return
DW_DLV_ERROR
offset_into_exception_tables
fde
fd_offset_into_exception_tables
return
DW_DLV_OK
A
consumer
code
function
Given
a
CIE
pointer
return
the
normal
CIE
data
thru
pointers
Special
augmentation
data
is
not
returned
here
int
dwarf_get_cie_info_b
Dwarf_Cie
cie
Dwarf_Unsigned
bytes_in_cie
Dwarf_Small
ptr_to_version
char
augmenter
Dwarf_Unsigned
code_alignment_factor
Dwarf_Signed
data_alignment_factor
Dwarf_Half
return_address_register
Dwarf_Ptr
initial_instructions
Dwarf_Unsigned
initial_instructions_length
Dwarf_Half
offset_size
Dwarf_Error
error
Dwarf_Debug
dbg
if
cie
NULL
_dwarf_error
NULL
error
DW_DLE_CIE_NULL
return
DW_DLV_ERROR
dbg
cie
ci_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_CIE_DBG_NULL
return
DW_DLV_ERROR
if
ptr_to_version
NULL
ptr_to_version
cie
ci_cie_version_number
if
augmenter
NULL
augmenter
cie
ci_augmentation
if
code_alignment_factor
NULL
code_alignment_factor
cie
ci_code_alignment_factor
if
data_alignment_factor
NULL
data_alignment_factor
cie
ci_data_alignment_factor
if
return_address_register
NULL
return_address_register
cie
ci_return_address_register
if
initial_instructions
NULL
initial_instructions
cie
ci_cie_instr_start
if
initial_instructions_length
NULL
initial_instructions_length
cie
ci_length
cie
ci_length_size
cie
ci_extension_size
cie
ci_cie_instr_start
cie
ci_cie_start
if
offset_size
offset_size
cie
ci_length_size
bytes_in_cie
cie
ci_length
return
DW_DLV_OK
Return
the
register
rules
for
all
registers
at
a
given
pc
static
int
_dwarf_get_fde_info_for_a_pc_row
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Frame
table
Dwarf_Half
cfa_reg_col_num
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Cie
cie
Dwarf_Signed
icount
int
res
if
fde
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
dbg
fde
fd_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_DBG_NULL
return
DW_DLV_ERROR
if
pc_requested
fde
fd_initial_location
pc_requested
fde
fd_initial_location
fde
fd_address_range
_dwarf_error
dbg
error
DW_DLE_PC_NOT_IN_FDE_RANGE
return
DW_DLV_ERROR
cie
fde
fd_cie
if
cie
ci_initial_table
NULL
Dwarf_Small
instrstart
cie
ci_cie_instr_start
Dwarf_Small
instrend
instrstart
cie
ci_length
cie
ci_length_size
cie
ci_extension_size
cie
ci_cie_instr_start
cie
ci_cie_start
if
instrend
cie
ci_cie_end
_dwarf_error
dbg
error
DW_DLE_CIE_INSTR_PTR_ERROR
return
DW_DLV_ERROR
cie
ci_initial_table
Dwarf_Frame
_dwarf_get_alloc
dbg
DW_DLA_FRAME
if
cie
ci_initial_table
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
dwarf_init_reg_rules_ru
cie
ci_initial_table
fr_reg
cie
ci_initial_table
fr_reg_count
dbg
de_frame_rule_initial_value
dwarf_init_reg_rules_ru
ci_initial_table
fr_cfa_rule
dbg
de_frame_rule_initial_value
res
_dwarf_exec_frame_instr
make_instr
false
ret_frame_instr
NULL
search_pc
false
search_pc_val
location
instrstart
instrend
cie
ci_initial_table
cie
dbg
cfa_reg_col_num
NULL
NULL
error
if
res
DW_DLV_OK
return
res
Dwarf_Small
instr_end
fde
fd_fde_instr_start
fde
fd_length
fde
fd_length_size
fde
fd_extension_size
fde
fd_fde_instr_start
fde
fd_fde_start
if
instr_end
fde
fd_fde_end
_dwarf_error
dbg
error
DW_DLE_FDE_INSTR_PTR_ERROR
return
DW_DLV_ERROR
res
_dwarf_exec_frame_instr
make_instr
false
ret_frame_instr
NULL
search_pc
true
search_pc_val
pc_requested
fde
fd_initial_location
fde
fd_fde_instr_start
instr_end
table
cie
dbg
cfa_reg_col_num
has_more_rows
subsequent_pc
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
A
consumer
call
for
efficiently
getting
the
register
info
for
all
registers
in
one
call
The
output
table
rules
array
is
size
DW_REG_TABLE_SIZE
The
frame
info
rules
array
in
fde_table
is
of
size
DW_REG_TABLE_SIZE
too
This
interface
really
only
works
well
with
MIPS
IRIX
where
DW_FRAME_CFA_COL
is
zero
in
that
case
it
s
safe
It
is
also
restricted
to
the
case
where
DW_REG_TABLE_SIZE
DW_FRAME_LAST_REG_NUM
dbg
de_frame_reg_rules_entry_count
true
for
MIPS
IRIX
If
this
condition
is
not
met
calling
this
routine
can
result
in
incorrect
output
or
in
memory
corruption
It
is
much
better
to
use
dwarf_get_fde_info_for_all_regs3
instead
of
this
interface
A
consumer
call
for
efficiently
getting
the
register
info
for
all
registers
in
one
call
The
output
table
rules
array
is
size
output_table_real_data_size
normally
DW_REG_TABLE_SIZE
The
frame
info
rules
array
in
fde_table
is
normally
of
size
DW_FRAME_LAST_REG_NUM
int
dwarf_get_fde_info_for_all_regs3
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Regtable3
reg_table
Dwarf_Addr
row_pc
Dwarf_Error
error
struct
Dwarf_Frame_s
fde_table
Dwarf_Signed
i
int
res
struct
Dwarf_Reg_Rule_s
rule
NULL
struct
Dwarf_Regtable_Entry3_s
out_rule
NULL
Dwarf_Debug
dbg
int
output_table_real_data_size
reg_table
rt3_reg_table_size
FDE_NULL_CHECKS_AND_SET_DBG
fde
dbg
output_table_real_data_size
MIN
output_table_real_data_size
dbg
de_frame_reg_rules_entry_count
res
dwarf_initialize_fde_table
dbg
output_table_real_data_size
error
if
res
DW_DLV_OK
return
res
_dwarf_get_fde_info_for_a_pc_row
will
perform
more
sanity
checks
res
_dwarf_get_fde_info_for_a_pc_row
fde
pc_requested
dbg
de_frame_cfa_col_number
NULL
NULL
error
if
res
DW_DLV_OK
dwarf_free_fde_table
return
res
out_rule
rt3_rules
rule
fr_reg
for
i
i
output_table_real_data_size
i
out_rule
rule
out_rule
dw_offset_relevant
rule
ru_is_off
out_rule
dw_value_type
rule
ru_value_type
out_rule
dw_regnum
rule
ru_register
out_rule
dw_offset_or_block_len
rule
ru_offset_or_block_len
out_rule
dw_block_ptr
rule
ru_block
dwarf_init_reg_rules_dw3
rt3_rules
i
reg_table
rt3_reg_table_size
dbg
de_frame_undefined_value_number
reg_table
rt3_cfa_rule
dw_offset_relevant
fde_table
fr_cfa_rule
ru_is_off
reg_table
rt3_cfa_rule
dw_value_type
fde_table
fr_cfa_rule
ru_value_type
reg_table
rt3_cfa_rule
dw_regnum
fde_table
fr_cfa_rule
ru_register
reg_table
rt3_cfa_rule
dw_offset_or_block_len
fde_table
fr_cfa_rule
ru_offset_or_block_len
reg_table
rt3_cfa_rule
dw_block_ptr
fde_table
fr_cfa_rule
ru_block
if
row_pc
NULL
row_pc
fde_table
fr_loc
dwarf_free_fde_table
return
DW_DLV_OK
In
this
interface
table_column
of
DW_FRAME_CFA_COL
is
not
meaningful
Use
dwarf_get_fde_info_for_cfa_reg3_b
to
get
the
CFA
Call
dwarf_set_frame_cfa_value
to
set
the
correct
column
after
calling
dwarf_init
DW_FRAME_CFA_COL3
is
a
sensible
column
to
use
New
May
If
one
is
tracking
the
value
of
a
single
table
column
through
a
function
this
lets
us
skip
to
the
next
pc
value
easily
if
pc_requested
is
a
change
from
the
last
pc_requested
on
this
pc
this
function
returns
has_more_rows
and
subsequent_pc
null
pointers
passed
are
acceptable
the
assignment
through
the
pointer
is
skipped
if
the
pointer
is
null
Otherwise
has_more_rows
and
subsequent_pc
are
not
set
int
dwarf_get_fde_info_for_reg3_b
Dwarf_Fde
fde
Dwarf_Half
table_column
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register_num
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
struct
Dwarf_Frame_s
fde_table
fde
fd_fde_table
int
res
DW_DLV_ERROR
Dwarf_Debug
dbg
int
table_real_data_size
FDE_NULL_CHECKS_AND_SET_DBG
fde
dbg
if
fde
fd_have_fde_tab
The
test
is
just
in
case
it
s
not
inside
the
table
For
non
MIPS
it
could
be
outside
the
table
and
that
is
just
fine
it
was
really
a
mistake
to
put
it
in
the
table
in
fde
fd_fde_pc_requested
pc_requested
if
fde
fd_have_fde_tab
dwarf_free_fde_table
fde_table
fde
fd_have_fde_tab
false
table_real_data_size
dbg
de_frame_reg_rules_entry_count
res
dwarf_initialize_fde_table
dbg
fde_table
table_real_data_size
error
if
res
DW_DLV_OK
return
res
if
table_column
table_real_data_size
dwarf_free_fde_table
fde_table
fde
fd_have_fde_tab
false
_dwarf_error
dbg
error
DW_DLE_FRAME_TABLE_COL_BAD
return
DW_DLV_ERROR
_dwarf_get_fde_info_for_a_pc_row
will
perform
more
sanity
checks
res
_dwarf_get_fde_info_for_a_pc_row
fde
pc_requested
fde_table
dbg
de_frame_cfa_col_number
has_more_rows
subsequent_pc
error
if
res
DW_DLV_OK
dwarf_free_fde_table
fde_table
fde
fd_have_fde_tab
false
return
res
if
register_num
NULL
register_num
fde_table
fr_reg
table_column
ru_register
if
offset_or_block_len
NULL
offset_or_block_len
fde_table
fr_reg
table_column
ru_offset_or_block_len
if
row_pc_out
NULL
row_pc_out
fde_table
fr_loc
if
block_ptr
block_ptr
fde_table
fr_reg
table_column
ru_block
Without
value_type
the
data
cannot
be
understood
so
we
insist
on
it
being
present
we
don
t
test
it
value_type
fde_table
fr_reg
table_column
ru_value_type
offset_relevant
fde_table
fr_reg
table_column
ru_is_off
fde
fd_have_fde_tab
true
fde
fd_fde_pc_requested
pc_requested
return
DW_DLV_OK
Compared
to
dwarf_get_fde_info_for_reg
it
more
correctly
deals
with
the
CFA
by
not
making
the
CFA
a
column
number
which
means
DW_FRAME_CFA_COL3
becomes
like
DW_CFA_SAME_VALUE
a
special
value
not
something
one
uses
as
an
index
Has
extra
arguments
has_more_rows
and
next_pc
which
can
be
used
to
more
efficiently
traverse
frame
data
primarily
for
dwarfdump
and
like
programs
This
deals
with
the
CFA
by
not
making
the
CFA
a
column
number
which
means
DW_FRAME_CFA_COL3
is
like
DW_CFA_SAME_VALUE
a
special
value
not
something
one
uses
as
an
index
Call
dwarf_set_frame_cfa_value
to
set
the
correct
column
after
calling
dwarf_init
DW_FRAME_CFA_COL3
is
a
sensible
column
to
use
and
is
the
default
unless
enable
oldframecol
is
used
to
configure
libdwarf
int
dwarf_get_fde_info_for_cfa_reg3_b
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register_num
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
struct
Dwarf_Frame_s
fde_table
int
res
DW_DLV_ERROR
Dwarf_Debug
dbg
int
table_real_data_size
FDE_NULL_CHECKS_AND_SET_DBG
fde
dbg
table_real_data_size
dbg
de_frame_reg_rules_entry_count
res
dwarf_initialize_fde_table
dbg
table_real_data_size
error
if
res
DW_DLV_OK
return
res
res
_dwarf_get_fde_info_for_a_pc_row
fde
pc_requested
dbg
de_frame_cfa_col_number
has_more_rows
subsequent_pc
error
if
res
DW_DLV_OK
dwarf_free_fde_table
return
res
if
register_num
NULL
register_num
fde_table
fr_cfa_rule
ru_register
if
offset_or_block_len
NULL
offset_or_block_len
fde_table
fr_cfa_rule
ru_offset_or_block_len
if
row_pc_out
NULL
row_pc_out
fde_table
fr_loc
if
block_ptr
block_ptr
fde_table
fr_cfa_rule
ru_block
Without
value_type
the
data
cannot
be
understood
so
we
insist
on
it
being
present
we
don
t
test
it
value_type
fde_table
fr_cfa_rule
ru_value_type
offset_relevant
fde_table
fr_cfa_rule
ru_is_off
dwarf_free_fde_table
return
DW_DLV_OK
Return
pointer
to
the
instructions
in
the
dwarf
fde
int
dwarf_get_fde_instr_bytes
Dwarf_Fde
inFde
Dwarf_Ptr
outinstraddr
Dwarf_Unsigned
outaddrlen
Dwarf_Error
error
Dwarf_Unsigned
len
unsigned
char
instrs
Dwarf_Debug
dbg
if
inFde
NULL
_dwarf_error
dbg
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
dbg
inFde
fd_dbg
if
dbg
NULL
_dwarf_error
dbg
error
DW_DLE_FDE_DBG_NULL
return
DW_DLV_ERROR
instrs
inFde
fd_fde_instr_start
len
inFde
fd_fde_start
inFde
fd_length
inFde
fd_length_size
inFde
fd_extension_size
instrs
outinstraddr
instrs
outaddrlen
len
return
DW_DLV_OK
Allows
getting
an
fde
from
its
table
via
an
index
With
more
error
checking
than
simply
indexing
oneself
int
dwarf_get_fde_n
Dwarf_Fde
fde_data
Dwarf_Unsigned
fde_index
Dwarf_Fde
returned_fde
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Unsigned
fdecount
if
fde_data
NULL
_dwarf_error
dbg
error
DW_DLE_FDE_PTR_NULL
return
DW_DLV_ERROR
FDE_NULL_CHECKS_AND_SET_DBG
fde_data
dbg
Assumes
fde_data
table
has
at
least
one
entry
fdecount
fde_data
fd_is_eh?
dbg
de_fde_count_eh
dbg
de_fde_count
if
fde_index
fdecount
return
DW_DLV_NO_ENTRY
returned_fde
fde_data
fde_index
return
DW_DLV_OK
Lopc
and
hipc
are
extensions
to
the
interface
to
return
the
range
of
addresses
that
are
described
by
the
returned
fde
int
dwarf_get_fde_at_pc
Dwarf_Fde
fde_data
Dwarf_Addr
pc_of_interest
Dwarf_Fde
returned_fde
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Error
error
Dwarf_Debug
dbg
NULL
Dwarf_Fde
fde
NULL
Dwarf_Fde
entryfde
NULL
Dwarf_Signed
fdecount
if
fde_data
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_PTR_NULL
return
DW_DLV_ERROR
Assumes
fde_data
table
has
at
least
one
entry
entryfde
fde_data
FDE_NULL_CHECKS_AND_SET_DBG
entryfde
dbg
fdecount
entryfde
fd_is_eh?
dbg
de_fde_count_eh
dbg
de_fde_count
The
fdes
are
sorted
by
their
addresses
Binary
search
to
find
correct
fde
Dwarf_Signed
low
Dwarf_Signed
high
fdecount
Dwarf_Signed
middle
Dwarf_Fde
cur_fde
while
low
high
middle
low
high
cur_fde
fde_data
middle
if
pc_of_interest
cur_fde
fd_initial_location
high
middle
else
if
pc_of_interest
cur_fde
fd_initial_location
cur_fde
fd_address_range
low
middle
else
fde
fde_data
middle
break
if
fde
if
lopc
NULL
lopc
fde
fd_initial_location
if
hipc
NULL
hipc
fde
fd_initial_location
fde
fd_address_range
returned_fde
fde
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
Expands
a
single
frame
instruction
block
from
a
specific
cie
into
a
n
array
of
Dwarf_Frame_Op
s
This
depends
on
having
the
cfa
column
set
sensibly
Call
dwarf_set_frame_cfa_value
to
set
the
correct
column
after
calling
dwarf_init
unless
you
are
using
the
old
MIPS
frame
interfaces
in
which
case
the
default
will
be
ok
DW_FRAME_CFA_COL3
is
a
sensible
column
to
use
int
dwarf_expand_frame_instructions
Dwarf_Cie
cie
Dwarf_Ptr
instruction
Dwarf_Unsigned
i_length
Dwarf_Frame_Op
returned_op_list
Dwarf_Signed
returned_op_count
Dwarf_Error
error
Dwarf_Signed
instr_count
int
res
DW_DLV_ERROR
Dwarf_Debug
dbg
Dwarf_Small
instr_start
instruction
Dwarf_Small
instr_end
Dwarf_Small
instruction
i_length
if
cie
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
dbg
cie
ci_dbg
if
returned_op_list
returned_op_count
_dwarf_error
dbg
error
DW_DLE_RET_OP_LIST_NULL
return
DW_DLV_ERROR
if
instr_end
instr_start
Impossible
unless
there
was
wraparond
somewhere
and
we
missed
it
_dwarf_error
dbg
error
DW_DLE_FDE_INSTR_PTR_ERROR
return
DW_DLV_ERROR
res
_dwarf_exec_frame_instr
make_instr
true
returned_op_list
search_pc
false
search_pc_val
location
instr_start
instr_end
Dwarf_Frame
NULL
cie
dbg
dbg
de_frame_cfa_col_number
NULL
NULL
error
if
res
DW_DLV_OK
return
res
returned_op_count
instr_count
return
DW_DLV_OK
Used
by
dwarfdump
v
to
print
offsets
for
debugging
dwarf
info
The
dwarf_
version
is
preferred
over
the
obsolete
_dwarf
version
_dwarf
version
kept
for
compatibility
ARGSUSED
int
_dwarf_fde_section_offset
Dwarf_Debug
dbg
Dwarf_Fde
in_fde
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Dwarf_Error
err
return
dwarf_fde_section_offset
dbg
in_fde
fde_off
cie_off
err
ARGSUSED
int
dwarf_fde_section_offset
Dwarf_Debug
dbg
Dwarf_Fde
in_fde
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Dwarf_Error
err
char
start
char
loc
if
in_fde
_dwarf_error
dbg
err
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
start
char
in_fde
fd_section_ptr
loc
char
in_fde
fd_fde_start
fde_off
loc
start
cie_off
in_fde
fd_cie_offset
return
DW_DLV_OK
Used
by
dwarfdump
v
to
print
offsets
for
debugging
dwarf
info
The
dwarf_
version
is
preferred
over
the
obsolete
_dwarf
version
_dwarf
version
kept
for
compatibility
ARGSUSED
int
_dwarf_cie_section_offset
Dwarf_Debug
dbg
Dwarf_Cie
in_cie
Dwarf_Off
cie_off
Dwarf_Error
err
return
dwarf_cie_section_offset
dbg
in_cie
cie_off
err
ARGSUSED
int
dwarf_cie_section_offset
Dwarf_Debug
dbg
Dwarf_Cie
in_cie
Dwarf_Off
cie_off
Dwarf_Error
err
char
start
char
loc
if
in_cie
_dwarf_error
dbg
err
DW_DLE_CIE_NULL
return
DW_DLV_ERROR
start
char
in_cie
ci_section_ptr
loc
char
in_cie
ci_cie_start
cie_off
loc
start
return
DW_DLV_OK
Returns
a
pointer
to
target
specific
augmentation
data
thru
augdata
and
returns
the
length
of
the
data
thru
augdata_len
It
s
up
to
the
consumer
code
to
know
how
to
interpret
the
bytes
of
target
specific
data
endian
issues
apply
too
these
are
just
raw
bytes
pointed
to
See
Linux
Standard
Base
Core
Specification
version
for
the
details
on
eh_frame
info
Returns
DW_DLV_ERROR
if
fde
is
NULL
or
some
other
serious
error
Returns
DW_DLV_NO_ENTRY
if
there
is
no
target
specific
augmentation
data
The
bytes
pointed
to
are
in
the
Dwarf_Cie
and
as
long
as
that
is
valid
the
bytes
are
there
No
dealloc
call
is
needed
for
the
bytes
int
dwarf_get_cie_augmentation_data
Dwarf_Cie
cie
Dwarf_Small
augdata
Dwarf_Unsigned
augdata_len
Dwarf_Error
error
if
cie
NULL
_dwarf_error
NULL
error
DW_DLE_CIE_NULL
return
DW_DLV_ERROR
if
cie
ci_gnu_eh_augmentation_len
return
DW_DLV_NO_ENTRY
augdata
Dwarf_Small
cie
ci_gnu_eh_augmentation_bytes
augdata_len
cie
ci_gnu_eh_augmentation_len
return
DW_DLV_OK
Returns
a
pointer
to
target
specific
augmentation
data
thru
augdata
and
returns
the
length
of
the
data
thru
augdata_len
It
s
up
to
the
consumer
code
to
know
how
to
interpret
the
bytes
of
target
specific
data
endian
issues
apply
too
these
are
just
raw
bytes
pointed
to
See
Linux
Standard
Base
Core
Specification
version
for
the
details
on
eh_frame
info
Returns
DW_DLV_ERROR
if
fde
is
NULL
or
some
other
serious
error
Returns
DW_DLV_NO_ENTRY
if
there
is
no
target
specific
augmentation
data
The
bytes
pointed
to
are
in
the
Dwarf_Fde
and
as
long
as
that
is
valid
the
bytes
are
there
No
dealloc
call
is
needed
for
the
bytes
int
dwarf_get_fde_augmentation_data
Dwarf_Fde
fde
Dwarf_Small
augdata
Dwarf_Unsigned
augdata_len
Dwarf_Error
error
Dwarf_Cie
cie
if
fde
NULL
_dwarf_error
NULL
error
DW_DLE_FDE_NULL
return
DW_DLV_ERROR
if
fde
fd_gnu_eh_aug_present
return
DW_DLV_NO_ENTRY
cie
fde
fd_cie
if
cie
NULL
_dwarf_error
NULL
error
DW_DLE_CIE_NULL
return
DW_DLV_ERROR
augdata
Dwarf_Small
fde
fd_gnu_eh_augmentation_bytes
augdata_len
fde
fd_gnu_eh_augmentation_len
return
DW_DLV_OK
if
FOR
DEBUGGING
Used
solely
for
debugging
libdwarf
static
void
dump_frame_rule
char
msg
struct
Dwarf_Reg_Rule_s
reg_rule
printf
s
type
s
DW_PR_XZEROS
DW_PR_DUx
is_off
DW_PR_DUu
reg
DW_PR_DUu
offset
DW_PR_XZEROS
DW_PR_DUx
blockp
DW_PR_XZEROS
DW_PR_DUx
n
msg
reg_rule
ru_value_type
DW_EXPR_OFFSET
DW_EXPR_OFFSET
reg_rule
ru_value_type
DW_EXPR_VAL_OFFSET
DW_EXPR_VAL_OFFSET
reg_rule
ru_value_type
DW_EXPR_VAL_EXPRESSION
DW_EXPR_VAL_EXPRESSION
reg_rule
ru_value_type
DW_EXPR_EXPRESSION
DW_EXPR_EXPRESSION
Unknown
Dwarf_Unsigned
reg_rule
ru_value_type
Dwarf_Unsigned
reg_rule
ru_is_off
Dwarf_Unsigned
reg_rule
ru_register
Dwarf_Unsigned
reg_rule
ru_offset_or_block_len
Dwarf_Unsigned
reg_rule
ru_block
return
endif
This
allows
consumers
to
set
the
initial
value
so
that
an
ISA
ABI
specific
default
can
be
used
dynamically
at
run
time
Useful
for
dwarfdump
and
non
MIPS
architectures
The
value
defaults
to
one
of
DW_FRAME_SAME_VALUE
or
DW_FRAME_UNKNOWN_VALUE
but
dwarfdump
can
dump
multiple
ISA
ABI
objects
so
we
may
want
to
get
this
set
to
what
the
ABI
says
is
correct
Returns
the
value
that
was
present
before
we
changed
it
here
Dwarf_Half
dwarf_set_frame_rule_initial_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
orig
dbg
de_frame_rule_initial_value
dbg
de_frame_rule_initial_value
value
return
orig
The
following
spelling
for
backwards
compatibility
Dwarf_Half
dwarf_set_frame_rule_inital_value
Dwarf_Debug
dbg
Dwarf_Half
value
return
dwarf_set_frame_rule_initial_value
dbg
value
This
allows
consumers
to
set
the
array
size
of
the
reg
rules
table
so
that
an
ISA
ABI
specific
value
can
be
used
dynamically
at
run
time
Useful
for
non
MIPS
architectures
The
value
defaults
to
DW_FRAME_LAST_REG_NUM
but
dwarfdump
can
dump
multiple
ISA
ABI
objects
so
consumers
want
to
get
this
set
to
what
the
ABI
says
is
correct
Returns
the
value
that
was
present
before
we
changed
it
here
Dwarf_Half
dwarf_set_frame_rule_table_size
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
orig
dbg
de_frame_reg_rules_entry_count
dbg
de_frame_reg_rules_entry_count
value
Take
the
caller
specified
value
but
do
not
let
the
value
be
too
small
Keep
it
at
least
to
DW_FRAME_LAST_REG_NUM
This
helps
prevent
libdwarf
mistakenly
indexing
outside
of
of
a
register
array
when
the
ABI
reg
count
is
really
small
if
value
DW_FRAME_LAST_REG_NUM
dbg
de_frame_reg_rules_entry_count
DW_FRAME_LAST_REG_NUM
return
orig
This
allows
consumers
to
set
the
CFA
register
value
so
that
an
ISA
ABI
specific
value
can
be
used
dynamically
at
run
time
Useful
for
non
MIPS
architectures
The
value
defaults
to
DW_FRAME_CFA_COL3
and
should
be
higher
than
any
real
register
in
the
ABI
Dwarfdump
can
dump
multiple
ISA
ABI
objects
so
consumers
want
to
get
this
set
to
what
the
ABI
says
is
correct
Returns
the
value
that
was
present
before
we
changed
it
here
Dwarf_Half
dwarf_set_frame_cfa_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
orig
dbg
de_frame_cfa_col_number
dbg
de_frame_cfa_col_number
value
return
orig
Similar
to
above
but
for
the
other
crucial
fields
for
frames
Dwarf_Half
dwarf_set_frame_same_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
orig
dbg
de_frame_same_value_number
dbg
de_frame_same_value_number
value
return
orig
Dwarf_Half
dwarf_set_frame_undefined_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
orig
dbg
de_frame_same_value_number
dbg
de_frame_undefined_value_number
value
return
orig
Does
something
only
if
value
passed
in
is
greater
than
and
a
size
than
we
can
handle
in
number
of
bytes
Dwarf_Small
dwarf_set_default_address_size
Dwarf_Debug
dbg
Dwarf_Small
value
Dwarf_Small
orig
dbg
de_pointer_size
if
value
value
sizeof
Dwarf_Addr
dbg
de_pointer_size
value
return
orig
static
int
init_reg_rules_alloc
Dwarf_Debug
dbg
struct
Dwarf_Frame_s
f
unsigned
count
Dwarf_Error
error
f
fr_reg_count
count
f
fr_reg
struct
Dwarf_Reg_Rule_s
calloc
sizeof
struct
Dwarf_Reg_Rule_s
count
if
f
fr_reg
if
error
_dwarf_error
dbg
error
DW_DLE_DF_ALLOC_FAIL
return
DW_DLV_ERROR
dwarf_init_reg_rules_ru
f
fr_reg
count
dbg
de_frame_rule_initial_value
return
DW_DLV_OK
static
int
dwarf_initialize_fde_table
Dwarf_Debug
dbg
struct
Dwarf_Frame_s
fde_table
unsigned
table_real_data_size
Dwarf_Error
error
unsigned
entry_size
sizeof
struct
Dwarf_Frame_s
memset
fde_table
entry_size
fde_table
fr_loc
fde_table
fr_next
return
init_reg_rules_alloc
dbg
fde_table
table_real_data_size
error
static
void
dwarf_free_fde_table
struct
Dwarf_Frame_s
fde_table
free
fde_table
fr_reg
fde_table
fr_reg_count
fde_table
fr_reg
Return
DW_DLV_OK
if
we
succeed
else
return
DW_DLV_ERROR
int
_dwarf_frame_constructor
Dwarf_Debug
dbg
void
frame
struct
Dwarf_Frame_s
fp
frame
if
dbg
return
DW_DLV_ERROR
return
init_reg_rules_alloc
dbg
fp
dbg
de_frame_reg_rules_entry_count
void
_dwarf_frame_destructor
void
frame
struct
Dwarf_Frame_s
fp
frame
dwarf_free_fde_table
fp
void
_dwarf_fde_destructor
void
f
struct
Dwarf_Fde_s
fde
f
if
fde
fd_have_fde_tab
dwarf_free_fde_table
fd_fde_table
fde
fd_have_fde_tab
false
static
void
dwarf_init_reg_rules_ru
struct
Dwarf_Reg_Rule_s
base
unsigned
first
unsigned
last
int
initial_value
struct
Dwarf_Reg_Rule_s
r
base
first
unsigned
i
first
for
i
last
i
r
r
ru_is_off
r
ru_value_type
DW_EXPR_OFFSET
r
ru_register
initial_value
r
ru_offset_or_block_len
r
ru_block
static
void
dwarf_init_reg_rules_dw3
struct
Dwarf_Regtable_Entry3_s
base
unsigned
first
unsigned
last
int
initial_value
struct
Dwarf_Regtable_Entry3_s
r
base
first
unsigned
i
first
for
i
last
i
r
r
dw_offset_relevant
r
dw_value_type
DW_EXPR_OFFSET
r
dw_regnum
initial_value
r
dw_offset_or_block_len
r
dw_block_ptr
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
implements
_dwarf_get_fde_list_internal
and
related
helper
functions
for
reading
cie
fde
data
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
for
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_frame
h
include
dwarf_arange
h
using
Arange
as
a
way
to
build
a
list
include
dwarfstring
h
For
a
little
information
about
eh_frame
see
https
stackoverflow
com
questions
what
do
the
eh
frame
and
eh
frame
hdr
sections
store
exactly
http
refspecs
linuxfoundation
org
LSB_3
LSB
Core
generic
LSB
Core
generic
ehframechpt
html
The
above
give
information
about
fields
and
sizes
but
very
very
little
about
content
eh_frame_hdr
contains
data
for
C
unwinding
Namely
tables
for
fast
access
into
eh_frame
if
FOR
DEBUGGING
For
debugging
only
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
static
int
dwarf_find_existing_cie_ptr
Dwarf_Small
cie_ptr
Dwarf_Cie
cur_cie_ptr
Dwarf_Cie
cie_ptr_to_use_out
Dwarf_Cie
head_cie_ptr
static
void
dealloc_fde_cie_list_internal
Dwarf_Fde
head_fde_ptr
Dwarf_Cie
head_cie_ptr
static
int
dwarf_create_cie_from_start
Dwarf_Debug
dbg
Dwarf_Small
cie_ptr_val
Dwarf_Small
section_ptr
Dwarf_Unsigned
section_index
Dwarf_Unsigned
section_length
Dwarf_Small
section_ptr_end
Dwarf_Unsigned
cie_id_value
Dwarf_Unsigned
cie_count
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_to_use_out
Dwarf_Error
error
static
int
get_gcc_eh_augmentation
Dwarf_Debug
dbg
Dwarf_Small
frame_ptr
unsigned
long
size_of_augmentation_data
enum
Dwarf_augmentation_type
augtype
Dwarf_Small
section_end_pointer
char
augmentation
Dwarf_Error
error
static
int
gnu_aug_encodings
Dwarf_Debug
dbg
char
augmentation
Dwarf_Small
aug_data
Dwarf_Unsigned
aug_data_len
Dwarf_Half
address_size
unsigned
char
pers_hand_enc_out
unsigned
char
lsda_enc_out
unsigned
char
fde_begin_enc_out
Dwarf_Addr
gnu_pers_addr_out
Dwarf_Error
error
static
int
read_encoded_ptr
Dwarf_Debug
dbg
Dwarf_Small
section_pointer
Dwarf_Small
input_field
int
gnu_encoding
Dwarf_Small
section_ptr_end
Dwarf_Half
address_size
Dwarf_Unsigned
addr
Dwarf_Small
input_field_out
Dwarf_Error
error
Called
by
qsort
to
compare
FDE
entries
Consumer
code
expects
the
array
of
FDE
pointers
to
be
in
address
order
static
int
qsort_compare
const
void
elem1
const
void
elem2
const
Dwarf_Fde
fde1
const
Dwarf_Fde
elem1
const
Dwarf_Fde
fde2
const
Dwarf_Fde
elem2
Dwarf_Addr
addr1
fde1
fd_initial_location
Dwarf_Addr
addr2
fde2
fd_initial_location
if
addr1
addr2
return
else
if
addr1
addr2
return
return
Adds
newone
to
the
end
of
the
list
starting
at
head
and
makes
the
new
one
current
static
void
chain_up_fde
Dwarf_Fde
newone
Dwarf_Fde
head
Dwarf_Fde
cur
if
head
NULL
head
newone
else
cur
fd_next
newone
cur
newone
Adds
newone
to
the
end
of
the
list
starting
at
head
and
makes
the
new
one
current
static
void
chain_up_cie
Dwarf_Cie
newone
Dwarf_Cie
head
Dwarf_Cie
cur
if
head
NULL
head
newone
else
cur
ci_next
newone
cur
newone
The
size
of
the
length
field
plus
the
value
of
length
must
be
an
integral
multiple
of
the
address
size
Dwarf4
standard
A
constant
that
gives
the
number
of
bytes
of
the
CIE
structure
not
including
the
length
field
itself
where
length
mod
size
of
an
address
see
Section
Dwarf3
standard
A
uword
constant
that
gives
the
number
of
bytes
of
the
CIE
structure
not
including
the
length
field
itself
length
mod
addressing
unit
size
Dwarf2
standard
static
void
validate_length
Dwarf_Debug
dbg
Dwarf_Cie
cieptr
Dwarf_Unsigned
length
Dwarf_Unsigned
length_size
Dwarf_Unsigned
extension_size
Dwarf_Small
section_ptr
Dwarf_Small
ciefde_start
const
char
cieorfde
Dwarf_Unsigned
address_size
Dwarf_Unsigned
length_field_summed
length_size
extension_size
Dwarf_Unsigned
total_len
length
length_field_summed
Dwarf_Unsigned
mod
if
cieptr
address_size
cieptr
ci_address_size
else
address_size
dbg
de_pointer_size
mod
total_len
address_size
if
mod
dwarfstring
harm
Dwarf_Unsigned
sectionoffset
ciefde_start
section_ptr
dwarfstring_constructor
if
cieorfde
strlen
cieorfde
Coding
error
or
memory
corruption?
cieorfde
ERROR
dwarfstring_append_printf_u
DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE
len
DW_PR_XZEROS
DW_PR_DUx
length
dwarfstring_append_printf_u
len
size
DW_PR_XZEROS
DW_PR_DUx
length_size
dwarfstring_append_printf_u
extn
size
DW_PR_XZEROS
DW_PR_DUx
extension_size
dwarfstring_append_printf_u
totl
length
DW_PR_XZEROS
DW_PR_DUx
total_len
dwarfstring_append_printf_u
addr
size
DW_PR_XZEROS
DW_PR_DUx
address_size
dwarfstring_append_printf_u
mod
DW_PR_XZEROS
DW_PR_DUx
must
be
zero
mod
dwarfstring_append_printf_s
in
s
char
cieorfde
dwarfstring_append_printf_u
offset
DW_PR_XZEROS
DW_PR_DUx
sectionoffset
dwarf_insert_harmless_error
dbg
dwarfstring_string
dwarfstring_destructor
return
if
FOR
DEBUGGING
For
debugging
only
static
void
print_prefix
struct
cie_fde_prefix_s
prefix
int
line
printf
prefix
print
prefix
at
lx
line
d
n
unsigned
long
prefix
line
printf
start
addr
lx
after
prefix
lx
n
unsigned
long
prefix
cf_start_addr
unsigned
long
prefix
cf_addr_after_prefix
printf
length
DW_PR_DUx
len
size
d
ext
size
d
n
Dwarf_Unsigned
prefix
cf_length
prefix
cf_local_length_size
prefix
cf_local_extension_size
printf
cie_id
DW_PR_DUx
cie_id
cie_id_addr
lx
n
Dwarf_Unsigned
prefix
cf_cie_id
long
prefix
cf_cie_id_addr
printf
sec
ptr
lx
sec
index
DW_PR_DSd
sec
len
DW_PR_DUx
sec
past
end
lx
n
unsigned
long
prefix
cf_section_ptr
Dwarf_Signed
prefix
cf_section_index
Dwarf_Unsigned
prefix
cf_section_length
unsigned
long
prefix
cf_section_ptr
unsigned
long
prefix
cf_section_length
endif
Make
the
cieptr
consistent
across
debug_frame
and
eh_frame
Calculate
a
pointer
into
section
bytes
given
a
cie_id
in
an
FDE
header
In
debug_frame
the
CIE_pointer
is
an
offset
in
debug_frame
In
eh_frame
the
CIE
Pointer
is
when
cie_id_value
subtracted
from
the
cie_id_addr
the
address
in
memory
of
a
CIE
length
field
Since
cie_id_addr
is
the
address
of
an
FDE
CIE_Pointer
field
cie_id_value
for
eh_frame
has
to
account
for
the
length
prefix
so
that
the
returned
cieptr
really
points
to
a
CIE
length
field
Whew
Available
documentation
on
this
is
just
a
bit
ambiguous
but
this
calculation
is
correct
static
Dwarf_Small
get_cieptr_given_offset
Dwarf_Unsigned
cie_id_value
int
use_gnu_cie_calc
Dwarf_Small
section_ptr
Dwarf_Small
cie_id_addr
Dwarf_Small
cieptr
if
use_gnu_cie_calc
cie_id
value
is
offset
in
section
of
the
cie_id
itself
to
use
vm
ptr
of
the
value
less
the
value
to
get
to
the
cie
header
cieptr
cie_id_addr
cie_id_value
else
Traditional
dwarf
section
offset
is
in
cie_id
cieptr
section_ptr
cie_id_value
return
cieptr
Internal
function
called
from
various
places
to
create
lists
of
CIEs
and
FDEs
Not
directly
called
by
consumer
code
int
_dwarf_get_fde_list_internal
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Small
section_ptr
Dwarf_Unsigned
section_index
Dwarf_Unsigned
section_length
Dwarf_Unsigned
cie_id_value
int
use_gnu_cie_calc
Dwarf_Error
error
Scans
the
debug_frame
section
Dwarf_Small
frame_ptr
section_ptr
Dwarf_Small
section_ptr_end
section_ptr
section_length
New_cie
points
to
the
Cie
being
read
and
head_cie_ptr
and
cur_cie_ptr
are
used
for
chaining
them
up
in
sequence
In
case
cie
s
are
reused
aggressively
we
need
tail_cie_ptr
to
add
to
the
chain
If
we
re
use
an
early
cie
later
on
that
does
not
mean
we
chain
a
new
cie
to
the
early
one
we
always
chain
it
to
the
tail
Dwarf_Cie
head_cie_ptr
NULL
Dwarf_Cie
cur_cie_ptr
NULL
Dwarf_Cie
tail_cie_ptr
NULL
Dwarf_Unsigned
cie_count
Points
to
a
list
of
contiguous
pointers
to
Dwarf_Cie
structures
Dwarf_Cie
cie_list_ptr
New_fde
points
to
the
Fde
being
created
and
head_fde_ptr
and
cur_fde_ptr
are
used
to
chain
them
up
Dwarf_Fde
head_fde_ptr
NULL
Dwarf_Fde
cur_fde_ptr
NULL
Dwarf_Unsigned
fde_count
Points
to
a
list
of
contiguous
pointers
to
Dwarf_Fde
structures
Dwarf_Fde
fde_list_ptr
NULL
Dwarf_Unsigned
i
int
res
DW_DLV_ERROR
if
frame_ptr
return
DW_DLV_NO_ENTRY
We
create
the
fde
and
cie
arrays
Processing
each
CIE
as
we
come
to
it
or
as
an
FDE
refers
to
it
We
cannot
process
late
CIEs
late
as
GNU
eh_frame
complexities
mean
we
need
the
whole
CIE
before
we
can
process
the
FDE
correctly
while
frame_ptr
section_ptr_end
struct
cie_fde_prefix_s
prefix
First
read
in
the
common
prefix
to
figure
out
what
we
are
to
do
with
this
entry
memset
sizeof
prefix
res
dwarf_read_cie_fde_prefix
dbg
frame_ptr
section_ptr
section_index
section_length
error
if
res
DW_DLV_ERROR
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
res
if
res
DW_DLV_NO_ENTRY
break
frame_ptr
prefix
cf_addr_after_prefix
if
frame_ptr
section_ptr_end
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
following
a
the
start
of
a
cie
fde
we
have
run
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
if
prefix
cf_cie_id
cie_id_value
This
is
a
CIE
Dwarf_Cie
cie_ptr_to_use
int
resc
resc
dwarf_find_existing_cie_ptr
prefix
cf_start_addr
cur_cie_ptr
head_cie_ptr
if
resc
DW_DLV_OK
cur_cie_ptr
cie_ptr_to_use
Ok
Seen
already
else
if
resc
DW_DLV_NO_ENTRY
CIE
before
its
FDE
in
this
case
resc
dwarf_create_cie_from_after_start
dbg
section_ptr
frame_ptr
section_ptr_end
cie_count
use_gnu_cie_calc
error
if
resc
DW_DLV_OK
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
resc
cie_count
chain_up_cie
cie_ptr_to_use
cur_cie_ptr
tail_cie_ptr
else
res
DW_DLV_ERROR
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
resc
frame_ptr
cie_ptr_to_use
ci_cie_start
cie_ptr_to_use
ci_length
cie_ptr_to_use
ci_length_size
cie_ptr_to_use
ci_extension_size
continue
else
This
is
an
FDE
Frame
Description
Entry
see
the
Dwarf
Spec
section
in
DWARF2
DWARF3
DWARF4
Or
see
the
eh_frame
specification
from
the
Linux
Foundation
or
other
source
int
resf
DW_DLV_ERROR
Dwarf_Cie
cie_ptr_to_use
Dwarf_Fde
fde_ptr_to_use
Dwarf_Small
cieptr_val
cieptr_val
get_cieptr_given_offset
prefix
cf_cie_id
use_gnu_cie_calc
section_ptr
prefix
cf_cie_id_addr
resf
dwarf_find_existing_cie_ptr
cieptr_val
cur_cie_ptr
head_cie_ptr
if
resf
DW_DLV_OK
cur_cie_ptr
cie_ptr_to_use
Ok
Seen
CIE
already
else
if
resf
DW_DLV_NO_ENTRY
resf
dwarf_create_cie_from_start
dbg
cieptr_val
section_ptr
section_index
section_length
section_ptr_end
cie_id_value
cie_count
use_gnu_cie_calc
error
if
resf
DW_DLV_ERROR
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
resf
else
if
resf
DW_DLV_NO_ENTRY
return
resf
cie_count
chain_up_cie
cie_ptr_to_use
cur_cie_ptr
tail_cie_ptr
else
DW_DLV_ERROR
return
resf
resf
dwarf_create_fde_from_after_start
dbg
section_ptr
frame_ptr
section_ptr_end
use_gnu_cie_calc
cie_ptr_to_use
error
if
resf
DW_DLV_ERROR
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
resf
else
if
resf
DW_DLV_NO_ENTRY
impossible
return
resf
chain_up_fde
fde_ptr_to_use
fde_count
ASSERT
DW_DLV_OK
frame_ptr
cur_fde_ptr
fd_fde_start
cur_fde_ptr
fd_length
cur_fde_ptr
fd_length_size
cur_fde_ptr
fd_extension_size
if
frame_ptr
fde_ptr_to_use
fd_fde_instr_start
Sanity
check
With
a
really
short
fde
instruction
set
and
address_size
we
think
is
as
it
is
ELF64
but
is
really
as
in
DWARF
where
we
have
no
FDE
address_size
we
emit
an
error
This
error
means
things
will
not
go
well
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_POSSIBLE_ADDRESS_BOTCH
return
DW_DLV_ERROR
continue
Now
build
list
of
CIEs
from
the
list
If
there
are
no
CIEs
there
should
be
no
FDEs
if
cie_count
cie_list_ptr
Dwarf_Cie
_dwarf_get_alloc
dbg
DW_DLA_LIST
cie_count
else
if
fde_count
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
_dwarf_error
dbg
error
DW_DLE_ORPHAN_FDE
return
DW_DLV_ERROR
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
return
DW_DLV_NO_ENTRY
if
cie_list_ptr
NULL
dealloc_fde_cie_list_internal
head_fde_ptr
head_cie_ptr
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
if
head_cie_ptr
Should
be
impossible
_dwarf_error
dbg
error
DW_DLE_DEBUGFRAME_ERROR
return
DW_DLV_ERROR
cur_cie_ptr
head_cie_ptr
for
i
i
cie_count
i
cie_list_ptr
i
cur_cie_ptr
cur_cie_ptr
cur_cie_ptr
ci_next
Now
build
array
of
FDEs
from
the
list
With
orphan
CIEs
meaning
no
FDEs
lets
not
return
DW_DLV_NO_ENTRY
if
fde_count
fde_list_ptr
Dwarf_Fde
_dwarf_get_alloc
dbg
DW_DLA_LIST
fde_count
It
is
ok
if
fde_list_ptr
is
NULL
we
just
have
no
fdes
cur_fde_ptr
head_fde_ptr
for
i
i
fde_count
i
fde_list_ptr
i
cur_fde_ptr
cur_fde_ptr
cur_fde_ptr
fd_next
Return
arguments
cie_data
cie_list_ptr
cie_element_count
cie_count
fde_data
fde_list_ptr
fde_element_count
fde_count
if
use_gnu_cie_calc
dbg
de_fde_data_eh
fde_list_ptr
dbg
de_fde_count_eh
fde_count
dbg
de_cie_data_eh
cie_list_ptr
dbg
de_cie_count_eh
cie_count
else
dbg
de_fde_data
fde_list_ptr
dbg
de_fde_count
fde_count
dbg
de_cie_data
cie_list_ptr
dbg
de_cie_count
cie_count
Sort
the
list
by
the
address
so
that
dwarf_get_fde_at_pc
can
binary
search
this
list
if
fde_count
qsort
void
fde_list_ptr
fde_count
sizeof
Dwarf_Ptr
qsort_compare
return
DW_DLV_OK
Internal
function
not
called
by
consumer
code
prefix
has
accumulated
the
info
up
thru
the
cie
id
and
now
we
consume
the
rest
and
build
a
Dwarf_Cie_s
structure
int
dwarf_create_cie_from_after_start
Dwarf_Debug
dbg
struct
cie_fde_prefix_s
prefix
Dwarf_Small
section_pointer
Dwarf_Small
frame_ptr
Dwarf_Small
section_ptr_end
Dwarf_Unsigned
cie_count
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_out
Dwarf_Error
error
Dwarf_Cie
new_cie
egcs
eh_frame
uses
as
the
distinguishing
id
sgi
uses
in
debug_frame
eh_frame
not
quite
identical
to
debug_frame
We
here
default
the
address
size
as
it
is
not
present
in
DWARF2
or
DWARF3
cie
data
below
we
set
it
right
if
it
is
present
Dwarf_Half
address_size
dbg
de_pointer_size
Dwarf_Small
augmentation
Dwarf_Half
segment_size
Dwarf_Signed
data_alignment_factor
Dwarf_Unsigned
code_alignment_factor
Dwarf_Unsigned
return_address_register
int
local_length_size
Dwarf_Unsigned
leb128_length
Dwarf_Unsigned
cie_aug_data_len
Dwarf_Small
cie_aug_data
Dwarf_Addr
gnu_personality_handler_addr
unsigned
char
gnu_personality_handler_encoding
unsigned
char
gnu_lsda_encoding
unsigned
char
gnu_fde_begin_encoding
int
res
Dwarf_Small
version
enum
Dwarf_augmentation_type
augt
aug_unknown
This
is
a
CIE
Common
Information
Entry
See
the
dwarf
spec
section
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
reading
a
cie
version
byte
we
have
run
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
version
Dwarf_Small
frame_ptr
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
reading
an
augmentation
would
run
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
if
version
DW_CIE_VERSION
version
DW_CIE_VERSION3
version
DW_CIE_VERSION4
version
DW_CIE_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_FRAME_VERSION_BAD
cie
version
u
unknown
version
_dwarf_error_string
dbg
error
DW_DLE_FRAME_VERSION_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
frame_ptr
augmentation
frame_ptr
res
_dwarf_check_string_valid
dbg
section_pointer
frame_ptr
section_ptr_end
DW_DLE_AUGMENTATION_STRING_OFF_END
error
if
res
DW_DLV_OK
return
res
frame_ptr
frame_ptr
strlen
char
frame_ptr
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
following
any
augmentation
field
we
have
run
off
the
end
of
the
section
with
the
CIE
incomplete
Corrupt
Dwarf
return
DW_DLV_ERROR
augt
_dwarf_get_augmentation_type
dbg
augmentation
use_gnu_cie_calc
if
augt
aug_eh
REFERENCED
Not
used
in
this
instance
Dwarf_Unsigned
exception_table_addr
UNUSEDARG
if
frame_ptr
local_length_size
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
following
type
field
we
have
run
off
the
end
of
the
section
with
the
CIE
incomplete
Corrupt
Dwarf
return
DW_DLV_ERROR
this
is
per
egcs
as
on
RH
READ_UNALIGNED_CK
dbg
exception_table_addr
Dwarf_Unsigned
frame_ptr
local_length_size
error
section_ptr_end
frame_ptr
local_length_size
Dwarf_Unsigned
lreg
unsigned
long
size
if
version
DW_CIE_VERSION4
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
We
would
run
off
the
end
of
the
section
in
a
DWARF4
cie
header
Corrupt
Dwarf
return
DW_DLV_ERROR
address_size
unsigned
char
frame_ptr
if
address_size
_dwarf_error_string
dbg
error
DW_DLE_ADDRESS_SIZE_ZERO
DW_DLE_ADDRESS_SIZE_ZERO
bad
address
size
for
a
DWARF4
cie
header
return
DW_DLV_ERROR
if
address_size
sizeof
Dwarf_Addr
_dwarf_create_address_size_dwarf_error
dbg
error
address_size
DW_DLE_ADDRESS_SIZE_ERROR
DW_DLE_ADDRESS_SIZE_ERROR
return
DW_DLV_ERROR
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Running
off
the
end
of
a
CIE
header
Corrupt
DWARF4
return
DW_DLV_ERROR
frame_ptr
segment_size
unsigned
char
frame_ptr
frame_ptr
if
segment_size
sizeof
Dwarf_Addr
_dwarf_error
dbg
error
DW_DLE_SEGMENT_SIZE_BAD
return
DW_DLV_ERROR
Not
a
great
test
But
the
DECODE
do
checking
so
ok
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Running
off
the
end
of
a
CIE
header
before
the
code
alignment
value
read
Corrupt
DWARF
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
frame_ptr
lreg
dbg
error
section_ptr_end
code_alignment_factor
Dwarf_Unsigned
lreg
res
dwarf_decode_signed_leb128
char
frame_ptr
char
section_ptr_end
if
res
DW_DLV_OK
return
res
frame_ptr
frame_ptr
leb128_length
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Running
off
the
end
of
a
CIE
header
before
the
return
address
register
number
read
Corrupt
DWARF
return
DW_DLV_ERROR
res
_dwarf_get_return_address_reg
frame_ptr
version
dbg
section_ptr_end
error
if
res
DW_DLV_OK
return
res
if
return_address_register
dbg
de_frame_reg_rules_entry_count
_dwarf_error
dbg
error
DW_DLE_CIE_RET_ADDR_REG_ERROR
return
DW_DLV_ERROR
frame_ptr
size
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Past
the
end
of
a
CIE
header
before
reading
the
augmentation
string
Corrupt
DWARF
return
DW_DLV_ERROR
switch
augt
case
aug_empty_string
break
case
aug_irix_mti_v1
break
case
aug_irix_exception_table
Dwarf_Unsigned
lreg
Dwarf_Unsigned
length_of_augmented_fields
Decode
the
length
of
augmented
fields
DECODE_LEB128_UWORD_CK
frame_ptr
lreg
dbg
error
section_ptr_end
length_of_augmented_fields
Dwarf_Unsigned
lreg
set
the
frame_ptr
to
point
at
the
instruction
start
frame_ptr
length_of_augmented_fields
break
case
aug_eh
int
err
unsigned
long
increment
if
use_gnu_cie_calc
This
should
be
impossible
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
err
get_gcc_eh_augmentation
dbg
frame_ptr
augt
section_ptr_end
char
augmentation
error
if
err
DW_DLV_ERROR
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
frame_ptr
increment
break
case
aug_gcc_eh_z
Here
we
have
Augmentation
Data
Length
uleb128
followed
by
Augmentation
Data
bytes
not
a
string
int
resz
DW_DLV_ERROR
Dwarf_Unsigned
adlen
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_AUG_DATA_LENGTH_BAD
The
gcc
eh_frame
augmentation
data
cannot
be
read
Out
of
room
in
the
section
Corrupt
DWARF
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
frame_ptr
adlen
dbg
error
section_ptr_end
cie_aug_data_len
adlen
cie_aug_data
frame_ptr
if
adlen
Dwarf_Small
cie_aug_data_end
cie_aug_data
adlen
if
cie_aug_data_end
cie_aug_data
cie_aug_data_end
section_ptr_end
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_AUG_DATA_LENGTH_BAD
The
gcc
eh_frame
augmentation
data
length
of
DW_PR_DUu
is
too
long
to
fit
in
the
section
adlen
_dwarf_error_string
dbg
error
DW_DLE_AUG_DATA_LENGTH_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
resz
gnu_aug_encodings
dbg
char
augmentation
cie_aug_data
cie_aug_data_len
address_size
error
if
resz
DW_DLV_OK
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
resz
frame_ptr
adlen
break
case
aug_armcc
break
default
We
do
not
understand
the
augmentation
string
No
assumption
can
be
made
about
any
fields
other
than
what
we
have
already
read
frame_ptr
prefix
cf_start_addr
prefix
cf_length
prefix
cf_local_length_size
prefix
cf_local_extension_size
FIX
What
are
the
values
of
data_alignment_factor
code_alignment_factor
return_address_register
and
instruction
start?
They
were
clearly
uninitialized
in
the
previous
version
and
I
am
leaving
them
the
same
way
if
frame_ptr
section_ptr_end
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Reading
an
unknown
type
of
augmentation
string
run
off
the
end
of
the
section
Corrupt
DWARF
return
DW_DLV_ERROR
break
End
switch
on
augmentation
type
new_cie
Dwarf_Cie
_dwarf_get_alloc
dbg
DW_DLA_CIE
if
new_cie
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
new_cie
ci_cie_version_number
version
new_cie
ci_initial_table
NULL
new_cie
ci_length
Dwarf_Unsigned
prefix
cf_length
new_cie
ci_length_size
prefix
cf_local_length_size
new_cie
ci_extension_size
prefix
cf_local_extension_size
new_cie
ci_augmentation
char
augmentation
new_cie
ci_data_alignment_factor
Dwarf_Sbyte
data_alignment_factor
new_cie
ci_code_alignment_factor
Dwarf_Small
code_alignment_factor
new_cie
ci_return_address_register
return_address_register
new_cie
ci_cie_start
prefix
cf_start_addr
if
frame_ptr
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DF_FRAME_DECODING_ERROR
return
DW_DLV_ERROR
new_cie
ci_cie_instr_start
frame_ptr
new_cie
ci_dbg
dbg
new_cie
ci_augmentation_type
augt
new_cie
ci_gnu_eh_augmentation_len
cie_aug_data_len
new_cie
ci_gnu_eh_augmentation_bytes
cie_aug_data
new_cie
ci_gnu_personality_handler_encoding
gnu_personality_handler_encoding
new_cie
ci_gnu_personality_handler_addr
gnu_personality_handler_addr
new_cie
ci_gnu_lsda_encoding
gnu_lsda_encoding
new_cie
ci_gnu_fde_begin_encoding
gnu_fde_begin_encoding
new_cie
ci_index
cie_count
new_cie
ci_section_ptr
prefix
cf_section_ptr
new_cie
ci_section_end
section_ptr_end
new_cie
ci_cie_end
new_cie
ci_cie_start
new_cie
ci_length
new_cie
ci_length_size
new_cie
ci_extension_size
if
new_cie
ci_cie_end
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DF_FRAME_DECODING_ERROR
return
DW_DLV_ERROR
The
Following
new
in
DWARF4
new_cie
ci_address_size
address_size
new_cie
ci_segment_size
segment_size
validate_length
dbg
new_cie
new_cie
ci_length
new_cie
ci_length_size
new_cie
ci_extension_size
new_cie
ci_section_ptr
new_cie
ci_cie_start
cie
cie_ptr_out
new_cie
return
DW_DLV_OK
Internal
function
not
called
by
consumer
code
prefix
has
accumulated
the
info
up
thru
the
cie
id
and
now
we
consume
the
rest
and
build
a
Dwarf_Fde_s
structure
Can
be
called
with
cie_ptr_in
NULL
from
dwarf_frame
c
int
dwarf_create_fde_from_after_start
Dwarf_Debug
dbg
struct
cie_fde_prefix_s
prefix
Dwarf_Small
section_pointer
Dwarf_Small
frame_ptr
Dwarf_Small
section_ptr_end
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_in
Dwarf_Fde
fde_ptr_out
Dwarf_Error
error
Dwarf_Fde
new_fde
Dwarf_Cie
cieptr
Dwarf_Small
saved_frame_ptr
Dwarf_Small
initloc
frame_ptr
Dwarf_Signed
offset_into_exception_tables
Dwarf_Signed
DW_DLX_NO_EH_OFFSET
Dwarf_Small
fde_aug_data
Dwarf_Unsigned
fde_aug_data_len
Dwarf_Addr
cie_base_offset
prefix
cf_cie_id
Dwarf_Addr
initial_location
must
be
min
de_pointer_size
bytes
in
size
Dwarf_Addr
address_range
must
be
min
de_pointer_size
bytes
in
size
Dwarf_Half
address_size
Dwarf_Unsigned
eh_table_value
Dwarf_Bool
eh_table_value_set
FALSE
Temporary
assumption
enum
Dwarf_augmentation_type
augt
aug_empty_string
if
cie_ptr_in
cieptr
cie_ptr_in
address_size
cieptr
ci_address_size
augt
cieptr
ci_augmentation_type
if
augt
aug_gcc_eh_z
If
z
augmentation
this
is
eh_frame
and
initial_location
and
address_range
in
the
FDE
are
read
according
to
the
CIE
augmentation
string
instructions
Dwarf_Small
fp_updated
int
res
read_encoded_ptr
dbg
section_pointer
frame_ptr
cieptr
ci_gnu_fde_begin_encoding
section_ptr_end
address_size
error
if
res
DW_DLV_OK
return
res
frame_ptr
fp_updated
For
the
address
range
it
makes
no
sense
to
be
pc
relative
so
we
turn
it
off
with
a
section_pointer
of
NULL
Masking
off
DW_EH_PE_pcrel
from
the
ci_gnu_fde_begin_encoding
in
this
call
would
also
work
to
turn
off
DW_EH_PE_pcrel
res
read_encoded_ptr
dbg
Dwarf_Small
NULL
frame_ptr
cieptr
ci_gnu_fde_begin_encoding
section_ptr_end
address_size
error
if
res
DW_DLV_OK
return
res
frame_ptr
fp_updated
Dwarf_Unsigned
adlen
DECODE_LEB128_UWORD_CK
frame_ptr
adlen
dbg
error
section_ptr_end
fde_aug_data_len
adlen
fde_aug_data
frame_ptr
frame_ptr
adlen
if
adlen
if
frame_ptr
fde_aug_data
frame_ptr
section_ptr_end
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_AUG_DATA_LENGTH_BAD
The
gcc
eh_frame
augmentation
data
length
of
DW_PR_DUu
is
too
long
to
fit
in
the
section
adlen
_dwarf_error_string
dbg
error
DW_DLE_AUG_DATA_LENGTH_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
if
frame_ptr
address_size
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
initial_location
Dwarf_Addr
frame_ptr
address_size
error
section_ptr_end
frame_ptr
address_size
READ_UNALIGNED_CK
dbg
address_range
Dwarf_Addr
frame_ptr
address_size
error
section_ptr_end
frame_ptr
address_size
switch
augt
case
aug_irix_mti_v1
case
aug_empty_string
break
case
aug_irix_exception_table
Dwarf_Unsigned
lreg
Dwarf_Unsigned
length_of_augmented_fields
DECODE_LEB128_UWORD_CK
frame_ptr
lreg
dbg
error
section_ptr_end
length_of_augmented_fields
Dwarf_Unsigned
lreg
saved_frame_ptr
frame_ptr
The
first
word
is
an
offset
into
exception
tables
Defined
as
a
offset
even
for
CC
if
frame_ptr
DWARF_32BIT_SIZE
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
offset_into_exception_tables
Dwarf_Addr
frame_ptr
DWARF_32BIT_SIZE
error
section_ptr_end
SIGN_EXTEND
offset_into_exception_tables
DWARF_32BIT_SIZE
frame_ptr
saved_frame_ptr
length_of_augmented_fields
break
case
aug_eh
if
use_gnu_cie_calc
This
should
be
impossible
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
gnu
eh
fde
case
we
do
not
need
to
do
anything
REFERENCED
Not
used
in
this
instance
of
the
macro
if
frame_ptr
address_size
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
eh_table_value
Dwarf_Unsigned
frame_ptr
address_size
error
section_ptr_end
eh_table_value_set
TRUE
frame_ptr
address_size
break
case
aug_gcc_eh_z
The
Augmentation
Data
Length
is
here
followed
by
the
Augmentation
Data
bytes
themselves
break
case
aug_armcc
break
case
aug_past_last
break
case
aug_metaware
No
special
fields
See
dwarf_util
h
break
case
aug_unknown
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
End
switch
on
augmentation
type
if
frame_ptr
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DF_FRAME_DECODING_ERROR
return
DW_DLV_ERROR
new_fde
Dwarf_Fde
_dwarf_get_alloc
dbg
DW_DLA_FDE
if
new_fde
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
new_fde
fd_length
prefix
cf_length
new_fde
fd_length_size
prefix
cf_local_length_size
new_fde
fd_extension_size
prefix
cf_local_extension_size
new_fde
fd_is_eh
use_gnu_cie_calc
new_fde
fd_cie_offset
cie_base_offset
if
cieptr
new_fde
fd_cie_index
cieptr
ci_index
new_fde
fd_cie
cieptr
new_fde
fd_initial_location
initial_location
new_fde
fd_initial_loc_pos
initloc
new_fde
fd_address_range
address_range
new_fde
fd_fde_start
prefix
cf_start_addr
new_fde
fd_fde_instr_start
frame_ptr
new_fde
fd_fde_end
prefix
cf_start_addr
prefix
cf_length
prefix
cf_local_length_size
prefix
cf_local_extension_size
if
new_fde
fd_fde_end
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DF_FRAME_DECODING_ERROR
return
DW_DLV_ERROR
new_fde
fd_dbg
dbg
new_fde
fd_offset_into_exception_tables
offset_into_exception_tables
new_fde
fd_eh_table_value
eh_table_value
new_fde
fd_eh_table_value_set
eh_table_value_set
new_fde
fd_section_ptr
prefix
cf_section_ptr
new_fde
fd_section_index
prefix
cf_section_index
new_fde
fd_section_length
prefix
cf_section_length
new_fde
fd_section_end
section_ptr_end
if
augt
aug_gcc_eh_z
new_fde
fd_gnu_eh_aug_present
TRUE
new_fde
fd_gnu_eh_augmentation_bytes
fde_aug_data
new_fde
fd_gnu_eh_augmentation_len
fde_aug_data_len
validate_length
dbg
cieptr
new_fde
fd_length
new_fde
fd_length_size
new_fde
fd_extension_size
new_fde
fd_section_ptr
new_fde
fd_fde_start
fde
fde_ptr_out
new_fde
return
DW_DLV_OK
Read
in
the
common
cie
fde
prefix
including
reading
the
cie
value
which
shows
which
this
is
cie
or
fde
int
dwarf_read_cie_fde_prefix
Dwarf_Debug
dbg
Dwarf_Small
frame_ptr_in
Dwarf_Small
section_ptr_in
Dwarf_Unsigned
section_index_in
Dwarf_Unsigned
section_length_in
struct
cie_fde_prefix_s
data_out
Dwarf_Error
error
Dwarf_Unsigned
length
int
local_length_size
int
local_extension_size
Dwarf_Small
frame_ptr
frame_ptr_in
Dwarf_Small
cie_ptr_addr
Dwarf_Unsigned
cie_id
Dwarf_Small
section_end
section_ptr_in
section_length_in
if
section_end
frame_ptr
dwarfstring
m
Dwarf_Unsigned
u
Dwarf_Unsigned
uintptr_t
frame_ptr
Dwarf_Unsigned
uintptr_t
section_end
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_FRAME_LENGTH_BAD
Reading
the
cie
fde
prefix
would
put
us
u
bytes
past
the
end
of
the
frame
section
Corrupt
Dwarf
u
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
READ_AREA_LENGTH
updates
frame_ptr
for
consumed
bytes
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
frame_ptr
local_length_size
local_extension_size
error
section_length_in
section_end
if
length
nul
bytes
at
end
of
section
seen
at
end
of
egcs
eh_frame
sections
in
a
out
Take
this
as
meaning
no
more
CIE
FDE
data
We
should
be
very
close
to
end
of
section
return
DW_DLV_NO_ENTRY
if
frame_ptr
local_length_size
section_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
cie_ptr_addr
frame_ptr
READ_UNALIGNED_CK
dbg
cie_id
Dwarf_Unsigned
frame_ptr
local_length_size
error
section_end
SIGN_EXTEND
cie_id
local_length_size
frame_ptr
local_length_size
data_out
cf_start_addr
frame_ptr_in
data_out
cf_addr_after_prefix
frame_ptr
data_out
cf_length
length
if
length
section_length_in
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
if
cie_ptr_addr
length
section_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
data_out
cf_local_length_size
local_length_size
data_out
cf_local_extension_size
local_extension_size
We
do
not
know
if
it
is
a
CIE
or
FDE
id
yet
How
we
check
and
what
it
means
depends
whether
it
is
debug_frame
or
eh_frame
data_out
cf_cie_id
cie_id
The
address
of
the
CIE_id
or
FDE_id
value
in
memory
data_out
cf_cie_id_addr
cie_ptr_addr
data_out
cf_section_ptr
section_ptr_in
data_out
cf_section_index
section_index_in
data_out
cf_section_length
section_length_in
return
DW_DLV_OK
On
various
errors
previously
allocated
CIEs
and
FDEs
must
be
cleaned
up
This
helps
avoid
leaks
in
case
of
errors
static
void
dealloc_fde_cie_list_internal
Dwarf_Fde
head_fde_ptr
Dwarf_Cie
head_cie_ptr
Dwarf_Fde
curfde
Dwarf_Cie
curcie
Dwarf_Fde
nextfde
Dwarf_Cie
nextcie
for
curfde
head_fde_ptr
curfde
curfde
nextfde
nextfde
curfde
fd_next
dwarf_dealloc
curfde
fd_dbg
curfde
DW_DLA_FDE
for
curcie
head_cie_ptr
curcie
curcie
nextcie
Dwarf_Frame
frame
curcie
ci_initial_table
nextcie
curcie
ci_next
if
frame
dwarf_dealloc
curcie
ci_dbg
frame
DW_DLA_FRAME
dwarf_dealloc
curcie
ci_dbg
curcie
DW_DLA_CIE
Find
the
cie
whose
id
value
is
given
the
id
value
is
per
DWARF2
an
offset
in
the
section
For
debug_frame
zero
is
a
legal
offset
For
GNU
eh_frame
it
is
not
a
legal
offset
cie_ptr
is
a
pointer
into
our
section
not
an
offset
static
int
dwarf_find_existing_cie_ptr
Dwarf_Small
cie_ptr
Dwarf_Cie
cur_cie_ptr
Dwarf_Cie
cie_ptr_to_use_out
Dwarf_Cie
head_cie_ptr
Dwarf_Cie
next
if
cur_cie_ptr
cie_ptr
cur_cie_ptr
ci_cie_start
Usually
we
use
the
same
cie
again
and
again
cie_ptr_to_use_out
cur_cie_ptr
return
DW_DLV_OK
for
next
head_cie_ptr
next
next
next
ci_next
if
cie_ptr
next
ci_cie_start
cie_ptr_to_use_out
next
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
We
have
a
valid
cie_ptr_val
that
has
not
been
turned
into
an
internal
Cie
yet
Do
so
now
Returns
DW_DLV_OK
or
DW_DLV_ERROR
never
DW_DLV_NO_ENTRY
section_ptr
Points
to
first
byte
of
section
data
section_length
Length
of
the
section
in
bytes
section_ptr_end
Points
past
last
byte
of
section
data
static
int
dwarf_create_cie_from_start
Dwarf_Debug
dbg
Dwarf_Small
cie_ptr_val
Dwarf_Small
section_ptr
Dwarf_Unsigned
section_index
Dwarf_Unsigned
section_length
Dwarf_Small
section_ptr_end
Dwarf_Unsigned
cie_id_value
Dwarf_Unsigned
cie_count
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_to_use_out
Dwarf_Error
error
struct
cie_fde_prefix_s
prefix
int
res
DW_DLV_ERROR
Dwarf_Small
frame_ptr
cie_ptr_val
if
frame_ptr
section_ptr
frame_ptr
section_ptr_end
_dwarf_error
dbg
error
DW_DLE_DEBUG_FRAME_LENGTH_BAD
return
DW_DLV_ERROR
First
read
in
the
common
prefix
to
figure
out
what
we
are
to
do
with
this
entry
If
it
is
not
a
cie
we
are
in
big
trouble
memset
sizeof
prefix
res
dwarf_read_cie_fde_prefix
dbg
frame_ptr
section_ptr
section_index
section_length
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
error
_dwarf_error
dbg
error
DW_DLE_FRAME_CIE_DECODE_ERROR
return
DW_DLV_ERROR
if
prefix
cf_cie_id
cie_id_value
_dwarf_error
dbg
error
DW_DLE_FRAME_CIE_DECODE_ERROR
return
DW_DLV_ERROR
frame_ptr
prefix
cf_addr_after_prefix
res
dwarf_create_cie_from_after_start
dbg
section_ptr
frame_ptr
section_ptr_end
cie_count
use_gnu_cie_calc
cie_ptr_to_use_out
error
return
res
This
is
for
gnu
eh
frames
the
z
case
We
find
the
letter
involved
Return
the
augmentation
character
and
if
applicable
the
personality
routine
address
personality_routine_out
if
P
is
augchar
is
personality
handler
addr
Otherwise
is
not
set
aug_data
if
P
points
to
data
space
of
the
aug_data_len
length
of
areas
aug_data
points
to
It
is
not
clear
if
this
is
entirely
correct
static
int
gnu_aug_encodings
Dwarf_Debug
dbg
char
augmentation
Dwarf_Small
aug_data
Dwarf_Unsigned
aug_data_len
Dwarf_Half
address_size
unsigned
char
pers_hand_enc_out
unsigned
char
lsda_enc_out
unsigned
char
fde_begin_enc_out
Dwarf_Addr
gnu_pers_addr_out
Dwarf_Error
error
char
nc
Dwarf_Small
cur_aug_p
aug_data
Dwarf_Small
end_aug_p
aug_data
aug_data_len
for
nc
augmentation
nc
nc
char
c
nc
switch
c
case
z
Means
that
the
augmentation
data
is
present
continue
case
S
Indicates
this
is
a
signal
stack
frame
Debuggers
have
to
do
special
handling
We
don
t
need
to
do
more
than
print
this
flag
at
the
right
time
though
see
dwarfdump
where
it
prints
the
augmentation
string
A
signal
stack
frame
in
some
OS
s
can
only
be
unwound
backtraced
by
knowing
it
is
a
signal
stack
frame
perhaps
by
noticing
the
name
of
the
function
for
the
stack
frame
if
the
name
can
be
found
somehow
and
figuring
out
or
knowing
how
the
kernel
and
libc
pushed
a
structure
onto
the
stack
and
loading
registers
from
that
structure
Totally
different
from
normal
stack
unwinding
This
flag
gives
an
unwinder
a
big
leg
up
by
decoupling
the
hint
this
is
a
stack
frame
from
knowledge
like
the
function
name
the
name
might
be
unavailable
at
unwind
time
break
case
L
if
cur_aug_p
end_aug_p
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
lsda_enc_out
unsigned
char
cur_aug_p
cur_aug_p
break
case
R
Followed
by
a
one
byte
argument
giving
the
pointer
encoding
for
the
address
pointers
in
the
fde
if
cur_aug_p
end_aug_p
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
fde_begin_enc_out
unsigned
char
cur_aug_p
cur_aug_p
break
case
P
int
res
DW_DLV_ERROR
Dwarf_Small
updated_aug_p
unsigned
char
encoding
if
cur_aug_p
end_aug_p
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
encoding
unsigned
char
cur_aug_p
pers_hand_enc_out
encoding
cur_aug_p
if
cur_aug_p
end_aug_p
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
DW_EH_PE_pcrel
makes
no
sense
here
so
we
turn
it
off
via
a
section
pointer
of
NULL
res
read_encoded_ptr
dbg
Dwarf_Small
NULL
cur_aug_p
encoding
end_aug_p
address_size
gnu_pers_addr_out
error
if
res
DW_DLV_OK
return
res
cur_aug_p
updated_aug_p
if
cur_aug_p
end_aug_p
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
break
default
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
return
DW_DLV_OK
Given
augmentation
character
the
encoding
giving
the
address
format
read
the
address
from
input_field
and
return
an
incremented
value
past
the
input
bytes
of
the
address
Push
the
address
read
back
thru
the
addr
pointer
See
LSB
Linux
Standard
Base
exception
handling
documents
static
int
read_encoded_ptr
Dwarf_Debug
dbg
Dwarf_Small
section_pointer
Dwarf_Small
input_field
int
gnu_encoding
Dwarf_Small
section_end
Dwarf_Half
address_size
Dwarf_Unsigned
addr
Dwarf_Small
input_field_updated
Dwarf_Error
error
int
value_type
gnu_encoding
Dwarf_Small
input_field_original
input_field
if
gnu_encoding
There
is
no
data
here
addr
input_field_updated
input_field
Should
we
return
DW_DLV_NO_ENTRY?
return
DW_DLV_OK
switch
value_type
case
DW_EH_PE_absptr
value_type
is
zero
Treat
as
pointer
size
of
the
object
Dwarf_Unsigned
ret_value
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
input_field
address_size
error
section_end
addr
ret_value
input_field_updated
input_field
address_size
break
case
DW_EH_PE_uleb128
Dwarf_Unsigned
val
DECODE_LEB128_UWORD_CK
input_field
val
dbg
error
section_end
addr
val
input_field_updated
input_field
break
case
DW_EH_PE_udata2
Dwarf_Unsigned
ret_value
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
input_field
error
section_end
addr
ret_value
input_field_updated
input_field
break
case
DW_EH_PE_udata4
Dwarf_Unsigned
ret_value
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
input_field
DWARF_32BIT_SIZE
error
section_end
addr
ret_value
input_field_updated
input_field
DWARF_32BIT_SIZE
break
case
DW_EH_PE_udata8
Dwarf_Unsigned
ret_value
ASSERT
sizeof
Dwarf_Unsigned
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
input_field
DWARF_64BIT_SIZE
error
section_end
addr
ret_value
input_field_updated
input_field
DWARF_64BIT_SIZE
break
case
DW_EH_PE_sleb128
Dwarf_Signed
val
DECODE_LEB128_SWORD_CK
input_field
val
dbg
error
section_end
addr
Dwarf_Unsigned
val
input_field_updated
input_field
break
case
DW_EH_PE_sdata2
Dwarf_Unsigned
val
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
input_field
error
section_end
SIGN_EXTEND
val
addr
Dwarf_Unsigned
val
input_field_updated
input_field
break
case
DW_EH_PE_sdata4
Dwarf_Unsigned
val
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
input_field
DWARF_32BIT_SIZE
error
section_end
SIGN_EXTEND
val
DWARF_32BIT_SIZE
addr
Dwarf_Unsigned
val
input_field_updated
input_field
DWARF_32BIT_SIZE
break
case
DW_EH_PE_sdata8
Dwarf_Unsigned
val
ASSERT
sizeof
Dwarf_Unsigned
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
input_field
DWARF_64BIT_SIZE
error
section_end
addr
Dwarf_Unsigned
val
input_field_updated
input_field
DWARF_64BIT_SIZE
break
default
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
The
ELF
ABI
for
gnu
does
not
document
the
meaning
of
DW_EH_PE_pcrel
which
is
awkward
It
apparently
means
the
value
we
got
above
is
pc
relative
meaning
section
relative
so
we
adjust
the
value
Section_pointer
may
be
null
if
it
is
known
DW_EH_PE_pcrel
cannot
apply
such
as
for
debug_frame
or
for
an
address
range
value
if
section_pointer
gnu_encoding
DW_EH_PE_pcrel
Address
addr
above
is
pc
relative
with
respect
to
a
section
Add
to
the
offset
the
base
address
from
elf
of
section
and
the
distance
of
the
field
we
are
reading
from
the
section
beginning
to
get
the
actual
address
ASSERT
input_field_original
section_pointer
Dwarf_Unsigned
distance
input_field_original
section_pointer
addr
dbg
de_debug_frame_eh_gnu
dss_addr
distance
return
DW_DLV_OK
All
augmentation
string
checking
done
here
now
For
eh_frame
gcc
from
uses
the
z
style
earlier
used
only
eh
as
augmentation
We
don
t
yet
handle
decoding
eh_frame
with
the
z
style
extensions
like
L
P
gnu_aug_encodings
does
handle
L
P
These
are
nasty
heuristics
but
then
that
s
life
as
augmentations
are
implementation
specific
ARGSUSED
enum
Dwarf_augmentation_type
_dwarf_get_augmentation_type
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Small
augmentation_string
int
is_gcc_eh_frame
enum
Dwarf_augmentation_type
t
aug_unknown
char
ag_string
char
augmentation_string
if
ag_string
Empty
string
We
ll
just
guess
that
we
know
what
this
means
standard
dwarf2
with
no
implementation
defined
fields
t
aug_empty_string
else
if
strcmp
ag_string
DW_DEBUG_FRAME_AUGMENTER_STRING
The
string
is
mti
v1
Used
internally
at
SGI
probably
never
shipped
Replaced
by
z
Treat
like
nothing
special
t
aug_irix_mti_v1
else
if
ag_string
z
If
it
s
IRIX
cc
z
means
aug_irix_exception_table
z1
z2
were
designed
as
for
IRIX
CC
but
never
implemented
If
it
s
gcc
z
may
be
any
of
several
things
z
or
z
followed
optionally
followed
by
one
or
more
of
L
R
P
each
of
which
means
a
value
may
be
present
Should
be
in
eh_frame
only
I
think
if
is_gcc_eh_frame
t
aug_gcc_eh_z
else
if
ag_string
This
is
the
normal
IRIX
C
case
where
there
is
an
offset
into
a
table
in
each
fde
The
table
being
for
IRIX
CC
exception
handling
DW_CIE_AUGMENTER_STRING_V0
z
t
aug_irix_exception_table
Else
unknown
else
if
strncmp
ag_string
eh
gcc
eh_frame
augmentation
for
egcs
and
gcc
x
at
least
for
x86
t
aug_eh
else
if
strcmp
ag_string
armcc
Arm
uses
this
string
to
mean
a
bug
in
in
Arm
compilers
was
fixed
changing
to
the
standard
calculation
of
the
CFA
See
http
sourceware
org
ml
gdb
patches
msg00249
html
for
details
t
aug_armcc
else
if
strcmp
ag_string
HC
t
aug_metaware
else
return
t
Using
augmentation
and
version
read
in
the
augmentation
data
for
GNU
eh
Return
DW_DLV_OK
if
we
succeeded
DW_DLV_ERR
if
we
fail
On
success
update
size_of_augmentation_data
with
the
length
of
the
fields
that
are
part
of
augmentation
so
the
caller
can
increment
frame_ptr
appropriately
frame_ptr
points
within
section
section_end
points
to
end
of
section
area
of
interest
ARGSUSED
static
int
get_gcc_eh_augmentation
Dwarf_Debug
dbg
Dwarf_Small
frame_ptr
unsigned
long
size_of_augmentation_data
enum
Dwarf_augmentation_type
augtype
Dwarf_Small
section_ptr_end
char
augmentation
Dwarf_Error
error
char
suffix
unsigned
long
augdata_size
if
augtype
aug_gcc_eh_z
Has
leading
z
Dwarf_Unsigned
val
UNUSEDARG
Dwarf_Unsigned
leb128_length
Dwarf_Unsigned
eh_value
DECODE_LEB128_UWORD_LEN_CK
frame_ptr
val
leb128_length
dbg
error
section_ptr_end
augdata_size
leb128_length
suffix
augmentation
else
Prefix
is
eh
As
in
gcc
No
suffix
present
apparently
suffix
augmentation
if
suffix
We
have
no
idea
what
this
is
as
yet
Some
extensions
beyond
dwarf
exist
which
we
do
not
yet
handle
_dwarf_error
dbg
error
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
return
DW_DLV_ERROR
size_of_augmentation_data
augdata_size
return
DW_DLV_OK
To
properly
release
all
spaced
used
Earlier
approaches
before
July
letting
client
do
the
dealloc
directly
left
some
data
allocated
This
is
directly
called
by
consumer
code
void
dwarf_fde_cie_list_dealloc
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Signed
i
for
i
i
cie_element_count
i
Dwarf_Frame
frame
cie_data
i
ci_initial_table
if
frame
dwarf_dealloc
dbg
frame
DW_DLA_FRAME
dwarf_dealloc
dbg
cie_data
i
DW_DLA_CIE
for
i
i
fde_element_count
i
dwarf_dealloc
dbg
fde_data
i
DW_DLA_FDE
if
cie_data
dwarf_dealloc
dbg
cie_data
DW_DLA_LIST
if
fde_data
dwarf_dealloc
dbg
fde_data
DW_DLA_LIST
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_funcs
h
include
dwarf_global
h
int
dwarf_get_funcs
Dwarf_Debug
dbg
Dwarf_Func
funcs
Dwarf_Signed
ret_func_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_funcnames
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_funcnames
dss_size
return
DW_DLV_NO_ENTRY
return
_dwarf_internal_get_pubnames_like_data
dbg
debug_funcnames
dbg
de_debug_funcnames
dss_data
dbg
de_debug_funcnames
dss_size
Type
punning
for
sections
with
identical
format
Dwarf_Global
funcs
ret_func_count
error
DW_DLA_FUNC_CONTEXT
DW_DLA_FUNC
DW_DLE_DEBUG_FUNCNAMES_LENGTH_BAD
DW_DLE_DEBUG_FUNCNAMES_VERSION_ERROR
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_funcs_dealloc
Dwarf_Debug
dbg
Dwarf_Func
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
Dwarf_Global
dwgl
count
return
int
dwarf_funcname
Dwarf_Func
func_in
char
ret_name
Dwarf_Error
error
Dwarf_Global
func
Dwarf_Global
func_in
if
func
NULL
_dwarf_error
NULL
error
DW_DLE_FUNC_NULL
return
DW_DLV_ERROR
ret_name
char
func
gl_name
return
DW_DLV_OK
int
dwarf_func_die_offset
Dwarf_Func
func_in
Dwarf_Off
return_offset
Dwarf_Error
error
Dwarf_Global
func
Dwarf_Global
func_in
return
dwarf_global_die_offset
func
return_offset
error
int
dwarf_func_cu_offset
Dwarf_Func
func_in
Dwarf_Off
return_offset
Dwarf_Error
error
Dwarf_Global
func
Dwarf_Global
func_in
return
dwarf_global_cu_offset
func
return_offset
error
int
dwarf_func_name_offsets
Dwarf_Func
func_in
char
ret_func_name
Dwarf_Off
die_offset
Dwarf_Off
cu_die_offset
Dwarf_Error
error
Dwarf_Global
func
Dwarf_Global
func_in
return
dwarf_global_name_offsets
func
ret_func_name
die_offset
cu_die_offset
error
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
memcpy_swap
h
include
dwarf_gdbindex
h
The
dwarf_util
macro
READ_UNALIGNED
cannot
be
directly
used
because
gdb
defines
the
section
contents
of
gdb_index
as
little
endian
always
if
WORDS_BIGENDIAN
meaning
on
this
host
define
READ_GDBINDEX
dest
desttype
source
length
do
BIGGEST_UINT
_ltmp
_dwarf_memcpy_swap_bytes
char
sizeof
_ltmp
length
source
length
dest
desttype
_ltmp
while
else
little
endian
on
this
host
define
READ_GDBINDEX
dest
desttype
source
length
do
BIGGEST_UINT
_ltmp
memcpy
char
source
length
dest
desttype
_ltmp
while
endif
struct
gi_fileheader_s
char
gfs
struct
dwarf_64bitpair
gdbindex_64
offset
gdbindex_64
length
static
int
set_base
Dwarf_Debug
dbg
struct
Dwarf_Gdbindex_array_instance_s
hdr
Dwarf_Small
start
Dwarf_Small
end
entrylen
is
the
length
of
a
single
struct
as
seen
in
the
object
Dwarf_Unsigned
entrylen
The
size
of
each
field
in
the
struct
in
the
object
Dwarf_Unsigned
fieldlen
enum
gdbindex_type_e
type
Dwarf_Error
err
if
type
git_std
type
git_cuvec
cuvec
is
sort
of
a
fake
as
a
simple
section
but
a
useful
one
Dwarf_Unsigned
count
if
end
start
_dwarf_error
dbg
err
DW_DLE_GDB_INDEX_COUNT_ERROR
return
DW_DLV_ERROR
count
end
start
count
count
entrylen
hdr
dg_type
type
hdr
dg_base
start
hdr
dg_count
count
hdr
dg_entry_length
entrylen
hdr
dg_fieldlen
fieldlen
else
address
area
offset
Then
pad
Dwarf_Unsigned
count
hdr
dg_base
start
if
end
start
_dwarf_error
dbg
err
DW_DLE_GDB_INDEX_COUNT_ADDR_ERROR
return
DW_DLV_ERROR
entry
length
includes
pad
hdr
dg_entry_length
sizeof
gdbindex_64
DWARF_32BIT_SIZE
count
end
start
count
count
hdr
dg_entry_length
hdr
dg_count
count
The
dg_fieldlen
is
a
fake
the
fields
are
not
all
the
same
length
hdr
dg_fieldlen
DWARF_32BIT_SIZE
hdr
dg_type
type
return
DW_DLV_OK
int
dwarf_gdbindex_header
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
version
Dwarf_Unsigned
cu_list_offset
Dwarf_Unsigned
types_cu_list_offset
Dwarf_Unsigned
address_area_offset
Dwarf_Unsigned
symbol_table_offset
Dwarf_Unsigned
constant_pool_offset
Dwarf_Unsigned
section_size
Dwarf_Unsigned
unused_reserved
const
char
section_name
Dwarf_Error
error
struct
gi_fileheader_s
header
Dwarf_Gdbindex
indexptr
int
res
DW_DLV_ERROR
if
dbg
de_debug_gdbindex
dss_size
return
DW_DLV_NO_ENTRY
if
dbg
de_debug_gdbindex
dss_data
res
_dwarf_load_section
dbg
de_debug_gdbindex
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_gdbindex
dss_size
sizeof
struct
gi_fileheader_s
_dwarf_error
dbg
error
DW_DLE_ERRONEOUS_GDB_INDEX_SECTION
return
DW_DLV_ERROR
memcpy
dbg
de_debug_gdbindex
dss_data
sizeof
struct
gi_fileheader_s
indexptr
Dwarf_Gdbindex
_dwarf_get_alloc
dbg
DW_DLA_GDBINDEX
if
indexptr
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
indexptr
gi_dbg
dbg
indexptr
gi_section_data
dbg
de_debug_gdbindex
dss_data
indexptr
gi_section_length
dbg
de_debug_gdbindex
dss_size
READ_GDBINDEX
indexptr
gi_version
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
READ_GDBINDEX
indexptr
gi_cu_list_offset
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
READ_GDBINDEX
indexptr
gi_types_cu_list_offset
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
READ_GDBINDEX
indexptr
gi_address_area_offset
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
READ_GDBINDEX
indexptr
gi_symbol_table_offset
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
READ_GDBINDEX
indexptr
gi_constant_pool_offset
Dwarf_Unsigned
dbg
de_debug_gdbindex
dss_data
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
res
set_base
dbg
gi_culisthdr
dbg
de_debug_gdbindex
dss_data
indexptr
gi_cu_list_offset
dbg
de_debug_gdbindex
dss_data
indexptr
gi_types_cu_list_offset
sizeof
gdbindex_64
sizeof
gdbindex_64
git_std
error
if
res
DW_DLV_ERROR
return
res
res
set_base
dbg
gi_typesculisthdr
dbg
de_debug_gdbindex
dss_data
indexptr
gi_types_cu_list_offset
dbg
de_debug_gdbindex
dss_data
indexptr
gi_address_area_offset
sizeof
gdbindex_64
sizeof
gdbindex_64
git_std
error
if
res
DW_DLV_ERROR
return
res
res
set_base
dbg
gi_addressareahdr
dbg
de_debug_gdbindex
dss_data
indexptr
gi_address_area_offset
dbg
de_debug_gdbindex
dss_data
indexptr
gi_symbol_table_offset
sizeof
gdbindex_64
sizeof
gdbindex_64
git_address
error
if
res
DW_DLV_ERROR
return
res
res
set_base
dbg
gi_symboltablehdr
dbg
de_debug_gdbindex
dss_data
indexptr
gi_symbol_table_offset
dbg
de_debug_gdbindex
dss_data
indexptr
gi_constant_pool_offset
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
git_std
error
if
res
DW_DLV_ERROR
return
res
res
set_base
dbg
gi_cuvectorhdr
dbg
de_debug_gdbindex
dss_data
indexptr
gi_constant_pool_offset
There
is
no
real
single
vector
size
but
we
ll
use
the
entire
rest
as
if
there
was
dbg
de_debug_gdbindex
dss_data
indexptr
gi_section_length
DWARF_32BIT_SIZE
DWARF_32BIT_SIZE
git_cuvec
error
if
res
DW_DLV_ERROR
return
res
Really
just
pointing
to
constant
pool
area
indexptr
gi_string_pool
dbg
de_debug_gdbindex
dss_data
indexptr
gi_constant_pool_offset
gdbindexptr
indexptr
version
indexptr
gi_version
cu_list_offset
indexptr
gi_cu_list_offset
types_cu_list_offset
indexptr
gi_types_cu_list_offset
address_area_offset
indexptr
gi_address_area_offset
symbol_table_offset
indexptr
gi_symbol_table_offset
constant_pool_offset
indexptr
gi_constant_pool_offset
section_size
indexptr
gi_section_length
unused_reserved
section_name
dbg
de_debug_gdbindex
dss_name
return
DW_DLV_OK
int
dwarf_gdbindex_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
UNUSEDARG
list_length
gdbindexptr
gi_culisthdr
dg_count
return
DW_DLV_OK
entryindex
to
list_length
int
dwarf_gdbindex_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
cu_offset
Dwarf_Unsigned
cu_length
Dwarf_Error
error
Dwarf_Unsigned
max
gdbindexptr
gi_culisthdr
dg_count
Dwarf_Small
base
Dwarf_Unsigned
offset
Dwarf_Unsigned
length
unsigned
fieldlen
gdbindexptr
gi_culisthdr
dg_fieldlen
if
entryindex
max
_dwarf_error
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
base
gdbindexptr
gi_culisthdr
dg_base
base
entryindex
gdbindexptr
gi_culisthdr
dg_entry_length
READ_GDBINDEX
offset
Dwarf_Unsigned
base
fieldlen
READ_GDBINDEX
length
Dwarf_Unsigned
base
fieldlen
fieldlen
cu_offset
offset
cu_length
length
return
DW_DLV_OK
int
dwarf_gdbindex_types_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
UNUSEDARG
list_length
gdbindexptr
gi_typesculisthdr
dg_count
return
DW_DLV_OK
entryindex
to
list_length
int
dwarf_gdbindex_types_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
t_offset
Dwarf_Unsigned
t_length
Dwarf_Unsigned
t_signature
Dwarf_Error
error
Dwarf_Unsigned
max
gdbindexptr
gi_typesculisthdr
dg_count
Dwarf_Small
base
Dwarf_Unsigned
offset
Dwarf_Unsigned
length
Dwarf_Unsigned
signature
unsigned
fieldlen
gdbindexptr
gi_typesculisthdr
dg_fieldlen
if
entryindex
max
_dwarf_error
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
base
gdbindexptr
gi_typesculisthdr
dg_base
base
entryindex
gdbindexptr
gi_typesculisthdr
dg_entry_length
READ_GDBINDEX
offset
Dwarf_Unsigned
base
fieldlen
READ_GDBINDEX
length
Dwarf_Unsigned
base
fieldlen
fieldlen
READ_GDBINDEX
signature
Dwarf_Unsigned
base
fieldlen
fieldlen
t_offset
offset
t_length
length
t_signature
signature
return
DW_DLV_OK
int
dwarf_gdbindex_addressarea
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
UNUSEDARG
list_length
gdbindexptr
gi_addressareahdr
dg_count
return
DW_DLV_OK
entryindex
to
addressarea_list_length
int
dwarf_gdbindex_addressarea_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
low_address
Dwarf_Unsigned
high_address
Dwarf_Unsigned
cu_index
Dwarf_Error
error
Dwarf_Unsigned
max
gdbindexptr
gi_addressareahdr
dg_count
Dwarf_Small
base
Dwarf_Unsigned
lowaddr
Dwarf_Unsigned
highaddr
Dwarf_Unsigned
cuindex
if
entryindex
max
_dwarf_error
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
base
gdbindexptr
gi_addressareahdr
dg_base
base
entryindex
gdbindexptr
gi_addressareahdr
dg_entry_length
READ_GDBINDEX
lowaddr
Dwarf_Unsigned
base
sizeof
gdbindex_64
READ_GDBINDEX
highaddr
Dwarf_Unsigned
base
sizeof
gdbindex_64
sizeof
gdbindex_64
READ_GDBINDEX
cuindex
Dwarf_Unsigned
base
sizeof
gdbindex_64
DWARF_32BIT_SIZE
low_address
lowaddr
high_address
highaddr
cu_index
cuindex
return
DW_DLV_OK
int
dwarf_gdbindex_symboltable_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
UNUSEDARG
list_length
gdbindexptr
gi_symboltablehdr
dg_count
return
DW_DLV_OK
entryindex
to
symtab_list_length
int
dwarf_gdbindex_symboltable_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
string_offset
Dwarf_Unsigned
cu_vector_offset
Dwarf_Error
error
Dwarf_Unsigned
max
gdbindexptr
gi_symboltablehdr
dg_count
Dwarf_Small
base
Dwarf_Unsigned
symoffset
Dwarf_Unsigned
cuoffset
unsigned
fieldlen
gdbindexptr
gi_symboltablehdr
dg_fieldlen
if
entryindex
max
_dwarf_error
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
base
gdbindexptr
gi_symboltablehdr
dg_base
base
entryindex
gdbindexptr
gi_symboltablehdr
dg_entry_length
READ_GDBINDEX
symoffset
Dwarf_Unsigned
base
fieldlen
READ_GDBINDEX
cuoffset
Dwarf_Unsigned
base
fieldlen
fieldlen
string_offset
symoffset
cu_vector_offset
cuoffset
return
DW_DLV_OK
int
dwarf_gdbindex_cuvector_length
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innercount
Dwarf_Error
error
Dwarf_Small
base
gdbindex
gi_cuvectorhdr
dg_base
Dwarf_Small
end
gdbindex
gi_section_data
gdbindex
gi_section_length
Dwarf_Unsigned
val
unsigned
fieldlen
gdbindex
gi_cuvectorhdr
dg_entry_length
base
cuvector_offset
if
base
fieldlen
end
_dwarf_error
gdbindex
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
READ_GDBINDEX
val
Dwarf_Unsigned
base
fieldlen
innercount
val
return
DW_DLV_OK
int
dwarf_gdbindex_cuvector_inner_attributes
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innerindex
The
attr_value
is
a
field
of
bits
For
expanded
version
use
dwarf_gdbindex_instance_expand_value
Dwarf_Unsigned
attributes
Dwarf_Error
error
Dwarf_Small
base
gdbindexptr
gi_cuvectorhdr
dg_base
Dwarf_Small
end
gdbindexptr
gi_section_data
gdbindexptr
gi_section_length
Dwarf_Unsigned
val
unsigned
fieldlen
gdbindexptr
gi_cuvectorhdr
dg_entry_length
base
cuvector_offset
if
base
fieldlen
end
_dwarf_error
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
return
DW_DLV_ERROR
base
fieldlen
base
innerindex
fieldlen
READ_GDBINDEX
val
Dwarf_Unsigned
base
fieldlen
attributes
val
return
DW_DLV_OK
int
dwarf_gdbindex_cuvector_instance_expand_value
Dwarf_Gdbindex
gdbindexptr
UNUSEDARG
Dwarf_Unsigned
value
Dwarf_Unsigned
cu_index
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
symbol_kind
Dwarf_Unsigned
is_static
Dwarf_Error
error
UNUSEDARG
cu_index
value
reserved1
value
symbol_kind
value
is_static
value
return
DW_DLV_OK
The
strings
in
the
pool
follow
in
memory
the
cu
index
set
and
are
NUL
terminated
int
dwarf_gdbindex_string_by_offset
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
stringoffsetinpool
const
char
string_ptr
Dwarf_Error
error
Dwarf_Small
pooldata
Dwarf_Small
section_end
Dwarf_Small
stringitself
Dwarf_Debug
dbg
int
res
if
gdbindexptr
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_GDB_INDEX_INDEX_ERROR
The
gdbindex
pointer
to
dwarf_gdbindex_string_by_offset
is
NULL
_dwarf_error_string
gdbindexptr
gi_dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
dbg
gdbindexptr
gi_dbg
if
dbg
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_GDB_INDEX_INDEX_ERROR
The
gdbindex
Dwarf_Debug
in
dwarf_gdbindex_string_by_offset
is
NULL
_dwarf_error_string
dbg
error
DW_DLE_GDB_INDEX_INDEX_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
pooldata
gdbindexptr
gi_section_data
gdbindexptr
gi_constant_pool_offset
section_end
gdbindexptr
gi_section_data
gdbindexptr
gi_section_length
stringitself
pooldata
stringoffsetinpool
if
stringitself
section_end
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_GDBINDEX_STRING_ERROR
The
dwarf_gdbindex_string_by_offset
string
starts
past
the
end
of
the
section
at
section_offset
DW_PR_XZEROS
DW_PR_DUx
Dwarf_Unsigned
uintptr_t
stringitself
gdbindexptr
gi_section_data
_dwarf_error_string
dbg
error
DW_DLE_GDBINDEX_STRING_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
dbg
pooldata
stringitself
section_end
DW_DLE_GDBINDEX_STRING_ERROR
error
if
res
DW_DLV_OK
return
res
string_ptr
const
char
stringitself
return
DW_DLV_OK
void
dwarf_gdbindex_free
Dwarf_Gdbindex
indexptr
if
indexptr
Dwarf_Debug
dbg
indexptr
gi_dbg
dwarf_dealloc
dbg
indexptr
DW_DLA_GDBINDEX
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
Arxan
Technologies
Inc
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Here
is
the
deepest
routes
through
dwarf_init_path_dl
depending
on
arguments
It
is
called
by
dwarfdump
to
open
an
fd
and
return
Dwarf_Debug
Much
of
this
is
to
handle
GNU
debuglink
dwarf_init_path_dl
path
true_path
and
globals
dbg1
dwarf_object_detector_path_dSYM
dsym
only
if
returns
DW_DLV_OK
itis
dSYM
dwarf_object_detector_path_b
with
global
paths
dwarf_object_detector_path_b
ftype
check
for
dSYM
if
found
it
is
the
object
to
run
on
dwarf_object_detector_fd
gets
size
ftype
return
_dwarf_debuglink_finder_internal
TRUE
passing
in
globals
paths
listr
new
local
dbg
dwarf_init_path
path
no
dysm
or
debuglink
no
global
paths
dwarf_object_detector_path_b
path
no
dsym
or
debuglink
no
global
paths
dwarf_object_detector
path
dwarf_object_detector_fd
gets
size
ftype
for
each
global
pathin
list
add
to
dbg
dwarf_gnu_debuglink
dbg
for
each
global
path
in
debuglink
list
_dwarf_debuglink_finder_internal
FALSE
no
global
paths
if
crc
match
return
OK
with
pathname
and
fd
returned
else
return
NO_ENTRY
include
config
h
include
stdio
h
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
endif
HAVE_SYS_STAT_H
include
fcntl
h
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
_WIN32
include
io
h
elif
defined
HAVE_UNISTD_H
include
unistd
h
endif
_WIN32
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_object_detector
h
ifndef
O_BINARY
define
O_BINARY
endif
O_BINARY
This
is
the
initialization
set
intended
to
handle
multiple
object
formats
Created
September
The
init
functions
here
cannot
process
archives
For
archives
the
libelf
only
dwarf_elf_init
functions
are
used
if
present
else
archives
cannot
be
read
static
int
open_a_file
const
char
name
Set
to
a
file
number
that
cannot
be
legal
int
fd
if
HAVE_ELF_OPEN
It
is
not
possible
to
share
file
handles
between
applications
or
DLLs
Each
application
has
its
own
file
handle
table
For
two
applications
to
use
the
same
file
using
a
DLL
they
must
both
open
the
file
individually
Let
the
libelf
dll
open
and
close
the
file
fd
elf_open
name
O_RDONLY
O_BINARY
else
fd
open
name
O_RDONLY
O_BINARY
endif
return
fd
static
int
set_global_paths_init
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
res
dwarf_add_debuglink_global_path
dbg
usr
lib
debug
error
return
res
New
in
December
int
dwarf_init_path
const
char
path
char
true_path_out_buffer
unsigned
true_path_bufferlen
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
ret_dbg
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Error
error
return
dwarf_init_path_dl
path
true_path_out_buffer
true_path_bufferlen
groupnumber
errhand
errarg
ret_dbg
reserved1
reserved2
reserved3
error
static
void
final_common_settings
Dwarf_Debug
dbg
const
char
file_path
int
fd
unsigned
char
lpath_source
unsigned
char
path_source
Dwarf_Error
error
int
res
dbg
de_path
strdup
file_path
dbg
de_fd
fd
dbg
de_owns_fd
TRUE
dbg
de_path_source
lpath_source
if
path_source
path_source
lpath_source
dbg
de_owns_fd
TRUE
res
set_global_paths_init
dbg
error
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
return
New
October
Given
true_path_out_buffer
and
true_path_bufferlen
non
zero
this
finds
a
dSYM
if
such
exists
with
the
file
name
in
true_path_out_buffer
If
not
a
dSYM
it
follows
debuglink
rules
to
try
to
find
a
file
that
matches
requirements
If
found
returns
DW_DLV_OK
and
copies
the
name
to
true_path_out_buffer
If
none
of
the
above
found
it
copies
path
into
true_path
and
returns
DW_DLV_OK
we
know
the
name
is
good
The
fd
is
owned
by
libdwarf
and
is
in
the
created
dbg
de_fd
field
int
dwarf_init_path_dl
const
char
path
char
true_path_out_buffer
unsigned
true_path_bufferlen
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
ret_dbg
char
dl_path_array
unsigned
int
dl_path_count
unsigned
char
path_source
const
char
reserved1
UNUSEDARG
Dwarf_Unsigned
reserved2
UNUSEDARG
Dwarf_Unsigned
reserved3
UNUSEDARG
Dwarf_Error
error
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
res
DW_DLV_NO_ENTRY
int
errcode
int
fd
Dwarf_Debug
dbg
char
file_path
unsigned
char
lpath_source
DW_PATHSOURCE_basic
if
ret_dbg
DWARF_DBG_ERROR
NULL
DW_DLE_DWARF_INIT_DBG_NULL
DW_DLV_ERROR
if
path
Oops
Null
path
_dwarf_error_string
NULL
error
DW_DLE_STRING_PTR_NULL
DW_DLE_STRING_PTR_NULL
Passing
a
null
path
argument
to
dwarf_init_path
or
dwarf_init_path_dl
cannot
work
Error
return
DW_DLV_ERROR
a
special
dsym
call
so
we
only
check
once
if
true_path_out_buffer
res
dwarf_object_detector_path_dSYM
path
true_path_out_buffer
true_path_bufferlen
dl_path_array
dl_path_count
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
ignore
error
Look
further
errcode
else
if
res
DW_DLV_OK
res
dwarf_object_detector_path_b
path
true_path_out_buffer
true_path_bufferlen
dl_path_array
dl_path_count
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
errcode
if
res
DW_DLV_OK
So
as
a
last
resurt
in
case
of
data
corruption
in
the
object
Lets
try
without
investigating
debuglink
or
dSYM
res
dwarf_object_detector_path_b
path
dl_path_array
dl_path_count
if
res
DW_DLV_ERROR
errcode
if
res
DW_DLV_OK
impossible
The
last
above
had
to
work
return
res
ASSERT
lpath_source
DW_PATHSOURCE_unspecified
if
lpath_source
DW_PATHSOURCE_basic
MacOS
dSYM
or
GNU
debuglink
file_path
true_path_out_buffer
fd
open_a_file
true_path_out_buffer
else
ASSERT
pathlsource
DW_PATHSOURCE_basic
file_path
char
path
fd
open_a_file
path
if
fd
DWARF_DBG_ERROR
NULL
DW_DLE_FILE_UNAVAILABLE
DW_DLV_ERROR
switch
ftype
case
DW_FTYPE_ELF
res
_dwarf_elf_nlsetup
fd
file_path
ftype
endian
offsetsize
filesize
groupnumber
errhand
errarg
error
if
res
DW_DLV_OK
close
fd
return
res
final_common_settings
dbg
file_path
fd
lpath_source
path_source
error
ret_dbg
dbg
return
res
case
DW_FTYPE_MACH_O
res
_dwarf_macho_setup
fd
file_path
ftype
endian
offsetsize
filesize
groupnumber
errhand
errarg
error
if
res
DW_DLV_OK
close
fd
return
res
final_common_settings
dbg
file_path
fd
lpath_source
path_source
error
ret_dbg
dbg
return
res
case
DW_FTYPE_PE
res
_dwarf_pe_setup
fd
file_path
ftype
endian
offsetsize
filesize
groupnumber
errhand
errarg
error
if
res
DW_DLV_OK
close
fd
return
res
final_common_settings
dbg
file_path
fd
lpath_source
path_source
error
ret_dbg
dbg
return
res
default
close
fd
DWARF_DBG_ERROR
NULL
DW_DLE_FILE_WRONG_TYPE
DW_DLV_ERROR
return
DW_DLV_NO_ENTRY
New
March
this
provides
for
reading
object
files
with
multiple
elf
section
groups
If
you
are
unsure
about
group_number
use
DW_GROUPNUMBER_ANY
as
groupnumber
int
dwarf_init_b
int
fd
unsigned
group_number
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
ret_dbg
Dwarf_Error
error
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
res
int
errcode
if
ret_dbg
DWARF_DBG_ERROR
NULL
DW_DLE_DWARF_INIT_DBG_NULL
DW_DLV_ERROR
res
dwarf_object_detector_fd
fd
if
res
DW_DLV_NO_ENTRY
return
res
else
if
res
DW_DLV_ERROR
DWARF_DBG_ERROR
NULL
DW_DLE_FILE_WRONG_TYPE
DW_DLV_ERROR
switch
ftype
case
DW_FTYPE_ELF
int
res2
res2
_dwarf_elf_nlsetup
fd
ftype
endian
offsetsize
filesize
group_number
errhand
errarg
ret_dbg
error
if
res2
DW_DLV_OK
return
res2
set_global_paths_init
ret_dbg
error
return
res2
case
DW_FTYPE_MACH_O
int
resm
resm
_dwarf_macho_setup
fd
ftype
endian
offsetsize
filesize
group_number
errhand
errarg
ret_dbg
error
if
resm
DW_DLV_OK
return
resm
set_global_paths_init
ret_dbg
error
return
resm
case
DW_FTYPE_PE
int
resp
resp
_dwarf_pe_setup
fd
ftype
endian
offsetsize
filesize
group_number
errhand
errarg
ret_dbg
error
if
resp
DW_DLV_OK
return
resp
set_global_paths_init
ret_dbg
error
return
resp
DWARF_DBG_ERROR
NULL
DW_DLE_FILE_WRONG_TYPE
DW_DLV_ERROR
return
res
Frees
all
memory
that
was
not
previously
freed
by
dwarf_dealloc
Aside
from
certain
categories
Applicable
when
dwarf_init
or
dwarf_elf_init
or
the
b
form
was
used
to
init
dbg
int
dwarf_finish
Dwarf_Debug
dbg
Dwarf_Error
error
if
dbg
return
DW_DLV_OK
if
dbg
de_obj_file
The
initial
character
of
a
valid
dbg
de_obj_file
object
struct
is
a
letter
E
F
M
or
P
char
otype
char
dbg
de_obj_file
object
switch
otype
case
E
break
case
F
Non
libelf
elf
access
_dwarf_destruct_elf_nlaccess
dbg
de_obj_file
break
case
M
_dwarf_destruct_macho_access
dbg
de_obj_file
break
case
P
_dwarf_destruct_pe_access
dbg
de_obj_file
break
default
Do
nothing
A
serious
internal
error
break
if
dbg
de_owns_fd
close
dbg
de_fd
dbg
de_owns_fd
FALSE
free
void
dbg
de_path
dbg
de_path
dwarf_object_finish
also
frees
de_path
but
that
is
safe
because
we
set
it
to
zero
here
so
no
duplicate
free
will
occur
It
never
returns
DW_DLV_ERROR
Not
all
code
uses
libdwarf
exactly
as
we
do
hence
the
free
there
return
dwarf_object_finish
dbg
error
tieddbg
should
be
the
executable
or
o
that
has
the
debug_addr
section
that
the
base
dbg
refers
to
See
Split
Objects
in
DWARF5
Allows
setting
to
NULL
NULL
is
the
default
of
de_tied_data
td_tied_object
New
September
int
dwarf_set_tied_dbg
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg
Dwarf_Error
error
if
dbg
DWARF_DBG_ERROR
NULL
DW_DLE_DBG_NULL
DW_DLV_ERROR
dbg
de_tied_data
td_tied_object
tieddbg
if
tieddbg
tieddbg
de_tied_data
td_is_tied_object
TRUE
return
DW_DLV_OK
Unsure
of
the
use
case
of
this
New
September
int
dwarf_get_tied_dbg
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg_out
UNUSEDARG
Dwarf_Error
error
tieddbg_out
dbg
de_tied_data
td_tied_object
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_global
h
ifdef
__sgi
__sgi
should
only
be
defined
for
IRIX
MIPS
The
fixup
here
intended
for
IRIX
targets
only
With
a
GB
Elf64
IRIX
executable
under
in
size
some
DIE
offsets
wrongly
got
the
upper
bit
sign
extended
For
the
cu
header
offset
in
the
debug_pubnames
section
and
in
the
debug_aranges
section
the
varp
here
is
a
pointer
to
an
offset
into
debug_info
We
fix
up
the
offset
here
if
it
seems
advisable
As
of
June
we
have
identified
a
series
of
mistakes
in
ldx64
that
can
cause
this
bit
values
getting
passed
thru
bit
signed
knothole
void
_dwarf_fix_up_offset_irix
Dwarf_Debug
dbg
Dwarf_Unsigned
varp
char
caller_site_name
Dwarf_Unsigned
var
varp
define
UPPER33
define
LOWER32
Restrict
the
hack
to
the
known
case
Upper
bits
erroneously
sign
extended
from
lower
upper
bit
if
var
UPPER33
UPPER33
var
LOWER32
Apply
the
fix
Dreadful
hack
varp
var
undef
UPPER33
undef
LOWER32
return
endif
__sgi
static
void
dealloc_globals_chain
Dwarf_Debug
dbg
Dwarf_Chain
head_chain
Dwarf_Chain
curr_chain
Dwarf_Chain
prev_chain
int
chaintype
DW_DLA_CHAIN
Dwarf_Global_Context
lastcontext
Dwarf_Global_Context
curcontext
curr_chain
head_chain
for
curr_chain
Dwarf_Global
item
int
itemtype
item
Dwarf_Global
curr_chain
ch_item
itemtype
curr_chain
ch_itemtype
curcontext
item
gl_context
if
curcontext
curcontext
lastcontext
First
time
we
see
a
context
dealloc
it
lastcontext
curcontext
dwarf_dealloc
dbg
curcontext
curcontext
pu_alloc_type
prev_chain
curr_chain
dwarf_dealloc
dbg
item
itemtype
prev_chain
ch_item
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
chaintype
int
dwarf_get_globals
Dwarf_Debug
dbg
Dwarf_Global
globals
Dwarf_Signed
return_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_pubnames
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_pubnames
dss_size
return
DW_DLV_NO_ENTRY
res
_dwarf_internal_get_pubnames_like_data
dbg
debug_pubnames
dbg
de_debug_pubnames
dss_data
dbg
de_debug_pubnames
dss_size
globals
return_count
error
DW_DLA_GLOBAL_CONTEXT
DW_DLA_GLOBAL
DW_DLE_PUBNAMES_LENGTH_BAD
DW_DLE_PUBNAMES_VERSION_ERROR
return
res
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_globals_dealloc
Dwarf_Debug
dbg
Dwarf_Global
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
dwgl
count
return
void
_dwarf_internal_globals_dealloc
Dwarf_Debug
dbg
Dwarf_Global
dwgl
Dwarf_Signed
count
Dwarf_Signed
i
struct
Dwarf_Global_Context_s
glcp
struct
Dwarf_Global_Context_s
lastglcp
if
dwgl
return
for
i
i
count
i
Dwarf_Global
dgd
dwgl
i
if
dgd
continue
Avoids
duplicate
frees
of
repeated
use
of
contexts
while
assuming
that
all
uses
of
a
particular
gl_context
will
appear
next
to
each
other
glcp
dgd
gl_context
if
glcp
lastglcp
glcp
lastglcp
glcp
dwarf_dealloc
dbg
glcp
glcp
pu_alloc_type
dwarf_dealloc
dbg
dgd
dgd
gl_alloc_type
dwarf_dealloc
dbg
dwgl
DW_DLA_LIST
return
static
void
pubnames_error_length
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
spaceneeded
const
char
secname
const
char
specificloc
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_PUBNAMES_LENGTH_BAD
In
section
dwarfstring_append
char
secname
dwarfstring_append_printf_u
u
bytes
of
space
needed
but
the
section
is
out
of
space
spaceneeded
dwarfstring_append
reading
dwarfstring_append
char
specificloc
dwarfstring_append
_dwarf_error_string
dbg
error
DW_DLE_PUBNAMES_LENGTH_BAD
dwarfstring_string
dwarfstring_destructor
INVARIANTS
on
error
does
not
leak
Dwarf_Global
glname
is
not
malloc
space
Never
free
static
int
_dwarf_make_global_add_to_chain
Dwarf_Debug
dbg
Dwarf_Unsigned
global_DLA_code
Dwarf_Global_Context
pubnames_context
Dwarf_Off
die_offset_in_cu
unsigned
char
glname
Dwarf_Unsigned
global_count
Dwarf_Bool
pubnames_context_on_list
Dwarf_Chain
prev_chain
Dwarf_Chain
head_chain
Dwarf_Error
error
Dwarf_Chain
curr_chain
Dwarf_Global
global
global
Dwarf_Global
_dwarf_get_alloc
dbg
global_DLA_code
if
global
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
global_count
Recording
the
same
context
in
another
Dwarf_Global
global
gl_context
pubnames_context
global
gl_alloc_type
global_DLA_code
global
gl_named_die_offset_within_cu
die_offset_in_cu
global
gl_name
glname
Finish
off
current
entry
chain
curr_chain
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_chain
dwarf_dealloc
dbg
global
global_DLA_code
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Put
current
global
on
singly_linked
list
curr_chain
ch_item
Dwarf_Global
global
curr_chain
ch_itemtype
global_DLA_code
if
head_chain
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
pubnames_context_on_list
TRUE
return
DW_DLV_OK
Sweeps
the
complete
section
int
_dwarf_internal_get_pubnames_like_data
Dwarf_Debug
dbg
const
char
secname
Dwarf_Small
section_data_ptr
Dwarf_Unsigned
section_length
Dwarf_Global
globals
Dwarf_Signed
return_count
Dwarf_Error
error
int
context_DLA_code
int
global_DLA_code
int
length_err_num
int
version_err_num
Dwarf_Small
pubnames_like_ptr
Dwarf_Off
pubnames_section_offset
Dwarf_Small
section_end_ptr
section_data_ptr
section_length
Points
to
the
context
for
the
current
set
of
global
names
and
contains
information
to
identify
the
compilation
unit
that
the
set
refers
to
Dwarf_Global_Context
pubnames_context
Dwarf_Bool
pubnames_context_on_list
FALSE
Dwarf_Unsigned
version
Offset
from
the
start
of
compilation
unit
for
the
current
global
Dwarf_Off
die_offset_in_cu
Dwarf_Unsigned
global_count
Used
to
chain
the
Dwarf_Global_s
structs
for
creating
contiguous
list
of
pointers
to
the
structs
Dwarf_Chain
prev_chain
Dwarf_Chain
head_chain
Points
to
contiguous
block
of
Dwarf_Global
to
be
returned
Dwarf_Global
ret_globals
int
mres
Temporary
counter
Dwarf_Unsigned
i
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
We
will
eventually
need
the
debug_info
data
Load
it
now
if
dbg
de_debug_info
dss_data
int
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
if
section_data_ptr
NULL
return
DW_DLV_NO_ENTRY
pubnames_like_ptr
section_data_ptr
do
Dwarf_Unsigned
length
int
local_extension_size
int
local_length_size
Some
compilers
emit
padding
at
the
end
of
each
cu
s
area
pubnames_ptr_past_end_cu
records
the
true
area
end
for
the
pubnames
like
content
of
a
cu
Essentially
the
length
in
the
header
and
the
terminator
of
the
data
are
redundant
information
The
dwarf2
spec
does
not
mention
what
to
do
if
the
length
is
past
the
terminator
So
we
take
any
bytes
left
after
the
as
padding
and
ignore
them
Dwarf_Small
pubnames_ptr_past_end_cu
pubnames_context_on_list
FALSE
pubnames_context
Dwarf_Global_Context
_dwarf_get_alloc
dbg
context_DLA_code
if
pubnames_context
NULL
dealloc_globals_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
pubnames_context
not
recorded
anywhere
yet
READ_AREA_LENGTH
updates
pubnames_like_ptr
for
consumed
bytes
if
pubnames_like_ptr
DWARF_32BIT_SIZE
DWARF_HALF_SIZE
DWARF_32BIT_SIZE
A
minimum
size
needed
section_end_ptr
pubnames_error_length
dbg
error
DWARF_32BIT_SIZE
DWARF_HALF_SIZE
DWARF_32BIT_SIZE
secname
header
record
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
DW_DLV_ERROR
mres
_dwarf_read_area_length_ck_wrapper
dbg
section_length
section_end_ptr
error
if
mres
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
mres
pubnames_context
pu_alloc_type
context_DLA_code
pubnames_context
pu_length_size
local_length_size
pubnames_context
pu_length
length
pubnames_context
pu_extension_size
local_extension_size
pubnames_context
pu_dbg
dbg
pubnames_context
pu_pub_offset
pubnames_section_offset
pubnames_ptr_past_end_cu
pubnames_like_ptr
length
if
pubnames_like_ptr
DWARF_HALF_SIZE
A
minimum
size
needed
section_end_ptr
pubnames_error_length
dbg
error
DWARF_HALF_SIZE
secname
version
number
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
DW_DLV_ERROR
mres
_dwarf_read_unaligned_ck_wrapper
dbg
pubnames_like_ptr
DWARF_HALF_SIZE
section_end_ptr
error
if
mres
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
mres
pubnames_context
pu_version
version
pubnames_like_ptr
DWARF_HALF_SIZE
ASSERT
DW_PUBNAMES_VERSION2
DW_PUBTYPES_VERSION2
if
version
DW_PUBNAMES_VERSION2
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
_dwarf_error
dbg
error
version_err_num
return
DW_DLV_ERROR
Offset
of
CU
header
in
debug
section
if
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
pubnames_error_length
dbg
error
pubnames_context
pu_length_size
secname
header
DIE
offsets
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
DW_DLV_ERROR
mres
_dwarf_read_unaligned_ck_wrapper
dbg
pu_offset_of_cu_header
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
error
if
mres
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
mres
pubnames_like_ptr
pubnames_context
pu_length_size
FIX_UP_OFFSET_IRIX_BUG
dbg
pubnames_context
pu_offset_of_cu_header
pubnames
cu
header
offset
mres
_dwarf_read_unaligned_ck_wrapper
dbg
pu_info_length
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
error
if
mres
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
mres
pubnames_like_ptr
pubnames_context
pu_length_size
if
pubnames_like_ptr
section_data_ptr
section_length
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
_dwarf_error
dbg
error
length_err_num
return
DW_DLV_ERROR
begin
pubname
Read
initial
offset
of
DIE
within
CU
of
a
pubname
final
entry
is
not
a
pair
just
a
zero
offset
mres
_dwarf_read_unaligned_ck_wrapper
dbg
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
error
if
mres
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
mres
pubnames_like_ptr
pubnames_context
pu_length_size
FIX_UP_OFFSET_IRIX_BUG
dbg
die_offset_in_cu
offset
of
die
in
cu
if
pubnames_like_ptr
section_data_ptr
section_length
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
_dwarf_error
dbg
error
length_err_num
return
DW_DLV_ERROR
Loop
thru
pairs
DIE
off
with
CU
followed
by
string
if
die_offset_in_cu
if
dbg
de_return_empty_pubnames
int
res
Here
we
have
a
pubnames
CU
with
no
actual
entries
so
we
fake
up
an
entry
to
hold
the
header
data
There
are
no
pairs
here
just
the
end
of
list
zero
value
We
do
this
only
if
de_return_empty_pubnames
is
set
so
that
we
by
default
return
exactly
the
same
data
this
always
returned
yet
dwarfdump
can
request
the
empty
cu
records
get
created
to
test
that
feature
see
dwarf_get_globals_header
res
_dwarf_make_global_add_to_chain
dbg
global_DLA_code
pubnames_context
die_offset_in_cu
It
is
a
fake
global
so
empty
name
unsigned
char
error
if
res
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
res
pubnames_context
recorded
in
chain
else
The
section
is
empty
Nowhere
to
record
pubnames_context
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
pubnames_context
continue
while
die_offset_in_cu
int
res
unsigned
char
glname
non
zero
die_offset_in_cu
already
read
so
pubnames_like_ptr
points
to
a
string
res
_dwarf_check_string_valid
dbg
section_data_ptr
pubnames_like_ptr
section_end_ptr
DW_DLE_STRING_OFF_END_PUBNAMES_LIKE
error
if
res
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
res
glname
unsigned
char
pubnames_like_ptr
pubnames_like_ptr
pubnames_like_ptr
strlen
char
pubnames_like_ptr
Already
read
offset
and
verified
string
glname
now
points
to
the
string
res
_dwarf_make_global_add_to_chain
dbg
global_DLA_code
pubnames_context
die_offset_in_cu
glname
error
if
res
DW_DLV_OK
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
res
pubnames_context
recorded
in
chain
Ensure
room
for
a
next
entry
to
exist
if
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
pubnames_error_length
dbg
error
pubnames_context
pu_length_size
secname
global
record
offset
dealloc_globals_chain
dbg
head_chain
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
return
DW_DLV_ERROR
Read
die
offset
for
the
next
entry
mres
_dwarf_read_unaligned_ck_wrapper
dbg
pubnames_like_ptr
pubnames_context
pu_length_size
section_end_ptr
error
if
mres
DW_DLV_OK
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
dealloc_globals_chain
dbg
head_chain
return
mres
pubnames_like_ptr
pubnames_context
pu_length_size
FIX_UP_OFFSET_IRIX_BUG
dbg
die_offset_in_cu
offset
of
next
die
in
cu
if
pubnames_like_ptr
section_data_ptr
section_length
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
dealloc_globals_chain
dbg
head_chain
_dwarf_error
dbg
error
length_err_num
return
DW_DLV_ERROR
ASSERT
die_offset_in_cu
if
pubnames_like_ptr
pubnames_ptr_past_end_cu
This
is
some
kind
of
error
This
simply
cannot
happen
The
encoding
is
wrong
or
the
length
in
the
header
for
this
cu
s
contribution
is
wrong
_dwarf_error
dbg
error
length_err_num
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
dealloc_globals_chain
dbg
head_chain
return
DW_DLV_ERROR
If
there
is
some
kind
of
padding
at
the
end
of
the
section
as
emitted
by
some
compilers
skip
over
that
padding
and
simply
ignore
the
bytes
thus
passed
over
With
most
compilers
pubnames_like_ptr
pubnames_ptr_past_end_cu
at
this
point
Dwarf_Unsigned
increment
pubnames_context
pu_length_size
pubnames_context
pu_length
pubnames_context
pu_extension_size
pubnames_section_offset
increment
pubnames_like_ptr
pubnames_ptr_past_end_cu
while
pubnames_like_ptr
section_end_ptr
Points
to
contiguous
block
of
Dwarf_Global
ret_globals
Dwarf_Global
_dwarf_get_alloc
dbg
DW_DLA_LIST
global_count
if
ret_globals
NULL
if
pubnames_context_on_list
dwarf_dealloc
dbg
pubnames_context
context_DLA_code
dealloc_globals_chain
dbg
head_chain
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Store
pointers
to
Dwarf_Global_s
structs
in
contiguous
block
and
deallocate
the
chain
This
ignores
the
various
headers
Dwarf_Chain
curr_chain
curr_chain
head_chain
for
i
i
global_count
i
ret_globals
i
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
prev_chain
ch_item
Not
actually
necessary
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
globals
ret_globals
return_count
Dwarf_Signed
global_count
return
DW_DLV_OK
Given
a
pubnames
entry
or
other
like
section
entry
return
thru
the
ret_name
pointer
a
pointer
to
the
string
which
is
the
entry
name
int
dwarf_globname
Dwarf_Global
glob
char
ret_name
Dwarf_Error
error
if
glob
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_NULL
return
DW_DLV_ERROR
ret_name
char
glob
gl_name
return
DW_DLV_OK
Given
a
pubnames
entry
or
other
like
section
entry
return
thru
the
ret_off
pointer
the
global
offset
of
the
DIE
for
this
entry
The
global
offset
is
the
offset
within
the
debug_info
section
as
a
whole
int
dwarf_global_die_offset
Dwarf_Global
global
Dwarf_Off
ret_off
Dwarf_Error
error
if
global
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_NULL
return
DW_DLV_ERROR
if
global
gl_context
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_CONTEXT_NULL
return
DW_DLV_ERROR
ret_off
global
gl_named_die_offset_within_cu
global
gl_context
pu_offset_of_cu_header
return
DW_DLV_OK
Given
a
pubnames
entry
or
other
like
section
entry
return
thru
the
ret_off
pointer
the
offset
of
the
compilation
unit
header
of
the
compilation
unit
the
global
is
part
of
In
early
versions
of
this
the
value
returned
was
the
offset
of
the
compilation
unit
die
and
other
cu
local
die
offsets
were
faked
so
adding
this
to
such
a
cu
local
offset
got
a
true
section
offset
Now
things
do
as
they
say
adding
cu_header_offset
to
a
cu
local
offset
gets
the
section
offset
int
dwarf_global_cu_offset
Dwarf_Global
global
Dwarf_Off
cu_header_offset
Dwarf_Error
error
Dwarf_Global_Context
con
if
global
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_NULL
return
DW_DLV_ERROR
con
global
gl_context
if
con
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_CONTEXT_NULL
return
DW_DLV_ERROR
In
early
libdwarf
this
incorrectly
returned
the
offset
of
the
CU
DIE
Now
correctly
returns
the
header
offset
cu_header_offset
con
pu_offset_of_cu_header
return
DW_DLV_OK
static
void
build_off_end_msg
Dwarf_Unsigned
offval
Dwarf_Unsigned
withincr
Dwarf_Unsigned
secsize
dwarfstring
m
const
char
msg
past
if
offval
secsize
msg
too
near
dwarfstring_append_printf_u
m
DW_DLE_OFFSET_BAD
The
CU
header
offset
of
u
in
a
pubnames
like
entry
withincr
dwarfstring_append_printf_s
m
would
put
us
s
the
end
of
debug_info
No
room
for
a
DIE
there
Corrupt
Dwarf
char
msg
return
Give
back
the
pubnames
entry
or
any
other
like
section
name
symbol
DIE
offset
and
the
cu
DIE
offset
Various
errors
are
possible
The
string
pointer
returned
thru
ret_name
is
not
dwarf_get_alloc
ed
so
no
dwarf_dealloc
DW_DLA_STRING
should
be
applied
to
it
int
dwarf_global_name_offsets
Dwarf_Global
global
char
ret_name
Dwarf_Off
die_offset
Dwarf_Off
cu_die_offset
Dwarf_Error
error
Dwarf_Global_Context
con
Dwarf_Debug
dbg
Dwarf_Off
cuhdr_off
if
global
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_NULL
return
DW_DLV_ERROR
con
global
gl_context
if
con
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_CONTEXT_NULL
return
DW_DLV_ERROR
cuhdr_off
con
pu_offset_of_cu_header
The
offset
had
better
not
be
too
close
to
the
end
If
it
is
_dwarf_length_of_cu_header
will
step
off
the
end
and
therefore
must
not
be
used
is
a
meaningless
heuristic
but
no
CU
header
is
that
small
so
it
is
safe
An
erroneous
offset
is
due
to
a
bug
in
the
tool
chain
A
bug
like
this
has
been
seen
on
IRIX
with
MIPSpro
and
an
executable
in
size
and
with
million
pubnames
entries
define
MIN_CU_HDR_SIZE
dbg
con
pu_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
Cannot
refer
to
debug_types
if
dbg
de_debug_info
dss_size
cuhdr_off
MIN_CU_HDR_SIZE
dbg
de_debug_info
dss_size
dwarfstring
m
dwarfstring_constructor
build_off_end_msg
cuhdr_off
cuhdr_off
MIN_CU_HDR_SIZE
dbg
de_debug_info
dss_size
_dwarf_error_string
dbg
error
DW_DLE_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
undef
MIN_CU_HDR_SIZE
If
global
gl_named_die_offset_within_cu
is
zero
then
this
is
a
fake
global
for
a
pubnames
CU
with
no
pubnames
The
offset
is
from
the
start
of
the
CU
header
so
no
die
can
have
a
zero
offset
all
valid
offsets
are
positive
numbers
if
die_offset
if
global
gl_named_die_offset_within_cu
die_offset
global
gl_named_die_offset_within_cu
cuhdr_off
else
die_offset
ret_name
char
global
gl_name
if
cu_die_offset
Globals
cannot
refer
to
debug_types
int
cres
Dwarf_Unsigned
headerlen
int
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_OK
return
res
The
offset
had
better
not
be
too
close
to
the
end
If
it
is
_dwarf_length_of_cu_header
will
step
off
the
end
and
therefore
must
not
be
used
is
a
meaningless
heuristic
but
no
CU
header
is
that
small
so
it
is
safe
Globals
cannot
refer
to
debug_types
if
cuhdr_off
dbg
de_debug_info
dss_size
dwarfstring
m
dwarfstring_constructor
build_off_end_msg
cuhdr_off
cuhdr_off
dbg
de_debug_info
dss_size
_dwarf_error_string
dbg
error
DW_DLE_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
cres
_dwarf_length_of_cu_header
dbg
cuhdr_off
true
error
if
cres
DW_DLV_OK
return
cres
cu_die_offset
cuhdr_off
headerlen
return
DW_DLV_OK
New
February
from
better
dwarfdump
printing
of
debug_pubnames
and
pubtypes
For
ao
the
Dwarf_Global
records
in
one
pubnames
CU
group
exactly
the
same
data
will
be
returned
int
dwarf_get_globals_header
Dwarf_Global
global
Dwarf_Off
pub_section_hdr_offset
Dwarf_Unsigned
pub_offset_size
Dwarf_Unsigned
pub_cu_length
Dwarf_Unsigned
version
Dwarf_Off
info_header_offset
Dwarf_Unsigned
info_length
Dwarf_Error
error
Dwarf_Global_Context
con
Dwarf_Debug
dbg
if
global
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_NULL
return
DW_DLV_ERROR
con
global
gl_context
if
con
NULL
_dwarf_error
NULL
error
DW_DLE_GLOBAL_CONTEXT_NULL
return
DW_DLV_ERROR
dbg
con
pu_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
pub_section_hdr_offset
pub_section_hdr_offset
con
pu_pub_offset
if
pub_offset_size
pub_offset_size
con
pu_length_size
if
pub_cu_length
pub_cu_length
con
pu_length
if
version
version
con
pu_version
if
info_header_offset
info_header_offset
con
pu_offset_of_cu_header
if
info_length
info_length
con
pu_info_length
return
DW_DLV_OK
We
have
the
offset
to
a
CU
header
Return
thru
outFileOffset
the
offset
of
the
CU
DIE
New
June
Used
by
SGI
IRIX
debuggers
No
error
used
to
be
possible
As
of
May
an
error
is
possible
if
the
DWARF
is
corrupted
IRIX
debuggers
are
no
longer
built
See
also
dwarf_CU_dieoffset_given_die
This
is
assumed
to
never
apply
to
data
in
debug_types
it
only
refers
to
debug_info
ARGSUSED
The
following
version
new
in
October
does
allow
finding
the
offset
if
one
knows
whether
debug_info
or
debug_types
or
any
debug_info
type
including
the
DWARF5
flavors
It
indirectly
calls
_dwarf_length_of_cu_header
which
knows
all
the
varieties
of
header
int
dwarf_get_cu_die_offset_given_cu_header_offset_b
Dwarf_Debug
dbg
Dwarf_Off
in_cu_header_offset
Dwarf_Bool
is_info
Dwarf_Off
out_cu_die_offset
Dwarf_Error
err
Dwarf_Off
headerlen
int
cres
cres
_dwarf_length_of_cu_header
dbg
in_cu_header_offset
is_info
err
if
cres
DW_DLV_OK
return
cres
out_cu_die_offset
in_cu_header_offset
headerlen
return
DW_DLV_OK
dwarf_CU_dieoffset_given_die
returns
the
global
debug_info
section
offset
of
the
CU
die
that
is
the
CU
containing
the
given
passed
in
die
This
information
makes
it
possible
for
a
consumer
to
find
and
print
context
information
for
any
die
Use
dwarf_offdie_b
passing
in
the
offset
this
returns
to
get
a
die
pointer
to
the
CU
die
int
dwarf_CU_dieoffset_given_die
Dwarf_Die
die
Dwarf_Off
return_offset
Dwarf_Error
error
Dwarf_Off
dieoff
Dwarf_CU_Context
cucontext
CHECK_DIE
die
DW_DLV_ERROR
cucontext
die
di_cu_context
dieoff
cucontext
cc_debug_offset
The
following
call
cannot
fail
so
no
error
check
dwarf_get_cu_die_offset_given_cu_header_offset_b
cucontext
cc_dbg
dieoff
die
di_is_info
return_offset
error
return
DW_DLV_OK
We
do
not
want
to
screw
up
error
in
case
it
has
something
important
So
not
touching
it
now
int
dwarf_return_empty_pubnames
Dwarf_Debug
dbg
int
flag
UNUSEDARG
Dwarf_Error
err
if
dbg
NULL
return
DW_DLV_OK
if
flag
flag
return
DW_DLV_OK
dbg
de_return_empty_pubnames
unsigned
char
flag
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
is
for
accessing
debug_gnu_pubnames
and
debug_gnu_pubtypes
It
has
nothing
to
do
with
gdb_index
include
config
h
include
stdio
h
include
limits
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_gnu_index
h
include
dwarfstring
h
if
static
void
dump_block
const
char
msg
int
bn
int
lno
struct
Dwarf_Gnu_IBlock_s
b
printf
BLOCK
dump
block
d
s
line
d
n
bn
msg
lno
printf
head
lx
n
unsigned
long
b
ib_head
printf
index
lu
n
unsigned
long
b
ib_index
printf
blk
len
offset
lx
n
unsigned
long
b
ib_block_length_offset
printf
block
length
lu
lx
n
unsigned
long
b
ib_block_length
unsigned
long
b
ib_block_length
printf
offset
size
u
n
b
ib_offset_size
printf
extension
size
u
n
b
ib_extension_size
printf
version
u
n
b
ib_version
printf
built
entries?
s
n
b
ib_counted_entries?
yes
no
printf
debug_info
offset
lx
n
unsigned
long
b
ib_offset_in_debug_info
printf
debug_info
size
lu
lx
n
unsigned
long
b
ib_size_in_debug_info
unsigned
long
b
ib_size_in_debug_info
printf
data
offset
lx
n
unsigned
long
b
ib_b_data_offset
printf
entries
offset
lx
n
unsigned
long
b
ib_b_offset
printf
entries
ptr
lx
n
unsigned
long
b
ib_b_data
printf
entries
length
lu
lx
n
unsigned
long
b
ib_b_entrylength
unsigned
long
b
ib_b_entrylength
printf
entry
count
lu
n
unsigned
long
b
ib_entry_count
printf
entries
array
lx
n
unsigned
long
b
ib_entryarray
endif
We
could
use
dwarf_get_real_section_name
to
determine
the
real
name
perhaps
ending
in
dwo
but
for
now
we
just
use
the
standard
name
here
static
void
get_pubxx_fields
Dwarf_Debug
dbg
Dwarf_Bool
for_gnu_pubnames
struct
Dwarf_Section_s
sec_out
const
char
sec_name_out
int
errnum_out
const
char
errstr_out
if
dbg
return
if
for_gnu_pubnames
if
sec_name_out
sec_name_out
debug_gnu_pubnames
if
sec_out
sec_out
de_debug_gnu_pubnames
if
errnum_out
errnum_out
DW_DLE_GNU_PUBNAMES_ERROR
if
errstr_out
errstr_out
DW_DLE_GNU_PUBNAMES_ERROR
else
if
sec_name_out
sec_name_out
debug_gnu_pubtypes
if
sec_out
sec_out
de_debug_gnu_pubtypes
if
errnum_out
errnum_out
DW_DLE_GNU_PUBTYPES_ERROR
if
errstr_out
errstr_out
DW_DLE_GNU_PUBTYPES_ERROR
static
int
load_pub_section
Dwarf_Debug
dbg
Dwarf_Bool
for_gnu_pubnames
Dwarf_Error
error
struct
Dwarf_Section_s
sec
int
res
get_pubxx_fields
dbg
for_gnu_pubnames
res
_dwarf_load_section
dbg
sec
error
return
res
static
int
scan_block_entries
Dwarf_Debug
dbg
Dwarf_Bool
for_gnu_pubnames
Dwarf_Unsigned
count_out
Dwarf_Error
error
struct
Dwarf_Section_s
sec
Dwarf_Small
startptr
Dwarf_Small
curptr
Dwarf_Small
endptr
Dwarf_Unsigned
seclen
Dwarf_Unsigned
count
Dwarf_Unsigned
filesize
Dwarf_Unsigned
blockoffset
int
errnum
const
char
errstr
const
char
secname
get_pubxx_fields
dbg
for_gnu_pubnames
filesize
dbg
de_filesize
startptr
sec
dss_data
curptr
startptr
seclen
sec
dss_size
endptr
startptr
seclen
if
filesize
if
seclen
filesize
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
char
errstr
dwarfstring_append_printf_u
section
length
u
is
larger
than
the
file
size
in
seclen
dwarfstring_append
char
secname
_dwarf_error_string
dbg
error
errnum
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
for
Dwarf_Unsigned
length
unsigned
int
offsetsize
unsigned
int
extensize
if
curptr
endptr
count_out
count
return
DW_DLV_OK
Not
sure
how
the
coders
think
about
the
initial
value
But
the
last
bytes
are
zero
ignore
those
Unclear
is
not
allowed
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
curptr
offsetsize
extensize
error
seclen
endptr
count
curptr
length
offsetsize
extensize
curptr
blockoffset
length
blockoffset
NOTREACHED
count_out
count
return
DW_DLV_OK
static
int
count_entries_in_block
struct
Dwarf_Gnu_IBlock_s
gib
struct
DGI_Entry_s
entries
Dwarf_Error
error
Dwarf_Small
curptr
gib
ib_b_data
Dwarf_Small
endptr
curptr
gib
ib_b_entrylength
Dwarf_Unsigned
entrycount
Dwarf_Half
offsetsize
gib
ib_offset_size
struct
DGI_Entry_s
curentry
Dwarf_Debug
dbg
Dwarf_Gnu_Index_Head
head
Dwarf_Bool
for_pubnames
char
strptr
head
gib
ib_head
for_pubnames
head
gi_is_pubnames
dbg
head
gi_dbg
for
curptr
endptr
entrycount
Dwarf_Unsigned
infooffset
Dwarf_Unsigned
offset
char
flagbyte
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
curptr
offsetsize
error
endptr
infooffset
offset
curptr
offsetsize
if
entries
curentry
entries
entrycount
curentry
ge_debug_info_offset
infooffset
Ensure
flag
and
start
of
string
possible
if
curptr
endptr
int
errnum
const
char
secname
const
char
errstr
dwarfstring
m
get_pubxx_fields
dbg
for_pubnames
dwarfstring_constructor
dwarfstring_append_printf_s
s
Past
end
of
current
block
reading
strings
char
errstr
dwarfstring_append_printf_s
in
s
char
secname
_dwarf_error_string
dbg
error
errnum
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
flagbyte
curptr
curptr
strptr
char
curptr
if
curentry
curentry
ge_flag_byte
flagbyte
curentry
ge_string
char
strptr
for
curptr
curptr
offset
if
curptr
endptr
int
errnum
const
char
secname
const
char
errstr
dwarfstring
m
get_pubxx_fields
dbg
for_pubnames
dwarfstring_constructor
dwarfstring_append_printf_s
s
Past
end
of
current
block
reading
strings
char
errstr
dwarfstring_append_printf_s
in
section
s
char
secname
_dwarf_error_string
dbg
error
errnum
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
string
terminating
null
byte
curptr
if
entries
gib
ib_entry_count
entrycount
else
if
gib
ib_entry_count
entrycount
int
err
const
char
errstr
const
char
secname
char
buf
dwarfstring
m
buf
get_pubxx_fields
dbg
for_pubnames
dwarfstring_constructor_static
buf
sizeof
buf
dwarfstring_append
char
errstr
dwarfstring_append_printf_s
mismatch
counts
creating
s
block_entries
char
secname
dwarfstring_append_printf_u
Origcount
u
gib
ib_entry_count
dwarfstring_append_printf_u
new
count
u
entrycount
_dwarf_error_string
dbg
error
err
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
fill_in_blocks
Dwarf_Gnu_Index_Head
head
Dwarf_Error
error
Dwarf_Unsigned
i
Dwarf_Unsigned
dataoffset
if
Dwarf_Unsigned
blockindex
Dwarf_Unsigned
blockoffset
Dwarf_Unsigned
listoffset
endif
Dwarf_Small
endptr
Dwarf_Small
curptr
Dwarf_Small
baseptr
Dwarf_Bool
is_for_pubnames
head
gi_is_pubnames
Dwarf_Debug
dbg
head
gi_dbg
Dwarf_Unsigned
seclen
head
gi_section_length
baseptr
head
gi_section_data
endptr
baseptr
head
gi_section_length
for
i
head
gi_blockcount
i
Dwarf_Unsigned
length
unsigned
int
offsetsize
unsigned
int
extensize
Dwarf_Half
version
Dwarf_Unsigned
offset_into_debug_info
Dwarf_Unsigned
length_of_CU_in_debug_info
struct
Dwarf_Gnu_IBlock_s
gib
int
res
gib
head
gi_blockarray
i
gib
is
a
blank
slate
ready
to
be
filled
curptr
baseptr
dataoffset
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
curptr
offsetsize
extensize
error
seclen
endptr
if
length
Must
be
end
of
the
section
if
curptr
endptr
const
char
errstr
int
errnum
const
char
secname
dwarfstring
m
Something
is
very
wrong
get_pubxx_fields
dbg
is_for_pubnames
dwarfstring_constructor
dwarfstring_append
char
errstr
dwarfstring_append_printf_s
encountered
zero
area
length
before
end
of
s
char
secname
_dwarf_error_string
dbg
error
errnum
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
gib
ib_index
i
gib
ib_head
head
gib
ib_offset_size
offsetsize
gib
ib_block_length
length
gib
ib_block_length_offset
dataoffset
dataoffset
offsetsize
extensize
gib
ib_b_data_offset
dataoffset
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
curptr
DWARF_HALF_SIZE
error
endptr
curptr
DWARF_HALF_SIZE
dataoffset
DWARF_HALF_SIZE
gib
ib_version
version
READ_UNALIGNED_CK
dbg
offset_into_debug_info
Dwarf_Unsigned
curptr
offsetsize
error
endptr
curptr
offsetsize
dataoffset
offsetsize
gib
ib_offset_in_debug_info
offset_into_debug_info
READ_UNALIGNED_CK
dbg
length_of_CU_in_debug_info
Dwarf_Unsigned
curptr
offsetsize
error
endptr
gib
ib_size_in_debug_info
length_of_CU_in_debug_info
dataoffset
offsetsize
curptr
offsetsize
gib
ib_b_data
curptr
gib
ib_b_offset
dataoffset
gib
ib_b_entrylength
length
offsetsize
Followed
by
bytes
of
zeroes
gib
ib_b_entrylength
Set
for
next
block
add
in4
for
ending
zeros
dataoffset
gib
ib_block_length_offset
length
res
count_entries_in_block
gib
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
static
int
fill_in_entries
Dwarf_Gnu_Index_Head
head
struct
Dwarf_Gnu_IBlock_s
gib
Dwarf_Error
error
Dwarf_Unsigned
count
gib
ib_entry_count
struct
DGI_Entry_s
entryarray
Dwarf_Bool
for_gnu_pubnames
head
gi_is_pubnames
char
buf
int
res
Dwarf_Debug
dbg
dbg
head
gi_dbg
buf
entryarray
struct
DGI_Entry_s
calloc
count
sizeof
struct
DGI_Entry_s
if
entryarray
int
err
const
char
errstr
const
char
secname
dwarfstring
m
get_pubxx_fields
dbg
for_gnu_pubnames
dwarfstring_constructor_static
buf
sizeof
buf
dwarfstring_append
char
errstr
dwarfstring_append_printf_s
Unable
to
allocate
block_entries
Out
of
memory
creating
s
record
char
secname
_dwarf_error_string
dbg
error
err
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
res
count_entries_in_block
gib
entryarray
error
if
res
DW_DLV_OK
free
entryarray
return
res
gib
ib_entryarray
entryarray
entryarray
return
DW_DLV_OK
int
dwarf_get_gnu_index_head
Dwarf_Debug
dbg
The
following
arg
false
to
select
gnu_pubtypes
Dwarf_Bool
for_gnu_pubnames
Dwarf_Gnu_Index_Head
index_head_out
Dwarf_Unsigned
index_block_count_out
Dwarf_Error
error
Dwarf_Unsigned
count
Dwarf_Gnu_Index_Head
head
struct
Dwarf_Gnu_IBlock_s
iblock_array
char
buf
int
res
if
dbg
_dwarf_error_string
dbg
error
DW_DLE_DBG_NULL
DW_DLE_DBG_NULL
in
dwarf_get_gnu_index_head
return
DW_DLV_ERROR
res
load_pub_section
dbg
for_gnu_pubnames
error
if
res
DW_DLV_OK
return
res
We
want
this
loaded
for
error
checking
by
callers
in
case
they
had
no
reason
to
load
already
res
_dwarf_load_debug_info
dbg
error
if
res
DW_DLV_ERROR
return
res
if
count
zero
returns
DW_DLV_NO_ENTRY
res
scan_block_entries
dbg
for_gnu_pubnames
error
if
res
DW_DLV_OK
return
res
head
Dwarf_Gnu_Index_Head
_dwarf_get_alloc
dbg
DW_DLA_GNU_INDEX_HEAD
if
head
dwarfstring
m
int
err
const
char
errstr
const
char
secname
get_pubxx_fields
dbg
for_gnu_pubnames
dwarfstring_constructor_static
buf
sizeof
buf
dwarfstring_append
char
errstr
dwarfstring_append_printf_s
Unable
to
allocate
a
header
record
Out
of
memory
creating
s
record
char
secname
_dwarf_error_string
dbg
error
err
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
head
gi_dbg
dbg
head
gi_section_data
for_gnu_pubnames?
dbg
de_debug_gnu_pubnames
dss_data
dbg
de_debug_gnu_pubtypes
dss_data
head
gi_section_length
for_gnu_pubnames?
dbg
de_debug_gnu_pubnames
dss_size
dbg
de_debug_gnu_pubtypes
dss_size
head
gi_is_pubnames
for_gnu_pubnames
iblock_array
calloc
count
sizeof
struct
Dwarf_Gnu_IBlock_s
if
iblock_array
dwarfstring
m
int
err
const
char
errstr
get_pubxx_fields
dbg
for_gnu_pubnames
dwarfstring_constructor_static
buf
sizeof
buf
dwarfstring_append
char
errstr
dwarfstring_append_printf_u
Unable
to
allocate
u
block
records
Out
of
memory
count
_dwarf_error_string
dbg
error
err
dwarfstring_string
dwarfstring_destructor
dwarf_gnu_index_dealloc
head
return
DW_DLV_ERROR
head
gi_blockarray
iblock_array
head
gi_blockcount
count
res
fill_in_blocks
head
error
if
res
DW_DLV_OK
return
res
index_head_out
head
index_block_count_out
count
return
DW_DLV_OK
Frees
all
resources
used
for
the
indexes
void
_dwarf_free_gnu_index_head_content
Dwarf_Gnu_Index_Head
head
if
head
return
if
head
gi_blockarray
Dwarf_Unsigned
i
struct
Dwarf_Gnu_IBlock_s
block
head
gi_blockarray
for
i
head
gi_blockcount
i
block
if
block
ib_entryarray
free
block
ib_entryarray
block
ib_entryarray
block
ib_entry_count
free
head
gi_blockarray
head
gi_blockarray
head
gi_blockcount
void
dwarf_gnu_index_dealloc
Dwarf_Gnu_Index_Head
head
Dwarf_Debug
dbg
if
head
return
dbg
head
gi_dbg
if
dbg
return
_dwarf_free_gnu_index_head_content
head
dwarf_dealloc
dbg
head
DW_DLA_GNU_INDEX_HEAD
void
_dwarf_gnu_index_head_destructor
void
incoming
Dwarf_Gnu_Index_Head
head
head
Dwarf_Gnu_Index_Head
incoming
if
head
return
_dwarf_free_gnu_index_head_content
head
return
int
dwarf_get_gnu_index_block
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
number
Dwarf_Unsigned
block_length
Dwarf_Half
version
Dwarf_Unsigned
offset_into_debug_info
Dwarf_Unsigned
size_of_debug_info_area
Dwarf_Unsigned
count_of_entries
Dwarf_Error
error
struct
Dwarf_Gnu_IBlock_s
gib
if
head
_dwarf_error_string
error
DW_DLE_DBG_NULL
DW_DLE_DBG_NULL
in
dwarf_get_gnu_index_block
return
DW_DLV_ERROR
if
number
head
gi_blockcount
return
DW_DLV_NO_ENTRY
gib
head
gi_blockarray
number
if
block_length
block_length
gib
ib_block_length
if
version
version
gib
ib_version
if
offset_into_debug_info
offset_into_debug_info
gib
ib_offset_in_debug_info
if
size_of_debug_info_area
size_of_debug_info_area
gib
ib_size_in_debug_info
if
count_of_entries
count_of_entries
gib
ib_entry_count
return
DW_DLV_OK
int
dwarf_get_gnu_index_block_entry
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
blocknumber
Dwarf_Unsigned
entrynumber
Dwarf_Unsigned
offset_in_debug_info
const
char
name_string
unsigned
char
flagbyte
unsigned
char
staticorglobal
unsigned
char
typeofentry
Dwarf_Error
error
struct
Dwarf_Gnu_IBlock_s
gib
struct
DGI_Entry_s
be
if
head
_dwarf_error_string
error
DW_DLE_DBG_NULL
DW_DLE_DBG_NULL
in
dwarf_get_gnu_index_block_entry
if
blocknumber
head
gi_blockcount
return
DW_DLV_NO_ENTRY
gib
head
gi_blockarray
blocknumber
if
gib
ib_counted_entries
int
res
gib
ib_counted_entries
TRUE
res
fill_in_entries
head
gib
error
if
res
DW_DLV_OK
return
res
if
entrynumber
gib
ib_entry_count
return
DW_DLV_NO_ENTRY
be
gib
ib_entryarray
entrynumber
if
offset_in_debug_info
offset_in_debug_info
be
ge_debug_info_offset
if
name_string
name_string
be
ge_string
if
flagbyte
flagbyte
be
ge_flag_byte
if
staticorglobal
if
be
ge_flag_byte
value
of
course
staticorglobal
DW_GNUIVIS_global
else
staticorglobal
DW_GNUIVIS_static
if
typeofentry
DW_GNUIKIND_
unsigned
v
be
ge_flag_byte
v
v
typeofentry
v
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_tsearch
h
define
HASHSEARCH
It
has
not
escaped
our
attention
that
the
section
group
tsearch
hash
table
could
be
replaced
by
a
simple
array
with
space
for
each
possible
section
number
each
element
being
the
group
number
This
would
be
much
simpler
than
what
follows
here
Each
section
number
can
appear
in
at
most
one
record
in
the
hash
because
each
section
belongs
in
only
one
group
Each
group
number
appears
as
often
as
appropriate
struct
Dwarf_Group_Map_Entry_s
unsigned
gm_key
section
number
unsigned
gm_group_number
What
group
number
is
The
name
is
from
static
storage
or
from
elf
so
there
is
nothing
to
free
on
record
delete
const
char
gm_section_name
static
void
grp_make_entry
unsigned
section
unsigned
group
const
char
name
struct
Dwarf_Group_Map_Entry_s
e
e
calloc
sizeof
struct
Dwarf_Group_Map_Entry_s
if
e
e
gm_key
section
e
gm_group_number
group
e
gm_section_name
name
return
e
static
DW_TSHASHTYPE
grp_data_hashfunc
const
void
keyp
const
struct
Dwarf_Group_Map_Entry_s
enp
keyp
DW_TSHASHTYPE
hashv
hashv
enp
gm_key
return
hashv
static
int
grp_compare_function
const
void
l
const
void
r
const
struct
Dwarf_Group_Map_Entry_s
lp
l
const
struct
Dwarf_Group_Map_Entry_s
rp
r
if
lp
gm_key
rp
gm_key
return
if
lp
gm_key
rp
gm_key
return
match
return
int
_dwarf_insert_in_group_map
Dwarf_Debug
dbg
unsigned
groupnum
unsigned
section_index
const
char
name
Dwarf_Error
error
struct
Dwarf_Group_Data_s
grp
de_groupnumbers
void
entry2
struct
Dwarf_Group_Map_Entry_s
entry3
if
grp
gd_map
Number
of
sections
is
a
kind
of
decent
guess
as
to
how
much
space
would
be
useful
dwarf_initialize_search_hash
gd_map
grp_data_hashfunc
grp
gd_number_of_sections
if
grp
gd_map
It
s
really
an
error
I
suppose
return
DW_DLV_NO_ENTRY
entry3
grp_make_entry
section_index
groupnum
name
if
entry3
_dwarf_error
dbg
error
DW_DLE_GROUP_MAP_ALLOC
return
DW_DLV_ERROR
entry2
dwarf_tsearch
entry3
gd_map
grp_compare_function
if
entry2
free
entry3
_dwarf_error
dbg
error
DW_DLE_GROUP_MAP_ALLOC
return
DW_DLV_ERROR
else
struct
Dwarf_Group_Map_Entry_s
re
re
struct
Dwarf_Group_Map_Entry_s
entry2
if
re
entry3
free
entry3
_dwarf_error
dbg
error
DW_DLE_GROUP_MAP_DUPLICATE
return
DW_DLV_ERROR
else
grp
gd_map_entry_count
OK
Added
Fall
thru
return
DW_DLV_OK
int
_dwarf_section_get_target_group_from_map
Dwarf_Debug
dbg
unsigned
obj_section_index
unsigned
groupnumber_out
UNUSEDARG
Dwarf_Error
error
struct
Dwarf_Group_Map_Entry_s
entry
struct
Dwarf_Group_Map_Entry_s
entry2
struct
Dwarf_Group_Data_s
grp
de_groupnumbers
if
grp
gd_map
return
DW_DLV_NO_ENTRY
entry
gm_key
obj_section_index
entry
gm_group_number
FAKE
entry
gm_section_name
FAKE
entry2
dwarf_tfind
gd_map
grp_compare_function
if
entry2
struct
Dwarf_Group_Map_Entry_s
e2
struct
Dwarf_Group_Map_Entry_s
entry2
groupnumber_out
e2
gm_group_number
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
New
May
So
users
can
find
out
what
groups
dwo
or
COMDAT
are
in
the
object
and
how
much
to
allocate
so
one
can
get
the
group
section
map
data
int
dwarf_sec_group_sizes
Dwarf_Debug
dbg
Dwarf_Unsigned
section_count_out
Dwarf_Unsigned
group_count_out
Dwarf_Unsigned
selected_group_out
Dwarf_Unsigned
map_entry_count_out
UNUSEDARG
Dwarf_Error
error
struct
Dwarf_Group_Data_s
grp
de_groupnumbers
section_count_out
grp
gd_number_of_sections
group_count_out
grp
gd_number_of_groups
selected_group_out
dbg
de_groupnumber
map_entry_count_out
grp
gd_map_entry_count
return
DW_DLV_OK
static
Dwarf_Unsigned
map_reccount
static
struct
temp_map_struc_s
Dwarf_Unsigned
section
Dwarf_Unsigned
group
const
char
name
temp_map_data
static
void
grp_walk_map
const
void
nodep
const
DW_VISIT
which
UNUSEDARG
const
int
depth
struct
Dwarf_Group_Map_Entry_s
re
re
struct
Dwarf_Group_Map_Entry_s
nodep
if
which
dwarf_postorder
which
dwarf_endorder
return
temp_map_data
map_reccount
group
re
gm_group_number
temp_map_data
map_reccount
section
re
gm_key
temp_map_data
map_reccount
name
re
gm_section_name
map_reccount
Looks
better
sorted
by
group
then
sec
num
static
int
map_sort_compar
const
void
l
const
void
r
struct
temp_map_struc_s
lv
struct
temp_map_struc_s
l
struct
temp_map_struc_s
rv
struct
temp_map_struc_s
r
if
lv
group
rv
group
return
if
lv
group
rv
group
return
if
lv
section
rv
section
return
if
lv
section
rv
section
return
Should
never
get
here
return
New
May
Reveals
the
map
between
group
numbers
and
section
numbers
Caller
must
allocate
the
arrays
with
space
for
map_entry_count
values
and
this
function
fills
in
the
array
entries
Output
ordered
by
group
number
and
section
number
int
dwarf_sec_group_map
Dwarf_Debug
dbg
Dwarf_Unsigned
map_entry_count
Dwarf_Unsigned
group_numbers_array
Dwarf_Unsigned
sec_numbers_array
const
char
sec_names_array
Dwarf_Error
error
Dwarf_Unsigned
i
struct
Dwarf_Group_Data_s
grp
if
temp_map_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
map_reccount
grp
de_groupnumbers
if
map_entry_count
grp
gd_map_entry_count
_dwarf_error
dbg
error
DW_DLE_GROUP_COUNT_ERROR
return
DW_DLV_ERROR
temp_map_data
calloc
map_entry_count
sizeof
struct
temp_map_struc_s
if
temp_map_data
_dwarf_error
dbg
error
DW_DLE_GROUP_MAP_ALLOC
return
DW_DLV_ERROR
dwarf_twalk
grp
gd_map
grp_walk_map
if
map_reccount
grp
gd_map_entry_count
Impossible
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
qsort
temp_map_data
map_reccount
sizeof
struct
temp_map_struc_s
map_sort_compar
for
i
i
map_reccount
i
sec_numbers_array
i
temp_map_data
i
section
group_numbers_array
i
temp_map_data
i
group
sec_names_array
i
temp_map_data
i
name
free
temp_map_data
map_reccount
temp_map_data
return
DW_DLV_OK
static
const
char
dwo_secnames
debug_info
dwo
debug_types
dwo
debug_abbrev
dwo
debug_line
dwo
debug_loc
dwo
debug_str
dwo
debug_loclists
dwo
debug_rnglists
dwo
debug_str_offsets
dwo
debug_macro
dwo
debug_cu_index
debug_tu_index
Assumption
dwo
sections
are
never
in
a
COMDAT
group
groupnumber
and
by
definition
here
are
never
group
Assumption
the
map
of
COMDAT
groups
not
necessarily
all
sections
but
at
least
all
COMDAT
is
complete
int
_dwarf_dwo_groupnumber_given_name
const
char
name
unsigned
grpnum_out
const
char
s
for
s
dwo_secnames
s
s
if
strcmp
name
s
grpnum_out
DW_GROUPNUMBER_DWO
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
unsigned
target_group
static
int
found_name_in_group
const
char
lookfor_name
static
void
grp_walk_for_name
const
void
nodep
const
DW_VISIT
which
UNUSEDARG
const
int
depth
struct
Dwarf_Group_Map_Entry_s
re
re
struct
Dwarf_Group_Map_Entry_s
nodep
if
which
dwarf_postorder
which
dwarf_endorder
return
if
re
gm_group_number
target_group
if
strcmp
lookfor_name
re
gm_section_name
found_name_in_group
TRUE
returns
TRUE
or
FALSE
int
_dwarf_section_in_group_by_name
Dwarf_Debug
dbg
const
char
scn_name
unsigned
groupnum
struct
Dwarf_Group_Data_s
grp
grp
de_groupnumbers
found_name_in_group
FALSE
target_group
groupnum
lookfor_name
scn_name
dwarf_twalk
grp
gd_map
grp_walk_for_name
return
found_name_in_group
static
void
_dwarf_grp_destroy_free_node
void
nodep
struct
Dwarf_Group_Map_Entry_s
enp
nodep
free
enp
return
void
_dwarf_destroy_group_map
Dwarf_Debug
dbg
dwarf_tdestroy
dbg
de_groupnumbers
gd_map
_dwarf_grp_destroy_free_node
dbg
de_groupnumbers
gd_map
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
implements
_dwarf_insert_harmless_error
and
related
helper
functions
for
recording
compiler
errors
that
need
not
make
the
input
unusable
Applications
can
use
dwarf_get_harmless_error_list
to
find
and
possibly
print
a
warning
about
such
errors
The
initial
error
reported
here
is
DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE
which
was
a
bug
in
a
specific
compiler
It
is
a
fixed
length
circular
list
to
constrain
the
space
used
for
errors
The
assumption
is
that
these
errors
are
exceedingly
rare
and
indicate
a
broken
compiler
the
one
that
produced
the
object
getting
the
error
s
dh_maxcount
is
recorded
internally
as
greater
than
requested
Hiding
the
fact
we
always
leave
one
slot
unused
at
least
So
a
user
request
for
N
slots
really
gives
the
user
N
usable
slots
include
config
h
include
dwarf_incl
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
dwarf_frame
h
include
dwarf_harmless
h
The
pointers
returned
here
through
errmsg_ptrs_array
become
invalidated
by
any
call
to
libdwarf
Any
call
int
dwarf_get_harmless_error_list
Dwarf_Debug
dbg
unsigned
count
const
char
errmsg_ptrs_array
unsigned
errs_count
struct
Dwarf_Harmless_s
dhp
de_harmless_errors
if
dhp
dh_errors
dhp
dh_errs_count
return
DW_DLV_NO_ENTRY
if
dhp
dh_errs_count
return
DW_DLV_NO_ENTRY
if
errs_count
errs_count
dhp
dh_errs_count
if
count
NULL
terminate
the
array
of
pointers
count
errmsg_ptrs_array
count
if
dhp
dh_next_to_use
dhp
dh_first
unsigned
i
unsigned
cur
dhp
dh_first
for
i
cur
dhp
dh_next_to_use
i
if
i
count
All
output
spaces
are
used
break
errmsg_ptrs_array
i
dhp
dh_errors
cur
cur
cur
dhp
dh_maxcount
errmsg_ptrs_array
i
dhp
dh_next_to_use
dhp
dh_first
dhp
dh_errs_count
return
DW_DLV_OK
strncpy
does
not
null
terminate
this
does
it
static
void
safe_strncpy
char
targ
char
src
unsigned
spaceavail
unsigned
goodcount
spaceavail
if
spaceavail
return
impossible
strncpy
targ
src
goodcount
targ
goodcount
Insertion
made
public
is
only
for
testing
the
harmless
error
code
it
is
not
necessarily
useful
for
libdwarf
client
code
aside
from
code
testing
libdwarf
void
dwarf_insert_harmless_error
Dwarf_Debug
dbg
char
newerror
struct
Dwarf_Harmless_s
dhp
de_harmless_errors
unsigned
next
unsigned
cur
dhp
dh_next_to_use
char
msgspace
if
dhp
dh_errors
dhp
dh_errs_count
return
msgspace
dhp
dh_errors
cur
safe_strncpy
msgspace
newerror
DW_HARMLESS_ERROR_MSG_STRING_SIZE
next
cur
dhp
dh_maxcount
dhp
dh_errs_count
dhp
dh_next_to_use
next
if
dhp
dh_next_to_use
dhp
dh_first
Array
is
full
set
full
invariant
dhp
dh_first
dhp
dh_first
dhp
dh_maxcount
The
size
of
the
circular
list
of
strings
may
be
set
and
reset
as
desired
Returns
the
previous
size
of
the
list
If
the
list
is
shortened
excess
error
entries
are
simply
dropped
If
the
reallocation
fails
the
list
size
is
left
unchanged
Do
not
make
this
a
long
list
Remember
the
maxcount
we
record
is
the
user
count
so
we
adjust
it
so
it
looks
like
the
user
count
unsigned
dwarf_set_harmless_error_list_size
Dwarf_Debug
dbg
unsigned
maxcount
struct
Dwarf_Harmless_s
dhp
de_harmless_errors
unsigned
prevcount
dhp
dh_maxcount
if
maxcount
maxcount
if
maxcount
dhp
dh_maxcount
Assign
transfers
ownership
of
the
malloc
areas
to
oldarray
struct
Dwarf_Harmless_s
oldarray
dhp
Do
not
double
increment
the
max
the
init
func
increments
it
too
dwarf_harmless_init
dhp
maxcount
if
oldarray
dh_next_to_use
oldarray
dh_first
unsigned
i
for
i
oldarray
dh_first
i
oldarray
dh_next_to_use
i
i
oldarray
dh_maxcount
dwarf_insert_harmless_error
dbg
oldarray
dh_errors
i
if
oldarray
dh_errs_count
dhp
dh_errs_count
dhp
dh_errs_count
oldarray
dh_errs_count
dwarf_harmless_cleanout
return
prevcount
Only
callable
from
within
libdwarf
as
a
practical
matter
void
dwarf_harmless_init
struct
Dwarf_Harmless_s
dhp
unsigned
size
unsigned
i
memset
dhp
sizeof
dhp
dhp
dh_maxcount
size
dhp
dh_errors
char
malloc
sizeof
char
dhp
dh_maxcount
if
dhp
dh_errors
dhp
dh_maxcount
return
for
i
i
dhp
dh_maxcount
i
char
newstr
char
malloc
DW_HARMLESS_ERROR_MSG_STRING_SIZE
dhp
dh_errors
i
newstr
if
newstr
dhp
dh_maxcount
Let
it
leak
the
leak
is
a
constrained
amount
dhp
dh_errors
return
We
make
the
string
content
well
defined
by
an
initial
NUL
byte
but
this
is
not
really
necessary
newstr
void
dwarf_harmless_cleanout
struct
Dwarf_Harmless_s
dhp
unsigned
i
if
dhp
dh_errors
return
for
i
i
dhp
dh_maxcount
i
free
dhp
dh_errors
i
dhp
dh_errors
i
free
dhp
dh_errors
dhp
dh_errors
dhp
dh_maxcount
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
Arxan
Technologies
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
endif
HAVE_SYS_STAT_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
memcpy_swap
h
include
dwarf_harmless
h
include
dwarfstring
h
ifdef
HAVE_ZLIB_H
include
zlib
h
endif
ifndef
ELFCOMPRESS_ZLIB
define
ELFCOMPRESS_ZLIB
endif
If
your
mingw
elf
h
is
missing
SHT_RELA
and
you
do
not
need
SHT_RELA
support
this
define
should
work
for
you
It
is
the
elf
value
hopefully
it
will
not
cause
trouble
If
does
not
work
try
or
something
else
and
let
us
know
what
works
ifndef
SHT_RELA
define
SHT_RELA
endif
ifndef
SHT_REL
define
SHT_REL
endif
For
COMDAT
GROUPS
Guarantees
we
can
compile
We
hope
ifndef
SHT_GROUP
define
SHT_GROUP
endif
ifndef
SHF_COMPRESSED
This
from
ubuntu
xenial
Is
in
top
of
trunk
binutils
as
of
February
Elf
Section
Flag
define
SHF_COMPRESSED
endif
Global
definition
of
the
function
pointer
type
typedef
in
dwarf_opaque
h
_dwarf_get_elf_flags_func_ptr_type
_dwarf_get_elf_flags_func_ptr
This
static
is
copied
to
the
dbg
on
dbg
init
so
that
the
static
need
not
be
referenced
at
run
time
preserving
better
locality
of
reference
Value
is
means
do
the
string
check
Value
non
zero
means
do
not
do
the
check
static
Dwarf_Small
_dwarf_assume_string_in_bounds
static
Dwarf_Small
_dwarf_apply_relocs
Call
this
after
calling
dwarf_init
but
before
doing
anything
else
It
applies
to
all
objects
not
just
the
current
object
int
dwarf_set_reloc_application
int
apply
int
oldval
_dwarf_apply_relocs
_dwarf_apply_relocs
apply
return
oldval
int
dwarf_set_stringcheck
int
newval
int
oldval
_dwarf_assume_string_in_bounds
_dwarf_assume_string_in_bounds
newval
return
oldval
static
int
startswith
const
char
input
char
ckfor
size_t
cklen
strlen
ckfor
if
strncmp
input
ckfor
cklen
return
TRUE
return
FALSE
if
static
int
endswith
const
char
input
char
ckfor
size_t
inlen
strlen
input
size_t
endlen
strlen
ckfor
const
char
endck
if
endlen
inlen
return
FALSE
endck
input
inlen
endlen
if
strcmp
endck
ckfor
return
TRUE
return
FALSE
endif
Unifies
the
basic
duplicate
empty
testing
and
section
data
setting
to
one
place
static
int
get_basic_section_data
Dwarf_Debug
dbg
struct
Dwarf_Section_s
secdata
struct
Dwarf_Obj_Access_Section_s
doas
Dwarf_Half
section_index
unsigned
group_number
Dwarf_Error
error
int
duperr
int
emptyerr
There
is
an
elf
convention
that
section
index
is
reserved
and
that
section
is
always
empty
Non
elf
object
formats
must
honor
that
by
ensuring
that
when
they
assign
numbers
to
sections
or
section
like
things
they
never
assign
a
real
section
section
number
to
dss_index
if
secdata
dss_index
DWARF_DBG_ERROR
dbg
duperr
DW_DLV_ERROR
if
doas
size
As
of
it
seems
impossible
to
detect
via
dwarfdump
whether
emptyerr
has
any
practical
effect
whether
TRUE
or
FALSE
if
emptyerr
Allow
empty
section
return
DW_DLV_OK
Know
no
reason
to
allow
section
DWARF_DBG_ERROR
dbg
emptyerr
DW_DLV_ERROR
secdata
dss_index
section_index
secdata
dss_size
doas
size
secdata
dss_group_number
group_number
secdata
dss_addr
doas
addr
secdata
dss_link
doas
link
secdata
dss_entrysize
doas
entrysize
if
_dwarf_get_elf_flags_func_ptr
We
do
this
so
we
do
not
need
to
update
the
public
struct
Dwarf_Obj_Access_Section_s
and
thereby
cause
binary
and
source
incompatibility
Dwarf_Unsigned
flags
Dwarf_Unsigned
addralign
int
res
int
interr
struct
Dwarf_Obj_Access_Interface_s
o
o
dbg
de_obj_file
res
_dwarf_get_elf_flags_func_ptr
o
object
section_index
if
res
DW_DLV_ERROR
Should
never
get
here
DWARF_DBG_ERROR
dbg
interr
DW_DLV_ERROR
if
res
DW_DLV_NO_ENTRY
return
res
secdata
dss_flags
flags
secdata
dss_addralign
addralign
if
flags
SHF_COMPRESSED
secdata
dss_shf_compressed
TRUE
We
are
not
looking
at
section
bytes
so
we
do
not
know
if
the
first
bytes
are
ZLIB
return
DW_DLV_OK
static
void
add_relx_data_to_secdata
struct
Dwarf_Section_s
secdata
struct
Dwarf_Obj_Access_Section_s
doas
Dwarf_Half
section_index
int
is_rela
secdata
dss_reloc_index
section_index
secdata
dss_reloc_size
doas
size
secdata
dss_reloc_entrysize
doas
entrysize
secdata
dss_reloc_addr
doas
addr
secdata
dss_reloc_symtab
doas
link
secdata
dss_reloc_link
doas
link
secdata
dss_is_rela
is_rela
Used
to
add
the
specific
information
for
a
debug
related
section
Called
on
each
section
of
interest
by
section
name
DWARF_MAX_DEBUG_SECTIONS
must
be
large
enough
to
allow
that
all
sections
of
interest
fit
in
the
table
returns
DW_DLV_ERROR
or
DW_DLV_OK
static
int
add_debug_section_info
Dwarf_Debug
dbg
Name
as
seen
in
object
file
const
char
name
const
char
standard_section_name
unsigned
obj_sec_num
struct
Dwarf_Section_s
secdata
unsigned
groupnum
The
have_dwarf
flag
is
a
somewhat
imprecise
way
to
determine
if
there
is
at
least
one
meaningful
DWARF
information
section
present
in
the
object
file
If
not
set
on
some
section
we
claim
later
that
there
is
no
DWARF
info
present
see
foundDwarf
in
this
file
int
duperr
int
emptyerr
int
have_dwarf
int
havezdebug
int
err
unsigned
total_entries
dbg
de_debug_sections_total_entries
if
secdata
dss_is_in_use
err
duperr
return
DW_DLV_ERROR
if
total_entries
DWARF_MAX_DEBUG_SECTIONS
struct
Dwarf_dbg_sect_s
debug_section
de_debug_sections
total_entries
secdata
dss_is_in_use
TRUE
debug_section
ds_name
name
debug_section
ds_number
obj_sec_num
debug_section
ds_secdata
secdata
debug_section
ds_groupnumber
groupnum
secdata
dss_name
name
Actual
name
from
object
file
secdata
dss_standard_name
standard_section_name
secdata
dss_number
obj_sec_num
secdata
dss_zdebug_requires_decompress
havezdebug
We
don
t
yet
know
about
SHF_COMPRESSED
debug_section
ds_duperr
duperr
debug_section
ds_emptyerr
emptyerr
debug_section
ds_have_dwarf
have_dwarf
debug_section
ds_have_zdebug
havezdebug
dbg
de_debug_sections_total_entries
return
DW_DLV_OK
This
represents
a
bug
in
libdwarf
Mis
setup
DWARF_MAX_DEBUG_SECTIONS
Or
possibly
a
use
of
section
groups
that
is
not
supported
err
DW_DLE_TOO_MANY_DEBUG
return
DW_DLV_ERROR
if
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
dump_bytes
s
msg
for
cur
end
cur
printf
cur
printf
n
static
int
all_sig8_bits_zero
Dwarf_Sig8
val
unsigned
u
for
u
sizeof
val
u
if
val
signature
u
return
FALSE
return
TRUE
endif
Return
DW_DLV_OK
etc
static
int
set_up_section
Dwarf_Debug
dbg
Section
name
from
object
format
Might
start
with
zdebug
not
debug
if
compressed
section
const
char
secname
Standard
section
name
such
as
debug_info
const
char
sec_standard_name
Section
number
from
object
format
unsigned
obj_sec_num
The
name
associated
with
this
secdata
in
libdwarf
const
char
targname
DW_GROUPNUMBER_ANY
or
BASE
or
DWO
or
some
other
group
num
unsigned
groupnum_of_sec
struct
Dwarf_Section_s
secdata
int
duperr
int
emptyerr
int
have_dwarf
int
err
Here
accomodate
the
debug
or
zdebug
version
and
of
course
non
debug
too
but
those
never
zlib
SECNAMEMAX
should
be
a
little
bigger
than
any
section
name
we
care
about
as
possibly
compressed
which
is
to
say
bigger
than
any
standard
section
name
define
SECNAMEMAX
int
secnamelen
strlen
secname
static
const
char
dprefix
debug_
define
DPREFIXLEN
static
const
char
zprefix
zdebug_
define
ZPREFIXLEN
int
havezdebug
FALSE
int
namesmatch
FALSE
For
example
if
the
secname
is
zdebug_info
we
update
the
finaltargname
to
debug_info
to
match
with
the
particular
known
predefined
object
section
name
We
add
one
character
so
check
to
see
if
it
will
in
the
end
fit
See
the
SET_UP_SECTION
macro
if
secnamelen
SECNAMEMAX
This
is
not
the
target
section
our
caller
will
keep
looking
return
DW_DLV_NO_ENTRY
if
secnamelen
SECNAMEMAX
strncmp
secname
zprefix
ZPREFIXLEN
strcmp
secname
ZPREFIXLEN
targname
DPREFIXLEN
zprefix
version
matches
the
object
section
name
so
the
section
is
compressed
and
is
the
section
this
targname
applies
to
havezdebug
TRUE
namesmatch
TRUE
else
if
strcmp
secname
targname
namesmatch
TRUE
undef
ZPREFIXLEN
undef
DPREFIXLEN
undef
SECNAMEMAX
if
namesmatch
This
is
not
the
target
section
our
caller
will
keep
looking
return
DW_DLV_NO_ENTRY
SETUP_SECTION
See
also
BUILDING_SECTIONS
BUILDING_MAP
The
section
name
is
a
match
with
targname
or
the
zdebug
version
of
targname
int
sectionerr
sectionerr
add_debug_section_info
dbg
secname
sec_standard_name
obj_sec_num
secdata
groupnum_of_sec
duperr
emptyerr
have_dwarf
havezdebug
err
if
sectionerr
DW_DLV_OK
err
is
set
already
return
sectionerr
return
DW_DLV_OK
define
SET_UP_SECTION
mdbg
mname
mtarg
mgrp
minfo
me1
me2
mdw
mer
int
lerr
lerr
set_up_section
mdbg
mname
actual
section
name
mtarg
std
section
name
scn_number
from
macro
use
context
scn_number
mtarg
mgrp
minfo
me1
me2
mdw
mer
if
lerr
DW_DLV_NO_ENTRY
return
lerr
else
fall
through
If
running
this
long
set
of
tests
is
slow
enough
to
matter
one
could
set
up
a
local
tsearch
tree
with
all
this
content
and
search
it
instead
of
this
set
of
sequential
tests
Or
use
a
switch
here
with
a
search
tree
to
to
turn
name
into
index
for
the
switch
static
int
enter_section_in_de_debug_sections_array
Dwarf_Debug
dbg
const
char
scn_name
This
is
the
number
of
the
section
in
the
object
file
unsigned
scn_number
unsigned
group_number
int
err
Setup
the
table
that
contains
the
basic
information
about
the
sections
that
are
DWARF
related
The
entries
are
very
unlikely
to
change
very
often
SET_UP_SECTION
dbg
scn_name
debug_info
group_number
de_debug_info
DW_DLE_DEBUG_INFO_DUPLICATE
DW_DLE_DEBUG_INFO_NULL
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_info
dwo
DW_GROUPNUMBER_DWO
de_debug_info
DW_DLE_DEBUG_INFO_DUPLICATE
DW_DLE_DEBUG_INFO_NULL
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_types
group_number
de_debug_types
DW_DLE_DEBUG_TYPES_DUPLICATE
DW_DLE_DEBUG_TYPES_NULL
TRUE
err
types
dwo
is
non
standard
DWARF4
GNU
maybe
SET_UP_SECTION
dbg
scn_name
debug_types
dwo
DW_GROUPNUMBER_DWO
de_debug_types
DW_DLE_DEBUG_TYPES_DUPLICATE
DW_DLE_DEBUG_TYPES_NULL
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_abbrev
group_number
de_debug_abbrev
DW_DLE_DEBUG_ABBREV_DUPLICATE
DW_DLE_DEBUG_ABBREV_NULL
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_abbrev
dwo
DW_GROUPNUMBER_DWO
de_debug_abbrev
DW_DLE_DEBUG_ABBREV_DUPLICATE
DW_DLE_DEBUG_ABBREV_NULL
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_aranges
group_number
de_debug_aranges
DW_DLE_DEBUG_ARANGES_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_line
group_number
de_debug_line
DW_DLE_DEBUG_LINE_DUPLICATE
TRUE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_line_str
group_number
de_debug_line_str
DW_DLE_DEBUG_LINE_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_line
dwo
DW_GROUPNUMBER_DWO
de_debug_line
DW_DLE_DEBUG_LINE_DUPLICATE
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_frame
group_number
de_debug_frame
DW_DLE_DEBUG_FRAME_DUPLICATE
TRUE
err
gnu
egcs
data
SET_UP_SECTION
dbg
scn_name
eh_frame
group_number
de_debug_frame_eh_gnu
DW_DLE_DEBUG_FRAME_DUPLICATE
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_loc
group_number
de_debug_loc
DW_DLE_DEBUG_LOC_DUPLICATE
FALSE
err
debug_loc
dwo
would
be
non
standard
SET_UP_SECTION
dbg
scn_name
debug_loc
dwo
DW_GROUPNUMBER_DWO
de_debug_loc
DW_DLE_DEBUG_LOC_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_pubnames
group_number
de_debug_pubnames
DW_DLE_DEBUG_PUBNAMES_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_str
group_number
de_debug_str
DW_DLE_DEBUG_STR_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_str
dwo
DW_GROUPNUMBER_DWO
de_debug_str
DW_DLE_DEBUG_STR_DUPLICATE
FALSE
err
Section
new
in
DWARF3
SET_UP_SECTION
dbg
scn_name
debug_pubtypes
group_number
de_debug_pubtypes
DW_DLE_DEBUG_PUBTYPES_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_loclists
group_number
de_debug_loclists
DW_DLE_DEBUG_LOClISTS_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_loclists
dwo
DW_GROUPNUMBER_DWO
de_debug_loclists
DW_DLE_DEBUG_LOClISTS_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_rnglists
group_number
de_debug_rnglists
DW_DLE_DEBUG_RNGLISTS_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_rnglists
dwo
DW_GROUPNUMBER_DWO
de_debug_rnglists
DW_DLE_DEBUG_RNGLISTS_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_str_offsets
group_number
de_debug_str_offsets
DW_DLE_DEBUG_STR_OFFSETS_DUPLICATE
FALSE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_str_offsets
dwo
DW_GROUPNUMBER_DWO
de_debug_str_offsets
DW_DLE_DEBUG_STR_OFFSETS_DUPLICATE
FALSE
err
SGI
IRIX
only
SET_UP_SECTION
dbg
scn_name
debug_funcnames
group_number
de_debug_funcnames
DW_DLE_DEBUG_FUNCNAMES_DUPLICATE
FALSE
err
SGI
IRIX
only
created
years
before
DWARF3
Content
essentially
identical
to
debug_pubtypes
SET_UP_SECTION
dbg
scn_name
debug_typenames
group_number
de_debug_typenames
DW_DLE_DEBUG_TYPENAMES_DUPLICATE
FALSE
err
SGI
IRIX
only
SET_UP_SECTION
dbg
scn_name
debug_varnames
group_number
de_debug_varnames
DW_DLE_DEBUG_VARNAMES_DUPLICATE
FALSE
err
SGI
IRIX
only
SET_UP_SECTION
dbg
scn_name
debug_weaknames
group_number
de_debug_weaknames
DW_DLE_DEBUG_WEAKNAMES_DUPLICATE
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_macinfo
group_number
de_debug_macinfo
DW_DLE_DEBUG_MACINFO_DUPLICATE
TRUE
err
debug_macinfo
dwo
is
not
allowed
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_macro
group_number
de_debug_macro
DW_DLE_DEBUG_MACRO_DUPLICATE
TRUE
err
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_macro
dwo
DW_GROUPNUMBER_DWO
de_debug_macro
DW_DLE_DEBUG_MACRO_DUPLICATE
TRUE
err
SET_UP_SECTION
dbg
scn_name
debug_ranges
group_number
de_debug_ranges
DW_DLE_DEBUG_RANGES_DUPLICATE
TRUE
err
No
debug_ranges
dwo
allowed
New
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_sup
group_number
de_debug_sup
DW_DLE_DEBUG_SUP_DUPLICATE
TRUE
err
No
debug_sup
dwo
allowed
symtab
and
strtab
have
to
be
in
any
group
SET_UP_SECTION
dbg
scn_name
symtab
group_number
de_elf_symtab
DW_DLE_DEBUG_SYMTAB_ERR
FALSE
err
SET_UP_SECTION
dbg
scn_name
strtab
group_number
de_elf_strtab
DW_DLE_DEBUG_STRTAB_ERR
FALSE
err
New
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_addr
group_number
de_debug_addr
DW_DLE_DEBUG_ADDR_DUPLICATE
TRUE
err
No
debug_addr
dwo
allowed
gdb
added
this
SET_UP_SECTION
dbg
scn_name
gdb_index
group_number
de_debug_gdbindex
DW_DLE_DUPLICATE_GDB_INDEX
FALSE
err
New
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_names
group_number
de_debug_names
DW_DLE_DEBUG_NAMES_DUPLICATE
FALSE
err
No
debug_names
dwo
allowed
gdb
added
this
in
DW4
It
is
in
standard
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_cu_index
DW_GROUPNUMBER_DWO
de_debug_cu_index
DW_DLE_DUPLICATE_CU_INDEX
FALSE
err
gdb
added
this
in
DW4
It
is
in
standard
DWARF5
SET_UP_SECTION
dbg
scn_name
debug_tu_index
DW_GROUPNUMBER_DWO
de_debug_tu_index
DW_DLE_DUPLICATE_TU_INDEX
FALSE
err
GNU
added
this
It
is
not
part
of
DWARF
SET_UP_SECTION
dbg
scn_name
gnu_debuglink
DW_GROUPNUMBER_DWO
de_gnu_debuglink
DW_DLE_DUPLICATE_GNU_DEBUGLINK
FALSE
err
GNU
added
this
It
is
not
part
of
DWARF
SET_UP_SECTION
dbg
scn_name
note
gnu
build
id
DW_GROUPNUMBER_DWO
de_note_gnu_buildid
DW_DLE_DUPLICATE_GNU_DEBUGLINK
FALSE
err
GNU
added
this
It
is
not
part
of
DWARF
SET_UP_SECTION
dbg
scn_name
debug_gnu_pubtypes
dwo
DW_GROUPNUMBER_DWO
de_debug_gnu_pubtypes
DW_DLE_DUPLICATE_GNU_DEBUG_PUBTYPES
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_gnu_pubtypes
group_number
de_debug_gnu_pubtypes
DW_DLE_DUPLICATE_GNU_DEBUG_PUBTYPES
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_gnu_pubnames
dwo
DW_GROUPNUMBER_DWO
de_debug_gnu_pubnames
DW_DLE_DUPLICATE_GNU_DEBUG_PUBNAMES
FALSE
err
SET_UP_SECTION
dbg
scn_name
debug_gnu_pubnames
group_number
de_debug_gnu_pubnames
DW_DLE_DUPLICATE_GNU_DEBUG_PUBNAMES
FALSE
err
return
DW_DLV_NO_ENTRY
static
int
is_section_name_known_already
Dwarf_Debug
dbg
const
char
scn_name
unsigned
i
for
i
dbg
de_debug_sections_total_entries
i
struct
Dwarf_dbg_sect_s
section
de_debug_sections
i
if
strcmp
scn_name
section
ds_name
The
caller
will
declare
this
a
duplicate
an
error
return
DW_DLV_OK
This
is
normal
we
expect
we
ve
not
accepted
scn_name
already
return
DW_DLV_NO_ENTRY
Given
an
Elf
ptr
set
up
dbg
with
pointers
to
all
the
Dwarf
data
sections
Return
NULL
on
error
This
function
is
also
responsible
for
determining
whether
the
given
object
contains
Dwarf
information
or
not
The
test
currently
used
is
that
it
contains
either
a
debug_info
or
a
debug_frame
section
If
not
it
returns
DW_DLV_NO_ENTRY
causing
dwarf_init
also
to
return
DW_DLV_NO_ENTRY
Earlier
we
had
thought
of
using
only
the
presence
absence
of
debug_info
to
test
but
we
added
debug_frame
since
there
could
be
stripped
objects
that
have
only
a
debug_frame
section
for
exception
processing
DW_DLV_NO_ENTRY
or
DW_DLV_OK
or
DW_DLV_ERROR
This
does
not
allow
for
section
groups
in
object
files
for
which
many
debug_info
and
other
DWARF
sections
may
exist
We
process
rela
SHT_RELA
and
rel
SHT_REL
sections
because
with
rela
the
referencing
section
offset
value
is
zero
whereas
with
rel
the
referencing
section
value
is
already
correct
for
the
object
itself
In
other
words
we
do
it
because
of
the
definition
of
rela
relocations
in
Elf
However
In
some
cases
clang
emits
a
rel
section
at
least
for
rel
debug_info
where
symtab
entries
have
an
st_value
that
must
be
treated
like
an
addend
the
compiler
did
not
bother
to
backpatch
the
DWARF
information
for
these
These
help
us
ignore
some
sections
that
are
irrelevant
to
libdwarf
Maybe
should
use
a
hash
table
instead
of
sequential
search?
int
_dwarf_ignorethissection
const
char
scn_name
if
strcmp
scn_name
bss
return
TRUE
if
strcmp
scn_name
comment
return
TRUE
if
strcmp
scn_name
sbss
return
TRUE
if
strcmp
scn_name
jcr
return
TRUE
if
strcmp
scn_name
init
return
TRUE
if
strcmp
scn_name
fini_array
return
TRUE
if
strcmp
scn_name
fini
return
TRUE
if
strcmp
scn_name
fini_array
return
TRUE
if
strcmp
scn_name
interp
return
TRUE
if
strcmp
scn_name
text
return
TRUE
if
strcmp
scn_name
rela
text
return
TRUE
if
strcmp
scn_name
rel
text
return
TRUE
if
strcmp
scn_name
plt
return
TRUE
if
strcmp
scn_name
rela
plt
return
TRUE
if
strcmp
scn_name
rel
plt
return
TRUE
if
strcmp
scn_name
data
return
TRUE
if
strcmp
scn_name
rel
data
return
TRUE
if
strcmp
scn_name
rela
data
return
TRUE
if
strcmp
scn_name
got
return
TRUE
if
strcmp
scn_name
rela
got
return
TRUE
if
strcmp
scn_name
rel
got
return
TRUE
return
FALSE
For
an
object
file
with
an
incorrect
rela
section
name
readelf
prints
correct
debug
information
as
the
tool
takes
the
section
type
instead
of
the
section
name
So
check
the
section
name
but
test
section
type
static
int
is_a_relx_section
const
char
scn_name
int
type
int
is_rela
if
startswith
scn_name
rela
is_rela
TRUE
return
TRUE
if
startswith
scn_name
rel
is_rela
FALSE
return
TRUE
if
type
SHT_RELA
is_rela
TRUE
return
TRUE
if
type
SHT_REL
is_rela
FALSE
return
TRUE
is_rela
FALSE
return
FALSE
ASSERT
names
like
debug_
or
zdebug_
never
passed
in
here
static
int
is_a_special_section_semi_dwarf
const
char
scn_name
if
strcmp
scn_name
strtab
strcmp
scn_name
symtab
return
TRUE
It
s
not
one
of
these
special
sections
referenced
in
the
test
return
FALSE
static
int
this_section_dwarf_relevant
const
char
scn_name
int
type
int
is_rela
A
small
helper
function
for
_dwarf_setup
if
startswith
scn_name
zdebug_
startswith
scn_name
debug_
standard
debug
return
TRUE
if
_dwarf_ignorethissection
scn_name
return
FALSE
Now
check
if
a
special
section
could
be
in
a
section_group
but
though
seems
unlikely
if
strcmp
scn_name
eh_frame
This
is
not
really
a
group
related
file
but
it
is
harmless
to
consider
it
such
return
TRUE
if
strcmp
scn_name
gnu_debuglink
This
is
not
a
group
or
DWARF
related
file
but
it
is
useful
for
split
dwarf
return
TRUE
if
strcmp
scn_name
note
gnu
build
id
This
is
not
a
group
or
DWARF
related
file
but
it
is
useful
for
split
dwarf
return
TRUE
if
strcmp
scn_name
gdb_index
return
TRUE
if
is_a_special_section_semi_dwarf
scn_name
return
TRUE
if
is_a_relx_section
scn_name
type
is_rela
return
TRUE
All
sorts
of
sections
are
of
no
interest
text
rel
and
many
others
return
FALSE
This
assumes
any
non
Elf
object
files
have
no
SHT_GROUP
sections
So
this
code
will
not
be
invoked
on
non
Elf
objects
One
supposes
this
is
unlikely
to
match
any
non
Elf
version
of
COMDAT
static
int
insert_sht_list_in_group_map
Dwarf_Debug
dbg
struct
Dwarf_Obj_Access_Section_s
doas
unsigned
comdat_group_number
unsigned
section_number
Dwarf_Unsigned
section_count
struct
Dwarf_Obj_Access_Interface_s
obj
unsigned
did_add_map
Dwarf_Error
error
struct
Dwarf_Section_s
secdata
Dwarf_Small
data
int
res
Dwarf_Small
secend
memset
sizeof
secdata
secdata
dss_size
doas
size
secdata
dss_entrysize
doas
entrysize
secdata
dss_group_number
arbitrary
secdata
dss_index
section_number
secdata
dss_name
group
secdata
dss_standard_name
group
secdata
dss_number
section_number
secdata
dss_ignore_reloc_group_sec
TRUE
res
_dwarf_load_section
dbg
error
if
res
DW_DLV_OK
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
return
res
if
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
if
doas
entrysize
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
So
now
pick
up
the
data
in
dss_data
It
is
an
array
of
bit
fields
Entry
zero
is
just
a
constant
Each
additional
is
a
section
number
data
secdata
dss_data
secend
data
secdata
dss_size
unsigned
i
unsigned
count
doas
size
doas
entrysize
Dwarf_Unsigned
fval
The
fields
treatments
with
regard
to
endianness
is
unclear
In
any
case
a
single
bit
should
be
on
as
without
any
endiannes
swapping
Or
so
it
seems
given
limited
evidence
We
read
with
length
checking
and
allow
the
reader
to
byte
swap
and
then
fix
things
At
least
one
test
case
has
big
endian
data
but
little
endian
SHT_GROUP
data
if
data
DWARF_32BIT_SIZE
secend
Duplicates
the
check
in
READ_UNALIGNED_CK
so
we
can
free
allocated
memory
bere
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
fval
Dwarf_Unsigned
data
DWARF_32BIT_SIZE
error
secend
if
fval
fval
Could
be
corrupted
elf
object
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
data
data
doas
entrysize
for
i
i
count
i
Dwarf_Unsigned
val
if
data
DWARF_32BIT_SIZE
secend
Duplicates
the
check
in
READ_UNALIGNED_CK
so
we
can
free
allocated
memory
bere
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
data
DWARF_32BIT_SIZE
error
secend
if
val
section_count
Might
be
confused
endianness
by
the
compiler
generating
the
SHT_GROUP
This
is
pretty
horrible
Dwarf_Unsigned
valr
_dwarf_memcpy_swap_bytes
DWARF_32BIT_SIZE
if
valr
section_count
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_ERROR
Ok
Yes
ugly
val
valr
Ensure
this
group
entry
DWARF
relevant
before
adding
to
group
map
struct
Dwarf_Obj_Access_Section_s
doasx
int
resx
DW_DLV_ERROR
int
err
int
is_rela
FALSE
memset
sizeof
doasx
resx
obj
methods
get_section_info
obj
object
val
if
resx
DW_DLV_NO_ENTRY
Should
we
really
ignore
this?
continue
else
if
resx
DW_DLV_ERROR
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
_dwarf_error
dbg
error
err
return
resx
if
this_section_dwarf_relevant
doasx
name
doasx
type
continue
data
DWARF_32BIT_SIZE
did_add_map
TRUE
res
_dwarf_insert_in_group_map
dbg
comdat_group_number
val
doasx
name
error
if
res
DW_DLV_OK
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
return
res
if
secdata
dss_data_was_malloc
free
secdata
dss_data
secdata
dss_data
return
DW_DLV_OK
Split
dwarf
CUs
can
be
in
an
object
with
non
split
or
split
may
be
in
a
separate
object
If
all
in
one
object
the
default
is
to
deal
with
group_number
and
ignore
DW_GROUPNUMBER_DWO
If
only
dwo
the
default
is
DW_GROUPNUMBER_DWO
Otherwise
use
DW_GROUP_NUMBER_BASE
If
there
are
COMDAT
SHT_GROUP
sections
these
are
assigned
group
numbers
N
as
needed
At
present
this
makes
the
assumption
that
COMDAT
group
ie
SHT_GROUP
sections
have
lower
section
numbers
than
the
sections
COMDAT
refers
to
It
is
not
clear
whether
this
is
guaranteed
COMDAT
is
not
an
official
Elf
thing
and
documentation
is
scarce
In
the
s
SGI
folks
and
others
formed
a
committee
and
attempted
to
get
COMDAT
and
a
feature
allowing
section
numbers
greater
than
bits
into
Elf
but
there
was
no
group
that
was
able
to
approve
such
things
This
is
called
once
at
dbg
init
time
static
int
determine_target_group
Dwarf_Unsigned
section_count
struct
Dwarf_Obj_Access_Interface_s
obj
unsigned
group_number_out
Dwarf_Debug
dbg
Dwarf_Error
error
unsigned
obj_section_index
int
found_group_one
int
found_group_two
struct
Dwarf_Group_Data_s
grp
unsigned
comdat_group_next
unsigned
lowest_comdat_groupnum
grp
de_groupnumbers
grp
gd_number_of_groups
grp
gd_number_of_sections
section_count
if
grp
gd_map
_dwarf_error
dbg
error
DW_DLE_GROUP_INTERNAL_ERROR
return
DW_DLV_OK
for
obj_section_index
obj_section_index
section_count
obj_section_index
struct
Dwarf_Obj_Access_Section_s
doas
int
res
DW_DLV_ERROR
int
err
const
char
scn_name
unsigned
groupnumber
unsigned
mapgroupnumber
int
is_rela
FALSE
memset
sizeof
doas
res
obj
methods
get_section_info
obj
object
obj_section_index
if
res
DW_DLV_NO_ENTRY
return
res
else
if
res
DW_DLV_ERROR
_dwarf_error
dbg
error
err
return
res
if
doas
type
SHT_GROUP
See
assumptions
in
function
comment
above
unsigned
did_add_map
Add
to
our
map
Here
we
are
assuming
SHT_GROUP
records
come
first
Till
proven
wrong
res
insert_sht_list_in_group_map
dbg
comdat_group_next
obj_section_index
section_count
obj
error
if
res
DW_DLV_OK
return
res
if
lowest_comdat_groupnum
lowest_comdat_groupnum
comdat_group_next
if
did_add_map
grp
gd_number_of_groups
comdat_group_next
continue
scn_name
doas
name
if
this_section_dwarf_relevant
scn_name
doas
type
continue
Now
at
a
normal
section
though
we
do
not
quite
know
what
group
it
is
res
_dwarf_section_get_target_group_from_map
dbg
obj_section_index
error
if
res
DW_DLV_OK
groupnumber
is
set
Fall
through
All
COMDAT
group
should
get
here
mapgroupnumber
groupnumber
else
if
res
DW_DLV_ERROR
return
res
else
DW_DLV_NO_ENTRY
Normal
non
COMDAT
groupnumber
is
zero
BUILDING_MAP
See
also
BUILDING_SECTIONS
SETUP_SECTION
if
groupnumber
res
_dwarf_dwo_groupnumber_given_name
scn_name
DW_DLV_ERROR
impossible
here
if
res
DW_DLV_OK
groupnumber
set
else
This
is
what
it
has
to
be
rela
in
here
too
groupnumber
DW_GROUPNUMBER_BASE
if
is_a_relx_section
scn_name
doas
type
continue
ASSERT
groupnumber
non
zero
now
if
is_a_special_section_semi_dwarf
scn_name
if
mapgroupnumber
Already
in
group
map
continue
mapgroupnumber
res
_dwarf_insert_in_group_map
dbg
groupnumber
obj_section_index
scn_name
error
if
res
DW_DLV_OK
return
res
if
groupnumber
found_group_one
else
if
groupnumber
found_group_two
continue
if
found_group_two
grp
gd_number_of_groups
if
found_group_one
group_number_out
DW_GROUPNUMBER_BASE
grp
gd_number_of_groups
else
if
found_group_two
group_number_out
DW_GROUPNUMBER_DWO
else
if
lowest_comdat_groupnum
group_number_out
lowest_comdat_groupnum
else
group_number_out
DW_GROUPNUMBER_BASE
return
DW_DLV_OK
static
int
_dwarf_setup
Dwarf_Debug
dbg
Dwarf_Error
error
const
char
scn_name
struct
Dwarf_Obj_Access_Interface_s
obj
int
resn
struct
Dwarf_Section_s
sections
Dwarf_Endianness
endianness
Dwarf_Unsigned
section_count
unsigned
default_group_number
unsigned
foundDwarf
FALSE
unsigned
obj_section_index
dbg
de_assume_string_in_bounds
_dwarf_assume_string_in_bounds
First
make
an
arbitrary
assumption
dbg
de_same_endian
dbg
de_copy_word
_dwarf_memcpy_noswap_bytes
obj
dbg
de_obj_file
endianness
obj
methods
get_byte_order
obj
object
Then
adjust
any
changes
we
need
ifdef
WORDS_BIGENDIAN
dbg
de_big_endian_object
if
endianness
DW_OBJECT_LSB
dbg
de_same_endian
dbg
de_big_endian_object
dbg
de_copy_word
_dwarf_memcpy_swap_bytes
else
little
endian
dbg
de_big_endian_object
if
endianness
DW_OBJECT_MSB
dbg
de_same_endian
dbg
de_big_endian_object
dbg
de_copy_word
_dwarf_memcpy_swap_bytes
endif
WORDS_BIGENDIAN
The
following
de_length_size
is
Not
Too
Significant
Only
used
one
calculation
and
an
approximate
one
at
that
dbg
de_length_size
obj
methods
get_length_size
obj
object
dbg
de_pointer_size
obj
methods
get_pointer_size
obj
object
section_count
obj
methods
get_section_count
obj
object
resn
determine_target_group
section_count
obj
dbg
error
if
resn
DW_DLV_ERROR
return
DW_DLV_ERROR
if
dbg
de_groupnumber
DW_GROUPNUMBER_ANY
dbg
de_groupnumber
default_group_number
Allocate
space
to
record
references
to
debug
sections
that
can
be
referenced
by
RELA
sections
in
the
sh_info
field
sections
struct
Dwarf_Section_s
calloc
section_count
sizeof
struct
Dwarf_Section_s
if
sections
Impossible
case
we
hope
Give
up
_dwarf_error
dbg
error
DW_DLE_SECTION_ERROR
return
DW_DLV_ERROR
We
can
skip
index
when
considering
ELF
files
but
not
other
object
types
Indeed
regardless
of
the
object
type
we
should
skip
section
here
This
is
a
convention
We
depend
on
it
Non
elf
object
access
code
should
in
itself
understand
we
will
index
beginning
at
and
adjust
itself
to
deal
with
this
Elf
convention
Without
this
convention
various
parts
of
the
code
in
this
file
won
t
work
correctly
A
dss_index
of
must
not
be
used
even
though
we
start
at
here
So
the
get_section_info
must
adapt
to
the
situation
the
elf
version
does
automatically
as
a
result
of
Elf
having
a
section
zero
with
zero
length
and
an
empty
name
ASSERT
all
group
map
entries
set
up
for
obj_section_index
obj_section_index
section_count
obj_section_index
struct
Dwarf_Obj_Access_Section_s
doas
int
res
DW_DLV_ERROR
int
err
unsigned
groupnumber
unsigned
mapgroupnumber
int
is_rela
FALSE
res
_dwarf_section_get_target_group_from_map
dbg
obj_section_index
error
if
res
DW_DLV_OK
groupnumber
is
set
Fall
through
mapgroupnumber
groupnumber
else
if
res
DW_DLV_ERROR
free
sections
return
res
else
DW_DLV_NO_ENTRY
fall
through
a
BASE
or
DWO
group
possibly
memset
sizeof
doas
res
obj
methods
get_section_info
obj
object
obj_section_index
if
res
DW_DLV_NO_ENTRY
free
sections
return
res
else
if
res
DW_DLV_ERROR
free
sections
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
scn_name
doas
name
if
groupnumber
This
finds
dwo
sections
group
res
_dwarf_dwo_groupnumber_given_name
scn_name
if
res
DW_DLV_NO_ENTRY
No
must
be
group
groupnumber
DW_GROUPNUMBER_BASE
if
this_section_dwarf_relevant
scn_name
doas
type
continue
if
is_a_relx_section
scn_name
doas
type
is_a_special_section_semi_dwarf
scn_name
We
do
these
actions
only
for
group
related
sections
Do
for
debug_info
etc
never
for
strtab
or
rela
We
already
tested
for
relevance
so
that
part
is
not
news
if
mapgroupnumber
dbg
de_groupnumber
OK
Mapped
Part
of
the
group
This
will
catch
the
cases
where
there
are
versions
of
a
section
in
multiple
COMDATs
and
in
BASE
an
DWO
to
get
the
right
one
else
This
section
not
mapped
into
this
group
if
groupnumber
dbg
de_groupnumber
_dwarf_section_in_group_by_name
dbg
scn_name
dbg
de_groupnumber
Load
the
section
but
as
group
else
continue
BUILDING_SECTIONS
See
also
BUILDING_MAP
SETUP_SECTION
Build
up
the
sections
table
and
the
de_debug
etc
pointers
in
Dwarf_Debug
struct
Dwarf_dbg_sect_s
section
int
found_match
FALSE
res
is_section_name_known_already
dbg
scn_name
if
res
DW_DLV_OK
DUPLICATE
free
sections
DWARF_DBG_ERROR
dbg
DW_DLE_SECTION_DUPLICATION
DW_DLV_ERROR
else
if
res
DW_DLV_ERROR
free
sections
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
No
entry
new
to
us
section
the
normal
case
res
enter_section_in_de_debug_sections_array
dbg
scn_name
obj_section_index
groupnumber
if
res
DW_DLV_OK
section
de_debug_sections
dbg
de_debug_sections_total_entries
res
get_basic_section_data
dbg
section
ds_secdata
obj_section_index
groupnumber
error
section
ds_duperr
section
ds_emptyerr
if
res
DW_DLV_OK
free
sections
return
res
sections
obj_section_index
section
ds_secdata
foundDwarf
section
ds_have_dwarf
found_match
TRUE
Normal
section
set
up
Fall
through
else
if
res
DW_DLV_NO_ENTRY
We
get
here
for
relocation
sections
Fall
through
else
free
sections
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
if
found_match
For
an
object
file
with
incorrect
rel
a
section
name
the
readelf
tool
prints
correct
debug
information
as
the
tool
takes
the
section
type
instead
of
the
section
name
If
the
current
section
is
a
RELA
one
and
the
sh_info
refers
to
a
debug
section
add
the
relocation
data
if
is_a_relx_section
scn_name
doas
type
if
doas
info
section_count
if
sections
doas
info
add_relx_data_to_secdata
sections
doas
info
obj_section_index
is_rela
else
Something
is
wrong
with
the
ELF
file
free
sections
DWARF_DBG_ERROR
dbg
DW_DLE_ELF_SECT_ERR
DW_DLV_ERROR
Fetch
next
section
Free
table
with
section
information
free
sections
if
foundDwarf
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
There
is
one
table
per
CU
and
one
per
TU
and
each
table
refers
to
the
associated
other
DWARF
data
for
that
CU
or
TU
See
DW_SECT_
In
DWARF4
the
type
units
are
in
debug_types
In
DWARF5
the
type
units
are
in
debug_info
static
int
load_debugfission_tables
Dwarf_Debug
dbg
Dwarf_Error
error
int
i
if
dbg
de_debug_cu_index
dss_size
dbg
de_debug_tu_index
dss_size
This
is
the
normal
case
No
debug
fission
Not
a
dwp
object
return
DW_DLV_NO_ENTRY
for
i
i
i
Dwarf_Xu_Index_Header
xuptr
struct
Dwarf_Section_s
dwsect
Dwarf_Unsigned
version
Dwarf_Unsigned
number_of_cols
L
Dwarf_Unsigned
number_of_CUs
N
Dwarf_Unsigned
number_of_slots
M
const
char
secname
int
res
const
char
type
if
i
dwsect
de_debug_cu_index
type
cu
else
dwsect
de_debug_tu_index
type
tu
if
dwsect
dss_size
continue
res
dwarf_get_xu_index_header
dbg
type
error
if
res
DW_DLV_NO_ENTRY
continue
if
res
DW_DLV_OK
return
res
if
i
dbg
de_cu_hashindex_data
xuptr
else
dbg
de_tu_hashindex_data
xuptr
return
DW_DLV_OK
Use
a
Dwarf_Obj_Access_Interface
to
kick
things
off
All
other
init
routines
eventually
use
this
one
The
returned
Dwarf_Debug
contains
a
copy
of
obj
the
callers
copy
of
obj
may
be
freed
whenever
the
caller
wishes
New
March
Enables
dealing
with
DWARF5
split
dwarf
more
fully
int
dwarf_object_init_b
Dwarf_Obj_Access_Interface
obj
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
unsigned
groupnumber
Dwarf_Debug
ret_dbg
Dwarf_Error
error
Dwarf_Debug
dbg
int
setup_result
DW_DLV_OK
dbg
_dwarf_get_debug
if
dbg
NULL
DWARF_DBG_ERROR
dbg
DW_DLE_DBG_ALLOC
DW_DLV_ERROR
dbg
de_errhand
errhand
dbg
de_errarg
errarg
dbg
de_frame_rule_initial_value
DW_FRAME_REG_INITIAL_VALUE
dbg
de_frame_reg_rules_entry_count
DW_FRAME_LAST_REG_NUM
ifdef
HAVE_OLD_FRAME_CFA_COL
DW_FRAME_CFA_COL
is
really
only
suitable
for
old
libdwarf
frame
interfaces
and
its
value
of
there
is
only
usable
where
as
in
MIPS
register
has
no
value
other
than
so
we
can
use
the
frame
table
column
for
the
CFA
value
and
rely
on
client
software
to
know
when
register
is
the
cfa
and
when
to
just
use
a
value
for
register
dbg
de_frame_cfa_col_number
DW_FRAME_CFA_COL
else
dbg
de_frame_cfa_col_number
DW_FRAME_CFA_COL3
endif
dbg
de_frame_same_value_number
DW_FRAME_SAME_VAL
dbg
de_frame_undefined_value_number
DW_FRAME_UNDEFINED_VAL
dbg
de_obj_file
obj
dbg
de_groupnumber
groupnumber
setup_result
_dwarf_setup
dbg
error
if
setup_result
DW_DLV_OK
int
fission_result
load_debugfission_tables
dbg
error
In
most
cases
we
get
setup_result
DW_DLV_NO_ENTRY
here
as
having
debugfission
dwp
objects
is
fairly
rare
if
fission_result
DW_DLV_ERROR
Something
is
very
wrong
setup_result
fission_result
if
setup_result
DW_DLV_OK
int
freeresult
int
myerr
dwarfstring
msg
dwarfstring_constructor
We
cannot
use
any
_dwarf_setup
error
here
as
we
are
freeing
dbg
making
that
error
setup
as
part
of
dbg
stale
Hence
we
have
to
make
a
new
error
without
a
dbg
But
error
might
be
NULL
and
the
init
call
error
handler
function
might
be
set
if
setup_result
DW_DLV_ERROR
error
Preserve
our
_dwarf_setup
error
number
but
this
does
not
apply
if
error
NULL
myerr
dwarf_errno
error
dwarfstring_append
dwarf_errmsg
error
deallocate
the
soon
stale
error
pointer
dwarf_dealloc
dbg
error
DW_DLA_ERROR
error
The
status
we
want
to
return
here
is
of
_dwarf_setup
not
of
the
_dwarf_free_all_of_one_debug
dbg
call
So
use
a
local
status
variable
for
the
free
freeresult
_dwarf_free_all_of_one_debug
dbg
dbg
DW_DLV_NO_ENTRY
not
possible
in
freeresult
if
freeresult
DW_DLV_ERROR
Use
the
_dwarf_setup
error
number
If
error
is
NULL
the
following
will
issue
a
message
on
stderr
and
abort
as
without
dbg
there
is
no
error
handler
function
_dwarf_error_string
dbg
error
DW_DLE_DBG_ALLOC
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
setup_result
DW_DLV_ERROR
Use
the
_dwarf_setup
error
number
If
error
is
NULL
the
following
will
issue
a
message
on
stderr
and
abort
as
without
dbg
there
is
no
error
handler
function
_dwarf_error_string
dbg
error
myerr
dwarfstring_string
dwarfstring_destructor
return
setup_result
dwarf_harmless_init
de_harmless_errors
DW_HARMLESS_ERROR_CIRCULAR_LIST_DEFAULT_SIZE
ret_dbg
dbg
return
DW_DLV_OK
A
finish
routine
that
is
completely
unaware
of
ELF
Frees
all
memory
that
was
not
previously
freed
by
dwarf_dealloc
NEVER
returns
DW_DLV_ERROR
Aside
from
certain
categories
int
dwarf_object_finish
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Error
error
int
res
res
_dwarf_free_all_of_one_debug
dbg
return
res
ifdef
HAVE_ZLIB
case
The
input
stream
is
assumed
to
contain
the
four
letters
ZLIB
Followed
by
bytes
of
the
size
of
the
uncompressed
stream
Presented
as
a
big
endian
binary
number
Following
that
is
the
stream
to
decompress
case
The
section
flag
bit
SHF_COMPRESSED
must
be
set
we
then
do
the
equivalent
of
reading
a
Elf32_External_Chdr
or
Elf64_External_Chdr
to
get
the
type
which
must
be
and
the
decompressed_length
Then
what
follows
the
implicit
Chdr
is
decompressed
ALLOWED_ZLIB_INFLATION
is
a
heuristic
not
necessarily
right
The
test
case
klingler2
compresseddebug
amd64
actually
inflates
about
times
define
ALLOWED_ZLIB_INFLATION
static
int
do_decompress_zlib
Dwarf_Debug
dbg
struct
Dwarf_Section_s
section
Dwarf_Error
error
Bytef
basesrc
Bytef
section
dss_data
Bytef
src
Bytef
basesrc
uLong
srclen
section
dss_size
Dwarf_Unsigned
flags
section
dss_flags
Dwarf_Small
endsection
int
res
Bytef
dest
uLongf
destlen
Dwarf_Unsigned
uncompressed_len
endsection
basesrc
srclen
if
src
endsection
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_SECTION_SHORT
DW_DLV_ERROR
section
dss_compressed_length
section
dss_size
if
strncmp
ZLIB
const
char
src
unsigned
i
unsigned
l
unsigned
char
c
src
for
i
l
i
c
uncompressed_len
uncompressed_len
c
src
src
srclen
section
dss_uncompressed_length
uncompressed_len
section
dss_ZLIB_compressed
TRUE
else
if
flags
SHF_COMPRESSED
The
prefix
is
a
struct
unsigned
int
type
followed
by
pad
if
following
are
size
of
target
address
size
size
of
target
address
If
we
read
using
libelf
libelf
knows
about
SHF_COMPRESSED
and
if
the
object
and
the
running
libelf
do
not
match
endianness
libelf
already
transformed
the
two
fields
we
care
about
to
host
endianness
so
the
READ_UNALIGNED
is
just
wrong
Just
noticed
this
issue
November
Dwarf_Small
ptr
Dwarf_Small
src
Dwarf_Unsigned
type
Dwarf_Unsigned
size
Dwarf_Unsigned
addralign
unsigned
fldsize
dbg
de_pointer_size
unsigned
structsize
fldsize
if
dbg
de_using_libelf
unsigned
offset
unsigned
offsetb
ifdef
WORDS_BIGENDIAN
offset
sizeof
type
DWARF_32BIT_SIZE
offsetb
sizeof
type
fldsize
else
LITTLE_ENDIAN
offset
offsetb
endif
BIG_ENDIAM
memcpy
char
offset
ptr
size_t
DWARF_32BIT_SIZE
ptr
fldsize
memcpy
char
offsetb
ptr
size_t
fldsize
else
READ_UNALIGNED_CK
dbg
type
Dwarf_Unsigned
ptr
DWARF_32BIT_SIZE
error
endsection
ptr
fldsize
READ_UNALIGNED_CK
dbg
size
Dwarf_Unsigned
ptr
fldsize
error
endsection
if
type
ELFCOMPRESS_ZLIB
DWARF_DBG_ERROR
dbg
DW_DLE_ZDEBUG_INPUT_FORMAT_ODD
DW_DLV_ERROR
uncompressed_len
size
section
dss_uncompressed_length
uncompressed_len
src
structsize
srclen
structsize
section
dss_shf_compressed
TRUE
else
DWARF_DBG_ERROR
dbg
DW_DLE_ZDEBUG_INPUT_FORMAT_ODD
DW_DLV_ERROR
According
to
zlib
net
zlib
essentially
never
expands
the
data
when
compressing
There
is
no
statement
about
any
effective
limit
in
the
compression
factor
though
we
here
assume
such
a
limit
to
check
for
sanity
in
the
object
file
These
tests
are
heuristics
Dwarf_Unsigned
max_inflated_len
srclen
ALLOWED_ZLIB_INFLATION
if
srclen
If
srclen
not
super
tiny
lets
check
the
following
if
uncompressed_len
srclen
Violates
the
approximate
invariant
about
compression
not
actually
inflating
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_UNCOMPRESS_ERROR
DW_DLV_ERROR
if
max_inflated_len
srclen
The
calculation
overflowed
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_UNCOMPRESS_ERROR
DW_DLV_ERROR
if
uncompressed_len
max_inflated_len
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_UNCOMPRESS_ERROR
DW_DLV_ERROR
if
src
srclen
endsection
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_SECTION_SHORT
DW_DLV_ERROR
destlen
uncompressed_len
dest
malloc
destlen
if
dest
DWARF_DBG_ERROR
dbg
DW_DLE_ALLOC_FAIL
DW_DLV_ERROR
res
uncompress
dest
src
srclen
if
res
Z_BUF_ERROR
free
dest
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_BUF_ERROR
DW_DLV_ERROR
else
if
res
Z_MEM_ERROR
free
dest
DWARF_DBG_ERROR
dbg
DW_DLE_ALLOC_FAIL
DW_DLV_ERROR
else
if
res
Z_OK
free
dest
Probably
Z_DATA_ERROR
DWARF_DBG_ERROR
dbg
DW_DLE_ZLIB_DATA_ERROR
DW_DLV_ERROR
Z_OK
section
dss_data
dest
section
dss_size
destlen
section
dss_data_was_malloc
TRUE
section
dss_did_decompress
TRUE
return
DW_DLV_OK
endif
HAVE_ZLIB
Load
the
ELF
section
with
the
specified
index
and
set
its
dss_data
pointer
to
the
memory
where
it
was
loaded
int
_dwarf_load_section
Dwarf_Debug
dbg
struct
Dwarf_Section_s
section
Dwarf_Error
error
int
res
DW_DLV_ERROR
int
err
struct
Dwarf_Obj_Access_Interface_s
o
check
to
see
if
the
section
is
already
loaded
if
section
dss_data
NULL
return
DW_DLV_OK
o
dbg
de_obj_file
There
is
an
elf
convention
that
section
index
is
reserved
and
that
section
is
always
empty
Non
elf
object
formats
must
honor
that
by
ensuring
that
when
they
assign
numbers
to
sections
or
section
like
things
they
never
assign
a
real
section
section
number
to
dss_index
There
is
also
a
convention
for
bss
that
that
section
and
its
like
sections
have
no
data
but
do
have
a
size
That
is
never
true
of
DWARF
sections
res
o
methods
load_section
o
object
section
dss_index
dss_data
if
res
DW_DLV_ERROR
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
For
PE
and
mach
o
all
section
data
was
always
malloc
d
We
do
not
need
to
set
dss_data_was_malloc
though
as
the
o
object
data
will
eventually
free
the
original
section
data
The
first
character
of
any
o
object
struct
gives
the
type
if
res
DW_DLV_NO_ENTRY
Gets
this
for
section
dss_index
Which
by
ELF
definition
is
a
section
index
which
is
not
used
reserved
by
Elf
to
mean
no
section
index
Otherwise
NULL
dss_data
gets
error
BSS
would
legitimately
have
no
data
but
no
DWARF
related
section
could
possibly
be
bss
We
also
get
it
if
the
section
is
present
but
zero
size
return
res
if
section
dss_ignore_reloc_group_sec
Neither
zdebug
nor
reloc
apply
to
group
sections
return
res
if
section
dss_zdebug_requires_decompress
section
dss_shf_compressed
section
dss_ZLIB_compressed
section
dss_did_decompress
if
section
dss_data
Impossible
This
makes
no
sense
Corrupt
object
DWARF_DBG_ERROR
dbg
DW_DLE_COMPRESSED_EMPTY_SECTION
DW_DLV_ERROR
ifdef
HAVE_ZLIB
res
do_decompress_zlib
dbg
section
error
if
res
DW_DLV_OK
return
res
section
dss_did_decompress
TRUE
else
DWARF_DBG_ERROR
dbg
DW_DLE_ZDEBUG_REQUIRES_ZLIB
DW_DLV_ERROR
endif
if
_dwarf_apply_relocs
return
res
if
section
dss_reloc_size
return
res
if
o
methods
relocate_a_section
return
res
apply
relocations
res
o
methods
relocate_a_section
o
object
section
dss_index
dbg
if
res
DW_DLV_ERROR
DWARF_DBG_ERROR
dbg
err
res
return
res
This
is
a
hack
so
clients
can
verify
offsets
Added
without
so
many
sections
to
report
April
so
that
debugger
can
detect
broken
offsets
which
happened
in
an
IRIX
executable
larger
than
using
MIPSpro
compilers
A
couple
debug_pubnames
offsets
were
wrong
Now
with
sections
new
to
DWARF5
int
dwarf_get_section_max_offsets_d
Dwarf_Debug
dbg
Dwarf_Unsigned
debug_info_size
Dwarf_Unsigned
debug_abbrev_size
Dwarf_Unsigned
debug_line_size
Dwarf_Unsigned
debug_loc_size
Dwarf_Unsigned
debug_aranges_size
Dwarf_Unsigned
debug_macinfo_size
Dwarf_Unsigned
debug_pubnames_size
Dwarf_Unsigned
debug_str_size
Dwarf_Unsigned
debug_frame_size
Dwarf_Unsigned
debug_ranges_size
Dwarf_Unsigned
debug_typenames_size
Dwarf_Unsigned
debug_types_size
Dwarf_Unsigned
debug_macro_size
Dwarf_Unsigned
debug_str_offsets_size
Dwarf_Unsigned
debug_sup_size
Dwarf_Unsigned
debug_cu_index_size
Dwarf_Unsigned
debug_tu_index_size
Dwarf_Unsigned
debug_names_size
Dwarf_Unsigned
debug_loclists_size
Dwarf_Unsigned
debug_rnglists_size
if
debug_info_size
debug_info_size
dbg
de_debug_info
dss_size
if
debug_abbrev_size
debug_abbrev_size
dbg
de_debug_abbrev
dss_size
if
debug_line_size
debug_line_size
dbg
de_debug_line
dss_size
if
debug_loc_size
debug_loc_size
dbg
de_debug_loc
dss_size
if
debug_aranges_size
debug_aranges_size
dbg
de_debug_aranges
dss_size
if
debug_macinfo_size
debug_macinfo_size
dbg
de_debug_macinfo
dss_size
if
debug_pubnames_size
debug_pubnames_size
dbg
de_debug_pubnames
dss_size
if
debug_str_size
debug_str_size
dbg
de_debug_str
dss_size
if
debug_frame_size
debug_frame_size
dbg
de_debug_frame
dss_size
if
debug_ranges_size
debug_ranges_size
dbg
de_debug_ranges
dss_size
if
debug_typenames_size
debug_typenames_size
dbg
de_debug_typenames
dss_size
if
debug_types_size
debug_types_size
dbg
de_debug_types
dss_size
if
debug_macro_size
debug_macro_size
dbg
de_debug_macro
dss_size
if
debug_str_offsets_size
debug_str_offsets_size
dbg
de_debug_str_offsets
dss_size
if
debug_sup_size
debug_sup_size
dbg
de_debug_sup
dss_size
if
debug_cu_index_size
debug_cu_index_size
dbg
de_debug_cu_index
dss_size
if
debug_tu_index_size
debug_tu_index_size
dbg
de_debug_tu_index
dss_size
if
debug_names_size
debug_names_size
dbg
de_debug_names
dss_size
if
debug_loclists_size
debug_loclists_size
dbg
de_debug_loclists
dss_size
if
debug_rnglists_size
debug_rnglists_size
dbg
de_debug_rnglists
dss_size
return
DW_DLV_OK
Given
a
section
name
get
its
size
and
address
int
dwarf_get_section_info_by_name
Dwarf_Debug
dbg
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
struct
Dwarf_Obj_Access_Section_s
doas
struct
Dwarf_Obj_Access_Interface_s
obj
Dwarf_Unsigned
section_count
Dwarf_Half
section_index
section_addr
section_size
obj
dbg
de_obj_file
if
NULL
obj
return
DW_DLV_NO_ENTRY
section_count
obj
methods
get_section_count
obj
object
We
can
skip
index
when
considering
ELF
files
but
not
other
object
types
for
section_index
section_index
section_count
section_index
int
err
int
res
obj
methods
get_section_info
obj
object
section_index
if
res
DW_DLV_ERROR
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
if
strcmp
section_name
doas
name
section_addr
doas
addr
section_size
doas
size
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
Given
a
section
index
get
its
size
and
address
int
dwarf_get_section_info_by_index
Dwarf_Debug
dbg
int
section_index
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
section_addr
section_size
section_name
NULL
Check
if
we
have
a
valid
section
index
if
section_index
section_index
dwarf_get_section_count
dbg
int
res
int
err
struct
Dwarf_Obj_Access_Section_s
doas
struct
Dwarf_Obj_Access_Interface_s
obj
dbg
de_obj_file
if
NULL
obj
return
DW_DLV_NO_ENTRY
res
obj
methods
get_section_info
obj
object
section_index
if
res
DW_DLV_ERROR
DWARF_DBG_ERROR
dbg
err
DW_DLV_ERROR
section_addr
doas
addr
section_size
doas
size
section_name
doas
name
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
Get
section
count
int
dwarf_get_section_count
Dwarf_Debug
dbg
struct
Dwarf_Obj_Access_Interface_s
obj
dbg
de_obj_file
if
NULL
obj
return
DW_DLV_NO_ENTRY
return
obj
methods
get_section_count
obj
object
Dwarf_Cmdline_Options
dwarf_cmdline_options
FALSE
Use
quiet
mode
by
default
Lets
libdwarf
reflect
a
command
line
option
so
we
can
get
details
of
some
errors
printed
using
libdwarf
internal
information
void
dwarf_record_cmdline_options
Dwarf_Cmdline_Options
options
dwarf_cmdline_options
options
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_util
h
define
MORE_BYTES
define
DATA_MASK
define
DIGIT_WIDTH
define
SIGN_BIT
Note
that
with
make
check
many
of
the
test
items
only
make
sense
if
Dwarf_Unsigned
and
Dwarf_Signed
are
bits
The
encode
decode
logic
should
be
fine
whether
those
types
are
or
bits
See
runtests
sh
The
encode
decode
functions
here
are
public
bytes
of
leb
bits
each
part
of
the
number
gives
room
for
a
number
While
any
number
of
leading
zeroes
would
be
legal
so
no
max
is
really
truly
required
here
why
would
a
compiler
generate
leading
zeros
for
unsigned
leb
That
would
seem
strange
except
in
rare
circumstances
a
compiler
may
want
for
overall
alignment
to
add
extra
bytes
So
we
allow
more
than
as
it
is
legal
for
a
compiler
to
generate
an
leb
with
correct
but
useless
trailing
zero
bytes
note
the
interaction
with
sign
in
the
signed
case
The
value
of
BYTESLEBMAX
is
arbitrary
but
allows
catching
corrupt
data
before
dark
Before
April
BYTESLEBMAX
was
define
BYTESLEBMAX
define
BITSPERBYTE
Decode
SLEB
with
checking
int
dwarf_decode_leb128
char
leb128
Dwarf_Unsigned
leb128_length
Dwarf_Unsigned
outval
char
endptr
unsigned
byte
Dwarf_Unsigned
word_number
Dwarf_Unsigned
number
size_t
shift
The
byte_length
value
will
be
a
small
non
negative
integer
unsigned
byte_length
if
leb128
endptr
return
DW_DLV_ERROR
The
following
unrolls
the
loop
for
the
first
two
bytes
and
unpacks
into
bits
to
make
this
as
fast
as
possible
word_number
is
assumed
big
enough
that
the
shift
has
a
defined
result
byte
leb128
if
byte
if
leb128_length
leb128_length
outval
byte
return
DW_DLV_OK
else
unsigned
byte2
if
leb128
endptr
return
DW_DLV_ERROR
byte2
leb128
if
byte2
if
leb128_length
leb128_length
word_number
byte
word_number
byte2
outval
word_number
return
DW_DLV_OK
Gets
messy
to
hand
inline
more
byte
checking
The
rest
handles
long
numbers
Because
the
number
may
be
larger
than
the
default
int
unsigned
we
must
cast
the
byte
before
the
shift
for
the
shift
to
have
a
defined
result
number
shift
byte_length
for
unsigned
b
byte
if
shift
sizeof
number
BITSPERBYTE
Shift
is
large
Maybe
corrupt
value
maybe
some
padding
high
end
byte
zeroes
that
we
can
ignore
if
b
byte_length
if
byte_length
BYTESLEBMAX
Erroneous
input
if
leb128_length
leb128_length
BYTESLEBMAX
return
DW_DLV_ERROR
leb128
shift
cannot
overflow
as
BYTESLEBMAX
is
not
a
large
value
shift
if
leb128
endptr
return
DW_DLV_ERROR
byte
leb128
continue
Too
big
corrupt
data
given
the
non
zero
byte
content
return
DW_DLV_ERROR
number
Dwarf_Unsigned
b
shift
if
byte
if
leb128_length
leb128_length
byte_length
outval
number
return
DW_DLV_OK
shift
byte_length
if
byte_length
BYTESLEBMAX
Erroneous
input
if
leb128_length
leb128_length
BYTESLEBMAX
break
leb128
if
leb128
endptr
return
DW_DLV_ERROR
byte
leb128
return
DW_DLV_ERROR
Decode
SLEB
int
dwarf_decode_signed_leb128
char
leb128
Dwarf_Unsigned
leb128_length
Dwarf_Signed
outval
char
endptr
Dwarf_Unsigned
byte
unsigned
int
b
Dwarf_Signed
number
size_t
shift
int
sign
FALSE
The
byte_length
value
will
be
a
small
non
negative
integer
unsigned
byte_length
byte_length
being
the
number
of
bytes
of
data
absorbed
so
far
in
turning
the
leb
into
a
Dwarf_Signed
if
outval
return
DW_DLV_ERROR
if
leb128
endptr
return
DW_DLV_ERROR
byte
leb128
for
b
byte
if
shift
sizeof
number
BITSPERBYTE
Shift
is
large
Maybe
corrupt
value
maybe
some
padding
high
end
byte
zeroes
that
we
can
ignore
but
notice
sign
bit
from
the
last
usable
byte
sign
b
if
byte
byte
The
value
is
complete
break
if
b
byte_length
if
byte_length
BYTESLEBMAX
Erroneous
input
if
leb128_length
leb128_length
BYTESLEBMAX
return
DW_DLV_ERROR
leb128
shift
cannot
overflow
as
BYTESLEBMAX
is
not
a
large
value
shift
if
leb128
endptr
return
DW_DLV_ERROR
byte
leb128
continue
Too
big
corrupt
data
given
the
non
zero
byte
content
return
DW_DLV_ERROR
This
bit
of
the
last
most
significant
useful
byte
indicates
sign
sign
b
number
Dwarf_Unsigned
b
shift
shift
if
byte
break
leb128
if
leb128
endptr
return
DW_DLV_ERROR
byte
leb128
byte_length
if
byte_length
BYTESLEBMAX
Erroneous
input
if
leb128_length
leb128_length
BYTESLEBMAX
return
DW_DLV_ERROR
if
sign
The
following
avoids
undefined
behavior
unsigned
shiftlim
sizeof
Dwarf_Signed
BITSPERBYTE
if
shift
shiftlim
Dwarf_Signed
y
Dwarf_Signed
Dwarf_Unsigned
shift
Dwarf_Signed
x
y
number
x
else
if
shift
shiftlim
Dwarf_Signed
x
Dwarf_Unsigned
shift
number
x
else
trailing
zeroes
case
Dwarf_Signed
x
Dwarf_Unsigned
shiftlim
number
x
if
leb128_length
leb128_length
byte_length
outval
number
return
DW_DLV_OK
Encode
val
as
a
uleb128
This
encodes
it
as
an
unsigned
number
Return
DW_DLV_ERROR
or
DW_DLV_OK
space
to
write
leb
number
is
provided
by
caller
with
caller
passing
length
number
of
bytes
used
returned
thru
nbytes
arg
int
dwarf_encode_leb128
Dwarf_Unsigned
val
int
nbytes
char
space
int
splen
char
a
char
end
space
splen
a
space
do
unsigned
char
uc
if
a
end
return
DW_DLV_ERROR
uc
val
DATA_MASK
val
DIGIT_WIDTH
if
val
uc
MORE_BYTES
a
uc
a
while
val
nbytes
int
a
space
return
DW_DLV_OK
int
dwarf_encode_signed_leb128
Dwarf_Signed
value
int
nbytes
char
space
int
splen
char
str
Dwarf_Signed
sign
value
int
more
char
end
space
splen
str
space
do
unsigned
char
byte
value
DATA_MASK
value
DIGIT_WIDTH
if
str
end
return
DW_DLV_ERROR
Remaining
chunks
would
just
contain
the
sign
bit
and
this
chunk
has
already
captured
at
least
one
sign
bit
if
value
sign
byte
SIGN_BIT
sign
SIGN_BIT
more
else
byte
MORE_BYTES
str
byte
str
while
more
nbytes
int
str
space
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
Google
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_line
h
include
dwarfstring
h
include
dwarf_debuglink
h
Line
Register
Set
initial
conditions
static
struct
Dwarf_Line_Registers_s
_dwarf_line_table_regs_default_values
Dwarf_Addr
lr_address
Dwarf_Unsigned
lr_file
Dwarf_Unsigned
lr_line
Dwarf_Unsigned
lr_column
Dwarf_Bool
lr_is_stmt
false
Dwarf_Bool
lr_basic_block
false
Dwarf_Bool
lr_end_sequence
false
Dwarf_Bool
lr_prologue_end
false
Dwarf_Bool
lr_epilogue_begin
false
Dwarf_Small
lr_isa
Dwarf_Unsigned
lr_op_index
Dwarf_Unsigned
lr_discriminator
Dwarf_Unsigned
lr_call_context
Dwarf_Unsigned
lr_subprogram
void
_dwarf_set_line_table_regs_default_values
Dwarf_Line_Registers
regs
UNUSEDARG
unsigned
lineversion
Dwarf_Bool
is_stmt
regs
_dwarf_line_table_regs_default_values
if
lineversion
DW_LINE_VERSION5
In
DWARF5
change
the
default
this
way
We
are
ignoring
the
DWARF5
Section
considering
a
special
value
meaning
no
file
The
DWARF5
standard
is
self
contradictory
on
this
considered
as
a
whole
So
with
default
and
numbering
files
from
things
work
ok
regs
lr_file
regs
lr_is_stmt
is_stmt
Detect
Windows
full
paths
as
well
as
Unix
Linux
ASSERT
fname
NULL
Dwarf_Bool
_dwarf_file_name_is_full_path
Dwarf_Small
fname
Dwarf_Small
firstc
fname
Not
relative
path
if
path
begins
with
UNC
path
path
begins
with
with
being
a
letter
path
bagins
with
see
https
docs
microsoft
com
en
us
windows
win32
fileio
naming
a
file
paths
if
firstc
return
FALSE
if
firstc
return
TRUE
if
firstc
return
TRUE
We
assume
anything
starting
with
c
etc
is
a
genuine
Windows
name
That
turns
out
to
be
important
as
we
dump
PE
objects
on
linux
It
s
safe
too
as
a
specially
crafted
file
might
have
add
path
output
but
would
not
break
anything
if
firstc
a
firstc
z
firstc
A
firstc
Z
if
fname
Some
test
cases
use
some
if
fname
return
TRUE
if
fname
return
TRUE
This
is
a
relative
path
to
the
current
directory
on
the
drive
named
Windows
has
a
current
directory
with
each
drive
letter
in
use
return
FALSE
include
dwarf_line_table_reader_common
h
With
this
routine
we
ensure
the
file
full
path
is
calculated
identically
for
dwarf_srcfiles
and
dwarf_filename
As
of
March
this
always
does
an
allocation
for
the
string
dwarf_dealloc
is
crucial
to
do
no
matter
what
So
we
have
consistency
dwarf_finish
will
do
the
dealloc
if
nothing
else
does
Unless
the
calling
application
did
the
call
dwarf_set_de_alloc_flag
_dwarf_pathjoinl
takes
care
of
and
Windows
static
int
create_fullest_file_path
Dwarf_Debug
dbg
Dwarf_File_Entry
fe
Dwarf_Line_Context
line_context
char
name_ptr_out
Dwarf_Error
error
Dwarf_Unsigned
dirno
char
full_name
char
file_name
Large
enough
that
almost
never
will
any
malloc
be
needed
by
dwarfstring
Arbitrary
size
static
char
targbuf
static
char
nbuf
dwarfstring
targ
dwarfstring
nxt
unsigned
linetab_version
line_context
lc_version_number
dirno
fe
fi_dir_index
file_name
char
fe
fi_file_name
if
file_name
_dwarf_error
dbg
error
DW_DLE_NO_FILE_NAME
return
DW_DLV_ERROR
if
_dwarf_file_name_is_full_path
Dwarf_Small
file_name
char
tmp
dwarfstring_constructor_static
targbuf
sizeof
targbuf
dwarfstring_constructor_static
nbuf
sizeof
nbuf
dwarfstring_append
file_name
_dwarf_pathjoinl
tmp
char
_dwarf_get_alloc
dbg
DW_DLA_STRING
dwarfstring_strlen
if
tmp
strcpy
tmp
dwarfstring_string
name_ptr_out
tmp
dwarfstring_destructor
dwarfstring_destructor
return
DW_DLV_OK
dwarfstring_destructor
dwarfstring_destructor
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
int
need_dir
FALSE
unsigned
include_dir_offset
static
char
compdirbuf
static
char
incdirbuf
static
char
filenamebuf
dwarfstring
compdir
dwarfstring
incdir
dwarfstring
filename
dwarfstring_constructor_static
targbuf
sizeof
targbuf
dwarfstring_constructor_static
compdirbuf
sizeof
compdirbuf
dwarfstring_constructor_static
incdirbuf
sizeof
incdirbuf
dwarfstring_constructor_static
filenamebuf
sizeof
filenamebuf
if
line_context
lc_compilation_directory
char
comp_dir_name
char
line_context
lc_compilation_directory
dwarfstring_append
comp_dir_name
if
dirno
line_context
lc_include_directories_count
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
_dwarf_error
dbg
error
DW_DLE_INCL_DIR_NUM_BAD
return
DW_DLV_ERROR
if
linetab_version
DW_LINE_VERSION5
include_dir_offset
need_dir
TRUE
else
if
dirno
fe
fi_dir_index
include_dir_offset
need_dir
TRUE
if
need_dir
char
inc_dir_name
char
line_context
lc_include_directories
fe
fi_dir_index
include_dir_offset
if
inc_dir_name
This
should
never
ever
happen
except
in
case
of
a
corrupted
object
file
inc_dir_name
erroneous
NULL
include
dir
pointer
dwarfstring_append
inc_dir_name
dwarfstring_append
file_name
if
dwarfstring_strlen
_dwarf_file_name_is_full_path
Dwarf_Small
dwarfstring_string
_dwarf_pathjoinl
_dwarf_pathjoinl
else
if
dwarfstring_strlen
_dwarf_pathjoinl
if
dwarfstring_strlen
_dwarf_pathjoinl
_dwarf_pathjoinl
full_name
char
_dwarf_get_alloc
dbg
DW_DLA_STRING
dwarfstring_strlen
if
full_name
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
strcpy
full_name
dwarfstring_string
name_ptr_out
full_name
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
return
DW_DLV_OK
static
void
report_bogus_stmt_list_form
Dwarf_Debug
dbg
Dwarf_Half
attrform
Dwarf_Error
error
dwarfstring
m
dwarfstring
f
const
char
formname
dwarfstring_constructor
dwarf_get_FORM_name
attrform
if
formname
dwarfstring_append_printf_u
Invalid
Form
Code
DW_PR_DUx
attrform
else
dwarfstring_append
char
formname
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_LINE_OFFSET_WRONG_FORM
form
s
instead
of
an
allowed
section
offset
form
dwarfstring_string
_dwarf_error_string
dbg
error
DW_DLE_LINE_OFFSET_WRONG_FORM
dwarfstring_string
dwarfstring_destructor
dwarfstring_destructor
Although
source
files
is
supposed
to
return
the
source
files
in
the
compilation
unit
it
does
not
look
for
any
in
the
statement
program
In
other
words
it
ignores
those
defined
using
the
extended
opcode
DW_LNE_define_file
We
do
not
know
of
a
producer
that
uses
DW_LNE_define_file
In
DWARF2
the
array
of
sourcefiles
is
represented
differently
than
DWARF5
DWARF
and
experimental
line
table
Subtract
from
the
DW_AT_decl_file
etc
to
index
into
the
array
of
names
zero
means
there
is
no
file
DWARF
DW_AT_decl_file
etc
numbers
should
be
directly
used
to
index
into
the
array
of
names
Do
not
subtract
anything
For
further
information
see
the
discussion
of
dwarf_srcfiles
in
libdwarf2
pdf
version
and
later
Section
around
page
int
dwarf_srcfiles
Dwarf_Die
die
char
srcfiles
Dwarf_Signed
srcfilecount
Dwarf_Error
error
This
pointer
is
used
to
scan
the
portion
of
the
debug_line
section
for
the
current
cu
Dwarf_Small
line_ptr
Pointer
to
a
DW_AT_stmt_list
attribute
in
case
it
exists
in
the
die
Dwarf_Attribute
stmt_list_attr
const
char
const_comp_name
Pointer
to
name
of
compilation
directory
const
char
const_comp_dir
Dwarf_Small
comp_dir
Offset
into
debug_line
specified
by
a
DW_AT_stmt_list
attribute
Dwarf_Unsigned
line_offset
This
points
to
a
block
of
char
s
each
of
which
points
to
a
file
name
char
ret_files
The
Dwarf_Debug
this
die
belongs
to
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Line_Context
line_context
Used
to
chain
the
file
names
Dwarf_Chain
curr_chain
NULL
Dwarf_Chain
prev_chain
NULL
Dwarf_Chain
head_chain
NULL
Dwarf_Half
attrform
int
resattr
DW_DLV_ERROR
int
lres
DW_DLV_ERROR
unsigned
i
int
res
DW_DLV_ERROR
Dwarf_Small
section_start
BEGIN
CODE
Reset
error
if
error
NULL
error
NULL
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dbg
context
cc_dbg
resattr
dwarf_attr
die
DW_AT_stmt_list
error
if
resattr
DW_DLV_OK
return
resattr
if
dbg
de_debug_line
dss_index
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_DEBUG_LINE_NULL
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_line
error
if
res
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
res
if
dbg
de_debug_line
dss_size
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
DW_DLV_NO_ENTRY
section_start
dbg
de_debug_line
dss_data
lres
dwarf_whatform
stmt_list_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
if
attrform
DW_FORM_addr
Dwarf_Addr
addr
DW_AT_producer
Based
on
Apple
Inc
build
LLVM
build
generated
DW_FORM_addr
for
DW_AT_stmt_list
lres
dwarf_formaddr
stmt_list_attr
error
if
lres
DW_DLV_OK
if
lres
DW_DLV_ERROR
report_bogus_stmt_list_form
dbg
attrform
error
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
line_offset
Dwarf_Unsigned
addr
else
if
attrform
DW_FORM_data4
attrform
DW_FORM_data8
attrform
DW_FORM_sec_offset
attrform
DW_FORM_GNU_ref_alt
report_bogus_stmt_list_form
dbg
attrform
error
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
DW_DLV_ERROR
else
standard
setup
lres
dwarf_global_formref
stmt_list_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
if
line_offset
dbg
de_debug_line
dss_size
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
line_ptr
dbg
de_debug_line
dss_data
line_offset
Dwarf_Unsigned
fission_offset
Dwarf_Unsigned
fission_size
int
resl
_dwarf_get_fission_addition_die
die
DW_SECT_LINE
error
if
resl
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
resl
line_ptr
fission_offset
if
line_ptr
dbg
de_debug_line
dss_data
dbg
de_debug_line
dss_size
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_FISSION_ADDITION_ERROR
return
DW_DLV_ERROR
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
stmt_list_attr
resattr
_dwarf_internal_get_die_comp_dir
die
error
if
resattr
DW_DLV_ERROR
return
resattr
Horrible
cast
away
const
to
match
historical
interfaces
comp_dir
Dwarf_Small
const_comp_dir
line_context
Dwarf_Line_Context
_dwarf_get_alloc
dbg
DW_DLA_LINE_CONTEXT
if
line_context
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
line_context
lc_new_style_access
false
We
are
in
dwarf_srcfiles
Dwarf_Small
line_ptr_out
int
dres
dres
_dwarf_read_line_table_header
dbg
context
section_start
line_ptr
dbg
de_debug_line
dss_size
line_context
NULL
NULL
error
if
dres
DW_DLV_ERROR
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
line_context
return
dres
if
dres
DW_DLV_NO_ENTRY
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
line_context
return
dres
For
DWARF5
use
of
DW_AT_comp_dir
not
needed
Line
table
file
names
and
directories
start
with
comp_dir
and
name
line_context
lc_compilation_directory
comp_dir
We
are
in
dwarf_srcfiles
Dwarf_File_Entry
fe
Dwarf_File_Entry
fe2
line_context
lc_file_entries
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
res
dwarf_srclines_files_indexes
line_context
error
if
res
DW_DLV_OK
return
res
for
i
baseindex
i
endindex
i
fe2
fe
fi_next
int
sres
char
name_out
fe
fe2
sres
create_fullest_file_path
dbg
fe
line_context
error
if
sres
DW_DLV_OK
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
This
can
leak
some
strings
return
sres
curr_chain
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_chain
NULL
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_chain
ch_item
name_out
if
head_chain
NULL
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
if
head_chain
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
srcfiles
NULL
srcfilecount
return
DW_DLV_NO_ENTRY
We
are
in
dwarf_srcfiles
if
line_context
lc_file_entry_count
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
srcfiles
NULL
srcfilecount
return
DW_DLV_NO_ENTRY
ret_files
char
_dwarf_get_alloc
dbg
DW_DLA_LIST
line_context
lc_file_entry_count
if
ret_files
NULL
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_chain
head_chain
for
i
i
line_context
lc_file_entry_count
i
ret_files
i
curr_chain
ch_item
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
Our
chain
is
not
recorded
in
the
line_context
so
the
line_context
destructor
will
not
destroy
our
list
of
strings
or
our
strings
Our
caller
has
to
do
the
deallocations
srcfiles
ret_files
srcfilecount
line_context
lc_file_entry_count
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
return
DW_DLV_OK
Return
DW_DLV_OK
if
ok
else
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
doaddrs
is
true
iff
this
is
being
called
for
SGI
IRIX
rqs
processing
ie
not
a
normal
libdwarf
dwarf_srclines
or
two
level
user
call
at
all
dolines
is
true
iff
this
is
called
by
a
dwarf_srclines
call
In
case
of
error
or
NO_ENTRY
in
this
code
we
use
the
dwarf_srcline_dealloc
line_context
and
dealloc
of
DW_DLA_LINE_CONTEXT
from
the
new
interface
for
uniformity
here
int
_dwarf_internal_srclines
Dwarf_Die
die
Dwarf_Bool
is_new_interface
Dwarf_Unsigned
version
Dwarf_Small
table_count
returns
or
Dwarf_Line_Context
line_context_out
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Bool
doaddrs
Dwarf_Bool
dolines
Dwarf_Error
error
This
pointer
is
used
to
scan
the
portion
of
the
debug_line
section
for
the
current
cu
Dwarf_Small
line_ptr
This
points
to
the
last
byte
of
the
debug_line
portion
for
the
current
cu
Dwarf_Small
line_ptr_end
For
two
level
line
tables
this
points
to
the
first
byte
of
the
actuals
table
and
the
end
of
the
logicals
table
for
the
current
cu
Dwarf_Small
line_ptr_actuals
Dwarf_Small
section_start
Dwarf_Small
section_end
Pointer
to
a
DW_AT_stmt_list
attribute
in
case
it
exists
in
the
die
Dwarf_Attribute
stmt_list_attr
const
char
const_comp_name
Pointer
to
name
of
compilation
directory
const
char
const_comp_dir
NULL
Dwarf_Small
comp_dir
NULL
Offset
into
debug_line
specified
by
a
DW_AT_stmt_list
attribute
Dwarf_Unsigned
line_offset
Pointer
to
a
Dwarf_Line_Context_s
structure
that
contains
the
context
such
as
file
names
and
include
directories
for
the
set
of
lines
being
generated
This
is
always
recorded
on
an
DW_LNS_end_sequence
operator
on
all
special
opcodes
and
on
DW_LNS_copy
Dwarf_Line_Context
line_context
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
fission_offset
The
Dwarf_Debug
this
die
belongs
to
Dwarf_Debug
dbg
int
resattr
DW_DLV_ERROR
int
lres
DW_DLV_ERROR
Dwarf_Half
address_size
Dwarf_Small
orig_line_ptr
int
res
DW_DLV_ERROR
BEGIN
CODE
if
error
NULL
error
NULL
CHECK_DIE
die
DW_DLV_ERROR
cu_context
die
di_cu_context
dbg
cu_context
cc_dbg
res
_dwarf_load_section
dbg
de_debug_line
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_line
dss_size
return
DW_DLV_NO_ENTRY
address_size
_dwarf_get_address_size
dbg
die
resattr
dwarf_attr
die
DW_AT_stmt_list
error
if
resattr
DW_DLV_OK
return
resattr
lres
dwarf_global_formref
stmt_list_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
if
line_offset
dbg
de_debug_line
dss_size
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
section_start
dbg
de_debug_line
dss_data
section_end
section_start
dbg
de_debug_line
dss_size
Dwarf_Unsigned
fission_size
int
resf
_dwarf_get_fission_addition_die
die
DW_SECT_LINE
error
if
resf
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
resf
line_ptr
fission_offset
if
line_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_FISSION_ADDITION_ERROR
return
DW_DLV_ERROR
section_start
dbg
de_debug_line
dss_data
section_end
section_start
dbg
de_debug_line
dss_size
orig_line_ptr
section_start
line_offset
fission_offset
line_ptr
orig_line_ptr
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
if
line_offset
fission_offset
dbg
de_debug_line
dss_size
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
line_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
If
die
has
DW_AT_comp_dir
attribute
get
the
string
that
names
the
compilation
directory
resattr
_dwarf_internal_get_die_comp_dir
die
error
if
resattr
DW_DLV_ERROR
return
resattr
Horrible
cast
to
match
historic
interfaces
comp_dir
Dwarf_Small
const_comp_dir
line_context
Dwarf_Line_Context
_dwarf_get_alloc
dbg
DW_DLA_LINE_CONTEXT
if
line_context
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
line_context
lc_new_style_access
is_new_interface
line_context
lc_compilation_directory
comp_dir
We
are
in
dwarf_internal_srclines
Dwarf_Small
newlinep
int
resp
_dwarf_read_line_table_header
dbg
cu_context
section_start
line_ptr
dbg
de_debug_line
dss_size
line_context
NULL
NULL
error
if
resp
DW_DLV_ERROR
if
is_new_interface
dwarf_srclines_dealloc_b
line_context
else
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
return
resp
if
resp
DW_DLV_NO_ENTRY
if
is_new_interface
dwarf_srclines_dealloc_b
line_context
else
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
return
resp
line_ptr_end
line_context
lc_line_ptr_end
line_ptr
newlinep
if
line_context
lc_actuals_table_offset
line_ptr_actuals
line_context
lc_line_prologue_start
line_context
lc_actuals_table_offset
if
line_ptr_actuals
ASSERT
lc_table_count
or
lc_table_count
int
err_count_out
Normal
style
single
level
line
table
Dwarf_Bool
is_actuals_table
false
Dwarf_Bool
local_is_single_table
true
res
read_line_table_program
dbg
line_ptr
line_ptr_end
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
local_is_single_table
is_actuals_table
error
if
res
DW_DLV_OK
if
is_new_interface
dwarf_srclines_dealloc_b
line_context
else
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
return
res
if
linebuf
linebuf
line_context
lc_linebuf_logicals
if
linecount
linecount
line_context
lc_linecount_logicals
if
linebuf_actuals
linebuf_actuals
NULL
if
linecount_actuals
linecount_actuals
else
Dwarf_Bool
is_actuals_table
false
Dwarf_Bool
local2_is_single_table
false
int
err_count_out
line_context
lc_is_single_table
false
Two
level
line
table
First
read
the
logicals
table
res
read_line_table_program
dbg
line_ptr
line_ptr_actuals
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
local2_is_single_table
is_actuals_table
error
if
res
DW_DLV_OK
if
is_new_interface
dwarf_srclines_dealloc_b
line_context
else
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
return
res
if
linebuf
linebuf
line_context
lc_linebuf_logicals
else
if
linecount
linecount
line_context
lc_linecount_logicals
if
is_new_interface
ASSERT
linebuf_actuals
NULL
is_actuals_table
true
The
call
requested
an
actuals
table
and
one
is
present
So
now
read
that
one
res
read_line_table_program
dbg
line_ptr_actuals
line_ptr_end
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
local2_is_single_table
is_actuals_table
error
if
res
DW_DLV_OK
dwarf_srclines_dealloc_b
line_context
return
res
if
linebuf_actuals
linebuf_actuals
line_context
lc_linebuf_actuals
if
linecount_actuals
NULL
linecount_actuals
line_context
lc_linecount_actuals
if
is_new_interface
linecount
linecount
linecount
linecount_actuals
linecount_actuals
Here
we
have
no
actual
lines
of
any
kind
In
other
words
it
looks
like
a
debugfission
line
table
skeleton
or
a
caller
not
prepared
for
skeletons
or
two
level
reading
In
that
case
there
are
no
line
entries
so
the
context
had
nowhere
to
be
recorded
Hence
we
have
to
delete
it
else
we
would
leak
the
context
dwarf_dealloc
dbg
line_context
DW_DLA_LINE_CONTEXT
line_context
return
DW_DLV_OK
table_count
line_context
lc_table_count
if
version
NULL
version
line_context
lc_version_number
line_context_out
line_context
return
DW_DLV_OK
int
dwarf_get_ranges_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
struct
Dwarf_Section_s
sec
if
error
NULL
error
NULL
sec
de_debug_ranges
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
section_name_out
sec
dss_name
return
DW_DLV_OK
int
dwarf_get_aranges_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
struct
Dwarf_Section_s
sec
if
error
NULL
error
NULL
sec
de_debug_aranges
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
section_name_out
sec
dss_name
return
DW_DLV_OK
int
dwarf_get_line_section_name_from_die
Dwarf_Die
die
const
char
section_name_out
Dwarf_Error
error
The
Dwarf_Debug
this
die
belongs
to
Dwarf_Debug
dbg
struct
Dwarf_Section_s
sec
BEGIN
CODE
if
error
error
NULL
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
sec
de_debug_line
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
section_name_out
sec
dss_name
return
DW_DLV_OK
int
dwarf_get_string_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
struct
Dwarf_Section_s
sec
BEGIN
CODE
if
error
NULL
error
NULL
sec
de_debug_str
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
section_name_out
sec
dss_name
return
DW_DLV_OK
int
dwarf_srclines_two_level
Dwarf_Die
die
Dwarf_Unsigned
version
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Error
error
Dwarf_Line_Context
line_context
Dwarf_Small
table_count
Dwarf_Bool
is_new_interface
false
int
res
_dwarf_internal_srclines
die
is_new_interface
version
linebuf
linecount
linebuf_actuals
linecount_actuals
addrlist
false
linelist
true
error
return
res
New
October
int
dwarf_srclines_b
Dwarf_Die
die
Dwarf_Unsigned
version_out
Dwarf_Small
table_count
Dwarf_Line_Context
line_context
Dwarf_Error
error
Dwarf_Signed
linecount_actuals
Dwarf_Line
linebuf
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount
Dwarf_Bool
is_new_interface
true
int
res
Dwarf_Unsigned
tcount
res
_dwarf_internal_srclines
die
is_new_interface
version_out
table_count
line_context
addrlist
false
linelist
true
error
if
res
DW_DLV_OK
line_context
lc_new_style_access
true
if
linecount_actuals
tcount
if
linecount
tcount
table_count
tcount
return
res
New
October
int
dwarf_srclines_from_linecontext
Dwarf_Line_Context
line_context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Error
error
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
line_context
lc_new_style_access
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
linebuf
line_context
lc_linebuf_logicals
linecount
line_context
lc_linecount_logicals
return
DW_DLV_OK
New
October
int
dwarf_srclines_two_level_from_linecontext
Dwarf_Line_Context
line_context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Error
error
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
line_context
lc_new_style_access
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
linebuf
line_context
lc_linebuf_logicals
linecount
line_context
lc_linecount_logicals
linebuf_actuals
line_context
lc_linebuf_actuals
linecount_actuals
line_context
lc_linecount_actuals
return
DW_DLV_OK
New
October
int
dwarf_srclines_table_offset
Dwarf_Line_Context
line_context
Dwarf_Unsigned
offset
Dwarf_Error
error
if
line_context
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
offset
line_context
lc_section_offset
return
DW_DLV_OK
New
October
If
the
CU
DIE
has
no
DW_AT_comp_dir
then
the
pointer
pushed
back
to
compilation_directory
will
be
NULL
For
DWARF5
the
line
table
header
has
the
compilation
directory
int
dwarf_srclines_comp_dir
Dwarf_Line_Context
line_context
const
char
compilation_directory
Dwarf_Error
error
if
line_context
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
compilation_directory
const
char
line_context
lc_compilation_directory
return
DW_DLV_OK
New
October
int
dwarf_srclines_subprog_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count_out
Dwarf_Error
error
if
line_context
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
count_out
line_context
lc_subprogs_count
return
DW_DLV_OK
New
October
Index
says
which
to
return
Valid
indexes
are
lc_subprogs_count
int
dwarf_srclines_subprog_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index_in
const
char
name
Dwarf_Unsigned
decl_file
Dwarf_Unsigned
decl_line
Dwarf_Error
error
Negative
values
not
sensible
Leaving
traditional
signed
interfaces
Dwarf_Unsigned
index
Dwarf_Unsigned
index_in
Dwarf_Subprog_Entry
sub
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
if
index
index
line_context
lc_subprogs_count
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_INDEX_WRONG
return
DW_DLV_ERROR
sub
line_context
lc_subprogs
index
name
const
char
sub
ds_subprog_name
decl_file
sub
ds_decl_file
decl_line
sub
ds_decl_line
return
DW_DLV_OK
New
October
See
also
dwarf_srclines_files_indexes
int
dwarf_srclines_files_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count_out
Dwarf_Error
error
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
Negative
values
not
sensible
Leaving
traditional
signed
interfaces
count_out
Dwarf_Signed
line_context
lc_file_entry_count
return
DW_DLV_OK
New
March
making
iteration
through
file
names
int
dwarf_srclines_files_indexes
Dwarf_Line_Context
line_context
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
Dwarf_Error
error
if
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
baseindex
line_context
lc_file_entry_baseindex
file_count
line_context
lc_file_entry_count
endindex
line_context
lc_file_entry_endindex
return
DW_DLV_OK
New
March
adding
DWARF5
data
int
dwarf_srclines_files_data_b
Dwarf_Line_Context
line_context
Dwarf_Signed
index_in
const
char
name
Dwarf_Unsigned
directory_index
Dwarf_Unsigned
last_mod_time
Dwarf_Unsigned
file_length
Dwarf_Form_Data16
data16ptr
Dwarf_Error
error
Dwarf_File_Entry
fi
Dwarf_Signed
i
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
Negative
values
not
sensible
Leaving
traditional
signed
interfaces
Dwarf_Signed
index
index_in
int
res
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
Special
accomodation
of
the
special
gnu
experimental
version
number
a
high
number
so
we
cannot
just
say
or
greater
This
is
awkward
but
at
least
if
there
is
a
version
or
later
it
still
allows
the
experimental
table
res
dwarf_srclines_files_indexes
line_context
error
if
res
DW_DLV_OK
return
res
fi
line_context
lc_file_entries
if
index
baseindex
index
endindex
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_INDEX_WRONG
return
DW_DLV_ERROR
for
i
baseindex
i
index
i
fi
fi
fi_next
if
fi
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_HEADER_CORRUPT
return
DW_DLV_ERROR
if
name
name
const
char
fi
fi_file_name
if
directory_index
directory_index
fi
fi_dir_index
if
last_mod_time
last_mod_time
fi
fi_time_last_mod
if
file_length
file_length
fi
fi_file_length
if
data16ptr
if
fi
fi_md5_present
data16ptr
fi_md5_value
else
data16ptr
return
DW_DLV_OK
New
October
int
dwarf_srclines_include_dir_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
count
line_context
lc_include_directories_count
return
DW_DLV_OK
New
October
int
dwarf_srclines_include_dir_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index_in
const
char
name
Dwarf_Error
error
It
never
made
sense
that
the
srclines
used
a
signed
count
But
that
cannot
be
fixed
in
interfaces
for
compatibility
So
we
adjust
here
Dwarf_Unsigned
index
index_in
unsigned
int
version
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
version
line_context
lc_version_number
if
version
DW_LINE_VERSION5
if
index
line_context
lc_include_directories_count
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_INDEX_WRONG
return
DW_DLV_ERROR
name
const
char
line_context
lc_include_directories
index
else
if
index
index
line_context
lc_include_directories_count
_dwarf_error
line_context
lc_dbg
error
DW_DLE_LINE_CONTEXT_INDEX_WRONG
return
DW_DLV_ERROR
name
const
char
line_context
lc_include_directories
index
return
DW_DLV_OK
New
October
int
dwarf_srclines_version
Dwarf_Line_Context
line_context
Dwarf_Unsigned
version_out
Dwarf_Small
table_count_out
Dwarf_Error
error
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_BOTCH
return
DW_DLV_ERROR
version_out
line_context
lc_version_number
table_count_out
line_context
lc_table_count
return
DW_DLV_OK
Every
line
table
entry
except
DW_DLE_end_sequence
which
is
returned
using
dwarf_lineendsequence
potentially
has
the
begin
statement
flag
marked
on
This
returns
thru
return_bool
the
begin
statement
flag
int
dwarf_linebeginstatement
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
if
line
NULL
return_bool
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
return_bool
line
li_addr_line
li_l_data
li_is_stmt
return
DW_DLV_OK
At
the
end
of
any
contiguous
line
table
there
may
be
a
DW_LNE_end_sequence
operator
This
returns
non
zero
thru
return_bool
if
and
only
if
this
line
entry
was
a
DW_LNE_end_sequence
Within
a
compilation
unit
or
function
there
may
be
multiple
line
tables
each
ending
with
a
DW_LNE_end_sequence
Each
table
describes
a
contiguous
region
Because
compilers
may
split
function
code
up
in
arbitrary
ways
compilers
may
need
to
emit
multiple
contigous
regions
ie
line
tables
for
a
single
function
See
the
DWARF3
spec
section
int
dwarf_lineendsequence
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
return_bool
line
li_addr_line
li_l_data
li_end_sequence
return
DW_DLV_OK
Each
line
entry
has
a
line
number
If
the
entry
is
a
DW_LNE_end_sequence
the
line
number
is
meaningless
see
dwarf_lineendsequence
just
above
int
dwarf_lineno
Dwarf_Line
line
Dwarf_Unsigned
ret_lineno
Dwarf_Error
error
if
line
NULL
ret_lineno
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
ret_lineno
line
li_addr_line
li_l_data
li_line
return
DW_DLV_OK
Each
line
entry
has
a
file
number
an
index
into
the
file
table
If
the
entry
is
a
DW_LNE_end_sequence
the
index
is
meaningless
see
dwarf_lineendsequence
just
above
The
file
number
returned
is
an
index
into
the
file
table
produced
by
dwarf_srcfiles
but
care
is
required
the
li_file
begins
with
for
DWARF2
files
so
that
the
li_file
returned
here
is
greater
than
its
index
into
the
dwarf_srcfiles
output
array
And
entries
from
DW_LNE_define_file
don
t
appear
in
the
dwarf_srcfiles
output
so
file
indexes
from
here
may
exceed
the
size
of
the
dwarf_srcfiles
output
array
size
int
dwarf_line_srcfileno
Dwarf_Line
line
Dwarf_Unsigned
ret_fileno
Dwarf_Error
error
if
line
NULL
ret_fileno
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
li_file
must
be
line
li_context
lc_file_entry_count
else
it
is
trash
li_file
means
not
attributable
to
any
source
file
per
dwarf2
spec
For
DWARF5
li_file
lc_file_entry_count
ret_fileno
line
li_addr_line
li_l_data
li_file
return
DW_DLV_OK
Each
line
entry
has
an
is_addr_set
attribute
If
the
entry
is
a
DW_LNE_set_address
return
TRUE
through
the
is_addr_set
pointer
int
dwarf_line_is_addr_set
Dwarf_Line
line
Dwarf_Bool
is_addr_set
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
is_addr_set
line
li_addr_line
li_l_data
li_is_addr_set
return
DW_DLV_OK
Each
line
entry
has
a
line
address
If
the
entry
is
a
DW_LNE_end_sequence
the
adddress
is
one
beyond
the
last
address
this
contigous
region
covers
so
the
address
is
not
inside
the
region
but
is
just
outside
it
int
dwarf_lineaddr
Dwarf_Line
line
Dwarf_Addr
ret_lineaddr
Dwarf_Error
error
if
line
NULL
ret_lineaddr
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
ret_lineaddr
line
li_address
return
DW_DLV_OK
Each
line
entry
has
a
column
within
line
offset
within
the
line
where
the
source
text
begins
If
the
entry
is
a
DW_LNE_end_sequence
the
line
number
is
meaningless
see
dwarf_lineendsequence
just
above
Lines
of
text
begin
at
column
The
value
means
the
line
begins
at
the
left
edge
of
the
line
See
the
DWARF3
spec
section
So
and
mean
essentially
the
same
thing
dwarf_lineoff_b
is
new
in
December
int
dwarf_lineoff_b
Dwarf_Line
line
Dwarf_Unsigned
ret_lineoff
Dwarf_Error
error
if
line
NULL
ret_lineoff
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
ret_lineoff
line
li_addr_line
li_l_data
li_column
return
DW_DLV_OK
static
int
dwarf_filename
Dwarf_Line_Context
context
Dwarf_Signed
fileno_in
char
ret_filename
Dwarf_Error
error
Dwarf_Signed
i
Dwarf_File_Entry
file_entry
Dwarf_Debug
dbg
context
lc_dbg
int
res
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
Negative
values
not
sensible
Leaving
traditional
signed
interfaces
in
place
Dwarf_Signed
fileno
fileno_in
unsigned
linetab_version
context
lc_version_number
res
dwarf_srclines_files_indexes
context
error
if
res
DW_DLV_OK
return
res
if
fileno
endindex
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_i
DW_DLE_NO_FILE_NAME
the
file
number
is
d
fileno
dwarfstring_append_printf_u
this
is
a
DWARF
x
linetable
linetab_version
dwarfstring_append_printf_i
yet
the
highest
allowed
file
name
index
is
d
endindex
_dwarf_error_string
dbg
error
DW_DLE_NO_FILE_NAME
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
if
linetab_version
DW_LINE_VERSION4
linetab_version
EXPERIMENTAL_LINE_TABLES_VERSION
if
fileno
return
DW_DLV_NO_ENTRY
else
ok
else
DW_LINE_VERSION5
so
file
index
is
fine
file_entry
context
lc_file_entries
zero
fileno
allowed
for
DWARF5
table
For
DWARF4
zero
fileno
handled
above
for
i
baseindex
i
fileno
i
file_entry
file_entry
fi_next
res
create_fullest_file_path
dbg
file_entry
context
ret_filename
error
return
res
int
dwarf_linesrc
Dwarf_Line
line
char
ret_linesrc
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
if
line
li_context
NULL
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_NULL
return
DW_DLV_ERROR
return
dwarf_filename
line
li_context
line
li_addr_line
li_l_data
li_file
ret_linesrc
error
Every
line
table
entry
potentially
has
the
basic
block
start
flag
marked
on
This
returns
thru
return_bool
the
basic
block
start
flag
int
dwarf_lineblock
Dwarf_Line
line
Dwarf_Bool
return_bool
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
return_bool
line
li_addr_line
li_l_data
li_basic_block
return
DW_DLV_OK
We
gather
these
into
one
call
as
it
s
likely
one
will
want
all
or
none
of
them
int
dwarf_prologue_end_etc
Dwarf_Line
line
Dwarf_Bool
prologue_end
Dwarf_Bool
epilogue_begin
Dwarf_Unsigned
isa
Dwarf_Unsigned
discriminator
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
prologue_end
line
li_addr_line
li_l_data
li_prologue_end
epilogue_begin
line
li_addr_line
li_l_data
li_epilogue_begin
isa
line
li_addr_line
li_l_data
li_isa
discriminator
line
li_addr_line
li_l_data
li_discriminator
return
DW_DLV_OK
int
dwarf_linelogical
Dwarf_Line
line
Dwarf_Unsigned
logical
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
logical
line
li_addr_line
li_l_data
li_line
return
DW_DLV_OK
int
dwarf_linecontext
Dwarf_Line
line
Dwarf_Unsigned
context
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
context
line
li_addr_line
li_l_data
li_call_context
return
DW_DLV_OK
int
dwarf_line_subprogno
Dwarf_Line
line
Dwarf_Unsigned
subprog
Dwarf_Error
error
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
subprog
line
li_addr_line
li_l_data
li_subprogram
return
DW_DLV_OK
int
dwarf_line_subprog
Dwarf_Line
line
char
subprog_name
char
decl_filename
Dwarf_Unsigned
decl_line
Dwarf_Error
error
Dwarf_Unsigned
subprog_no
Dwarf_Subprog_Entry
subprog
Dwarf_Debug
dbg
int
res
if
line
NULL
_dwarf_error
NULL
error
DW_DLE_DWARF_LINE_NULL
return
DW_DLV_ERROR
if
line
li_context
NULL
_dwarf_error
NULL
error
DW_DLE_LINE_CONTEXT_NULL
return
DW_DLV_ERROR
dbg
line
li_context
lc_dbg
subprog_no
line
li_addr_line
li_l_data
li_subprogram
if
subprog_no
subprog_name
NULL
decl_filename
NULL
decl_line
return
DW_DLV_OK
if
subprog_no
line
li_context
lc_subprogs_count
_dwarf_error
dbg
error
DW_DLE_NO_FILE_NAME
return
DW_DLV_ERROR
Adjusting
for
origin
subprog
no
subprog
li_context
lc_subprogs
subprog_no
subprog_name
char
subprog
ds_subprog_name
decl_line
subprog
ds_decl_line
res
dwarf_filename
line
li_context
subprog
ds_decl_file
decl_filename
error
if
res
DW_DLV_OK
decl_filename
NULL
return
res
return
DW_DLV_OK
This
is
another
line_context_destructor
static
void
delete_line_context_itself
Dwarf_Line_Context
context
Dwarf_Debug
dbg
Dwarf_File_Entry
fe
if
context
lc_magic
DW_CONTEXT_MAGIC
Something
is
wrong
return
dbg
context
lc_dbg
fe
context
lc_file_entries
while
fe
Dwarf_File_Entry
fenext
fe
fi_next
fe
fi_next
free
fe
fe
fenext
context
lc_file_entries
context
lc_file_entry_count
context
lc_file_entry_baseindex
context
lc_file_entry_endindex
if
context
lc_subprogs
free
context
lc_subprogs
context
lc_subprogs
free
context
lc_directory_format_values
context
lc_directory_format_values
free
context
lc_file_format_values
context
lc_file_format_values
if
context
lc_include_directories
free
context
lc_include_directories
context
lc_include_directories
context
lc_magic
dwarf_dealloc
dbg
context
DW_DLA_LINE_CONTEXT
It
s
impossible
for
callers
of
dwarf_srclines
to
get
to
and
free
all
the
resources
in
particular
the
li_context
and
its
lc_file_entries
So
this
function
new
July
does
it
Those
using
standard
DWARF
should
use
dwarf_srclines_b
and
dwarf_srclines_dealloc_b
instead
of
dwarf_srclines
and
dwarf_srclines_dealloc
as
that
gives
access
to
various
bits
of
useful
information
New
October
This
should
be
used
to
deallocate
all
lines
data
that
is
set
up
by
dwarf_srclines_b
This
and
dwarf_srclines_b
are
now
October
the
preferred
routine
to
use
void
dwarf_srclines_dealloc_b
Dwarf_Line_Context
line_context
Dwarf_Line
linestable
Dwarf_Signed
linescount
Dwarf_Signed
i
Dwarf_Debug
dbg
if
line_context
return
if
line_context
lc_magic
DW_CONTEXT_MAGIC
Something
is
wrong
return
dbg
line_context
lc_dbg
if
line_context
line_context
lc_magic
DW_CONTEXT_MAGIC
Something
is
badly
wrong
here
return
linestable
line_context
lc_linebuf_logicals
if
linestable
linescount
line_context
lc_linecount_logicals
for
i
i
linescount
i
dwarf_dealloc
dbg
linestable
i
DW_DLA_LINE
dwarf_dealloc
dbg
linestable
DW_DLA_LIST
line_context
lc_linebuf_logicals
line_context
lc_linecount_logicals
linestable
line_context
lc_linebuf_actuals
if
linestable
linescount
line_context
lc_linecount_actuals
for
i
i
linescount
i
dwarf_dealloc
dbg
linestable
i
DW_DLA_LINE
dwarf_dealloc
dbg
linestable
DW_DLA_LIST
line_context
lc_linebuf_actuals
line_context
lc_linecount_actuals
delete_line_context_itself
line_context
There
is
an
error
so
count
it
If
we
are
printing
errors
by
command
line
option
print
the
details
void
_dwarf_print_header_issue
Dwarf_Debug
dbg
const
char
specific_msg
Dwarf_Small
data_start
Dwarf_Signed
value
unsigned
index
unsigned
tabv
unsigned
linetabv
int
err_count_out
if
err_count_out
return
Are
we
in
verbose
mode
if
dwarf_cmdline_options
check_verbose_mode
dwarfstring
m1
dwarfstring_constructor
dwarfstring_append
n
DWARF
CHECK
debug_line
dwarfstring_append
char
specific_msg
dwarfstring_append_printf_i
DW_PR_DSd
value
if
index
tabv
linetabv
dwarfstring_append_printf_u
Mismatch
index
u
index
dwarfstring_append_printf_u
stdval
u
tabv
dwarfstring_append_printf_u
linetabval
u
linetabv
if
data_start
dbg
de_debug_line
dss_data
data_start
dbg
de_debug_line
dss_data
dbg
de_debug_line
dss_size
Dwarf_Unsigned
off
data_start
dbg
de_debug_line
dss_data
dwarfstring_append_printf_u
at
offset
DW_PR_XZEROS
DW_PR_DUx
off
dwarfstring_append_printf_u
DW_PR_DUu
off
else
dwarfstring_append
unknown
section
location
dwarfstring_append
n
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
err_count_out
void
_dwarf_report_bad_lnct
Dwarf_Debug
dbg
Dwarf_Unsigned
ltype
int
dlecode
const
char
dlename
Dwarf_Error
err
dwarfstring
m
dwarfstring
f2
const
char
typename
char
tnbuf
char
mnbuf
dwarfstring_constructor_static
tnbuf
sizeof
tnbuf
dwarf_get_LNCT_name
ltype
if
typename
dwarfstring_append_printf_u
Invalid
attribute
DW_PR_DUx
ltype
else
dwarfstring_append
char
typename
dwarfstring_constructor_static
mnbuf
sizeof
mnbuf
dwarfstring_append_printf_s
s
Unexpected
DW_LNCT
type
char
dlename
dwarfstring_append_printf_s
s
dwarfstring_string
_dwarf_error_string
dbg
err
dlecode
dwarfstring_string
dwarfstring_destructor
dwarfstring_destructor
static
void
report_ltype_form_issue
Dwarf_Debug
dbg
int
ltype
int
form
const
char
splmsg
Dwarf_Error
error
dwarfstring
m
dwarfstring
f2
dwarfstring
f
const
char
formname
const
char
typename
char
fnbuf
char
f2buf
char
mbuf
dwarfstring_constructor_static
fnbuf
sizeof
fnbuf
dwarfstring_constructor_static
f2buf
sizeof
f2buf
dwarf_get_LNCT_name
ltype
if
typename
dwarfstring_append_printf_u
Invalid
DW_LNCT
DW_PR_DUx
ltype
else
dwarfstring_append
char
typename
dwarf_get_FORM_name
form
if
formname
dwarfstring_append_printf_u
Invalid
Form
Code
DW_PR_DUx
form
else
dwarfstring_append
char
formname
dwarfstring_constructor_static
mbuf
sizeof
mbuf
dwarfstring_append_printf_s
DW_DLE_LNCT_FORM_CODE_NOT_HANDLED
form
s
instead
of
a
specifically
allowed
offset
form
dwarfstring_string
dwarfstring_append_printf_s
on
line
type
s
dwarfstring_string
if
splmsg
dwarfstring_append
dwarfstring_append
char
splmsg
_dwarf_error_string
dbg
error
DW_DLE_LNCT_FORM_CODE_NOT_HANDLED
dwarfstring_string
dwarfstring_destructor
dwarfstring_destructor
dwarfstring_destructor
int
_dwarf_decode_line_string_form
Dwarf_Debug
dbg
Dwarf_Unsigned
ltype
Dwarf_Unsigned
form
Dwarf_Unsigned
offset_size
Dwarf_Small
line_ptr
Dwarf_Small
line_ptr_end
char
return_str
Dwarf_Error
error
int
res
switch
form
case
DW_FORM_line_strp
Dwarf_Small
secstart
Dwarf_Small
secend
Dwarf_Small
strptr
Dwarf_Unsigned
offset
Dwarf_Small
offsetptr
line_ptr
res
_dwarf_load_section
dbg
de_debug_line_str
error
if
res
DW_DLV_OK
return
res
secstart
dbg
de_debug_line_str
dss_data
secend
secstart
dbg
de_debug_line_str
dss_size
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
offsetptr
offset_size
error
line_ptr_end
line_ptr
offset_size
strptr
secstart
offset
res
_dwarf_check_string_valid
dbg
secstart
strptr
secend
DW_DLE_LINE_STRP_OFFSET_BAD
error
if
res
DW_DLV_OK
return
res
return_str
char
strptr
return
DW_DLV_OK
case
DW_FORM_string
Dwarf_Small
secend
line_ptr_end
Dwarf_Small
strptr
line_ptr
res
_dwarf_check_string_valid
dbg
strptr
strptr
secend
DW_DLE_LINE_STRING_BAD
error
if
res
DW_DLV_OK
return
res
return_str
char
strptr
line_ptr
strlen
const
char
strptr
return
DW_DLV_OK
default
report_ltype_form_issue
dbg
ltype
form
error
return
DW_DLV_ERROR
int
_dwarf_decode_line_udata_form
Dwarf_Debug
dbg
Dwarf_Unsigned
ltype
Dwarf_Unsigned
form
Dwarf_Small
line_ptr
Dwarf_Unsigned
return_val
Dwarf_Small
line_end_ptr
Dwarf_Error
error
Dwarf_Unsigned
val
Dwarf_Small
lp
line_ptr
const
char
splmsg
We
will
not
get
here
for
DW_LNCT_MD5
no
need
to
consider
DW_FORM_data16
switch
form
case
DW_FORM_udata
if
ltype
DW_LNCT_directory_index
ltype
DW_LNCT_timestamp
ltype
DW_LNCT_GNU_decl_file
ltype
DW_LNCT_GNU_decl_line
ltype
DW_LNCT_size
break
DECODE_LEB128_UWORD_CK
lp
val
dbg
error
line_end_ptr
return_val
val
line_ptr
lp
return
DW_DLV_OK
case
DW_FORM_data1
if
ltype
DW_LNCT_directory_index
ltype
DW_LNCT_GNU_decl_file
ltype
DW_LNCT_GNU_decl_line
ltype
DW_LNCT_size
break
return_val
lp
line_ptr
lp
return
DW_DLV_OK
case
DW_FORM_data2
if
ltype
DW_LNCT_directory_index
ltype
DW_LNCT_GNU_decl_file
ltype
DW_LNCT_GNU_decl_line
ltype
DW_LNCT_size
break
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
lp
DWARF_HALF_SIZE
error
line_end_ptr
return_val
val
line_ptr
lp
DWARF_HALF_SIZE
return
DW_DLV_OK
case
DW_FORM_data4
if
ltype
DW_LNCT_timestamp
ltype
DW_LNCT_GNU_decl_file
ltype
DW_LNCT_GNU_decl_line
ltype
DW_LNCT_size
break
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
lp
DWARF_32BIT_SIZE
error
line_end_ptr
return_val
val
line_ptr
lp
DWARF_32BIT_SIZE
return
DW_DLV_OK
case
DW_FORM_block
Dwarf_Unsigned
leblen
Dwarf_Unsigned
length
Dwarf_Small
dataptr
if
ltype
DW_LNCT_timestamp
break
DECODE_LEB128_UWORD_LEN_CK
lp
length
leblen
dbg
error
line_end_ptr
dataptr
lp
leblen
if
length
sizeof
Dwarf_Unsigned
splmsg
FORM_block
length
bigger
than
Dwarf_Unsigned
break
if
dataptr
line_end_ptr
splmsg
FORM_block
data
starts
past
end
of
data
break
if
dataptr
length
line_end_ptr
splmsg
FORM_block
data
runs
past
end
of
data
break
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
dataptr
length
error
line_end_ptr
return_val
val
line_ptr
dataptr
length
return
DW_DLV_OK
case
DW_FORM_data8
if
ltype
DW_LNCT_size
ltype
DW_LNCT_size
break
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
lp
DWARF_64BIT_SIZE
error
line_end_ptr
return_val
val
line_ptr
lp
DWARF_64BIT_SIZE
return
DW_DLV_OK
report_ltype_form_issue
dbg
ltype
form
splmsg
error
return
DW_DLV_ERROR
void
_dwarf_update_chain_list
Dwarf_Chain
chain_line
Dwarf_Chain
head_chain
Dwarf_Chain
curr_chain
if
head_chain
NULL
head_chain
chain_line
else
curr_chain
ch_next
chain_line
curr_chain
chain_line
void
_dwarf_free_chain_entries
Dwarf_Debug
dbg
Dwarf_Chain
head
int
count
int
i
Dwarf_Chain
curr_chain
head
for
i
i
count
i
Dwarf_Chain
t
curr_chain
void
item
t
ch_item
int
itype
t
ch_itemtype
if
item
itype
valid
DW_DLA
types
are
never
dwarf_dealloc
dbg
item
itype
t
ch_item
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
t
DW_DLA_CHAIN
int
_dwarf_add_to_files_list
Dwarf_Line_Context
context
Dwarf_File_Entry
fe
unsigned
int
version
context
lc_version_number
if
context
lc_file_entries
context
lc_file_entries
fe
else
context
lc_last_entry
fi_next
fe
context
lc_last_entry
fe
context
lc_file_entry_count
Here
we
attempt
to
write
code
to
make
it
easy
to
interate
though
source
file
names
without
having
to
code
specially
for
DWARF2
vs
DWARF5
if
version
DW_LINE_VERSION5
context
lc_file_entry_baseindex
context
lc_file_entry_endindex
context
lc_file_entry_count
else
context
lc_file_entry_baseindex
context
lc_file_entry_endindex
context
lc_file_entry_count
return
DW_DLV_OK
int
_dwarf_line_context_constructor
Dwarf_Debug
dbg
void
m
Dwarf_Line_Context
line_context
Dwarf_Line_Context
m
dwarf_get_alloc
ensures
the
bytes
are
all
zero
when
m
is
passed
to
us
line_context
lc_magic
DW_CONTEXT_MAGIC
line_context
lc_dbg
dbg
return
DW_DLV_OK
This
cleans
up
a
contex
record
The
lines
tables
actuals
and
logicals
are
themselves
items
that
will
be
dealloc
d
either
manually
or
at
closing
the
libdwarf
dbg
automatically
So
we
DO
NOT
touch
the
lines
tables
here
See
also
delete_line_context_itself
void
_dwarf_line_context_destructor
void
m
Dwarf_Line_Context
line_context
Dwarf_Line_Context
m
if
line_context
lc_magic
DW_CONTEXT_MAGIC
Nothing
is
safe
do
nothing
return
if
line_context
lc_include_directories
free
line_context
lc_include_directories
line_context
lc_include_directories
line_context
lc_include_directories_count
if
line_context
lc_file_entries
Dwarf_File_Entry
fe
line_context
lc_file_entries
while
fe
Dwarf_File_Entry
t
fe
fe
t
fi_next
t
fi_next
free
t
line_context
lc_file_entries
line_context
lc_last_entry
line_context
lc_file_entry_count
line_context
lc_file_entry_baseindex
line_context
lc_file_entry_endindex
free
line_context
lc_directory_format_values
line_context
lc_directory_format_values
free
line_context
lc_file_format_values
line_context
lc_file_format_values
if
line_context
lc_subprogs
free
line_context
lc_subprogs
line_context
lc_subprogs
line_context
lc_subprogs_count
line_context
lc_magic
return
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
for
debugging
only
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
uintptr_t
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_loc
h
include
dwarfstring
h
static
int
_dwarf_read_loc_section_dwo
Dwarf_Debug
dbg
Dwarf_Block_c
return_block
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Bool
at_end
Dwarf_Half
lle_op
Dwarf_Off
sec_offset
Dwarf_Half
address_size
Dwarf_Half
lkind
Dwarf_Error
error
Used
to
enable
sanity
checking
of
these
data
items
before
we
return
to
caller
int
_dwarf_locdesc_c_constructor
Dwarf_Debug
dbg
void
locd
Dwarf_Locdesc_c
ldp
Dwarf_Locdesc_c
locd
if
dbg
return
DW_DLV_ERROR
ldp
ld_lle_value
DW_LLE_VALUE_BOGUS
ldp
ld_kind
DW_LKIND_unknown
return
DW_DLV_OK
static
void
_dwarf_lkind_name
unsigned
lkind
dwarfstring
m
switch
lkind
case
DW_LKIND_expression
dwarfstring_append
m
DW_LKIND_expression
return
case
DW_LKIND_loclist
dwarfstring_append
m
DW_LKIND_loclist
return
case
DW_LKIND_GNU_exp_list
dwarfstring_append
m
DW_LKIND_GNU_exp_list
return
case
DW_LKIND_loclists
dwarfstring_append
m
DW_LKIND_loclists
return
case
DW_LKIND_unknown
dwarfstring_append
m
DW_LKIND_unknown
return
dwarfstring_append_printf_u
m
DW_LKIND
location
kind
is
unknown
and
has
value
u
lkind
static
int
determine_location_lkind
unsigned
int
version
unsigned
int
form
UNUSEDARG
unsigned
int
attribute
Dwarf_Bool
is_dwo
switch
form
case
DW_FORM_exprloc
only
defined
for
DW_CFA_def_cfa_expression
case
DW_FORM_block
case
DW_FORM_block1
case
DW_FORM_block2
case
DW_FORM_block4
return
DW_LKIND_expression
break
case
DW_FORM_data4
case
DW_FORM_data8
if
version
version
return
DW_LKIND_loclist
break
case
DW_FORM_sec_offset
if
version
return
DW_LKIND_loclists
if
version
is_dwo
return
DW_LKIND_GNU_exp_list
return
DW_LKIND_loclist
break
case
DW_FORM_loclistx
if
version
return
DW_LKIND_loclists
break
default
break
return
DW_LKIND_unknown
static
void
_dwarf_free_op_chain
Dwarf_Debug
dbg
Dwarf_Loc_Chain
headloc
Dwarf_Loc_Chain
cur
headloc
while
cur
Dwarf_Loc_Chain
next
cur
lc_next
dwarf_dealloc
dbg
cur
DW_DLA_LOC_CHAIN
cur
next
Using
a
loclist
offset
to
get
the
in
memory
address
of
debug_loc
data
to
read
returns
the
loclist
header
info
in
return_block
define
MAX_ADDR
address_size
static
int
_dwarf_read_loc_section
Dwarf_Debug
dbg
Dwarf_Block_c
return_block
Dwarf_Addr
lowpc
Dwarf_Addr
hipc
Dwarf_Half
lle_val
Dwarf_Off
sec_offset
Dwarf_Half
address_size
UNUSEDARG
unsigned
lkind
Dwarf_Error
error
Dwarf_Small
beg
dbg
de_debug_loc
dss_data
sec_offset
Dwarf_Small
loc_section_end
dbg
de_debug_loc
dss_data
dbg
de_debug_loc
dss_size
start_addr
and
end_addr
are
actually
offsets
of
the
applicable
base
address
of
the
CU
They
are
address
size
Dwarf_Addr
start_addr
Dwarf_Addr
end_addr
Dwarf_Half
exprblock_size
Dwarf_Unsigned
exprblock_off
address_size
DWARF_HALF_SIZE
if
sec_offset
dbg
de_debug_loc
dss_size
We
re
at
the
end
No
more
present
return
DW_DLV_NO_ENTRY
If
it
goes
past
end
error
if
exprblock_off
dbg
de_debug_loc
dss_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
start_addr
Dwarf_Addr
beg
address_size
error
loc_section_end
READ_UNALIGNED_CK
dbg
end_addr
Dwarf_Addr
beg
address_size
address_size
error
loc_section_end
if
start_addr
end_addr
If
start_addr
and
end_addr
are
it
s
the
end
and
no
exprblock_size
field
follows
exprblock_size
exprblock_off
DWARF_HALF_SIZE
lle_val
DW_LLE_end_of_list
else
if
start_addr
MAX_ADDR
End
address
is
a
base
address
no
exprblock_size
field
here
either
exprblock_size
exprblock_off
DWARF_HALF_SIZE
lle_val
DW_LLE_base_address
else
Here
we
note
the
address
and
length
of
the
expression
operators
DW_OP_reg0
etc
READ_UNALIGNED_CK
dbg
exprblock_size
Dwarf_Half
beg
address_size
DWARF_HALF_SIZE
error
loc_section_end
exprblock_size
can
be
zero
means
no
expression
if
exprblock_size
dbg
de_debug_loc
dss_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
return
DW_DLV_ERROR
if
sec_offset
exprblock_off
exprblock_size
dbg
de_debug_loc
dss_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
return
DW_DLV_ERROR
lle_val
DW_LLE_start_end
lowpc
start_addr
hipc
end_addr
return_block
bl_len
exprblock_size
return_block
bl_kind
DW_LKIND_loclist
return_block
bl_data
beg
exprblock_off
return_block
bl_section_offset
Dwarf_Small
return_block
bl_data
dbg
de_debug_loc
dss_data
return
DW_DLV_OK
static
int
_dwarf_get_loclist_lle_count_dwo
Dwarf_Debug
dbg
Dwarf_Off
loclist_offset
Dwarf_Half
address_size
unsigned
lkind
int
loclist_count
Dwarf_Error
error
int
count
Dwarf_Off
offset
loclist_offset
for
Dwarf_Block_c
b
Dwarf_Bool
at_end
FALSE
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Half
lle_op
int
res
_dwarf_read_loc_section_dwo
dbg
offset
address_size
lkind
error
if
res
DW_DLV_OK
return
res
if
at_end
count
break
offset
b
bl_len
b
bl_section_offset
count
loclist_count
count
return
DW_DLV_OK
static
int
_dwarf_get_loclist_lle_count
Dwarf_Debug
dbg
Dwarf_Off
loclist_offset
Dwarf_Half
address_size
unsigned
lkind
int
loclist_count
Dwarf_Error
error
int
count
Dwarf_Off
offset
loclist_offset
for
Dwarf_Block_c
b
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Half
lle_val
DW_LLE_VALUE_BOGUS
int
res
_dwarf_read_loc_section
dbg
offset
address_size
lkind
error
if
res
DW_DLV_OK
return
res
offset
b
bl_len
b
bl_section_offset
if
lowpc
highpc
break
count
loclist_count
count
return
DW_DLV_OK
Helper
routine
to
avoid
code
duplication
static
int
_dwarf_setup_loc
Dwarf_Attribute
attr
Dwarf_Debug
dbg_ret
Dwarf_CU_Context
cucontext_ret
Dwarf_Half
form_ret
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Half
form
int
blkres
DW_DLV_ERROR
Creating
an
error
with
NULL
dbg
is
not
a
good
thing
These
won
t
be
freed
if
we
later
call
dealloc
with
a
non
NULL
dbg
if
attr
_dwarf_error
NULL
error
DW_DLE_ATTR_NULL
return
DW_DLV_ERROR
if
attr
ar_cu_context
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_NO_CU_CONTEXT
return
DW_DLV_ERROR
cucontext_ret
attr
ar_cu_context
dbg
attr
ar_cu_context
cc_dbg
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_ATTR_DBG_NULL
return
DW_DLV_ERROR
dbg_ret
dbg
blkres
dwarf_whatform
attr
error
if
blkres
DW_DLV_OK
return
blkres
form_ret
form
return
DW_DLV_OK
Helper
routine
to
avoid
code
duplication
static
int
_dwarf_get_loclist_header_start
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_Unsigned
loclist_offset_out
Dwarf_Error
error
Dwarf_Unsigned
loc_sec_size
Dwarf_Unsigned
loclist_offset
int
blkres
dwarf_global_formref
attr
error
if
blkres
DW_DLV_OK
return
blkres
if
dbg
de_debug_loc
dss_data
int
secload
_dwarf_load_section
dbg
de_debug_loc
error
if
secload
DW_DLV_OK
return
secload
if
dbg
de_debug_loc
dss_size
return
DW_DLV_NO_ENTRY
loc_sec_size
dbg
de_debug_loc
dss_size
if
loclist_offset
loc_sec_size
_dwarf_error
dbg
error
DW_DLE_LOCLIST_OFFSET_BAD
return
DW_DLV_ERROR
int
fisres
Dwarf_Unsigned
fissoff
Dwarf_Unsigned
size
fisres
_dwarf_get_fission_addition_die
attr
ar_die
DW_SECT_LOCLISTS
error
if
fisres
DW_DLV_OK
return
fisres
if
fissoff
loc_sec_size
_dwarf_error
dbg
error
DW_DLE_LOCLIST_OFFSET_BAD
return
DW_DLV_ERROR
loclist_offset
fissoff
if
loclist_offset
loc_sec_size
_dwarf_error
dbg
error
DW_DLE_LOCLIST_OFFSET_BAD
return
DW_DLV_ERROR
loclist_offset_out
loclist_offset
return
DW_DLV_OK
static
int
context_is_cu_not_tu
Dwarf_CU_Context
context
Dwarf_Bool
r
int
ut
context
cc_unit_type
if
ut
DW_UT_type
ut
DW_UT_split_type
r
FALSE
return
DW_DLV_OK
r
TRUE
return
DW_DLV_OK
Handles
only
a
location
expression
It
returns
the
location
expression
as
a
loclist
with
a
single
entry
Usable
to
access
dwarf
expressions
from
any
source
but
specifically
from
DW_CFA_def_cfa_expression
DW_CFA_expression
DW_CFA_val_expression
expression_in
must
point
to
a
valid
dwarf
expression
the
October
interfaces
int
_dwarf_loc_block_sanity_check
Dwarf_Debug
dbg
Dwarf_Block_c
loc_block
Dwarf_Error
error
unsigned
lkind
loc_block
bl_kind
if
lkind
DW_LKIND_loclist
Dwarf_Small
loc_ptr
Dwarf_Unsigned
loc_len
Dwarf_Small
end_ptr
loc_ptr
loc_block
bl_data
loc_len
loc_block
bl_len
end_ptr
dbg
de_debug_loc
dss_size
dbg
de_debug_loc
dss_data
if
loc_ptr
loc_len
end_ptr
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_LOC_SECTION_SHORT
kind
_dwarf_lkind_name
lkind
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
if
lkind
DW_LKIND_loclists
Dwarf_Small
loc_ptr
Dwarf_Unsigned
loc_len
Dwarf_Small
end_ptr
loc_ptr
loc_block
bl_data
loc_len
loc_block
bl_len
end_ptr
dbg
de_debug_loclists
dss_size
dbg
de_debug_loclists
dss_data
if
loc_ptr
loc_len
end_ptr
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_LOC_SECTION_SHORT
the
debug_loclists
section
is
short
kind
_dwarf_lkind_name
lkind
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
ld_kind
was
checked
before
calling
this
so
we
know
its
value
is
an
intended
value
static
const
char
kindset
DW_LKIND_expression
DW_LKIND_loclist
DW_LKIND_GNU_exp_list
DW_LKIND_unknown3
DW_LKIND_unknown4
DW_LKIND_loclists
static
const
char
get_loc_kind_str
Dwarf_Small
lkind
if
lkind
DW_LKIND_loclists
return
kindset
lkind
if
lkind
DW_LKIND_unknown
return
DW_LKIND_unknown
return
UNKNOWN
DW_LKIND
static
int
validate_lle_value
Dwarf_Debug
dbg
Dwarf_Locdesc_c
locdesc
Dwarf_Error
error
dwarfstring
m
if
locdesc
ld_kind
DW_LKIND_GNU_exp_list
switch
locdesc
ld_lle_value
case
DW_LLE_end_of_list
case
DW_LLE_base_addressx
case
DW_LLE_startx_endx
case
DW_LLE_startx_length
case
DW_LLE_offset_pair
case
DW_LLE_default_location
case
DW_LLE_base_address
case
DW_LLE_start_end
case
DW_LLE_start_length
return
DW_DLV_OK
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_LOCATION_ERROR
For
location
kind
s
char
get_loc_kind_str
locdesc
ld_kind
dwarfstring_append_printf_u
u
the
DW_LLE
value
is
not
properly
set
locdesc
ld_kind
dwarfstring_append_printf_u
but
is
u
which
is
a
libdwarf
bug
locdesc
ld_lle_value
_dwarf_error_string
dbg
error
DW_DLE_LOCATION_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
switch
locdesc
ld_lle_value
case
DW_LLEX_end_of_list_entry
case
DW_LLEX_base_address_selection_entry
case
DW_LLEX_start_end_entry
case
DW_LLEX_start_length_entry
case
DW_LLEX_offset_pair_entry
return
DW_DLV_OK
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_LOCATION_ERROR
For
location
kind
s
char
get_loc_kind_str
locdesc
ld_kind
dwarfstring_append_printf_u
u
the
DW_LLEX
value
is
not
properly
set
locdesc
ld_kind
dwarfstring_append_printf_u
but
is
u
which
is
a
libdwarf
bug
locdesc
ld_lle_value
_dwarf_error_string
dbg
error
DW_DLE_LOCATION_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
Sets
locdesc
operator
list
information
in
locdesc
Sets
the
locdesc
values
rawlow
rawhigh
etc
This
synthesizes
the
ld_lle_value
of
the
locdesc
if
it
s
not
already
provided
Not
passing
in
locdesc
pointer
the
locdesc_index
suffices
to
index
to
the
relevant
locdesc
pointer
See
also
dwarf_loclists
c
build_array_of_lle
int
_dwarf_fill_in_locdesc_op_c
Dwarf_Debug
dbg
Dwarf_Unsigned
locdesc_index
Dwarf_Loc_Head_c
loc_head
Dwarf_Block_c
loc_block
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Small
version_stamp
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Half
lle_op
Dwarf_Error
error
Offset
of
current
operator
from
start
of
block
Dwarf_Unsigned
offset
Chain
the
DW_OPerator
structs
Dwarf_Loc_Chain
new_loc
NULL
Dwarf_Loc_Chain
prev_loc
NULL
Dwarf_Loc_Chain
head_loc
NULL
Dwarf_Unsigned
op_count
Contiguous
block
of
Dwarf_Loc_Expr_Op_s
for
Dwarf_Locdesc
Dwarf_Loc_Expr_Op
block_loc
Dwarf_Locdesc_c
locdesc
loc_head
ll_locdesc
locdesc_index
Dwarf_Unsigned
i
int
res
Dwarf_Small
section_start
Dwarf_Unsigned
section_size
Dwarf_Small
section_end
const
char
section_name
Dwarf_Small
blockdataptr
unsigned
lkind
loc_head
ll_kind
BEGIN
CODE
blockdataptr
loc_block
bl_data
if
blockdataptr
loc_block
bl_len
an
empty
block
has
no
operations
so
no
section
or
tests
need
be
done
else
res
_dwarf_what_section_are_we
dbg
blockdataptr
error
if
res
DW_DLV_OK
_dwarf_error
dbg
error
DW_DLE_POINTER_SECTION_UNKNOWN
return
DW_DLV_ERROR
res
_dwarf_loc_block_sanity_check
dbg
loc_block
error
if
res
DW_DLV_OK
return
res
New
loop
getting
Loc
operators
Non
DWO
while
offset
loc_block
bl_len
Dwarf_Unsigned
nextoffset
struct
Dwarf_Loc_Expr_Op_s
temp_loc
This
call
is
ok
even
if
bl_data
NULL
and
bl_len
res
_dwarf_read_loc_expr_op
dbg
loc_block
op_count
version_stamp
offset_size
address_size
offset
section_end
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
Normal
end
Also
the
end
for
an
empty
loc_block
break
op_count
new_loc
Dwarf_Loc_Chain
_dwarf_get_alloc
dbg
DW_DLA_LOC_CHAIN
if
new_loc
NULL
_dwarf_free_op_chain
dbg
head_loc
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Copying
all
the
fields
DWARF
new_loc
lc_atom
temp_loc
lr_atom
new_loc
lc_opnumber
temp_loc
lr_opnumber
new_loc
lc_raw1
temp_loc
lr_number
new_loc
lc_raw2
temp_loc
lr_number2
new_loc
lc_raw3
temp_loc
lr_number3
new_loc
lc_number
temp_loc
lr_number
new_loc
lc_number2
temp_loc
lr_number2
new_loc
lc_number3
temp_loc
lr_number3
new_loc
lc_offset
temp_loc
lr_offset
if
head_loc
NULL
head_loc
prev_loc
new_loc
else
prev_loc
lc_next
new_loc
prev_loc
new_loc
offset
nextoffset
block_loc
Dwarf_Loc_Expr_Op
_dwarf_get_alloc
dbg
DW_DLA_LOC_BLOCK_C
op_count
new_loc
head_loc
if
block_loc
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
for
i
i
op_count
i
prev_loc
new_loc
new_loc
prev_loc
lc_next
dwarf_dealloc
dbg
prev_loc
DW_DLA_LOC_CHAIN
return
DW_DLV_ERROR
op_count
could
be
zero
new_loc
head_loc
for
i
i
op_count
i
Copying
only
the
fields
needed
by
DWARF
block_loc
i
lr_atom
new_loc
lc_atom
block_loc
i
lr_raw1
new_loc
lc_raw1
block_loc
i
lr_raw2
new_loc
lc_raw2
block_loc
i
lr_raw3
new_loc
lc_raw3
block_loc
i
lr_number
new_loc
lc_number
block_loc
i
lr_number2
new_loc
lc_number2
block_loc
i
lr_number3
new_loc
lc_number3
block_loc
i
lr_offset
new_loc
lc_offset
block_loc
i
lr_opnumber
new_loc
lc_opnumber
prev_loc
new_loc
new_loc
prev_loc
lc_next
dwarf_dealloc
dbg
prev_loc
DW_DLA_LOC_CHAIN
Synthesizing
the
DW_LLE
values
for
the
old
loclist
versions
switch
loc_head
ll_kind
case
DW_LKIND_loclist
if
highpc
lowpc
locdesc
ld_lle_value
DW_LLE_end_of_list
else
if
lowpc
MAX_ADDR
locdesc
ld_lle_value
DW_LLE_base_address
else
locdesc
ld_lle_value
DW_LLE_offset_pair
break
case
DW_LKIND_GNU_exp_list
DW_LKIND_GNU_exp_list
locdesc
ld_lle_value
lle_op
break
case
DW_LKIND_expression
This
is
a
kind
of
fake
but
better
than
locdesc
ld_lle_value
DW_LLE_start_end
break
case
DW_LKIND_loclists
ld_lle_value
already
set
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCATION_ERROR
An
impossible
DW_LKIND
value
of
u
encountered
likely
internal
libdwarf
error
or
data
corruption
unsigned
loc_head
ll_kind
_dwarf_error_string
dbg
error
DW_DLE_LOCATION_ERROR
dwarfstring_string
dwarfstring_destructor
dwarf_dealloc
dbg
block_loc
DW_DLA_LOC_BLOCK_C
return
DW_DLV_ERROR
locdesc
ld_cents
op_count
locdesc
ld_s
block_loc
locdesc
ld_kind
lkind
locdesc
ld_section_offset
loc_block
bl_section_offset
locdesc
ld_locdesc_offset
loc_block
bl_locdesc_offset
locdesc
ld_rawlow
lowpc
locdesc
ld_rawhigh
highpc
res
validate_lle_value
dbg
locdesc
error
if
res
DW_DLV_OK
dwarf_dealloc
dbg
block_loc
DW_DLA_LOC_BLOCK_C
return
res
Leaving
the
cooked
values
zero
Filled
in
later
We
have
not
yet
looked
for
debug_addr
so
we
ll
set
it
as
not
missing
locdesc
ld_index_failed
FALSE
return
DW_DLV_OK
Non
standard
DWARF4
dwo
loclist
static
int
_dwarf_read_loc_section_dwo
Dwarf_Debug
dbg
Dwarf_Block_c
return_block
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Bool
at_end
Dwarf_Half
lle_op
Dwarf_Off
sec_offset
Dwarf_Half
address_size
Dwarf_Half
lkind
Dwarf_Error
error
Dwarf_Small
beg
dbg
de_debug_loc
dss_data
sec_offset
Dwarf_Small
locptr
Dwarf_Small
llecode
Dwarf_Unsigned
expr_offset
sec_offset
Dwarf_Byte_Ptr
section_end
dbg
de_debug_loc
dss_data
dbg
de_debug_loc
dss_size
if
sec_offset
dbg
de_debug_loc
dss_size
We
re
at
the
end
No
more
present
return
DW_DLV_NO_ENTRY
memset
return_block
sizeof
return_block
not
the
same
as
non
split
loclist
but
still
a
list
return_block
bl_kind
lkind
This
is
non
standard
GNU
Dwarf4
loclist
return_block
bl_locdesc_offset
sec_offset
llecode
beg
locptr
beg
expr_offset
switch
llecode
case
DW_LLEX_end_of_list_entry
at_end
TRUE
return_block
bl_section_offset
expr_offset
expr_offset
break
case
DW_LLEX_base_address_selection_entry
Dwarf_Unsigned
addr_index
DECODE_LEB128_UWORD_CK
locptr
addr_index
dbg
error
section_end
return_block
bl_section_offset
expr_offset
So
this
behaves
much
like
non
dwo
loclist
lowpc
MAX_ADDR
highpc
addr_index
break
case
DW_LLEX_start_end_entry
Dwarf_Unsigned
addr_indexs
Dwarf_Unsigned
addr_indexe
Dwarf_Unsigned
exprlen
Dwarf_Unsigned
leb128_length
DECODE_LEB128_UWORD_LEN_CK
locptr
addr_indexs
leb128_length
dbg
error
section_end
expr_offset
leb128_length
DECODE_LEB128_UWORD_LEN_CK
locptr
addr_indexe
leb128_length
dbg
error
section_end
expr_offset
leb128_length
lowpc
addr_indexs
highpc
addr_indexe
READ_UNALIGNED_CK
dbg
exprlen
Dwarf_Unsigned
locptr
DWARF_HALF_SIZE
error
section_end
locptr
DWARF_HALF_SIZE
expr_offset
DWARF_HALF_SIZE
return_block
bl_len
exprlen
return_block
bl_data
locptr
return_block
bl_section_offset
expr_offset
expr_offset
exprlen
if
expr_offset
dbg
de_debug_loc
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_append_printf_u
in
DW_LLEX_start_end_entry
The
expression
offset
is
x
expr_offset
dwarfstring_append_printf_u
which
is
greater
than
the
section
size
of
x
Corrupt
Dwarf
dbg
de_debug_loc
dss_size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
case
DW_LLEX_start_length_entry
Dwarf_Unsigned
addr_index
Dwarf_Unsigned
range_length
Dwarf_Unsigned
exprlen
Dwarf_Unsigned
leb128_length
DECODE_LEB128_UWORD_LEN_CK
locptr
addr_index
leb128_length
dbg
error
section_end
expr_offset
leb128_length
READ_UNALIGNED_CK
dbg
range_length
Dwarf_Unsigned
locptr
DWARF_32BIT_SIZE
error
section_end
locptr
DWARF_32BIT_SIZE
expr_offset
DWARF_32BIT_SIZE
READ_UNALIGNED_CK
dbg
exprlen
Dwarf_Unsigned
locptr
DWARF_HALF_SIZE
error
section_end
locptr
DWARF_HALF_SIZE
expr_offset
DWARF_HALF_SIZE
lowpc
addr_index
highpc
range_length
return_block
bl_len
exprlen
return_block
bl_data
locptr
return_block
bl_section_offset
expr_offset
exprblock_size
can
be
zero
means
no
expression
expr_offset
exprlen
if
expr_offset
dbg
de_debug_loc
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_append_printf_u
in
DW_LLEX_start_length_entry
The
expression
offset
is
x
expr_offset
dwarfstring_append_printf_u
which
is
greater
than
the
section
size
of
x
Corrupt
Dwarf
dbg
de_debug_loc
dss_size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
case
DW_LLEX_offset_pair_entry
Dwarf_Unsigned
startoffset
Dwarf_Unsigned
endoffset
Dwarf_Unsigned
exprlen
READ_UNALIGNED_CK
dbg
startoffset
Dwarf_Unsigned
locptr
DWARF_32BIT_SIZE
error
section_end
locptr
DWARF_32BIT_SIZE
expr_offset
DWARF_32BIT_SIZE
READ_UNALIGNED_CK
dbg
endoffset
Dwarf_Unsigned
locptr
DWARF_32BIT_SIZE
error
section_end
locptr
DWARF_32BIT_SIZE
expr_offset
DWARF_32BIT_SIZE
lowpc
startoffset
highpc
endoffset
READ_UNALIGNED_CK
dbg
exprlen
Dwarf_Unsigned
locptr
DWARF_HALF_SIZE
error
section_end
locptr
DWARF_HALF_SIZE
expr_offset
DWARF_HALF_SIZE
return_block
bl_len
exprlen
return_block
bl_data
locptr
return_block
bl_section_offset
expr_offset
expr_offset
exprlen
if
expr_offset
dbg
de_debug_loc
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_append_printf_u
in
DW_LLEX_offset_pair_entry
The
expression
offset
is
x
expr_offset
dwarfstring_append_printf_u
which
is
greater
than
the
section
size
of
x
Corrupt
Dwarf
dbg
de_debug_loc
dss_size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_LOC_SECTION_SHORT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append
DW_DLE_LLE_CODE_UNKNOWN
dwarfstring_append_printf_u
in
DW_LLEX_
code
value
is
x
not
an
expected
value
llecode
_dwarf_error_string
dbg
error
DW_DLE_LLE_CODE_UNKNOWN
dwarfstring_string
dwarfstring_destructor
_dwarf_error
dbg
error
DW_DLE_LLE_CODE_UNKNOWN
return
DW_DLV_ERROR
lle_op
llecode
return
DW_DLV_OK
int
dwarf_get_loclist_head_kind
Dwarf_Loc_Head_c
ll_header
unsigned
int
kind
UNUSEDARG
Dwarf_Error
error
kind
ll_header
ll_kind
return
DW_DLV_OK
static
int
_dwarf_original_loclist_build
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
llhead
Dwarf_Attribute
attr
Dwarf_Error
error
Dwarf_Unsigned
loclist_offset
Dwarf_Unsigned
starting_loclist_offset
int
off_res
DW_DLV_ERROR
int
count_res
DW_DLV_ERROR
int
loclist_count
Dwarf_Unsigned
lli
unsigned
lkind
llhead
ll_kind
unsigned
address_size
llhead
ll_address_size
Dwarf_Unsigned
listlen
Dwarf_Locdesc_c
llbuf
Dwarf_CU_Context
cucontext
off_res
_dwarf_get_loclist_header_start
dbg
attr
error
if
off_res
DW_DLV_OK
return
off_res
starting_loclist_offset
loclist_offset
if
lkind
DW_LKIND_GNU_exp_list
count_res
_dwarf_get_loclist_lle_count_dwo
dbg
loclist_offset
address_size
llhead
ll_kind
error
else
count_res
_dwarf_get_loclist_lle_count
dbg
loclist_offset
address_size
llhead
ll_kind
error
if
count_res
DW_DLV_OK
return
count_res
if
loclist_count
return
DW_DLV_NO_ENTRY
listlen
loclist_count
llbuf
Dwarf_Locdesc_c
_dwarf_get_alloc
dbg
DW_DLA_LOCDESC_C
listlen
if
llbuf
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
llhead
ll_locdesc
llbuf
llhead
ll_locdesc_count
listlen
cucontext
llhead
ll_context
llhead
ll_llearea_offset
loclist_offset
Now
get
loc
ops
for
lli
lli
listlen
lli
int
lres
Dwarf_Half
lle_op
Dwarf_Bool
at_end
Dwarf_Block_c
loc_block
Dwarf_Unsigned
rawlowpc
Dwarf_Unsigned
rawhighpc
int
blkres
memset
sizeof
loc_block
if
lkind
DW_LKIND_GNU_exp_list
blkres
_dwarf_read_loc_section_dwo
dbg
loclist_offset
address_size
lkind
error
else
blkres
_dwarf_read_loc_section
dbg
loclist_offset
address_size
lkind
error
if
blkres
DW_DLV_OK
return
blkres
Fills
in
the
locdesc
and
its
operators
list
at
index
lli
lres
_dwarf_fill_in_locdesc_op_c
dbg
lli
llhead
address_size
cucontext
cc_length_size
cucontext
cc_version_stamp
rawlowpc
rawhighpc
lle_op
error
if
lres
DW_DLV_OK
return
lres
Now
get
to
next
loclist
entry
offset
loclist_offset
loc_block
bl_section_offset
loc_block
bl_len
We
need
to
calculate
the
cooked
values
for
each
locldesc
entry
that
will
be
done
in
dwarf_get_loclist_c
llhead
ll_bytes_total
loclist_offset
starting_loclist_offset
return
DW_DLV_OK
static
int
_dwarf_original_expression_build
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
llhead
Dwarf_Attribute
attr
Dwarf_Error
error
Dwarf_Block_c
loc_blockc
Dwarf_Unsigned
rawlowpc
Dwarf_Unsigned
rawhighpc
unsigned
form
llhead
ll_attrform
int
blkres
Dwarf_Locdesc_c
llbuf
unsigned
listlen
Dwarf_CU_Context
cucontext
llhead
ll_context
unsigned
address_size
llhead
ll_address_size
memset
sizeof
loc_blockc
if
form
DW_FORM_exprloc
blkres
dwarf_formexprloc
attr
bl_len
bl_data
error
if
blkres
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
blkres
loc_blockc
bl_kind
llhead
ll_kind
loc_blockc
bl_section_offset
char
loc_blockc
bl_data
char
dbg
de_debug_info
dss_data
loc_blockc
bl_locdesc_offset
not
relevant
else
Dwarf_Block
loc_block
memset
sizeof
loc_block
blkres
_dwarf_formblock_internal
dbg
attr
llhead
ll_context
error
if
blkres
DW_DLV_OK
return
blkres
loc_blockc
bl_len
loc_block
bl_len
loc_blockc
bl_data
loc_block
bl_data
loc_blockc
bl_kind
llhead
ll_kind
loc_blockc
bl_section_offset
loc_block
bl_section_offset
loc_blockc
bl_locdesc_offset
not
relevant
We
will
mark
the
Locdesc_c
DW_LLE_start_end
shortly
Here
we
fake
the
address
range
as
all
addresses
rawlowpc
rawhighpc
MAX_ADDR
llbuf
Dwarf_Locdesc_c
_dwarf_get_alloc
dbg
DW_DLA_LOCDESC_C
listlen
if
llbuf
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
llhead
ll_locdesc
llbuf
One
by
definition
of
a
location
entry
llhead
ll_locdesc_count
listlen
An
empty
location
description
block
length
means
the
code
generator
emitted
no
variable
the
variable
was
not
generated
it
was
unused
or
perhaps
never
tested
after
being
set
Dwarf2
section
In
other
words
it
is
not
an
error
and
we
don
t
test
for
block
length
specially
here
Fills
in
the
locdesc
and
its
operators
list
at
index
blkres
_dwarf_fill_in_locdesc_op_c
dbg
fake
locdesc
is
index
llhead
llhead
ll_address_size
cucontext
cc_length_size
cucontext
cc_version_stamp
rawlowpc
rawhighpc
error
llhead
ll_bytes_total
loc_blockc
bl_len
if
blkres
DW_DLV_OK
low
level
error
already
set
let
it
be
passed
back
return
blkres
return
DW_DLV_OK
Following
the
original
loclist
definition
the
low
value
is
all
one
bits
the
high
value
is
the
base
address
static
int
cook_original_loclist_contents
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
Dwarf_Unsigned
baseaddress
llhead
ll_cu_base_address
Dwarf_Unsigned
count
llhead
ll_locdesc_count
Dwarf_Unsigned
i
for
i
i
count
i
Dwarf_Locdesc_c
llc
llc
llhead
ll_locdesc
i
switch
llc
ld_lle_value
case
DW_LLE_end_of_list
nothing
to
do
break
case
DW_LLE_base_address
llc
ld_lopc
llc
ld_rawhigh
llc
ld_highpc
llc
ld_rawhigh
baseaddress
llc
ld_rawhigh
break
case
DW_LLE_offset_pair
llc
ld_lopc
llc
ld_rawlow
baseaddress
llc
ld_highpc
llc
ld_rawhigh
baseaddress
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
improper
synthesized
LLE
code
of
x
is
unknown
In
standard
DWARF3
loclist
llc
ld_lle_value
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
cook_gnu_loclist_contents
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
Dwarf_Unsigned
baseaddress
llhead
ll_cu_base_address
Dwarf_Unsigned
count
llhead
ll_locdesc_count
Dwarf_Unsigned
i
Dwarf_CU_Context
cucontext
llhead
ll_context
int
res
for
i
i
count
i
Dwarf_Locdesc_c
llc
llc
llhead
ll_locdesc
i
switch
llc
ld_lle_value
case
DW_LLEX_base_address_selection_entry
Dwarf_Addr
targaddr
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawhigh
error
if
res
DW_DLV_OK
llc
ld_index_failed
TRUE
llc
ld_lopc
llc
ld_highpc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_lopc
targaddr
llc
ld_highpc
targaddr
break
case
DW_LLEX_end_of_list_entry
Nothing
to
do
break
case
DW_LLEX_start_length_entry
Dwarf_Addr
targaddr
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
llc
ld_index_failed
TRUE
llc
ld_lopc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_lopc
targaddr
llc
ld_highpc
llc
ld_lopc
llc
ld_rawhigh
break
case
DW_LLEX_offset_pair_entry
llc
ld_lopc
llc
ld_rawlow
baseaddress
llc
ld_highpc
llc
ld_rawhigh
baseaddress
break
case
DW_LLEX_start_end_entry
Dwarf_Addr
targaddr
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
llc
ld_index_failed
TRUE
llc
ld_lopc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_lopc
targaddr
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
llc
ld_index_failed
TRUE
llc
ld_highpc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_highpc
targaddr
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
improper
LLEX
code
of
x
is
unknown
GNU
LLEX
dwo
loclists
error
llc
ld_lle_value
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
return
DW_DLV_OK
DWARF5
static
int
cook_loclists_contents
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
Dwarf_Unsigned
baseaddress
llhead
ll_cu_base_address
Dwarf_Unsigned
count
llhead
ll_locdesc_count
Dwarf_Unsigned
i
Dwarf_CU_Context
cucontext
llhead
ll_context
int
res
Dwarf_Bool
base_address_fail
FALSE
Dwarf_Bool
debug_addr_fail
FALSE
if
llhead
ll_cu_base_address_present
base_address_fail
TRUE
for
i
i
count
i
Dwarf_Locdesc_c
llc
llc
llhead
ll_locdesc
i
switch
llc
ld_lle_value
case
DW_LLE_base_addressx
Dwarf_Addr
targaddr
if
debug_addr_fail
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
debug_addr_fail
TRUE
base_address_fail
TRUE
llc
ld_index_failed
TRUE
llc
ld_lopc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
base_address_fail
FALSE
baseaddress
targaddr
llc
ld_lopc
targaddr
break
case
DW_LLE_startx_endx
two
indexes
into
debug_addr
Dwarf_Addr
targaddr
if
debug_addr_fail
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
debug_addr_fail
TRUE
llc
ld_index_failed
TRUE
llc
ld_lopc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_lopc
targaddr
if
debug_addr_fail
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawhigh
error
if
res
DW_DLV_OK
debug_addr_fail
TRUE
llc
ld_index_failed
TRUE
llc
ld_highpc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_highpc
targaddr
break
case
DW_LLE_startx_length
one
index
to
debug_addr
other
a
length
Dwarf_Addr
targaddr
if
debug_addr_fail
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
cucontext
llc
ld_rawlow
error
if
res
DW_DLV_OK
debug_addr_fail
TRUE
llc
ld_index_failed
TRUE
llc
ld_lopc
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
else
llc
ld_lopc
targaddr
llc
ld_highpc
targaddr
llc
ld_rawhigh
break
case
DW_LLE_offset_pair
if
base_address_fail
llc
ld_index_failed
TRUE
llc
ld_lopc
llc
ld_highpc
else
offsets
of
the
current
base
address
llc
ld_lopc
llc
ld_rawlow
baseaddress
llc
ld_highpc
llc
ld_rawhigh
baseaddress
break
case
DW_LLE_default_location
nothing
to
do
here
just
has
a
counted
location
description
break
case
DW_LLE_base_address
llc
ld_lopc
llc
ld_rawlow
llc
ld_highpc
llc
ld_rawlow
baseaddress
llc
ld_rawlow
base_address_fail
FALSE
break
case
DW_LLE_start_end
llc
ld_lopc
llc
ld_rawlow
llc
ld_highpc
llc
ld_rawhigh
break
case
DW_LLE_start_length
llc
ld_lopc
llc
ld_rawlow
llc
ld_highpc
llc
ld_rawlow
llc
ld_rawhigh
break
case
DW_LLE_end_of_list
do
nothing
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
improper
DW_LLE
code
of
x
is
unknown
DWARF5
loclists
error
llc
ld_lle_value
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
New
October
This
interface
requires
the
use
of
interface
functions
to
get
data
from
Dwarf_Locdesc_c
The
structures
are
not
visible
to
callers
int
dwarf_get_loclist_c
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
ll_header_out
Dwarf_Unsigned
listlen_out
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Half
form
Dwarf_Loc_Head_c
llhead
Dwarf_CU_Context
cucontext
unsigned
address_size
int
cuversionstamp
Dwarf_Bool
is_cu
FALSE
Dwarf_Unsigned
attrnum
Dwarf_Bool
is_dwo
int
setup_res
DW_DLV_ERROR
int
lkind
BEGIN
CODE
setup_res
_dwarf_setup_loc
attr
error
if
setup_res
DW_DLV_OK
return
setup_res
attrnum
attr
ar_attribute
cuversionstamp
cucontext
cc_version_stamp
address_size
cucontext
cc_address_size
is_dwo
cucontext
cc_is_dwo
lkind
determine_location_lkind
cuversionstamp
form
attrnum
is_dwo
if
lkind
DW_LKIND_unknown
dwarfstring
m
const
char
formname
unknownform
const
char
attrname
unknown
attribute
dwarfstring_constructor
dwarf_get_FORM_name
form
dwarf_get_AT_name
attrnum
dwarfstring_append_printf_u
DW_DLE_LOC_EXPR_BAD
For
Compilation
Unit
version
u
cuversionstamp
dwarfstring_append_printf_u
attribute
x
attrnum
dwarfstring_append
char
attrname
dwarfstring_append_printf_u
form
x
form
dwarfstring_append
char
formname
if
is_dwo
dwarfstring_append
the
CU
is
a
dwo
else
dwarfstring_append
the
CU
is
not
a
dwo
dwarfstring_append
we
don
t
understand
the
location
_dwarf_error_string
dbg
error
DW_DLE_LOC_EXPR_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
Doing
this
early
first
to
avoid
repeating
the
alloc
code
for
each
type
llhead
Dwarf_Loc_Head_c
_dwarf_get_alloc
dbg
DW_DLA_LOC_HEAD_C
if
llhead
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
llhead
ll_cuversion
cuversionstamp
llhead
ll_kind
lkind
llhead
ll_attrnum
attrnum
llhead
ll_attrform
form
llhead
ll_dbg
dbg
llhead
ll_address_size
address_size
llhead
ll_offset_size
cucontext
cc_length_size
llhead
ll_context
cucontext
llhead
ll_at_loclists_base_present
cucontext
cc_loclists_base_present
llhead
ll_at_loclists_base
cucontext
cc_loclists_base
llhead
ll_cu_base_address_present
cucontext
cc_low_pc_present
llhead
ll_cu_base_address
cucontext
cc_low_pc
llhead
ll_cu_addr_base
cucontext
cc_addr_base
llhead
ll_cu_addr_base_present
cucontext
cc_addr_base_present
if
lkind
DW_LKIND_loclist
lkind
DW_LKIND_GNU_exp_list
int
ores
Here
we
have
a
loclist
to
deal
with
ores
context_is_cu_not_tu
cucontext
if
ores
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
setup_res
ores
_dwarf_original_loclist_build
dbg
llhead
attr
error
if
ores
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
ores
if
lkind
DW_LKIND_loclist
ores
cook_original_loclist_contents
dbg
llhead
error
else
ores
cook_gnu_loclist_contents
dbg
llhead
error
if
ores
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
ores
else
if
lkind
DW_LKIND_expression
DWARF2
int
eres
eres
_dwarf_original_expression_build
dbg
llhead
attr
error
if
eres
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
eres
else
if
lkind
DW_LKIND_loclists
DWARF5
int
leres
leres
_dwarf_loclists_fill_in_lle_head
dbg
attr
llhead
error
if
leres
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
leres
leres
cook_loclists_contents
dbg
llhead
error
if
leres
DW_DLV_OK
dwarf_loc_head_c_dealloc
llhead
return
leres
ASSERT
else
impossible
ll_header_out
llhead
listlen_out
llhead
ll_locdesc_count
return
DW_DLV_OK
An
interface
giving
us
no
cu
context
This
is
not
going
to
be
quite
right
int
dwarf_loclist_from_expr_c
Dwarf_Debug
dbg
Dwarf_Ptr
expression_in
Dwarf_Unsigned
expression_length
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Small
dwarf_version
Dwarf_Loc_Head_c
loc_head
Dwarf_Unsigned
listlen
Dwarf_Error
error
Dwarf_Block
that
describes
a
single
location
expression
Dwarf_Block_c
loc_block
Dwarf_Loc_Head_c
llhead
Dwarf_Locdesc_c
llbuf
int
local_listlen
Dwarf_Addr
rawlowpc
Dwarf_Addr
rawhighpc
MAX_ADDR
Dwarf_Small
version_stamp
dwarf_version
int
res
llhead
Dwarf_Loc_Head_c
_dwarf_get_alloc
dbg
DW_DLA_LOC_HEAD_C
if
llhead
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
sizeof
loc_block
loc_block
bl_len
expression_length
loc_block
bl_data
expression_in
loc_block
bl_kind
DW_LKIND_expression
Not
from
loclist
loc_block
bl_section_offset
Fake
Not
meaningful
loc_block
bl_locdesc_offset
Fake
Not
meaningful
llbuf
Dwarf_Locdesc_c
_dwarf_get_alloc
dbg
DW_DLA_LOCDESC_C
local_listlen
if
llbuf
dwarf_loc_head_c_dealloc
llhead
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
llhead
ll_locdesc
llbuf
llhead
ll_locdesc_count
local_listlen
llhead
ll_context
Not
available
llhead
ll_dbg
dbg
llhead
ll_kind
DW_LKIND_expression
An
empty
location
description
block
length
means
the
code
generator
emitted
no
variable
the
variable
was
not
generated
it
was
unused
or
perhaps
never
tested
after
being
set
Dwarf2
section
In
other
words
it
is
not
an
error
and
we
don
t
test
for
block
length
specially
here
Fills
in
the
locdesc
and
its
operators
list
at
index
res
_dwarf_fill_in_locdesc_op_c
dbg
llhead
address_size
offset_size
version_stamp
rawlowpc
rawhighpc
DW_LKIND_expression
error
if
res
DW_DLV_OK
low
level
error
already
set
let
it
be
passed
back
dwarf_loc_head_c_dealloc
llhead
return
DW_DLV_ERROR
loc_head
llhead
listlen
local_listlen
return
DW_DLV_OK
New
June
Supports
all
versions
of
DWARF
Distinguishes
location
entry
values
as
in
the
file
directly
raw
from
the
computed
value
lowpc_out
hipc_out
after
applying
base
values
if
any
int
dwarf_get_locdesc_entry_d
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
index
Dwarf_Small
lle_value_out
Dwarf_Unsigned
rawval1
Dwarf_Unsigned
rawval2
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lowpc_out
cooked
value
Dwarf_Addr
hipc_out
cooked
value
Dwarf_Unsigned
loclist_expr_op_count_out
Returns
pointer
to
the
specific
locdesc
of
the
index
Dwarf_Locdesc_c
locdesc_entry_out
Dwarf_Small
loclist_source_out
or
Dwarf_Unsigned
expression_offset_out
Dwarf_Unsigned
locdesc_offset_out
Dwarf_Error
error
Dwarf_Locdesc_c
descs_base
Dwarf_Locdesc_c
desc
Dwarf_Unsigned
desc_count
Dwarf_Debug
dbg
desc_count
loclist_head
ll_locdesc_count
descs_base
loclist_head
ll_locdesc
dbg
loclist_head
ll_dbg
if
index
desc_count
_dwarf_error
dbg
error
DW_DLE_LOCLIST_INDEX_ERROR
return
DW_DLV_ERROR
desc
descs_base
index
lle_value_out
desc
ld_lle_value
rawval1
desc
ld_rawlow
rawval2
desc
ld_rawhigh
lowpc_out
desc
ld_lopc
hipc_out
desc
ld_highpc
debug_addr_unavailable
desc
ld_index_failed
loclist_expr_op_count_out
desc
ld_cents
locdesc_entry_out
desc
loclist_source_out
desc
ld_kind
expression_offset_out
desc
ld_section_offset
locdesc_offset_out
desc
ld_locdesc_offset
return
DW_DLV_OK
int
dwarf_get_location_op_value_d
Dwarf_Locdesc_c
locdesc
Dwarf_Unsigned
index
Dwarf_Small
atom_out
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Unsigned
rawop1
Dwarf_Unsigned
rawop2
Dwarf_Unsigned
rawop3
Dwarf_Unsigned
offset_for_branch
Dwarf_Error
error
Dwarf_Loc_Expr_Op
op
Dwarf_Unsigned
max
locdesc
ld_cents
if
index
max
Dwarf_Debug
dbg
locdesc
ld_loclist_head
ll_dbg
_dwarf_error
dbg
error
DW_DLE_LOCLIST_INDEX_ERROR
return
DW_DLV_ERROR
op
locdesc
ld_s
index
atom_out
op
lr_atom
operand1
op
lr_number
operand2
op
lr_number2
operand3
op
lr_number3
rawop1
op
lr_raw1
rawop2
op
lr_raw2
rawop3
op
lr_raw3
offset_for_branch
op
lr_offset
return
DW_DLV_OK
int
dwarf_get_location_op_value_c
Dwarf_Locdesc_c
locdesc
Dwarf_Unsigned
index
Dwarf_Small
atom_out
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Unsigned
offset_for_branch
Dwarf_Error
error
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
raw3
int
res
res
dwarf_get_location_op_value_d
locdesc
index
atom_out
operand1
operand2
operand3
offset_for_branch
error
return
res
void
dwarf_loc_head_c_dealloc
Dwarf_Loc_Head_c
loclist_head
Dwarf_Debug
dbg
loclist_head
ll_dbg
destructor
will
remove
content
then
free
head
itself
dwarf_dealloc
dbg
loclist_head
DW_DLA_LOC_HEAD_C
End
of
the
October
interfaces
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
for
debugging
only
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_loc
h
include
dwarfstring
h
Richard
Henderson
on
DW_OP_GNU_encoded_addr
The
operand
is
an
absolute
address
The
first
byte
of
the
value
is
an
encoding
length
or
If
zero
it
means
the
following
is
address
size
The
address
then
follows
immediately
for
that
number
of
bytes
static
int
read_encoded_addr
Dwarf_Small
loc_ptr
Dwarf_Debug
dbg
Dwarf_Small
section_end_ptr
Dwarf_Half
address_size
Dwarf_Unsigned
val_out
int
len_out
Dwarf_Error
error
int
len
Dwarf_Small
op
loc_ptr
Dwarf_Unsigned
operand
len
if
op
op
address_size
switch
op
case
val_out
loc_ptr
len
break
case
READ_UNALIGNED_CK
dbg
operand
Dwarf_Unsigned
loc_ptr
error
section_end_ptr
val_out
operand
len
break
case
READ_UNALIGNED_CK
dbg
operand
Dwarf_Unsigned
loc_ptr
error
section_end_ptr
val_out
operand
len
break
case
READ_UNALIGNED_CK
dbg
operand
Dwarf_Unsigned
loc_ptr
error
section_end_ptr
val_out
operand
len
break
default
We
do
not
know
how
much
to
read
_dwarf_error
dbg
error
DW_DLE_GNU_OPCODE_ERROR
return
DW_DLV_ERROR
len_out
len
return
DW_DLV_OK
Return
DW_DLV_NO_ENTRY
when
at
the
end
of
the
ops
for
this
block
a
single
Dwarf_Loccesc
and
multiple
Dwarf_Locs
will
eventually
result
from
calling
this
till
DW_DLV_NO_ENTRY
All
op
reader
code
should
call
this
to
extract
operator
fields
For
any
DWARF
version
int
_dwarf_read_loc_expr_op
Dwarf_Debug
dbg
Dwarf_Block_c
loc_block
Caller
Start
numbering
at
Dwarf_Signed
opnumber
for
DWARF
etc
Dwarf_Half
version_stamp
Dwarf_Half
offset_size
or
Dwarf_Half
address_size
Dwarf_Signed
startoffset_in
offset
in
block
not
section
offset
Dwarf_Small
section_end
nextoffset_out
so
caller
knows
next
entry
startoffset
Dwarf_Unsigned
nextoffset_out
The
values
picked
up
Dwarf_Loc_Expr_Op
curr_loc
Dwarf_Error
error
Dwarf_Small
loc_ptr
Dwarf_Unsigned
loc_len
Dwarf_Unsigned
offset
startoffset_in
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Small
atom
Dwarf_Unsigned
leb128_length
if
offset
loc_block
bl_len
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
loc_len
loc_block
bl_len
if
offset
loc_len
return
DW_DLV_NO_ENTRY
loc_ptr
Dwarf_Small
loc_block
bl_data
offset
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
memset
curr_loc
sizeof
curr_loc
curr_loc
lr_opnumber
opnumber
curr_loc
lr_offset
offset
loc_ptr
is
ok
to
deref
see
loc_ptr
test
just
above
atom
Dwarf_Small
loc_ptr
loc_ptr
offset
curr_loc
lr_atom
atom
switch
atom
case
DW_OP_reg0
case
DW_OP_reg1
case
DW_OP_reg2
case
DW_OP_reg3
case
DW_OP_reg4
case
DW_OP_reg5
case
DW_OP_reg6
case
DW_OP_reg7
case
DW_OP_reg8
case
DW_OP_reg9
case
DW_OP_reg10
case
DW_OP_reg11
case
DW_OP_reg12
case
DW_OP_reg13
case
DW_OP_reg14
case
DW_OP_reg15
case
DW_OP_reg16
case
DW_OP_reg17
case
DW_OP_reg18
case
DW_OP_reg19
case
DW_OP_reg20
case
DW_OP_reg21
case
DW_OP_reg22
case
DW_OP_reg23
case
DW_OP_reg24
case
DW_OP_reg25
case
DW_OP_reg26
case
DW_OP_reg27
case
DW_OP_reg28
case
DW_OP_reg29
case
DW_OP_reg30
case
DW_OP_reg31
break
case
DW_OP_regx
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_lit0
case
DW_OP_lit1
case
DW_OP_lit2
case
DW_OP_lit3
case
DW_OP_lit4
case
DW_OP_lit5
case
DW_OP_lit6
case
DW_OP_lit7
case
DW_OP_lit8
case
DW_OP_lit9
case
DW_OP_lit10
case
DW_OP_lit11
case
DW_OP_lit12
case
DW_OP_lit13
case
DW_OP_lit14
case
DW_OP_lit15
case
DW_OP_lit16
case
DW_OP_lit17
case
DW_OP_lit18
case
DW_OP_lit19
case
DW_OP_lit20
case
DW_OP_lit21
case
DW_OP_lit22
case
DW_OP_lit23
case
DW_OP_lit24
case
DW_OP_lit25
case
DW_OP_lit26
case
DW_OP_lit27
case
DW_OP_lit28
case
DW_OP_lit29
case
DW_OP_lit30
case
DW_OP_lit31
operand1
atom
DW_OP_lit0
break
case
DW_OP_addr
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
address_size
error
section_end
loc_ptr
address_size
offset
address_size
break
case
DW_OP_const1u
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
break
case
DW_OP_const1s
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Sbyte
loc_ptr
SIGN_EXTEND
operand1
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
break
case
DW_OP_const2u
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_const2s
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
SIGN_EXTEND
operand1
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_const4u
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_const4s
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
SIGN_EXTEND
operand1
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_const8u
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_const8s
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_constu
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_consts
DECODE_LEB128_SWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_fbreg
DECODE_LEB128_SWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_breg0
case
DW_OP_breg1
case
DW_OP_breg2
case
DW_OP_breg3
case
DW_OP_breg4
case
DW_OP_breg5
case
DW_OP_breg6
case
DW_OP_breg7
case
DW_OP_breg8
case
DW_OP_breg9
case
DW_OP_breg10
case
DW_OP_breg11
case
DW_OP_breg12
case
DW_OP_breg13
case
DW_OP_breg14
case
DW_OP_breg15
case
DW_OP_breg16
case
DW_OP_breg17
case
DW_OP_breg18
case
DW_OP_breg19
case
DW_OP_breg20
case
DW_OP_breg21
case
DW_OP_breg22
case
DW_OP_breg23
case
DW_OP_breg24
case
DW_OP_breg25
case
DW_OP_breg26
case
DW_OP_breg27
case
DW_OP_breg28
case
DW_OP_breg29
case
DW_OP_breg30
case
DW_OP_breg31
DECODE_LEB128_SWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_bregx
uleb
reg
num
followed
by
sleb
offset
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
DECODE_LEB128_SWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_dup
case
DW_OP_drop
break
case
DW_OP_pick
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
break
case
DW_OP_over
case
DW_OP_swap
case
DW_OP_rot
case
DW_OP_deref
break
case
DW_OP_deref_size
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
break
case
DW_OP_xderef
break
case
DW_OP_xderef_type
DWARF5
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_xderef_size
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
break
case
DW_OP_abs
case
DW_OP_and
case
DW_OP_div
case
DW_OP_minus
case
DW_OP_mod
case
DW_OP_mul
case
DW_OP_neg
case
DW_OP_not
case
DW_OP_or
case
DW_OP_plus
break
case
DW_OP_plus_uconst
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_shl
case
DW_OP_shr
case
DW_OP_shra
case
DW_OP_xor
break
case
DW_OP_le
case
DW_OP_ge
case
DW_OP_eq
case
DW_OP_lt
case
DW_OP_gt
case
DW_OP_ne
break
case
DW_OP_skip
case
DW_OP_bra
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
SIGN_EXTEND
operand1
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_piece
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_nop
break
case
DW_OP_push_object_address
DWARF3
break
case
DW_OP_call2
DWARF3
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_call4
DWARF3
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_call_ref
DWARF3
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
offset_size
error
section_end
loc_ptr
loc_ptr
offset_size
offset
offset
offset_size
break
case
DW_OP_form_tls_address
DWARF3f
break
case
DW_OP_call_frame_cfa
DWARF3f
break
case
DW_OP_bit_piece
DWARF3f
uleb
size
in
bits
followed
by
uleb
offset
in
bits
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
The
operator
means
push
the
currently
computed
by
the
operations
encountered
so
far
in
this
expression
onto
the
expression
stack
as
the
offset
in
thread
local
storage
of
the
variable
case
DW_OP_GNU_push_tls_address
Believed
to
have
no
operands
Unimplemented
in
gdb
break
case
DW_OP_deref_type
DWARF5
case
DW_OP_GNU_deref_type
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
operand1
Dwarf_Small
loc_ptr
loc_ptr
loc_ptr
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
die
offset
uleb128
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_implicit_value
DWARF4
uleb
length
of
value
bytes
followed
by
that
number
of
bytes
of
the
value
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
Second
operand
is
block
of
operand1
bytes
of
stuff
This
using
the
second
operand
as
a
pointer
is
quite
ugly
This
gets
an
ugly
compiler
warning
Sorry
operand2
Dwarf_Unsigned
uintptr_t
loc_ptr
offset
offset
operand1
loc_ptr
loc_ptr
operand1
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
break
case
DW_OP_stack_value
DWARF4
break
case
DW_OP_GNU_uninit
Unimplemented
in
gdb
Carolyn
Tice
Follows
a
DW_OP_reg
or
DW_OP_regx
and
marks
the
reg
as
being
uninitialized
break
case
DW_OP_GNU_encoded_addr
Richard
Henderson
The
operand
is
an
absolute
address
The
first
byte
of
the
value
is
an
encoding
length
or
If
zero
it
means
the
following
is
address
size
The
address
then
follows
immediately
for
that
number
of
bytes
int
length
int
reares
read_encoded_addr
loc_ptr
dbg
section_end
address_size
error
if
reares
DW_DLV_OK
return
reares
loc_ptr
length
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
length
break
case
DW_OP_implicit_pointer
DWARF5
case
DW_OP_GNU_implicit_pointer
Jakub
Jelinek
The
value
is
an
optimized
out
pointer
value
Represented
as
an
offset_size
DIE
offset
a
simple
unsigned
integer
in
DWARF3
followed
by
a
signed
leb128
offset
For
DWARF2
it
is
actually
pointer
size
address
size
The
offset
is
global
a
section
offset
not
cu
relative
Relocation
to
a
different
object
file
is
up
to
the
user
per
DWARF5
Page
http
www
dwarfstd
org
ShowIssue
php?issue
Dwarf_Small
iplen
offset_size
if
version_stamp
DW_CU_VERSION2
iplen
address_size
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
iplen
error
section_end
loc_ptr
loc_ptr
iplen
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
iplen
DECODE_LEB128_SWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_entry_value
DWARF5
case
DW_OP_GNU_entry_value
Jakub
Jelinek
A
register
reused
really
soon
but
the
value
is
unchanged
So
to
represent
that
value
we
have
a
uleb128
size
followed
by
a
DWARF
expression
block
that
size
http
www
dwarfstd
org
ShowIssue
php?issue
uleb
length
of
value
bytes
followed
by
that
number
of
bytes
of
the
value
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
Second
operand
is
block
of
operand1
bytes
of
stuff
This
using
the
second
operand
as
a
pointer
is
quite
ugly
This
gets
an
ugly
compiler
warning
Sorry
operand2
Dwarf_Unsigned
uintptr_t
loc_ptr
offset
offset
operand1
loc_ptr
loc_ptr
operand1
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
break
case
DW_OP_const_type
DWARF5
case
DW_OP_GNU_const_type
die
offset
as
uleb
cu
relative
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
Next
byte
is
size
of
following
data
block
operand2
loc_ptr
loc_ptr
loc_ptr
offset
offset
Operand
points
to
a
value
in
the
block
of
size
just
gotten
as
operand2
It
must
fit
in
a
Dwarf_Unsigned
Get
the
type
from
the
die
at
operand1
a
CU
relative
offset
FIXME
We
should
do
something
very
different
than
what
we
do
here
operand3
Dwarf_Unsigned
uintptr_t
loc_ptr
loc_ptr
loc_ptr
operand2
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
offset
offset
operand2
break
case
DW_OP_regval_type
DWARF5
case
DW_OP_GNU_regval_type
reg
num
uleb
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
cu
die
off
uleb
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand2
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_convert
DWARF5
case
DW_OP_GNU_convert
case
DW_OP_reinterpret
DWARF5
case
DW_OP_GNU_reinterpret
die
offset
or
zero
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_GNU_parameter_ref
byte
unsigned
int
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
error
section_end
loc_ptr
loc_ptr
offset
offset
break
case
DW_OP_addrx
DWARF5
case
DW_OP_GNU_addr_index
DebugFission
Index
into
debug_addr
The
value
in
debug_addr
is
an
address
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_constx
DWARF5
case
DW_OP_GNU_const_index
DebugFission
Index
into
debug_addr
The
value
in
debug_addr
is
a
constant
that
fits
in
an
address
DECODE_LEB128_UWORD_LEN_CK
loc_ptr
operand1
leb128_length
dbg
error
section_end
offset
offset
leb128_length
break
case
DW_OP_GNU_variable_value
By
J
Jelinek
https
gcc
gnu
org
legacy
ml
gcc
patches
msg01499
html
READ_UNALIGNED_CK
dbg
operand1
Dwarf_Unsigned
loc_ptr
offset_size
error
section_end
loc_ptr
loc_ptr
offset_size
if
loc_ptr
section_end
_dwarf_error_string
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
DW_DLE_LOCEXPR_OFF_SECTION_END
Error
reading
DW_OP_GNU_variable_value
return
DW_DLV_ERROR
break
default
dwarfstring
m
const
char
atomname
This
can
happen
if
the
offset_size
or
address_size
in
the
OP
stream
was
incorrect
for
the
object
file
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_LOC_EXPR_BAD
as
DW_OP
atom
x
atom
dwarfstring_append
dwarf_get_OP_name
atom
dwarfstring_append
char
atomname?
atomname
no
name
dwarfstring_append
dwarfstring_append
is
unknown
_dwarf_error_string
dbg
error
DW_DLE_LOC_EXPR_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
loc_ptr
section_end
_dwarf_error
dbg
error
DW_DLE_LOCEXPR_OFF_SECTION_END
return
DW_DLV_ERROR
If
offset
loc_len
this
would
be
normal
end
of
expression
if
offset
loc_len
We
stepped
past
the
end
of
the
expression
This
has
to
be
a
compiler
bug
Operators
missing
their
values
cannot
be
detected
as
such
except
at
the
end
of
an
expression
like
this
The
results
would
be
wrong
if
returned
_dwarf_error
dbg
error
DW_DLE_LOC_BAD_TERMINATION
return
DW_DLV_ERROR
curr_loc
lr_atom
atom
curr_loc
lr_raw1
operand1
curr_loc
lr_number
operand1
curr_loc
lr_raw2
operand2
curr_loc
lr_number2
operand2
lr_number
is
a
pointer
to
a
value
iff
DW_OP_const
or
DW_OP_GNU_const_type
curr_loc
lr_raw3
operand3
curr_loc
lr_number3
operand3
nextoffset_out
offset
return
DW_DLV_OK
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_loc
h
define
SIZEOFT8
define
SIZEOFT16
define
SIZEOFT32
define
SIZEOFT64
if
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
Used
in
case
of
error
reading
the
loclists
headers
not
referring
to
Dwarf_Loc_Head_c
here
to
clean
up
static
void
free_loclists_chain
Dwarf_Debug
dbg
Dwarf_Chain
head
Dwarf_Chain
cur
head
Dwarf_Chain
next
if
head
return
for
cur
cur
next
next
cur
ch_next
if
cur
ch_item
free
cur
ch_item
cur
ch_item
dwarf_dealloc
dbg
cur
DW_DLA_CHAIN
static
int
counted_loc_descr
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Small
enddata
Dwarf_Unsigned
offset
Dwarf_Unsigned
loc_ops_overall_size
Dwarf_Unsigned
loc_ops_count_len
Dwarf_Unsigned
loc_ops_len
Dwarf_Small
opsdata
Dwarf_Unsigned
opsoffset
Dwarf_Error
err
Dwarf_Unsigned
ops_len
Dwarf_Unsigned
leblen
DECODE_LEB128_UWORD_LEN_CK
data
ops_len
leblen
dbg
err
enddata
loc_ops_count_len
leblen
loc_ops_overall_size
ops_len
leblen
loc_ops_len
ops_len
opsdata
data
opsoffset
offset
leblen
return
DW_DLV_OK
static
int
read_single_lle_entry
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Unsigned
dataoffset
Dwarf_Small
enddata
unsigned
address_size
unsigned
bytes_count_out
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
opsblocksize
Just
the
expr
data
Dwarf_Unsigned
opsoffset
Just
the
expr
ops
data
Dwarf_Small
ops
pointer
to
expr
ops
ops
Dwarf_Error
err
Dwarf_Unsigned
count
unsigned
int
leblen
unsigned
int
code
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
Dwarf_Unsigned
loc_ops_overall_size
Dwarf_Unsigned
loc_ops_count_len
Dwarf_Unsigned
loc_ops_len
Dwarf_Small
lopsdata
Dwarf_Unsigned
lopsoffset
Some
of
these
have
a
Counted
Location
Description
in
them
code
data
data
count
switch
code
case
DW_LLE_end_of_list
break
case
DW_LLE_base_addressx
DECODE_LEB128_UWORD_LEN_CK
data
val1
leblen
dbg
err
enddata
count
leblen
break
case
DW_LLE_startx_endx
case
DW_LLE_startx_length
case
DW_LLE_offset_pair
int
res
DECODE_LEB128_UWORD_LEN_CK
data
val1
leblen
dbg
err
enddata
count
leblen
DECODE_LEB128_UWORD_LEN_CK
data
val2
leblen
dbg
err
enddata
count
leblen
res
counted_loc_descr
dbg
data
enddata
dataoffset
err
if
res
DW_DLV_OK
return
res
count
loc_ops_overall_size
data
loc_ops_overall_size
break
case
DW_LLE_default_location
int
res
res
counted_loc_descr
dbg
data
enddata
dataoffset
err
if
res
DW_DLV_OK
return
res
data
loc_ops_overall_size
count
loc_ops_overall_size
break
case
DW_LLE_base_address
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
break
case
DW_LLE_start_end
int
res
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
READ_UNALIGNED_CK
dbg
val2
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
res
counted_loc_descr
dbg
data
enddata
dataoffset
err
if
res
DW_DLV_OK
return
res
count
loc_ops_overall_size
data
loc_ops_overall_size
break
case
DW_LLE_start_length
int
res
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
DECODE_LEB128_UWORD_LEN_CK
data
val2
leblen
dbg
err
enddata
count
leblen
res
counted_loc_descr
dbg
data
enddata
dataoffset
err
if
res
DW_DLV_OK
return
res
count
loc_ops_overall_size
data
loc_ops_overall_size
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
The
loclists
entry
at
debug_loclists
offset
x
dataoffset
dwarfstring_append_printf_u
has
code
x
which
is
unknown
code
_dwarf_error_string
dbg
err
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
bytes_count_out
count
entry_kind
code
entry_operand1
val1
entry_operand2
val2
opsblocksize
loc_ops_len
opsoffset
lopsoffset
ops
lopsdata
return
DW_DLV_OK
Reads
the
header
Determines
the
various
offsets
including
offset
of
the
next
header
Does
no
memory
allocations
here
int
_dwarf_internal_read_loclists_header
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
sectionlength
Dwarf_Small
data
Dwarf_Small
end_data
Dwarf_Unsigned
offset
Dwarf_Loclists_Context
buildhere
Dwarf_Unsigned
next_offset
Dwarf_Error
error
Dwarf_Small
startdata
data
Dwarf_Unsigned
arealen
int
offset_size
int
exten_size
Dwarf_Unsigned
version
unsigned
address_size
unsigned
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
localoff
Dwarf_Unsigned
lists_len
READ_AREA_LENGTH_CK
dbg
arealen
Dwarf_Unsigned
data
offset_size
exten_size
error
sectionlength
end_data
if
arealen
sectionlength
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_SECTION_SIZE_ERROR
A
debug_loclists
area
size
of
x
arealen
dwarfstring_append_printf_u
at
offset
x
offset
dwarfstring_append_printf_u
is
larger
than
the
entire
section
size
of
x
Corrupt
DWARF
sectionlength
_dwarf_error_string
dbg
error
DW_DLE_SECTION_SIZE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
lc_length
arealen
offset_size
exten_size
buildhere
lc_dbg
dbg
buildhere
lc_index
contextnum
buildhere
lc_header_offset
offset
buildhere
lc_offset_size
offset_size
buildhere
lc_extension_size
exten_size
READ_UNALIGNED_CK
dbg
version
Dwarf_Unsigned
data
SIZEOFT16
error
end_data
if
version
DW_CU_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_VERSION_STAMP_ERROR
The
version
should
be
but
we
find
u
instead
version
_dwarf_error_string
dbg
error
DW_DLE_VERSION_STAMP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
lc_version
version
data
SIZEOFT16
READ_UNALIGNED_CK
dbg
address_size
unsigned
data
SIZEOFT8
error
end_data
if
version
DW_CU_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_VERSION_STAMP_ERROR
The
version
should
be
but
we
find
u
instead
version
_dwarf_error_string
dbg
error
DW_DLE_VERSION_STAMP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
address_size
address_size
address_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ADDRESS_SIZE_ERROR
The
address
size
of
u
is
not
supported
address_size
_dwarf_error_string
dbg
error
DW_DLE_ADDRESS_SIZE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
lc_address_size
address_size
data
READ_UNALIGNED_CK
dbg
segment_selector_size
unsigned
data
SIZEOFT8
error
end_data
buildhere
lc_segment_selector_size
segment_selector_size
data
READ_UNALIGNED_CK
dbg
offset_entry_count
Dwarf_Unsigned
data
SIZEOFT32
error
end_data
buildhere
lc_offset_entry_count
offset_entry_count
data
SIZEOFT32
if
offset_entry_count
buildhere
lc_offsets_array
data
localoff
data
startdata
lists_len
offset_size
offset_entry_count
data
lists_len
buildhere
lc_offsets_off_in_sect
offset
localoff
buildhere
lc_first_loclist_offset
offset
localoff
lists_len
buildhere
lc_loclists_header
startdata
buildhere
lc_endaddr
startdata
buildhere
lc_length
buildhere
lc_past_last_loclist_offset
buildhere
lc_header_offset
buildhere
lc_length
next_offset
buildhere
lc_past_last_loclist_offset
return
DW_DLV_OK
We
return
a
pointer
to
an
array
of
contexts
not
context
pointers
through
cxt
if
we
succeed
and
are
returning
DW_DLV_OK
We
never
return
DW_DLV_NO_ENTRY
here
static
int
internal_load_loclists_contexts
Dwarf_Debug
dbg
Dwarf_Loclists_Context
cxt
Dwarf_Unsigned
count
Dwarf_Error
error
Dwarf_Unsigned
offset
Dwarf_Unsigned
nextoffset
Dwarf_Small
data
dbg
de_debug_loclists
dss_data
Dwarf_Unsigned
section_size
dbg
de_debug_loclists
dss_size
Dwarf_Small
startdata
data
Dwarf_Small
end_data
data
section_size
Dwarf_Chain
curr_chain
Dwarf_Chain
prev_chain
Dwarf_Chain
head_chain
int
res
Dwarf_Unsigned
chainlength
Dwarf_Loclists_Context
fullarray
Dwarf_Unsigned
i
for
data
end_data
Dwarf_Loclists_Context
newcontext
sizeof
the
context
struct
not
sizeof
a
pointer
newcontext
malloc
sizeof
newcontext
if
newcontext
free_loclists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Allocation
of
Loclists_Context
failed
return
DW_DLV_ERROR
memset
newcontext
sizeof
newcontext
res
_dwarf_internal_read_loclists_header
dbg
chainlength
section_size
data
end_data
offset
newcontext
error
if
res
DW_DLV_ERROR
free
newcontext
free_loclists_chain
dbg
head_chain
return
DW_DLV_ERROR
curr_chain
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_chain
NULL
free_loclists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
allocating
Loclists_Context
chain
entry
return
DW_DLV_ERROR
curr_chain
ch_item
newcontext
chainlength
if
head_chain
NULL
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
data
startdata
nextoffset
offset
nextoffset
fullarray
Dwarf_Loclists_Context
malloc
chainlength
sizeof
Dwarf_Loclists_Context
pointer
if
fullarray
free_loclists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
Allocation
of
Loclists_Context
pointer
array
failed
return
DW_DLV_ERROR
curr_chain
head_chain
for
i
i
chainlength
i
fullarray
i
Dwarf_Loclists_Context
curr_chain
ch_item
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
ASSERT
the
chain
is
entirely
dealloc
d
and
the
array
of
pointers
points
to
individually
malloc
d
Dwarf_Loclists_Context_s
cxt
fullarray
count
chainlength
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
loclists
data
Loads
all
the
debug_loclists
dwo
headers
and
returns
DW_DLV_NO_ENTRY
if
the
section
is
missing
or
empty
Intended
to
be
done
quite
early
and
done
exactly
once
Harmless
to
do
more
than
once
With
DW_DLV_OK
it
returns
the
number
of
loclists
headers
in
the
section
through
loclists_count
int
dwarf_load_loclists
Dwarf_Debug
dbg
Dwarf_Unsigned
loclists_count
Dwarf_Error
error
int
res
DW_DLV_ERROR
Dwarf_Loclists_Context
cxt
Dwarf_Unsigned
count
if
dbg
de_loclists_context
if
loclists_count
loclists_count
dbg
de_loclists_context_count
if
dbg
de_debug_loclists
dss_size
nothing
there
return
DW_DLV_NO_ENTRY
if
dbg
de_debug_loclists
dss_data
res
_dwarf_load_section
dbg
de_debug_loclists
error
if
res
DW_DLV_OK
return
res
res
internal_load_loclists_contexts
dbg
error
if
res
DW_DLV_ERROR
return
res
dbg
de_loclists_context
cxt
dbg
de_loclists_context_count
count
if
loclists_count
loclists_count
count
return
DW_DLV_OK
Frees
the
memory
in
use
in
all
loclists
contexts
Done
by
dwarf_finish
void
_dwarf_dealloc_loclists_context
Dwarf_Debug
dbg
Dwarf_Unsigned
i
Dwarf_Loclists_Context
loccon
if
dbg
de_loclists_context
return
loccon
dbg
de_loclists_context
for
i
dbg
de_loclists_context_count
i
loccon
Dwarf_Loclists_Context
con
loccon
con
lc_offsets_array
con
lc_offset_entry_count
free
con
free
dbg
de_loclists_context
dbg
de_loclists_context
dbg
de_loclists_context_count
Used
by
dwarfdump
to
print
raw
loclists
data
int
dwarf_get_loclist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
Dwarf_Loclists_Context
con
unsigned
offset_len
Dwarf_Small
offsetptr
Dwarf_Unsigned
targetoffset
if
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
if
context_index
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_loclists_context
context_index
if
offsetentry_index
con
lc_offset_entry_count
return
DW_DLV_NO_ENTRY
offset_len
con
lc_offset_size
offsetptr
con
lc_offsets_array
offsetentry_index
offset_len
READ_UNALIGNED_CK
dbg
targetoffset
Dwarf_Unsigned
offsetptr
offset_len
error
con
lc_endaddr
if
offset_value_out
offset_value_out
targetoffset
if
global_offset_value_out
global_offset_value_out
targetoffset
con
lc_offsets_off_in_sect
return
DW_DLV_OK
Used
by
dwarfdump
to
print
basic
data
from
the
data
generated
to
look
at
a
specific
loclist
as
returned
by
dwarf_loclists_index_get_rle_head
or
dwarf_loclists_offset_get_rle_head
int
dwarf_get_loclist_head_basics
Dwarf_Loc_Head_c
head
Dwarf_Small
lkind
Dwarf_Unsigned
lle_count
Dwarf_Unsigned
lle_version
Dwarf_Unsigned
loclists_index_returned
Dwarf_Unsigned
bytes_total_in_lle
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Unsigned
overall_offset_of_this_context
Dwarf_Unsigned
total_length_of_this_context
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
Dwarf_Bool
loclists_base_present
Dwarf_Unsigned
loclists_base
Dwarf_Bool
loclists_base_address_present
Dwarf_Unsigned
loclists_base_address
Dwarf_Bool
loclists_debug_addr_base_present
Dwarf_Unsigned
loclists_debug_addr_base
Dwarf_Unsigned
loclists_offset_lle_set
UNUSEDARG
Dwarf_Error
error
Dwarf_Loclists_Context
loccontext
lkind
head
ll_kind
lle_count
head
ll_locdesc_count
lle_version
head
ll_cuversion
loclists_index_returned
head
ll_index
bytes_total_in_lle
head
ll_bytes_total
offset_size
head
ll_offset_size
address_size
head
ll_address_size
segment_selector_size
head
ll_segment_selector_size
If
a
dwarf_expression
no
ll_loccontext
loccontext
head
ll_localcontext
if
loccontext
overall_offset_of_this_context
loccontext
lc_header_offset
total_length_of_this_context
loccontext
lc_length
offset_table_offset
loccontext
lc_offsets_off_in_sect
offset_table_entrycount
loccontext
lc_offset_entry_count
loclists_base_present
head
ll_at_loclists_base_present
loclists_base
head
ll_at_loclists_base
loclists_base_address_present
head
ll_cu_base_address_present
loclists_base_address
head
ll_cu_base_address
loclists_debug_addr_base_present
head
ll_cu_addr_base_present
loclists_debug_addr_base
head
ll_cu_addr_base
loclists_offset_lle_set
head
ll_llearea_offset
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
loclists
data
Enables
printing
of
details
about
the
Range
List
Table
Headers
one
header
per
call
Index
starting
at
Returns
DW_DLV_NO_ENTRY
if
index
is
too
high
for
the
table
A
debug_loclists
section
may
contain
any
number
of
Range
List
Table
Headers
with
their
details
int
dwarf_get_loclist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_loclistentry
Dwarf_Unsigned
offset_past_last_loclistentry
UNUSEDARG
Dwarf_Error
error
Dwarf_Loclists_Context
con
if
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
if
context_index
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_loclists_context
context_index
if
header_offset
header_offset
con
lc_header_offset
if
offset_size
offset_size
con
lc_offset_size
if
offset_size
extension_size
con
lc_extension_size
if
version
version
con
lc_version
if
address_size
address_size
con
lc_address_size
if
segment_selector_size
segment_selector_size
con
lc_segment_selector_size
if
offset_entry_count
offset_entry_count
con
lc_offset_entry_count
if
offset_of_offset_array
offset_of_offset_array
con
lc_offsets_off_in_sect
if
offset_of_first_loclistentry
offset_of_first_loclistentry
con
lc_first_loclist_offset
if
offset_past_last_loclistentry
offset_past_last_loclistentry
con
lc_past_last_loclist_offset
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
loclists
data
entry
offset
is
offset_of_first_loclistentry
Stop
when
the
returned
next_entry_offset
is
offset_past_last_loclistentry
from
dwarf_get_loclist_context_plus
This
only
makes
sense
within
those
loclists
This
retrieves
raw
detail
from
the
section
no
base
values
or
anything
are
added
So
this
returns
raw
individual
entries
for
a
single
loclist
header
meaning
a
a
single
Dwarf_Loclists_Context
int
dwarf_get_loclist_lle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
entrylen
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
expr_ops_blocksize
Dwarf_Unsigned
expr_ops_offset
Dwarf_Small
expr_opsdata
Dwarf_Error
err
Dwarf_Loclists_Context
con
Dwarf_Small
data
Dwarf_Small
enddata
int
res
unsigned
address_size
if
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
data
dbg
de_debug_loclists
dss_data
entry_offset
enddata
dbg
de_debug_loclists
dss_data
endoffset
if
contextnumber
dbg
de_loclists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_loclists_context
contextnumber
address_size
con
lc_address_size
res
read_single_lle_entry
dbg
data
entry_offset
enddata
address_size
entrylen
entry_kind
entry_operand1
entry_operand2
expr_ops_blocksize
expr_ops_offset
expr_opsdata
err
return
res
static
int
_dwarf_which_loclists_context
Dwarf_Debug
dbg
Dwarf_CU_Context
ctx
Dwarf_Unsigned
loclist_offset
Dwarf_Unsigned
index
Dwarf_Error
error
Dwarf_Unsigned
count
Dwarf_Loclists_Context
array
Dwarf_Unsigned
i
Dwarf_Loclists_Context
rcx
Dwarf_Unsigned
rcxoff
Dwarf_Unsigned
rcxend
array
dbg
de_loclists_context
count
dbg
de_loclists_context_count
if
array
return
DW_DLV_NO_ENTRY
rcx
array
i
rcxoff
rcx
lc_header_offset
rcxend
rcxoff
rcx
lc_length
if
ctx
cc_loclists_base_present
We
look
at
the
location
of
each
loclist
context
to
find
one
with
the
offset
the
DIE
gave
us
for
i
i
count
i
rcx
array
i
rcxoff
rcx
lc_header_offset
rcxend
rcxoff
rcx
lc_length
rcxend
rcxoff
rcx
lc_length
if
loclist_offset
rcxoff
continue
if
loclist_offset
rcxend
index
i
return
DW_DLV_OK
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
loclist
ran
off
end
finding
target
offset
of
DW_PR_XZEROS
DW_PR_DUx
loclist_offset
dwarfstring_append
Not
found
anywhere
in
debug_loclists
data
Corrupted
data?
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
We
have
a
DW_AT_loclists_base
lc_loclists_base
let
s
use
it
Dwarf_Unsigned
lookfor
lookfor
ctx
cc_loclists_base
for
i
i
count
i
dwarfstring
m
rcx
array
i
if
rcx
lc_offsets_off_in_sect
lookfor
index
i
return
DW_DLV_OK
if
rcx
lc_offsets_off_in_sect
lookfor
continue
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
loclists
base
of
DW_PR_XZEROS
DW_PR_DUx
lookfor
dwarfstring_append_printf_u
was
not
found
though
we
are
now
at
base
DW_PR_XZEROS
DW_PR_DUx
rcx
lc_offsets_off_in_sect
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
loclist
base
of
DW_PR_XZEROS
DW_PR_DUx
lookfor
dwarfstring_append
was
not
found
anywhere
in
debug_loclists
data
Corrupted
data?
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_ERROR
Caller
will
eventually
free
as
appropriate
static
int
alloc_rle_and_append_to_list
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
rctx
Dwarf_Locdesc_c
e_out
Dwarf_Error
error
Dwarf_Locdesc_c
e
e
malloc
sizeof
struct
Dwarf_Locdesc_c_s
if
e
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Out
of
memory
in
building
list
of
loclists
entries
on
a
DIE
return
DW_DLV_ERROR
memset
e
sizeof
struct
Dwarf_Locdesc_c_s
_dwarf_locdesc_c_constructor
dbg
e
if
rctx
ll_first
rctx
ll_last
ld_next
e
rctx
ll_last
e
else
rctx
ll_first
e
rctx
ll_last
e
rctx
ll_locdesc_count
e_out
e
return
DW_DLV_OK
Read
the
group
of
loclists
entries
and
finally
build
an
array
of
Dwarf_Locdesc_c
records
Attach
to
rctx
here
Since
on
error
the
caller
will
destruct
the
rctx
and
we
ensure
to
attach
allocations
there
the
caller
will
destruct
the
allocations
here
in
case
we
return
DW_DLV_ERROR
static
int
build_array_of_lle
Dwarf_Debug
dbg
Dwarf_Loc_Head_c
rctx
Dwarf_Error
error
int
res
Dwarf_Small
data
rctx
ll_llepointer
Dwarf_Unsigned
dataoffset
rctx
ll_llearea_offset
Dwarf_Small
enddata
rctx
ll_end_data_area
unsigned
int
offset_size
rctx
ll_offset_size
unsigned
int
address_size
rctx
ll_address_size
Dwarf_Unsigned
bytescounttotal
int
done
FALSE
Dwarf_Unsigned
locdesc_index
Dwarf_Unsigned
i
for
done
locdesc_index
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
Dwarf_Locdesc_c
e
Dwarf_Unsigned
opsblocksize
Dwarf_Unsigned
opsoffset
Dwarf_Small
ops
Dwarf_Block_c
eops
memset
sizeof
eops
res
read_single_lle_entry
dbg
data
dataoffset
enddata
address_size
error
if
res
DW_DLV_OK
return
res
res
alloc_rle_and_append_to_list
dbg
rctx
error
if
res
DW_DLV_OK
return
res
eops
bl_len
opsblocksize
eops
bl_data
ops
eops
bl_kind
rctx
ll_kind
eops
bl_section_offset
opsoffset
eops
bl_locdesc_offset
dataoffset
e
ld_kind
rctx
ll_kind
e
ld_lle_value
code
e
ld_entrylen
entrylen
e
ld_rawlow
val1
e
ld_rawhigh
val2
e
ld_opsblock
eops
bytescounttotal
entrylen
data
entrylen
if
code
DW_LLE_end_of_list
done
TRUE
break
if
rctx
ll_locdesc_count
Dwarf_Locdesc_c
array
Dwarf_Locdesc_c
cur
Dwarf_Locdesc_c
prev
array
of
structs
Here
we
copy
the
previous
malloc
set
of
Dwarf_Locdesc_c
into
a
dwarf_get_alloc
set
and
free
the
malloc
set
array
Dwarf_Locdesc_c
_dwarf_get_alloc
dbg
DW_DLA_LOCDESC_C
rctx
ll_locdesc_count
if
array
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Out
of
memory
in
copying
list
of
locdescs
into
array
return
DW_DLV_ERROR
rctx
ll_locdesc
array
cur
rctx
ll_first
for
i
i
rctx
ll_locdesc_count
i
prev
cur
array
i
cur
cur
cur
ld_next
free
prev
rctx
ll_first
rctx
ll_last
for
i
i
rctx
ll_locdesc_count
i
Dwarf_Locdesc_c
ldc
rctx
ll_locdesc
i
res
_dwarf_fill_in_locdesc_op_c
dbg
i
rctx
ld_opsblock
address_size
offset_size
rctx
ll_cuversion
ldc
ld_rawlow
ldc
ld_rawhigh
ldc
ld_lle_value
error
if
res
DW_DLV_OK
return
res
rctx
ll_bytes_total
bytescounttotal
return
DW_DLV_OK
Build
a
head
with
all
the
relevent
Entries
attached
all
the
locdescs
and
for
each
such
all
its
expression
operators
int
_dwarf_loclists_fill_in_lle_head
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
int
res
Dwarf_Unsigned
loclists_contextnum
Dwarf_Small
table_base
Dwarf_Small
table_entry
Dwarf_Small
enddata
Dwarf_Loclists_Context
array
Dwarf_Loclists_Context
rctx
Dwarf_Unsigned
entrycount
unsigned
offsetsize
Dwarf_Unsigned
lle_global_offset
Dwarf_CU_Context
ctx
Dwarf_Unsigned
offset_in_loclists
Dwarf_Bool
is_loclistx
FALSE
int
theform
llhead
ll_attrform
Dwarf_Unsigned
attr_val
ctx
attr
ar_cu_context
array
dbg
de_loclists_context
if
theform
DW_FORM_sec_offset
DW_FORM_sec_offset
is
not
formudata
often
seen
in
in
DW5
DW_AT_location
etc
res
dwarf_global_formref
attr
error
if
res
DW_DLV_OK
return
res
offset_in_loclists
attr_val
else
if
theform
DW_FORM_loclistx
is_loclistx
TRUE
res
dwarf_formudata
attr
error
if
res
DW_DLV_OK
return
res
the
context
cc_loclists_base
gives
the
offset
of
the
array
of
offsets
if
cc_loclists_base_present
offset_in_loclists
attr_val
if
is_loclistx
if
ctx
cc_loclists_base_present
offset_in_loclists
ctx
cc_loclists_base
else
if
dbg
de_loclists_context_count
missing
a
DW_AT_loclists_base
offset_in_loclists
else
FIXME
check
in
tied
file
for
a
cc_loclists_base
possibly?
Make
any
sense?
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
loclists
table
index
of
u
attr_val
dwarfstring_append
is
unusable
without
a
tied
file
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
offset_in_loclists
attr_val
res
_dwarf_which_loclists_context
dbg
ctx
offset_in_loclists
error
if
res
DW_DLV_OK
return
res
rctx
array
loclists_contextnum
table_base
rctx
lc_offsets_array
entrycount
rctx
lc_offset_entry_count
offsetsize
rctx
lc_offset_size
enddata
rctx
lc_endaddr
if
is_loclistx
attr_val
entrycount
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LOCLISTS_ERROR
loclists
table
index
of
u
attr_val
dwarfstring_append_printf_u
too
large
for
table
of
u
entries
entrycount
_dwarf_error_string
dbg
error
DW_DLE_LOCLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
llhead
ll_localcontext
rctx
llhead
ll_index
loclists_contextnum
llhead
ll_cuversion
rctx
lc_version
llhead
ll_offset_size
offsetsize
llhead
ll_address_size
rctx
lc_address_size
llhead
ll_segment_selector_size
rctx
lc_segment_selector_size
if
is_loclistx
Dwarf_Unsigned
table_entryval
table_entry
attr_val
offsetsize
table_base
No
malloc
here
yet
so
no
leak
if
the
macro
returns
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
table_entryval
Dwarf_Unsigned
table_entry
offsetsize
error
enddata
lle_global_offset
rctx
lc_offsets_off_in_sect
table_entryval
else
lle_global_offset
attr_val
llhead
ll_end_data_area
enddata
llhead
ll_llearea_offset
lle_global_offset
llhead
ll_llepointer
lle_global_offset
dbg
de_debug_loclists
dss_data
res
build_array_of_lle
dbg
llhead
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
int
dwarf_get_loclists_entry_fields
Dwarf_Loc_Head_c
head
Dwarf_Unsigned
entrynum
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
FIXME
not
right
for
loclists
or
their
loc
exprs
UNUSEDARG
Dwarf_Error
err
Dwarf_Locdesc_c
e
if
entrynum
head
ll_locdesc_count
return
DW_DLV_NO_ENTRY
e
head
ll_locdesc
entrynum
entrylen
e
ld_entrylen
code
e
ld_lle_value
raw1
e
ld_rawlow
raw2
e
ld_rawhigh
cooked1
e
ld_lopc
cooked2
e
ld_highpc
return
DW_DLV_OK
Deals
with
both
fully
and
partially
build
head
void
_dwarf_free_loclists_head_content
Dwarf_Loc_Head_c
head
Dwarf_Debug
dbg
head
ll_dbg
if
head
ll_first
partially
built
head
ASSERT
ll_loclists
is
NULL
Dwarf_Locdesc_c
cur
head
ll_first
Dwarf_Locdesc_c
next
for
cur
cur
next
next
cur
ld_next
cur
ld_next
free
cur
head
ll_first
head
ll_last
head
ll_locdesc_count
else
if
head
ll_locdesc
Dwarf_Locdesc_c
desc
head
ll_locdesc
ASSERT
ll_first
and
ll_last
are
NULL
fully
built
head
Dwarf_Unsigned
listlen
head
ll_locdesc_count
Dwarf_Unsigned
i
for
i
listlen
i
Dwarf_Loc_Expr_Op
loc
desc
i
ld_s
if
loc
dwarf_dealloc
dbg
loc
DW_DLA_LOC_BLOCK_C
desc
i
ld_s
dwarf_dealloc
dbg
head
ll_locdesc
DW_DLA_LOCDESC_C
head
ll_locdesc
head
ll_locdesc_count
dwarf_alloc
calls
this
on
dealloc
head
is
freed
there
after
this
returns
void
_dwarf_loclists_head_destructor
void
head
Dwarf_Loc_Head_c
h
head
_dwarf_free_loclists_head_content
h
Copyright
c
David
Anderson
All
rights
reserved
cc
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
file
reads
the
parts
of
an
Apple
mach
o
object
file
appropriate
to
reading
DWARF
debugging
data
Overview
_dwarf_macho_setup
Does
all
macho
setup
calls
_dwarf_macho_access_init
calls
_dwarf_macho_object_access_internals_init
Creates
internals
record
M
dwarf_macho_object_access_internals_t
Sets
flags
data
in
internals
record
Loads
macho
object
data
needed
later
Sets
methods
struct
to
access
macho
object
calls
_dwarf_object_init_b
Creates
Dwarf_Debug
independent
of
any
macho
code
Sets
internals
record
into
dbg
_dwarf_destruct_macho_access
This
frees
the
macho
internals
record
created
in
_dwarf_macho_object_access_internals_init
in
case
of
errors
during
setup
or
when
dwarf_finish
is
called
Works
safely
for
partially
or
fully
set
up
macho
internals
record
Other
than
in
_dwarf_macho_setup
the
macho
code
knows
nothing
about
Dwarf_Debug
and
the
rest
of
libdwarf
knows
nothing
about
the
content
of
the
macho
internals
record
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
open
include
time
h
ifdef
_WIN32
include
io
h
lseek
read
close
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf
h
include
libdwarf_private
h
include
dwarf_base_types
h
include
dwarf_opaque
h
include
dwarf_error
h
for
_dwarf_error
declaration
include
dwarf_reading
h
include
memcpy_swap
h
include
dwarf_object_read_common
h
include
dwarf_machoread
h
include
dwarf_object_detector
h
include
dwarf_macho_loader
h
ifndef
TYP
define
TYP
n
l
char
n
l
endif
TYPE
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
MACH
O
and
dwarf
section
names
static
struct
macho_sect_names_s
char
const
ms_moname
char
const
ms_dwname
const
SectionNames
ELF
index
entry
__debug_abbrev
debug_abbrev
__debug_aranges
debug_aranges
__debug_frame
debug_frame
__debug_info
debug_info
__debug_line
debug_line
__debug_macinfo
debug_macinfo
__debug_loc
debug_loc
__debug_pubnames
debug_pubnames
__debug_pubtypes
debug_pubtypes
__debug_str
debug_str
__debug_ranges
debug_ranges
__debug_macro
debug_macro
__debug_gdb_scri
debug_gdb_scripts
static
int
_dwarf_macho_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
static
Dwarf_Endianness
macho_get_byte_order
void
obj
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
return
macho
mo_endian
static
Dwarf_Small
macho_get_length_size
void
obj
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
return
macho
mo_offsetsize
static
Dwarf_Small
macho_get_pointer_size
void
obj
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
return
macho
mo_pointersize
static
Dwarf_Unsigned
macho_get_section_count
void
obj
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
return
macho
mo_dwarf_sectioncount
static
int
macho_get_section_info
void
obj
Dwarf_Half
section_index
Dwarf_Obj_Access_Section
return_section
UNUSEDARG
int
error
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
if
section_index
macho
mo_dwarf_sectioncount
struct
generic_macho_section
sp
sp
macho
mo_dwarf_sections
section_index
return_section
addr
return_section
type
return_section
size
sp
size
return_section
name
sp
dwarfsectname
return_section
link
return_section
info
return_section
entrysize
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
macho_load_section
void
obj
Dwarf_Half
section_index
Dwarf_Small
return_data
int
error
dwarf_macho_object_access_internals_t
macho
dwarf_macho_object_access_internals_t
obj
if
section_index
section_index
macho
mo_dwarf_sectioncount
int
res
struct
generic_macho_section
sp
macho
mo_dwarf_sections
section_index
if
sp
loaded_data
return_data
sp
loaded_data
return
DW_DLV_OK
if
sp
size
return
DW_DLV_NO_ENTRY
if
sp
size
sp
offset
macho
mo_filesize
error
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
sp
loaded_data
malloc
size_t
sp
size
if
sp
loaded_data
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
RRMOA
macho
mo_fd
sp
loaded_data
off_t
sp
offset
size_t
sp
size
off_t
macho
mo_filesize
error
if
res
DW_DLV_OK
free
sp
loaded_data
sp
loaded_data
return
res
return_data
sp
loaded_data
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
void
_dwarf_destruct_macho_access
struct
Dwarf_Obj_Access_Interface_s
aip
dwarf_macho_object_access_internals_t
mp
Dwarf_Unsigned
i
if
aip
return
mp
dwarf_macho_object_access_internals_t
aip
object
if
mp
mo_destruct_close_fd
close
mp
mo_fd
mp
mo_fd
if
mp
mo_commands
free
mp
mo_commands
mp
mo_commands
if
mp
mo_segment_commands
free
mp
mo_segment_commands
mp
mo_segment_commands
free
char
mp
mo_path
if
mp
mo_dwarf_sections
struct
generic_macho_section
sp
sp
mp
mo_dwarf_sections
for
i
i
mp
mo_dwarf_sectioncount
i
sp
if
sp
loaded_data
free
sp
loaded_data
sp
loaded_data
free
mp
mo_dwarf_sections
mp
mo_dwarf_sections
free
mp
free
aip
return
load_macho_header32
dwarf_macho_object_access_internals_t
mfp
static
int
load_macho_header32
dwarf_macho_object_access_internals_t
mfp
int
errcode
struct
mach_header
mh32
int
res
if
sizeof
mh32
mfp
mo_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
res
RRMOA
mfp
mo_fd
sizeof
mh32
off_t
mfp
mo_filesize
errcode
if
res
DW_DLV_OK
return
res
Do
not
adjust
endianness
of
magic
leave
as
is
ASNAR
memcpy
mfp
mo_header
magic
mh32
magic
ASNAR
mfp
mo_copy_word
mfp
mo_header
cputype
mh32
cputype
ASNAR
mfp
mo_copy_word
mfp
mo_header
cpusubtype
mh32
cpusubtype
ASNAR
mfp
mo_copy_word
mfp
mo_header
filetype
mh32
filetype
ASNAR
mfp
mo_copy_word
mfp
mo_header
ncmds
mh32
ncmds
ASNAR
mfp
mo_copy_word
mfp
mo_header
sizeofcmds
mh32
sizeofcmds
ASNAR
mfp
mo_copy_word
mfp
mo_header
flags
mh32
flags
mfp
mo_header
reserved
mfp
mo_command_count
unsigned
int
mfp
mo_header
ncmds
mfp
mo_command_start_offset
sizeof
mh32
return
DW_DLV_OK
load_macho_header64
dwarf_macho_object_access_internals_t
mfp
static
int
load_macho_header64
dwarf_macho_object_access_internals_t
mfp
int
errcode
struct
mach_header_64
mh64
int
res
if
sizeof
mh64
mfp
mo_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
res
RRMOA
mfp
mo_fd
sizeof
mh64
off_t
mfp
mo_filesize
errcode
if
res
DW_DLV_OK
return
res
Do
not
adjust
endianness
of
magic
leave
as
is
ASNAR
memcpy
mfp
mo_header
magic
mh64
magic
ASNAR
mfp
mo_copy_word
mfp
mo_header
cputype
mh64
cputype
ASNAR
mfp
mo_copy_word
mfp
mo_header
cpusubtype
mh64
cpusubtype
ASNAR
mfp
mo_copy_word
mfp
mo_header
filetype
mh64
filetype
ASNAR
mfp
mo_copy_word
mfp
mo_header
ncmds
mh64
ncmds
ASNAR
mfp
mo_copy_word
mfp
mo_header
sizeofcmds
mh64
sizeofcmds
ASNAR
mfp
mo_copy_word
mfp
mo_header
flags
mh64
flags
ASNAR
mfp
mo_copy_word
mfp
mo_header
reserved
mh64
reserved
mfp
mo_command_count
unsigned
int
mfp
mo_header
ncmds
mfp
mo_command_start_offset
sizeof
mh64
return
DW_DLV_OK
int
dwarf_load_macho_header
dwarf_macho_object_access_internals_t
mfp
int
errcode
int
res
if
mfp
mo_offsetsize
res
load_macho_header32
mfp
errcode
else
if
mfp
mo_offsetsize
res
load_macho_header64
mfp
errcode
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
return
res
static
int
load_segment_command_content32
dwarf_macho_object_access_internals_t
mfp
struct
generic_macho_command
mmp
struct
generic_macho_segment_command
msp
Dwarf_Unsigned
mmpindex
int
errcode
struct
segment_command
sc
int
res
Dwarf_Unsigned
filesize
mfp
mo_filesize
Dwarf_Unsigned
segoffset
mmp
offset_this_command
Dwarf_Unsigned
afterseghdr
segoffset
sizeof
sc
if
mmp
offset_this_command
filesize
mmp
cmdsize
filesize
mmp
cmdsize
mmp
offset_this_command
filesize
errcode
DW_DLE_MACH_O_SEGOFFSET_BAD
return
DW_DLV_ERROR
res
RRMOA
mfp
mo_fd
off_t
mmp
offset_this_command
sizeof
sc
off_t
filesize
errcode
if
res
DW_DLV_OK
return
res
ASNAR
mfp
mo_copy_word
msp
cmd
sc
cmd
ASNAR
mfp
mo_copy_word
msp
cmdsize
sc
cmdsize
strncpy
msp
segname
sc
segname
msp
segname
ASNAR
mfp
mo_copy_word
msp
vmaddr
sc
vmaddr
ASNAR
mfp
mo_copy_word
msp
vmsize
sc
vmsize
ASNAR
mfp
mo_copy_word
msp
fileoff
sc
fileoff
ASNAR
mfp
mo_copy_word
msp
filesize
sc
filesize
if
msp
fileoff
mfp
mo_filesize
msp
filesize
mfp
mo_filesize
corrupt
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
if
msp
fileoff
msp
filesize
filesize
corrupt
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
ASNAR
mfp
mo_copy_word
msp
maxprot
sc
maxprot
ASNAR
mfp
mo_copy_word
msp
initprot
sc
initprot
ASNAR
mfp
mo_copy_word
msp
nsects
sc
nsects
ASNAR
mfp
mo_copy_word
msp
flags
sc
flags
msp
macho_command_index
mmpindex
msp
sectionsoffset
afterseghdr
return
DW_DLV_OK
static
int
load_segment_command_content64
dwarf_macho_object_access_internals_t
mfp
struct
generic_macho_command
mmp
struct
generic_macho_segment_command
msp
Dwarf_Unsigned
mmpindex
int
errcode
struct
segment_command_64
sc
int
res
Dwarf_Unsigned
filesize
mfp
mo_filesize
Dwarf_Unsigned
segoffset
mmp
offset_this_command
Dwarf_Unsigned
afterseghdr
segoffset
sizeof
sc
if
mmp
offset_this_command
filesize
mmp
cmdsize
filesize
mmp
cmdsize
mmp
offset_this_command
filesize
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
res
RRMOA
mfp
mo_fd
off_t
mmp
offset_this_command
sizeof
sc
off_t
filesize
errcode
if
res
DW_DLV_OK
return
res
ASNAR
mfp
mo_copy_word
msp
cmd
sc
cmd
ASNAR
mfp
mo_copy_word
msp
cmdsize
sc
cmdsize
strncpy
msp
segname
sc
segname
msp
segname
ASNAR
mfp
mo_copy_word
msp
vmaddr
sc
vmaddr
ASNAR
mfp
mo_copy_word
msp
vmsize
sc
vmsize
ASNAR
mfp
mo_copy_word
msp
fileoff
sc
fileoff
ASNAR
mfp
mo_copy_word
msp
filesize
sc
filesize
if
msp
fileoff
filesize
msp
filesize
filesize
corrupt
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
if
msp
fileoff
msp
filesize
filesize
corrupt
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
ASNAR
mfp
mo_copy_word
msp
maxprot
sc
maxprot
ASNAR
mfp
mo_copy_word
msp
initprot
sc
initprot
ASNAR
mfp
mo_copy_word
msp
nsects
sc
nsects
ASNAR
mfp
mo_copy_word
msp
flags
sc
flags
msp
macho_command_index
mmpindex
msp
sectionsoffset
afterseghdr
return
DW_DLV_OK
static
int
dwarf_macho_load_segment_commands
dwarf_macho_object_access_internals_t
mfp
int
errcode
Dwarf_Unsigned
i
struct
generic_macho_command
mmp
struct
generic_macho_segment_command
msp
if
mfp
mo_segment_count
return
DW_DLV_OK
mfp
mo_segment_commands
struct
generic_macho_segment_command
calloc
sizeof
struct
generic_macho_segment_command
size_t
mfp
mo_segment_count
if
mfp
mo_segment_commands
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
mmp
mfp
mo_commands
msp
mfp
mo_segment_commands
for
i
i
mfp
mo_command_count
i
mmp
unsigned
cmd
unsigned
mmp
cmd
int
res
if
cmd
LC_SEGMENT
res
load_segment_command_content32
mfp
mmp
msp
i
errcode
msp
else
if
cmd
LC_SEGMENT_64
res
load_segment_command_content64
mfp
mmp
msp
i
errcode
msp
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
static
int
dwarf_macho_load_dwarf_section_details32
dwarf_macho_object_access_internals_t
mfp
struct
generic_macho_segment_command
segp
Dwarf_Unsigned
segi
int
errcode
Dwarf_Unsigned
seci
Dwarf_Unsigned
seccount
segp
nsects
Dwarf_Unsigned
secalloc
seccount
Dwarf_Unsigned
curoff
segp
sectionsoffset
Dwarf_Unsigned
shdrlen
sizeof
struct
section
struct
generic_macho_section
secs
secs
struct
generic_macho_section
calloc
sizeof
struct
generic_macho_section
size_t
secalloc
if
secs
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_OK
mfp
mo_dwarf_sections
secs
mfp
mo_dwarf_sectioncount
secalloc
if
curoff
mfp
mo_filesize
seccount
mfp
mo_filesize
curoff
seccount
sizeof
struct
section
mfp
mo_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
secs
offset_of_sec_rec
curoff
Leave
section
all
zeros
except
our
offset
elf
like
in
a
sense
secs
dwarfsectname
secs
seci
for
seci
secalloc
seci
secs
curoff
shdrlen
struct
section
mosec
int
res
res
RRMOA
mfp
mo_fd
off_t
curoff
sizeof
mosec
off_t
mfp
mo_filesize
errcode
if
res
DW_DLV_OK
return
res
strncpy
secs
sectname
mosec
sectname
secs
sectname
strncpy
secs
segname
mosec
segname
secs
segname
ASNAR
mfp
mo_copy_word
secs
addr
mosec
addr
ASNAR
mfp
mo_copy_word
secs
size
mosec
size
ASNAR
mfp
mo_copy_word
secs
offset
mosec
offset
ASNAR
mfp
mo_copy_word
secs
align
mosec
align
ASNAR
mfp
mo_copy_word
secs
reloff
mosec
reloff
ASNAR
mfp
mo_copy_word
secs
nreloc
mosec
nreloc
ASNAR
mfp
mo_copy_word
secs
flags
mosec
flags
if
secs
offset
mfp
mo_filesize
secs
size
mfp
mo_filesize
secs
offset
secs
size
mfp
mo_filesize
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
secs
reserved1
secs
reserved2
secs
reserved3
secs
generic_segment_num
segi
secs
offset_of_sec_rec
curoff
return
DW_DLV_OK
static
int
dwarf_macho_load_dwarf_section_details64
dwarf_macho_object_access_internals_t
mfp
struct
generic_macho_segment_command
segp
Dwarf_Unsigned
segi
int
errcode
Dwarf_Unsigned
seci
Dwarf_Unsigned
seccount
segp
nsects
Dwarf_Unsigned
secalloc
seccount
Dwarf_Unsigned
curoff
segp
sectionsoffset
Dwarf_Unsigned
shdrlen
sizeof
struct
section_64
struct
generic_macho_section
secs
secs
struct
generic_macho_section
calloc
sizeof
struct
generic_macho_section
size_t
secalloc
if
secs
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
mfp
mo_dwarf_sections
secs
mfp
mo_dwarf_sectioncount
secalloc
secs
offset_of_sec_rec
curoff
Leave
section
all
zeros
except
our
offset
elf
like
in
a
sense
secs
dwarfsectname
secs
if
curoff
mfp
mo_filesize
seccount
mfp
mo_filesize
curoff
seccount
sizeof
struct
section_64
mfp
mo_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
seci
for
seci
secalloc
seci
secs
curoff
shdrlen
int
res
struct
section_64
mosec
res
RRMOA
mfp
mo_fd
off_t
curoff
sizeof
mosec
off_t
mfp
mo_filesize
errcode
if
res
DW_DLV_OK
return
res
strncpy
secs
sectname
mosec
sectname
secs
sectname
strncpy
secs
segname
mosec
segname
secs
segname
ASNAR
mfp
mo_copy_word
secs
addr
mosec
addr
ASNAR
mfp
mo_copy_word
secs
size
mosec
size
ASNAR
mfp
mo_copy_word
secs
offset
mosec
offset
ASNAR
mfp
mo_copy_word
secs
align
mosec
align
ASNAR
mfp
mo_copy_word
secs
reloff
mosec
reloff
ASNAR
mfp
mo_copy_word
secs
nreloc
mosec
nreloc
ASNAR
mfp
mo_copy_word
secs
flags
mosec
flags
if
secs
offset
mfp
mo_filesize
secs
size
mfp
mo_filesize
secs
offset
secs
size
mfp
mo_filesize
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_OK
secs
reserved1
secs
reserved2
secs
reserved3
secs
offset_of_sec_rec
curoff
secs
generic_segment_num
segi
return
DW_DLV_OK
static
int
dwarf_macho_load_dwarf_section_details
dwarf_macho_object_access_internals_t
mfp
struct
generic_macho_segment_command
segp
Dwarf_Unsigned
segi
int
errcode
int
res
if
mfp
mo_offsetsize
res
dwarf_macho_load_dwarf_section_details32
mfp
segp
segi
errcode
else
if
mfp
mo_offsetsize
res
dwarf_macho_load_dwarf_section_details64
mfp
segp
segi
errcode
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
return
res
static
int
dwarf_macho_load_dwarf_sections
dwarf_macho_object_access_internals_t
mfp
int
errcode
Dwarf_Unsigned
segi
struct
generic_macho_segment_command
segp
mfp
mo_segment_commands
for
segi
mfp
mo_segment_count
segi
segp
int
res
if
strcmp
segp
segname
__DWARF
continue
Found
DWARF
for
now
assume
only
one
such
res
dwarf_macho_load_dwarf_section_details
mfp
segp
segi
errcode
return
res
return
DW_DLV_OK
Works
the
same
or
bit
int
dwarf_load_macho_commands
dwarf_macho_object_access_internals_t
mfp
int
errcode
Dwarf_Unsigned
cmdi
Dwarf_Unsigned
curoff
mfp
mo_command_start_offset
Dwarf_Unsigned
cmdspace
struct
load_command
mc
struct
generic_macho_command
mcp
unsigned
segment_command_count
int
res
if
mfp
mo_command_count
mfp
mo_filesize
corrupt
object
errcode
DW_DLE_MACH_O_SEGOFFSET_BAD
return
DW_DLV_ERROR
if
curoff
mfp
mo_command_count
sizeof
mc
mfp
mo_filesize
corrupt
object
errcode
DW_DLE_MACH_O_SEGOFFSET_BAD
return
DW_DLV_ERROR
mfp
mo_commands
struct
generic_macho_command
calloc
mfp
mo_command_count
sizeof
struct
generic_macho_command
if
mfp
mo_commands
out
of
memory
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
mcp
mfp
mo_commands
for
cmdi
mfp
mo_header
ncmds
cmdi
mcp
res
RRMOA
mfp
mo_fd
off_t
curoff
sizeof
mc
off_t
mfp
mo_filesize
errcode
if
res
DW_DLV_OK
return
res
ASNAR
mfp
mo_copy_word
mcp
cmd
mc
cmd
ASNAR
mfp
mo_copy_word
mcp
cmdsize
mc
cmdsize
mcp
offset_this_command
curoff
curoff
mcp
cmdsize
cmdspace
mcp
cmdsize
if
mcp
cmdsize
mfp
mo_filesize
curoff
mfp
mo_filesize
corrupt
object
errcode
DW_DLE_FILE_OFFSET_BAD
return
DW_DLV_ERROR
if
mcp
cmd
LC_SEGMENT
mcp
cmd
LC_SEGMENT_64
segment_command_count
mfp
mo_segment_count
segment_command_count
res
dwarf_macho_load_segment_commands
mfp
errcode
if
res
DW_DLV_OK
return
res
res
dwarf_macho_load_dwarf_sections
mfp
errcode
return
res
int
_dwarf_macho_setup
int
fd
char
true_path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Obj_Access_Interface
binary_interface
dwarf_macho_object_access_internals_t
intfc
int
res
DW_DLV_OK
int
localerrnum
res
_dwarf_macho_object_access_init
fd
ftype
endian
offsetsize
filesize
if
res
DW_DLV_OK
if
res
DW_DLV_NO_ENTRY
return
res
_dwarf_error
NULL
error
localerrnum
return
DW_DLV_ERROR
allocates
and
initializes
Dwarf_Debug
generic
code
res
dwarf_object_init_b
binary_interface
errhand
errarg
groupnumber
dbg
error
if
res
DW_DLV_OK
_dwarf_destruct_macho_access
binary_interface
return
res
intfc
binary_interface
object
intfc
mo_path
strdup
true_path
return
res
static
Dwarf_Obj_Access_Methods
const
macho_methods
macho_get_section_info
macho_get_byte_order
macho_get_length_size
macho_get_pointer_size
macho_get_section_count
macho_load_section
We
do
not
do
macho
relocations
dsym
files
do
not
require
it
NULL
On
any
error
this
frees
internals
argument
static
int
_dwarf_macho_object_access_internals_init
dwarf_macho_object_access_internals_t
internals
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
int
errcode
dwarf_macho_object_access_internals_t
intfc
internals
Dwarf_Unsigned
i
struct
generic_macho_section
sp
struct
Dwarf_Obj_Access_Interface_s
localdoas
int
res
Must
malloc
as
_dwarf_destruct_macho_access
forces
that
due
to
other
uses
localdoas
struct
Dwarf_Obj_Access_Interface_s
malloc
sizeof
struct
Dwarf_Obj_Access_Interface_s
if
localdoas
free
internals
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
localdoas
sizeof
struct
Dwarf_Obj_Access_Interface_s
intfc
mo_ident
M
intfc
mo_ident
intfc
mo_fd
fd
intfc
mo_is_64bit
offsetsize
FALSE
intfc
mo_offsetsize
offsetsize
intfc
mo_pointersize
offsetsize
intfc
mo_filesize
filesize
intfc
mo_ftype
ftype
ifdef
WORDS_BIGENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
mo_copy_word
_dwarf_memcpy_swap_bytes
intfc
mo_endian
DW_OBJECT_LSB
else
intfc
mo_copy_word
_dwarf_memcpy_noswap_bytes
intfc
mo_endian
DW_OBJECT_MSB
else
LITTLE
ENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
mo_copy_word
_dwarf_memcpy_noswap_bytes
intfc
mo_endian
DW_OBJECT_LSB
else
intfc
mo_copy_word
_dwarf_memcpy_swap_bytes
intfc
mo_endian
DW_OBJECT_MSB
endif
LITTLE
BIG
ENDIAN
res
dwarf_load_macho_header
intfc
errcode
if
res
DW_DLV_OK
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_macho_access
localdoas
return
res
Load
sections
res
dwarf_load_macho_commands
intfc
errcode
if
res
DW_DLV_OK
localdoas
methods
localdoas
object
intfc
_dwarf_destruct_macho_access
localdoas
return
res
sp
intfc
mo_dwarf_sections
for
i
i
intfc
mo_dwarf_sectioncount
i
sp
int
j
int
lim
sizeof
SectionNames
sizeof
SectionNames
sp
dwarfsectname
for
j
lim
j
if
strcmp
sp
sectname
SectionNames
j
ms_moname
sp
dwarfsectname
SectionNames
j
ms_dwname
break
free
localdoas
return
DW_DLV_OK
static
int
_dwarf_macho_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
int
res
dwarf_macho_object_access_internals_t
internals
Dwarf_Obj_Access_Interface
intfc
internals
malloc
sizeof
dwarf_macho_object_access_internals_t
if
internals
localerrnum
DW_DLE_ALLOC_FAIL
Impossible
case
we
hope
Give
up
return
DW_DLV_ERROR
memset
internals
sizeof
internals
res
_dwarf_macho_object_access_internals_init
internals
fd
ftype
endian
offsetsize
filesize
localerrnum
if
res
DW_DLV_OK
err
is
already
set
and
the
call
freed
internals
return
DW_DLV_ERROR
intfc
malloc
sizeof
Dwarf_Obj_Access_Interface
if
intfc
Impossible
case
we
hope
Give
up
free
internals
localerrnum
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Initialize
the
interface
struct
intfc
object
internals
intfc
methods
binary_interface
intfc
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
limits
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_macro
h
define
LEFTPAREN
define
RIGHTPAREN
define
SPACE
Given
the
dwarf
macro
string
return
a
pointer
to
the
value
Returns
pointer
to
byte
at
end
of
string
if
no
value
found
meaning
the
value
is
the
empty
string
Only
understands
well
formed
dwarf
macinfo
strings
char
dwarf_find_macro_value_start
char
str
char
lcp
int
funclike
for
lcp
str
lcp
lcp
switch
lcp
case
LEFTPAREN
funclike
break
case
RIGHTPAREN
lcp
must
be
a
space
and
following
char
is
the
value
return
lcp
case
SPACE
We
allow
extraneous
spaces
inside
macro
parameter
list
just
in
case
This
is
not
really
needed
if
funclike
return
lcp
break
Never
found
value
returns
pointer
to
the
byte
at
end
of
string
return
lcp
Try
to
keep
fileindex
correct
in
every
Macro_Details
record
by
tracking
file
starts
and
ends
Uses
high
water
mark
space
reused
not
freed
Presumption
is
that
this
makes
sense
for
most
uses
STARTERMAX
is
set
so
that
the
array
need
not
be
expanded
for
most
files
it
is
the
initial
include
file
depth
struct
macro_stack_s
Dwarf_Signed
st_base
long
st_max
long
st_next_to_use
int
st_was_fault
static
void
_dwarf_reset_index_macro_stack
struct
macro_stack_s
ms
static
void
free_macro_stack
Dwarf_Debug
dbg
struct
macro_stack_s
ms
dwarf_dealloc
dbg
ms
st_base
DW_DLA_STRING
_dwarf_reset_index_macro_stack
ms
define
STARTERMAX
static
void
_dwarf_reset_index_macro_stack
struct
macro_stack_s
ms
ms
st_base
ms
st_max
ms
st_next_to_use
ms
st_was_fault
static
int
_dwarf_macro_stack_push_index
Dwarf_Debug
dbg
Dwarf_Signed
indx
struct
macro_stack_s
ms
if
ms
st_max
ms
st_next_to_use
ms
st_max
long
new_size
ms
st_max
Dwarf_Signed
newbase
if
new_size
new_size
STARTERMAX
new_size
new_size
newbase
Dwarf_Signed
_dwarf_get_alloc
dbg
DW_DLA_STRING
new_size
sizeof
Dwarf_Signed
if
newbase
just
leave
the
old
array
in
place
ms
st_was_fault
return
DW_DLV_ERROR
if
ms
st_base
memcpy
newbase
ms
st_base
ms
st_next_to_use
sizeof
Dwarf_Signed
dwarf_dealloc
dbg
ms
st_base
DW_DLA_STRING
ms
st_base
newbase
ms
st_max
new_size
ms
st_base
ms
st_next_to_use
indx
ms
st_next_to_use
return
DW_DLV_OK
static
Dwarf_Signed
_dwarf_macro_stack_pop_index
struct
macro_stack_s
ms
if
ms
st_was_fault
return
if
ms
st_next_to_use
ms
st_next_to_use
return
ms
st_base
ms
st_next_to_use
else
ms
st_was_fault
return
Starting
at
macro_offset
in
debug_macinfo
if
maximum_count
is
treat
as
if
it
is
infinite
get
macro
data
up
thru
maximum_count
entries
or
the
end
of
a
compilation
unit
s
entries
whichever
comes
first
debug_macinfo
never
appears
in
a
dwp
Package
File
So
offset
adjustment
for
such
is
not
needed
int
dwarf_get_macro_details
Dwarf_Debug
dbg
Dwarf_Off
macro_offset
Dwarf_Unsigned
maximum_count
Dwarf_Signed
entry_count
Dwarf_Macro_Details
details
Dwarf_Error
error
Dwarf_Small
macro_base
Dwarf_Small
macro_end
Dwarf_Small
pnext
Dwarf_Unsigned
endloc
unsigned
char
uc
unsigned
long
depth
By
section
Dwarf3
draft
the
base
file
should
appear
as
DW_MACINFO_start_file
See
http
gcc
gnu
org
ml
gcc
bugs
msg03442
html
on
Bug
debug
New
regression
Macro
debug
info
broken
due
to
lexer
change
for
how
gcc
is
broken
in
some
versions
We
no
longer
use
depth
as
a
stopping
point
it
s
not
needed
as
a
stopping
point
anyway
int
res
count
space
used
by
strings
unsigned
long
str_space
int
done
unsigned
long
space_needed
unsigned
long
string_offset
Dwarf_Small
return_data
Dwarf_Small
pdata
unsigned
long
final_count
Dwarf_Signed
fileindex
Dwarf_Small
latest_str_loc
struct
macro_stack_s
msdata
unsigned
long
count
unsigned
long
max_count
unsigned
long
maximum_count
_dwarf_reset_index_macro_stack
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
free_macro_stack
dbg
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_macinfo
error
if
res
DW_DLV_OK
free_macro_stack
dbg
return
res
if
dbg
de_debug_abbrev
dss_size
free_macro_stack
dbg
return
DW_DLV_NO_ENTRY
macro_base
dbg
de_debug_macinfo
dss_data
if
macro_base
NULL
free_macro_stack
dbg
return
DW_DLV_NO_ENTRY
if
macro_offset
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
return
DW_DLV_NO_ENTRY
macro_end
macro_base
dbg
de_debug_macinfo
dss_size
FIXME
debugfission
is
NOT
handled
here
pnext
macro_base
macro_offset
if
maximum_count
max_count
ULONG_MAX
how
many
entries
and
how
much
space
will
they
take?
endloc
pnext
macro_base
if
endloc
dbg
de_debug_macinfo
dss_size
if
endloc
dbg
de_debug_macinfo
dss_size
normal
found
last
entry
free_macro_stack
dbg
return
DW_DLV_NO_ENTRY
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_LENGTH_BAD
free_macro_stack
dbg
return
DW_DLV_ERROR
for
count
done
count
max_count
count
unsigned
long
slen
Set
but
not
used
UNUSEDARG
Dwarf_Unsigned
utemp
uc
pnext
pnext
get
past
the
type
code
switch
uc
case
DW_MACINFO_define
case
DW_MACINFO_undef
line
string
case
DW_MACINFO_vendor_ext
number
string
DECODE_LEB128_UWORD_CK
pnext
utemp
dbg
error
macro_end
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
dbg
macro_base
pnext
macro_end
DW_DLE_MACINFO_STRING_BAD
error
if
res
DW_DLV_OK
return
res
slen
strlen
char
pnext
pnext
slen
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
str_space
slen
break
case
DW_MACINFO_start_file
line
file
index
DECODE_LEB128_UWORD_CK
pnext
utemp
dbg
error
macro_end
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
pnext
utemp
dbg
error
macro_end
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
depth
break
case
DW_MACINFO_end_file
if
depth
done
no
do
not
stop
here
at
least
one
gcc
had
the
wrong
depth
settings
in
the
gcc
timeframe
no
string
or
number
here
break
case
end
of
cu
s
entries
done
break
default
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
bogus
macinfo
endloc
pnext
macro_base
if
endloc
dbg
de_debug_macinfo
dss_size
done
else
if
endloc
dbg
de_debug_macinfo
dss_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_LENGTH_BAD
free_macro_stack
dbg
return
DW_DLV_ERROR
ASSERT
The
above
loop
will
never
let
us
get
here
with
count
No
need
to
test
for
a
zero
count
We
have
count
array
entries
to
allocate
and
str_space
bytes
of
string
space
to
provide
for
string_offset
count
sizeof
Dwarf_Macro_Details
extra
not
really
needed
space_needed
string_offset
str_space
return_data
pdata
Dwarf_Small
_dwarf_get_alloc
dbg
DW_DLA_STRING
space_needed
latest_str_loc
pdata
string_offset
if
pdata
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_MALLOC_SPACE
return
DW_DLV_ERROR
pnext
macro_base
macro_offset
done
A
series
ends
with
a
type
code
of
for
final_count
done
final_count
count
final_count
unsigned
long
slen
Dwarf_Unsigned
v1
Dwarf_Macro_Details
pdmd
Dwarf_Macro_Details
pdata
final_count
sizeof
Dwarf_Macro_Details
endloc
pnext
macro_base
if
endloc
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_LENGTH_BAD
return
DW_DLV_ERROR
uc
pnext
pdmd
dmd_offset
pnext
macro_base
pdmd
dmd_type
uc
pdmd
dmd_fileindex
fileindex
pdmd
dmd_lineno
pdmd
dmd_macro
pnext
get
past
the
type
code
switch
uc
case
DW_MACINFO_define
case
DW_MACINFO_undef
line
string
case
DW_MACINFO_vendor_ext
number
string
DECODE_LEB128_UWORD_CK
pnext
v1
dbg
error
macro_end
pdmd
dmd_lineno
v1
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
dwarf_dealloc
dbg
return_data
DW_DLA_STRING
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
res
_dwarf_check_string_valid
dbg
macro_base
pnext
macro_end
DW_DLE_MACINFO_STRING_BAD
error
if
res
DW_DLV_OK
return
res
slen
strlen
char
pnext
strcpy
char
latest_str_loc
char
pnext
pdmd
dmd_macro
char
latest_str_loc
latest_str_loc
slen
pnext
slen
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
dwarf_dealloc
dbg
return_data
DW_DLA_STRING
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
break
case
DW_MACINFO_start_file
Line
file
index
DECODE_LEB128_UWORD_CK
pnext
v1
dbg
error
macro_end
pdmd
dmd_lineno
v1
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
dwarf_dealloc
dbg
return_data
DW_DLA_STRING
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
pnext
v1
dbg
error
macro_end
pdmd
dmd_fileindex
v1
void
_dwarf_macro_stack_push_index
dbg
fileindex
We
ignore
the
error
we
just
let
fileindex
be
when
we
pop
this
one
fileindex
v1
if
Dwarf_Unsigned
pnext
macro_base
dbg
de_debug_macinfo
dss_size
free_macro_stack
dbg
dwarf_dealloc
dbg
return_data
DW_DLA_STRING
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
break
case
DW_MACINFO_end_file
fileindex
_dwarf_macro_stack_pop_index
break
no
string
or
number
here
case
Type
code
of
means
the
end
of
cu
s
entries
done
break
default
Bogus
macinfo
dwarf_dealloc
dbg
return_data
DW_DLA_STRING
free_macro_stack
dbg
_dwarf_error
dbg
error
DW_DLE_DEBUG_MACRO_INCONSISTENT
return
DW_DLV_ERROR
entry_count
count
details
Dwarf_Macro_Details
return_data
free_macro_stack
dbg
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
limits
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_macro5
h
include
dwarfstring
h
define
MC_SENTINAL
define
CHECKNULLCONTEXT
m
d
e
if
m
m
mc_sentinel
MC_SENTINAL
if
m
d
m
mc_dbg
_dwarf_error_string
d
e
DW_DLE_BAD_MACRO_HEADER_POINTER
DW_DLE_BAD_MACRO_HEADER_POINTER
NULL
header
or
corrupt
header
return
DW_DLV_ERROR
Section
Macro
Information
Each
macro
unit
ends
with
an
entry
containing
an
opcode
of
static
const
Dwarf_Small
dwarf_udata_string_form
DW_FORM_udata
DW_FORM_string
static
const
Dwarf_Small
dwarf_udata_udata_form
DW_FORM_udata
DW_FORM_udata
static
const
Dwarf_Small
dwarf_udata_strp_form
DW_FORM_udata
DW_FORM_strp
static
const
Dwarf_Small
dwarf_udata_strp_sup_form
DW_FORM_udata
DW_FORM_strp_sup
static
const
Dwarf_Small
dwarf_secoffset_form
DW_FORM_sec_offset
static
const
Dwarf_Small
dwarf_udata_strx_form
DW_FORM_udata
DW_FORM_strx
struct
Dwarf_Macro_Forms_s
dw5formsarray
DW_MACRO_define
dwarf_udata_string_form
DW_MACRO_undef
dwarf_udata_string_form
DW_MACRO_start_file
dwarf_udata_udata_form
DW_MACRO_end_file
DW_MACRO_define_strp
dwarf_udata_strp_form
DW_MACRO_undef_strp
dwarf_udata_strp_form
DW_MACRO_import
dwarf_secoffset_form
DW_MACRO_define_sup
dwarf_udata_strp_sup_form
DW_MACRO_undef_sup
dwarf_udata_strp_sup_form
DW_MACRO_import_sup
dwarf_secoffset_form
DW_MACRO_define_strx
dwarf_udata_strx_form
DW_MACRO_undef_strx
dwarf_udata_strx_form
Represents
DWARF
macro
info
debug_macro
predefined
in
order
by
value
static
const
struct
Dwarf_Macro_OperationsList_s
dwarf_default_macro_opslist
dw5formsarray
static
int
_dwarf_internal_macro_context_by_offset
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
char
srcfiles
Dwarf_Signed
srcfilescount
const
char
comp_dir
const
char
comp_name
Dwarf_CU_Context
cu_context
Dwarf_Error
error
static
int
_dwarf_internal_macro_context
Dwarf_Die
die
Dwarf_Bool
offset_specified
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context_out
Dwarf_Unsigned
macro_unit_offset_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
Dwarf_Error
error
static
int
is_std_moperator
Dwarf_Small
op
if
op
op
DW_MACRO_undef_strx
return
TRUE
return
FALSE
static
int
_dwarf_skim_forms
Dwarf_Debug
dbg
Dwarf_Macro_Context
mcontext
Dwarf_Small
mdata_start
unsigned
formcount
const
Dwarf_Small
forms
Dwarf_Small
section_end
Dwarf_Unsigned
forms_length
Dwarf_Error
error
unsigned
i
Dwarf_Small
curform
Dwarf_Unsigned
totallen
Dwarf_Unsigned
v
Dwarf_Unsigned
ret_value
Dwarf_Unsigned
length
Dwarf_Small
mdata
mdata_start
Dwarf_Unsigned
leb128_length
for
i
formcount
i
curform
forms
i
if
mdata
section_end
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
switch
curform
default
_dwarf_error
dbg
error
DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE
return
DW_DLV_ERROR
case
DW_FORM_block1
v
Dwarf_Small
mdata
totallen
v
mdata
v
break
case
DW_FORM_block2
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
mdata
DWARF_HALF_SIZE
error
section_end
v
ret_value
DWARF_HALF_SIZE
totallen
v
mdata
v
break
case
DW_FORM_block4
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
mdata
DWARF_32BIT_SIZE
error
section_end
v
ret_value
DWARF_32BIT_SIZE
totallen
v
mdata
v
break
case
DW_FORM_data1
v
totallen
v
mdata
v
break
case
DW_FORM_data2
v
totallen
v
mdata
v
break
case
DW_FORM_data4
v
totallen
v
mdata
v
break
case
DW_FORM_data8
v
totallen
v
mdata
v
break
case
DW_FORM_data16
v
totallen
v
mdata
v
break
case
DW_FORM_string
int
res
_dwarf_check_string_valid
dbg
mdata
mdata
section_end
DW_DLE_MACRO_STRING_BAD
error
if
res
DW_DLV_OK
return
res
v
strlen
char
mdata
totallen
v
mdata
v
break
case
DW_FORM_block
DECODE_LEB128_UWORD_LEN_CK
mdata
length
leb128_length
dbg
error
section_end
v
length
leb128_length
totallen
v
break
case
DW_FORM_flag
v
totallen
v
mdata
v
break
case
DW_FORM_sec_offset
If
dwarf
is
Else
is
dwarf
and
is
v
mcontext
mc_offset_size
totallen
v
mdata
v
break
case
DW_FORM_sdata
Discard
the
decoded
value
we
just
want
the
length
of
the
value
DECODE_LEB128_UWORD_LEN_CK
mdata
length
leb128_length
dbg
error
section_end
totallen
v
break
case
DW_FORM_strx
DECODE_LEB128_UWORD_LEN_CK
mdata
length
leb128_length
dbg
error
section_end
totallen
leb128_length
break
case
DW_FORM_strp
v
mcontext
mc_offset_size
mdata
v
totallen
v
break
case
DW_FORM_udata
Discard
the
decoded
value
we
just
want
the
length
of
the
value
DECODE_LEB128_UWORD_LEN_CK
mdata
length
leb128_length
dbg
error
section_end
totallen
leb128_length
break
if
mdata
section_end
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
forms_length
totallen
return
DW_DLV_OK
if
FOR
DEBUGGING
static
void
dump_bytes
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
unsigned
pos
printf
dump
ld
bytes
start
at
lx
n
len
unsigned
long
start
printf
for
cur
end
pos
cur
if
pos
printf
printf
cur
printf
n
Dwarf_Bool
is_defundef
unsigned
op
switch
op
case
DW_MACRO_define
case
DW_MACRO_undef
case
DW_MACRO_define_strp
case
DW_MACRO_undef_strp
case
DW_MACRO_define_strx
case
DW_MACRO_undef_strx
case
DW_MACRO_define_sup
case
DW_MACRO_undef_sup
return
TRUE
return
FALSE
endif
FOR
DEBUGGING
On
first
call
for
this
macro_context
build_ops_array
is
FALSE
On
second
it
is
TRUE
and
we
know
the
count
so
we
allocate
and
fill
in
the
ops
array
static
int
_dwarf_get_macro_ops_count_internal
Dwarf_Macro_Context
macro_context
Dwarf_Bool
build_ops_array
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Small
mdata
Dwarf_Small
section_end
Dwarf_Small
section_base
Dwarf_Unsigned
opcount
Dwarf_Unsigned
known_ops_count
struct
Dwarf_Macro_Operator_s
opsarray
struct
Dwarf_Macro_Operator_s
curopsentry
int
res
dbg
macro_context
mc_dbg
if
build_ops_array
known_ops_count
macro_context
mc_macro_ops_count
opsarray
struct
Dwarf_Macro_Operator_s
calloc
known_ops_count
sizeof
struct
Dwarf_Macro_Operator_s
if
opsarray
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curopsentry
opsarray
macro_context
mc_ops
opsarray
section_base
dbg
de_debug_macro
dss_data
section_end
section_base
dbg
de_debug_macro
dss_size
mdata
macro_context
mc_macro_ops
while
mdata
section_end
Dwarf_Small
op
op
mdata
opcount
mdata
if
op
Dwarf_Unsigned
opslen
End
of
ops
this
is
terminator
count
the
ending
as
an
operator
so
dwarfdump
can
print
it
Normally
we
don
t
see
this
the
end
operator
signals
end
opslen
mdata
macro_context
mc_macro_ops
macro_context
mc_macro_ops_count
opcount
macro_context
mc_ops_data_length
opslen
macro_context
mc_total_length
opslen
macro_context
mc_macro_header_length
if
build_ops_array
curopsentry
mo_opcode
op
curopsentry
mo_form
curopsentry
mo_data
return
DW_DLV_OK
if
is_std_moperator
op
struct
Dwarf_Macro_Forms_s
ourform
dw5formsarray
op
ASSERT
op
ourform
mf_code
unsigned
formcount
ourform
mf_formcount
const
Dwarf_Small
forms
ourform
mf_formbytes
Dwarf_Unsigned
forms_length
res
_dwarf_skim_forms
dbg
macro_context
mdata
formcount
forms
section_end
error
if
res
DW_DLV_OK
return
res
if
build_ops_array
curopsentry
mo_opcode
op
curopsentry
mo_form
ourform
curopsentry
mo_data
mdata
mdata
forms_length
else
FIXME
Add
support
for
user
defined
ops
_dwarf_error
dbg
error
DW_DLE_MACRO_OP_UNHANDLED
return
DW_DLV_ERROR
if
mdata
section_end
_dwarf_error
dbg
error
DW_DLE_MACRO_PAST_END
return
DW_DLV_ERROR
if
build_ops_array
curopsentry
_dwarf_error
dbg
error
DW_DLE_MACRO_PAST_END
return
DW_DLV_ERROR
int
dwarf_get_macro_op
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
op_start_section_offset
Dwarf_Half
macro_operator
Dwarf_Half
forms_count
const
Dwarf_Small
formcode_array
Dwarf_Error
error
struct
Dwarf_Macro_Operator_s
curop
Dwarf_Debug
dbg
Dwarf_Unsigned
op_offset
Dwarf_Half
operator
CHECKNULLCONTEXT
macro_context
dbg
error
dbg
macro_context
mc_dbg
if
op_number
macro_context
mc_macro_ops_count
_dwarf_error
dbg
error
DW_DLE_BAD_MACRO_INDEX
return
DW_DLV_ERROR
curop
macro_context
mc_ops
op_number
operator
curop
mo_opcode
if
operator
For
the
null
byte
at
the
end
of
an
operator
list
op_start_section_offset
macro_context
mc_total_length
macro_context
mc_section_offset
macro_operator
operator
forms_count
formcode_array
return
DW_DLV_OK
op_offset
curop
mo_data
macro_context
mc_macro_header
macro_context
mc_section_offset
if
op_offset
macro_context
mc_section_size
dwarfstring
m
char
buf
dwarfstring_constructor_static
buf
sizeof
buf
dwarfstring_append_printf_u
DW_DLE_MACRO_OFFSET_BAD
offset
lx
op_offset
dwarfstring_append_printf_u
section
size
of
lx
macro_context
mc_section_size
_dwarf_error_string
dbg
error
DW_DLE_MACRO_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
op_start_section_offset
op_offset
macro_operator
operator
if
curop
mo_form
forms_count
curop
mo_form
mf_formcount
formcode_array
curop
mo_form
mf_formbytes
else
ASSERT
macro_operator
forms_count
formcode_array
return
DW_DLV_OK
Here
a
DW_DLV_NO_ENTRY
return
means
the
macro
operator
is
not
a
def
undef
operator
int
dwarf_get_macro_defundef
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Unsigned
offset
Dwarf_Half
forms_count
const
char
macro_string
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Small
mdata
int
res
Dwarf_Small
startptr
Dwarf_Small
endptr
Dwarf_Half
lformscount
struct
Dwarf_Macro_Operator_s
curop
unsigned
macop
CHECKNULLCONTEXT
macro_context
dbg
error
dbg
macro_context
mc_dbg
if
op_number
macro_context
mc_macro_ops_count
_dwarf_error
dbg
error
DW_DLE_BAD_MACRO_INDEX
return
DW_DLV_ERROR
curop
macro_context
mc_ops
op_number
macop
curop
mo_opcode
startptr
macro_context
mc_macro_header
endptr
startptr
macro_context
mc_total_length
mdata
curop
mo_data
lformscount
curop
mo_form
mf_formcount
if
lformscount
_dwarf_error
dbg
error
DW_DLE_MACRO_OPCODE_FORM_BAD
return
DW_DLV_NO_ENTRY
switch
macop
case
DW_MACRO_define
case
DW_MACRO_undef
Dwarf_Unsigned
linenum
const
char
content
DECODE_LEB128_UWORD_CK
mdata
linenum
dbg
error
endptr
content
const
char
mdata
res
_dwarf_check_string_valid
dbg
startptr
mdata
endptr
DW_DLE_MACRO_STRING_BAD
error
if
res
DW_DLV_OK
return
res
line_number
linenum
index
offset
forms_count
lformscount
macro_string
content
return
DW_DLV_OK
case
DW_MACRO_define_strp
case
DW_MACRO_undef_strp
Dwarf_Unsigned
linenum
Dwarf_Unsigned
stringoffset
Dwarf_Small
form1
curop
mo_form
mf_formbytes
char
localstr
DECODE_LEB128_UWORD_CK
mdata
linenum
dbg
error
endptr
READ_UNALIGNED_CK
dbg
stringoffset
Dwarf_Unsigned
mdata
macro_context
mc_offset_size
error
endptr
res
_dwarf_extract_local_debug_str_string_given_offset
dbg
form1
stringoffset
error
index
line_number
linenum
offset
stringoffset
forms_count
lformscount
if
res
DW_DLV_ERROR
macro_string
Error
getting
local
debug_str
return
res
else
if
res
DW_DLV_NO_ENTRY
macro_string
Error
NO_ENTRY
on
debug_string
strp
else
macro_string
const
char
localstr
return
DW_DLV_OK
case
DW_MACRO_define_strx
case
DW_MACRO_undef_strx
Dwarf_Unsigned
linenum
Dwarf_Unsigned
stringindex
Dwarf_Unsigned
offsettostr
int
ress
Dwarf_Byte_Ptr
mdata_copy
Dwarf_Small
form1
curop
mo_form
mf_formbytes
DECODE_LEB128_UWORD_CK
mdata
linenum
dbg
error
endptr
line_number
linenum
mdata_copy
mdata
DECODE_LEB128_UWORD_CK
mdata_copy
stringindex
dbg
error
endptr
mdata_copy
is
for
call
below
index
stringindex
forms_count
lformscount
Redoes
the
index
getting
Gets
offset
ress
_dwarf_extract_string_offset_via_str_offsets
dbg
mdata_copy
endptr
DW_AT_macros
arbitrary
unused
by
called
routine
form1
macro_context
mc_cu_context
error
if
ress
DW_DLV_ERROR
return
ress
if
ress
DW_DLV_OK
char
localstr
index
stringindex
offset
offsettostr
ress
_dwarf_extract_local_debug_str_string_given_offset
dbg
form1
offsettostr
error
if
ress
DW_DLV_ERROR
return
ress
else
if
ress
DW_DLV_NO_ENTRY
macro_string
No
string
available
else
macro_string
const
char
localstr
All
is
ok
else
index
stringindex
offset
macro_string
debug_str_offsets
not
available
return
DW_DLV_OK
case
DW_MACRO_define_sup
case
DW_MACRO_undef_sup
Dwarf_Unsigned
linenum
Dwarf_Unsigned
supoffset
char
localstring
int
resup
Dwarf_Error
lerr
DECODE_LEB128_UWORD_CK
mdata
linenum
dbg
error
endptr
READ_UNALIGNED_CK
dbg
supoffset
Dwarf_Unsigned
mdata
macro_context
mc_offset_size
error
endptr
line_number
linenum
index
offset
supoffset
forms_count
lformscount
resup
_dwarf_get_string_from_tied
dbg
supoffset
if
resup
DW_DLV_OK
if
resup
DW_DLV_ERROR
int
myerrno
dwarf_errno
lerr
if
myerrno
DW_DLE_NO_TIED_FILE_AVAILABLE
macro_string
char
DW_FORM_str_sup
no
tied_file
else
_dwarf_error
dbg
error
myerrno
macro_string
char
Error
DW_FORM_str_sup
got
error
dwarf_dealloc
dbg
lerr
DW_DLA_ERROR
else
macro_string
DW_FORM_str_sup
no
entry
return
resup
macro_string
const
char
localstring
If
NO
ENTRY
available
return
DW_DLV_NO_ENTRY
We
suspect
this
is
better
than
DW_DLV_OK
return
resup
default
_dwarf_error
dbg
error
DW_DLE_MACRO_OP_UNHANDLED
return
DW_DLV_ERROR
return
DW_DLV_NO_ENTRY
ASSERT
we
elsewhere
guarantee
room
to
copy
into
If
trimtarg
trim
trailing
slash
in
targ
Caller
should
not
pass
in
src
with
leading
static
void
specialcat
char
targ
char
src
int
trimtarg
char
last
while
targ
last
targ
targ
TARG
now
points
at
terminating
NUL
LAST
points
at
final
character
in
targ
if
trimtarg
if
last
last
Truncate
last
targ
last
TARG
again
points
at
terminating
NUL
while
src
targ
src
targ
src
targ
If
returns
NULL
caller
must
handle
it
static
const
char
construct_from_dir_and_name
const
char
dir
const
char
name
int
truelen
char
final
Allow
for
NUL
char
and
added
truelen
strlen
dir
strlen
name
final
char
malloc
truelen
if
final
return
NULL
final
specialcat
final
char
dir
strcat
final
specialcat
final
char
name
return
final
If
returns
NULL
caller
must
handle
it
static
const
char
construct_at_path_from_parts
Dwarf_Macro_Context
mc
if
mc
mc_file_path
return
mc
mc_file_path
if
mc
mc_at_comp_dir
mc
mc_at_comp_dir
return
mc
mc_at_name
if
mc
mc_at_name
mc
mc_at_name
return
NULL
if
_dwarf_file_name_is_full_path
Dwarf_Small
mc
mc_at_name
return
mc
mc_at_name
Dwarf_Macro_Context
destructor
will
free
this
mc
mc_file_path
construct_from_dir_and_name
mc
mc_at_comp_dir
mc
mc_at_name
return
mc
mc_file_path
int
dwarf_get_macro_startend_file
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
name_index_to_line_tab
const
char
src_file_name
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_Small
mdata
unsigned
macop
struct
Dwarf_Macro_Operator_s
curop
Dwarf_Byte_Ptr
startptr
Dwarf_Byte_Ptr
endptr
CHECKNULLCONTEXT
macro_context
dbg
error
dbg
macro_context
mc_dbg
if
op_number
macro_context
mc_macro_ops_count
_dwarf_error
dbg
error
DW_DLE_BAD_MACRO_INDEX
return
DW_DLV_ERROR
startptr
macro_context
mc_macro_header
endptr
startptr
macro_context
mc_total_length
curop
macro_context
mc_ops
op_number
macop
curop
mo_opcode
mdata
curop
mo_data
if
macop
DW_MACRO_start_file
macop
DW_MACRO_end_file
return
DW_DLV_NO_ENTRY
if
macop
DW_MACRO_start_file
Dwarf_Unsigned
linenum
Dwarf_Unsigned
srcindex
Dwarf_Signed
trueindex
DECODE_LEB128_UWORD_CK
mdata
linenum
dbg
error
endptr
DECODE_LEB128_UWORD_CK
mdata
srcindex
dbg
error
endptr
line_number
linenum
name_index_to_line_tab
srcindex
We
deal
with
DWARF4
GNU
extension
with
debug_macro
version
number
and
DWARF5
debug_macro
version
number
if
macro_context
mc_version_number
DW_MACRO_VERSION5
trueindex
srcindex
if
trueindex
src_file_name
source
file
index
low
no
name
available
return
DW_DLV_OK
if
trueindex
macro_context
mc_srcfiles_count
src_file_name
macro_context
mc_srcfiles
trueindex
return
DW_DLV_OK
else
src_file_name
src
index
high
no
source
file
name
available
return
DW_DLV_OK
else
All
except
DWARF5
Unsigned
to
signed
here
trueindex
srcindex
Protects
against
crazy
big
srcindex
overflow
territory
if
trueindex
Something
insane
here
src_file_name
source
file
index
low
no
name
available
return
DW_DLV_OK
Protects
against
crazy
big
srcindex
overflow
territory
if
trueindex
macro_context
mc_srcfiles_count
Something
insane
here
src_file_name
source
file
index
high
no
name
available
return
DW_DLV_OK
trueindex
might
now
be
if
trueindex
macro_context
mc_srcfiles_count
src_file_name
adjusted
source
file
index
high
no
name
available
if
srcindex
trueindex
macro_context
mc_srcfiles_count
src_file_name
macro_context
mc_srcfiles
trueindex
else
const
char
mcatcomp
construct_at_path_from_parts
macro_context
if
mcatcomp
src_file_name
mcatcomp
else
src_file_name
no
source
file
name
available
else
DW_MACRO_end_file
No
operands
return
DW_DLV_OK
Target_offset
is
the
offset
in
a
debug_macro
section
of
a
macro
unit
header
Returns
DW_DLV_NO_ENTRY
if
the
macro
operator
is
not
one
of
the
import
operators
int
dwarf_get_macro_import
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
target_offset
Dwarf_Error
error
Dwarf_Unsigned
supoffset
Dwarf_Debug
dbg
unsigned
macop
struct
Dwarf_Macro_Operator_s
curop
Dwarf_Small
mdata
Dwarf_Byte_Ptr
startptr
Dwarf_Byte_Ptr
endptr
CHECKNULLCONTEXT
macro_context
dbg
error
startptr
macro_context
mc_macro_header
endptr
startptr
macro_context
mc_total_length
dbg
macro_context
mc_dbg
if
op_number
macro_context
mc_macro_ops_count
_dwarf_error
dbg
error
DW_DLE_BAD_MACRO_INDEX
return
DW_DLV_ERROR
curop
macro_context
mc_ops
op_number
macop
curop
mo_opcode
mdata
curop
mo_data
if
macop
DW_MACRO_import
macop
DW_MACRO_import_sup
return
DW_DLV_NO_ENTRY
READ_UNALIGNED_CK
dbg
supoffset
Dwarf_Unsigned
mdata
macro_context
mc_offset_size
error
endptr
target_offset
supoffset
return
DW_DLV_OK
static
int
valid_macro_form
Dwarf_Half
form
switch
form
case
DW_FORM_block
case
DW_FORM_block1
case
DW_FORM_block2
case
DW_FORM_block4
case
DW_FORM_data1
case
DW_FORM_data2
case
DW_FORM_data4
case
DW_FORM_data8
case
DW_FORM_data16
case
DW_FORM_sdata
case
DW_FORM_udata
case
DW_FORM_flag
case
DW_FORM_sec_offset
case
DW_FORM_string
case
DW_FORM_strp
case
DW_FORM_strx
return
TRUE
return
FALSE
static
int
validate_opcode
Dwarf_Debug
dbg
struct
Dwarf_Macro_Forms_s
curform
Dwarf_Error
error
unsigned
i
struct
Dwarf_Macro_Forms_s
stdfptr
if
curform
mf_code
DW_MACRO_lo_user
Nothing
to
check
user
level
return
DW_DLV_OK
if
curform
mf_code
DW_MACRO_undef_strx
_dwarf_error
dbg
error
DW_DLE_MACRO_OPCODE_BAD
return
DW_DLV_ERROR
if
curform
mf_code
_dwarf_error
dbg
error
DW_DLE_MACRO_OPCODE_BAD
return
DW_DLV_ERROR
stdfptr
mol_data
curform
mf_code
if
curform
mf_formcount
stdfptr
mf_formcount
_dwarf_error
dbg
error
DW_DLE_MACRO_OPCODE_FORM_BAD
return
DW_DLV_ERROR
for
i
i
curform
mf_formcount
i
if
curform
mf_formbytes
i
stdfptr
mf_formbytes
_dwarf_error
dbg
error
DW_DLE_MACRO_OPCODE_FORM_BAD
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
read_operands_table
Dwarf_Macro_Context
macro_context
Dwarf_Small
macro_header
Dwarf_Small
macro_data
Dwarf_Small
section_base
Dwarf_Unsigned
section_size
Dwarf_Unsigned
table_size_out
Dwarf_Error
error
Dwarf_Small
table_data_start
macro_data
Dwarf_Unsigned
local_size
Dwarf_Unsigned
cur_offset
Dwarf_Small
operand_table_count
unsigned
i
struct
Dwarf_Macro_Forms_s
curformentry
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
startptr
Dwarf_Byte_Ptr
endptr
CHECKNULLCONTEXT
macro_context
dbg
error
dbg
macro_context
mc_dbg
cur_offset
macro_data
macro_header
if
cur_offset
section_size
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
startptr
macro_context
mc_macro_header
endptr
startptr
macro_context
mc_total_length
READ_UNALIGNED_CK
dbg
operand_table_count
Dwarf_Small
macro_data
sizeof
Dwarf_Small
error
endptr
macro_data
sizeof
Dwarf_Small
Estimating
minimum
size
local_size
operand_table_count
cur_offset
local_size
macro_data
section_base
if
cur_offset
section_size
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
first
get
size
of
table
table_data_start
macro_data
for
i
i
operand_table_count
i
Compiler
warning
about
unused
opcode_number
variable
should
be
ignored
UNUSEDARG
Dwarf_Small
opcode_number
Dwarf_Unsigned
formcount
READ_UNALIGNED_CK
dbg
opcode_number
Dwarf_Small
macro_data
sizeof
Dwarf_Small
error
endptr
macro_data
sizeof
Dwarf_Small
DECODE_LEB128_UWORD_CK
macro_data
formcount
dbg
error
endptr
cur_offset
formcount
macro_data
section_base
if
cur_offset
section_size
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
The
ubyte
forms
follow
Step
past
them
macro_data
formcount
reset
for
reread
macro_data
table_data_start
allocate
table
macro_context
mc_opcode_forms
struct
Dwarf_Macro_Forms_s
calloc
operand_table_count
sizeof
struct
Dwarf_Macro_Forms_s
macro_context
mc_opcode_count
operand_table_count
if
macro_context
mc_opcode_forms
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curformentry
macro_context
mc_opcode_forms
for
i
i
operand_table_count
i
curformentry
Dwarf_Small
opcode_number
Dwarf_Unsigned
formcount
int
res
cur_offset
macro_data
section_base
if
cur_offset
section_size
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
opcode_number
Dwarf_Small
macro_data
sizeof
Dwarf_Small
error
endptr
macro_data
sizeof
Dwarf_Small
DECODE_LEB128_UWORD_CK
macro_data
formcount
dbg
error
endptr
curformentry
mf_code
opcode_number
curformentry
mf_formcount
formcount
cur_offset
formcount
macro_data
section_base
if
cur_offset
section_size
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
curformentry
mf_formbytes
macro_data
macro_data
formcount
if
opcode_number
DW_MACRO_undef_strx
Dwarf_Half
k
for
k
k
formcount
k
if
valid_macro_form
curformentry
mf_formbytes
k
_dwarf_error
dbg
error
DW_DLE_MACRO_OP_UNHANDLED
return
DW_DLV_ERROR
res
validate_opcode
macro_context
mc_dbg
curformentry
error
if
res
DW_DLV_OK
return
res
table_size_out
macro_data
table_data_start
return
DW_DLV_OK
This
is
not
the
normal
srcfiles
from
dwarf_srcfiles
See
translate
translate_srcfiles_to_srcfiles2
It
is
a
list
but
the
contents
were
directly
malloc
not
_dwarf_get_alloc
static
void
dealloc_macro_srcfiles
char
srcfiles
Dwarf_Signed
srcfiles_count
Dwarf_Signed
i
if
srcfiles
srcfiles_count
return
for
i
i
srcfiles_count
i
if
srcfiles
i
free
srcfiles
i
srcfiles
i
free
srcfiles
This
makes
the
macro
context
safe
from
duplicate
frees
in
case
of
error
static
int
translate_srcfiles_to_srcfiles2
char
srcfiles
Dwarf_Signed
srcfiles_count
char
srcfiles2
Dwarf_Signed
i
for
i
i
srcfiles_count
i
char
ostr
char
newstr
size_t
slen
ostr
srcfiles
i
slen
strlen
ostr
newstr
calloc
slen
if
newstr
return
DW_DLV_ERROR
strcpy
newstr
ostr
srcfiles2
i
newstr
return
DW_DLV_OK
static
void
drop_srcfiles
Dwarf_Debug
dbg
char
srcfiles
Dwarf_Signed
srcfiles_count
Dwarf_Signed
i
for
i
i
srcfiles_count
i
if
srcfiles
i
dwarf_dealloc
dbg
srcfiles
i
DW_DLA_STRING
dwarf_dealloc
dbg
srcfiles
DW_DLA_LIST
static
int
_dwarf_internal_macro_context
Dwarf_Die
die
Dwarf_Bool
offset_specified
Dwarf_Unsigned
offset_in
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context_out
Dwarf_Unsigned
macro_unit_offset_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
Dwarf_Error
error
Dwarf_CU_Context
cu_context
The
Dwarf_Debug
this
die
belongs
to
Dwarf_Debug
dbg
int
resattr
DW_DLV_ERROR
int
lres
DW_DLV_ERROR
int
res
DW_DLV_ERROR
Dwarf_Unsigned
macro_offset
Dwarf_Attribute
macro_attr
Dwarf_Signed
srcfiles_count
Dwarf_Signed
srcfiles2_count
char
srcfiles
srcfiles
uses
dwarf_get_alloc
for
strings
so
dealloc_macro_srcfiles
here
will
result
in
double
dealloc
when
dwarf_finish
happens
to
see
the
string
deallocs
before
the
macro
context
dealloc
the
context
dealloc
will
call
dealloc_macro_srcfiles
Also
see
the
comment
at
_dwarf_macro_destructor
here
char
srcfiles2
const
char
comp_dir
const
char
comp_name
BEGIN
CODE
if
error
NULL
error
NULL
CHECK_DIE
die
DW_DLV_ERROR
cu_context
die
di_cu_context
dbg
cu_context
cc_dbg
Doing
the
load
here
results
in
duplication
of
the
section
load
call
in
the
by_offset
interface
below
but
detects
the
missing
section
quickly
res
_dwarf_load_section
dbg
de_debug_macro
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_macro
dss_size
return
DW_DLV_NO_ENTRY
resattr
dwarf_attr
die
DW_AT_macros
error
if
resattr
DW_DLV_NO_ENTRY
resattr
dwarf_attr
die
DW_AT_GNU_macros
error
if
resattr
DW_DLV_OK
return
resattr
if
offset_specified
lres
dwarf_global_formref
macro_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
return
lres
else
macro_offset
offset_in
If
DWP
cc_macro_base
may
be
non
zero
macro_offset
cu_context
cc_macro_base
lres
dwarf_srcfiles
die
error
if
lres
DW_DLV_ERROR
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
return
lres
lres
_dwarf_internal_get_die_comp_dir
die
error
if
lres
DW_DLV_ERROR
drop_srcfiles
dbg
srcfiles
srcfiles_count
srcfiles
srcfiles_count
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
srcfiles
return
lres
macro_unit_offset_out
macro_offset
We
cannot
use
space
allocated
by
_dwarf_get_alloc
in
the
macro_context
we
will
allocate
shortly
So
copy
from
what
we
have
to
a
similar
data
set
but
malloc
space
directly
if
srcfiles_count
srcfiles2
char
calloc
srcfiles_count
sizeof
char
if
srcfiles2
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
drop_srcfiles
dbg
srcfiles
srcfiles_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
lres
translate_srcfiles_to_srcfiles2
srcfiles
srcfiles_count
srcfiles2
drop_srcfiles
dbg
srcfiles
srcfiles_count
srcfiles2_count
srcfiles_count
srcfiles
srcfiles_count
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
dealloc_macro_srcfiles
srcfiles2
srcfiles2_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
lres
else
drop_srcfiles
dbg
srcfiles
srcfiles_count
srcfiles
srcfiles_count
dwarf_dealloc
dbg
macro_attr
DW_DLA_ATTR
NO
ENTRY
or
OK
we
accept
though
NO
ENTRY
means
there
are
no
source
files
available
lres
_dwarf_internal_macro_context_by_offset
dbg
macro_offset
version_out
macro_context_out
macro_ops_count_out
macro_ops_data_length
srcfiles2
srcfiles2_count
comp_dir
comp_name
cu_context
error
In
case
of
ERROR
or
NO_ENTRY
srcfiles2
is
already
freed
return
lres
static
int
_dwarf_internal_macro_context_by_offset
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
char
srcfiles
Dwarf_Signed
srcfilescount
const
char
comp_dir
const
char
comp_name
Dwarf_CU_Context
cu_context
Dwarf_Error
error
Dwarf_Unsigned
line_table_offset
Dwarf_Small
macro_header
Dwarf_Small
macro_data
Dwarf_Unsigned
version
Dwarf_Unsigned
flags
Dwarf_Small
offset_size
Dwarf_Unsigned
cur_offset
Dwarf_Unsigned
section_size
Dwarf_Small
section_base
Dwarf_Small
section_end
Dwarf_Unsigned
optablesize
Dwarf_Unsigned
macro_offset
offset
int
res
Dwarf_Macro_Context
macro_context
Dwarf_Bool
build_ops_array
FALSE
res
_dwarf_load_section
dbg
de_debug_macro
error
if
res
DW_DLV_OK
dealloc_macro_srcfiles
srcfiles
srcfilescount
return
res
if
dbg
de_debug_macro
dss_size
dealloc_macro_srcfiles
srcfiles
srcfilescount
return
DW_DLV_NO_ENTRY
section_base
dbg
de_debug_macro
dss_data
section_size
dbg
de_debug_macro
dss_size
The
ensures
the
header
initial
bytes
present
too
if
macro_offset
section_size
dealloc_macro_srcfiles
srcfiles
srcfilescount
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
macro_header
macro_offset
section_base
macro_data
macro_header
section_end
section_base
section_size
macro_context
Dwarf_Macro_Context
_dwarf_get_alloc
dbg
DW_DLA_MACRO_CONTEXT
if
macro_context
dealloc_macro_srcfiles
srcfiles
srcfilescount
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
if
section_base
DWARF_HALF_SIZE
sizeof
Dwarf_Small
section_end
dealloc_macro_srcfiles
srcfiles
srcfilescount
dwarf_dealloc_macro_context
macro_context
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
Note
here
so
if
error
return
we
get
these
freed
eventually
macro_context
mc_srcfiles
srcfiles
macro_context
mc_srcfiles_count
srcfilescount
macro_context
mc_cu_context
cu_context
res
_dwarf_read_unaligned_ck_wrapper
dbg
macro_data
DWARF_HALF_SIZE
section_end
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
if
version
DW_MACRO_VERSION4
version
DW_MACRO_VERSION5
dwarfstring
ms
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_MACRO_VERSION_ERROR
version
x
version
dwarfstring_append_printf_u
at
section
offset
DW_PR_XZEROS
DW_PR_DUx
is
incorrect
only
or
the
GNU
extension
value
of
are
valid
Corrupt
dwarf
macro_offset
_dwarf_error_string
dbg
error
DW_DLE_MACRO_VERSION_ERROR
dwarfstring_string
dwarfstring_destructor
dwarf_dealloc_macro_context
macro_context
return
DW_DLV_ERROR
macro_data
DWARF_HALF_SIZE
res
_dwarf_read_unaligned_ck_wrapper
dbg
macro_data
sizeof
Dwarf_Small
section_end
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
macro_data
sizeof
Dwarf_Small
macro_context
mc_at_comp_dir
comp_dir
macro_context
mc_at_name
comp_name
macro_context
mc_macro_header
macro_header
macro_context
mc_section_offset
macro_offset
macro_context
mc_section_size
section_size
macro_context
mc_version_number
version
macro_context
mc_flags
flags
macro_context
mc_dbg
dbg
macro_context
mc_offset_size_flag
flags&
MACRO_OFFSET_SIZE_FLAG?TRUE
FALSE
macro_context
mc_debug_line_offset_flag
flags&
MACRO_LINE_OFFSET_FLAG?TRUE
FALSE
macro_context
mc_operands_table_flag
flags&
MACRO_OP_TABLE_FLAG?TRUE
FALSE
offset_size
macro_context
mc_offset_size_flag?8
macro_context
mc_offset_size
offset_size
if
macro_context
mc_debug_line_offset_flag
cur_offset
offset_size
macro_data
section_base
if
cur_offset
section_size
dwarf_dealloc_macro_context
macro_context
_dwarf_error
dbg
error
DW_DLE_MACRO_OFFSET_BAD
return
DW_DLV_ERROR
res
_dwarf_read_unaligned_ck_wrapper
dbg
macro_data
offset_size
section_end
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
macro_data
offset_size
macro_context
mc_debug_line_offset
line_table_offset
if
macro_context
mc_operands_table_flag
res
read_operands_table
macro_context
macro_header
macro_data
section_base
section_size
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
macro_data
optablesize
macro_context
mc_macro_ops
macro_data
macro_context
mc_macro_header_length
macro_data
macro_header
build_ops_array
FALSE
res
_dwarf_get_macro_ops_count_internal
macro_context
build_ops_array
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
build_ops_array
TRUE
res
_dwarf_get_macro_ops_count_internal
macro_context
build_ops_array
error
if
res
DW_DLV_OK
dwarf_dealloc_macro_context
macro_context
return
res
macro_ops_count_out
macro_context
mc_macro_ops_count
macro_ops_data_length
macro_context
mc_ops_data_length
version_out
version
macro_context_out
macro_context
return
DW_DLV_OK
int
dwarf_macro_context_total_length
Dwarf_Macro_Context
head
Dwarf_Unsigned
mac_total_len
Dwarf_Error
error
Dwarf_Debug
dbg
if
head
dbg
head
mc_dbg
CHECKNULLCONTEXT
head
dbg
error
mac_total_len
head
mc_total_length
return
DW_DLV_OK
int
dwarf_macro_context_head
Dwarf_Macro_Context
head
Dwarf_Half
version
Dwarf_Unsigned
mac_offset
Dwarf_Unsigned
mac_len
Dwarf_Unsigned
mac_header_len
unsigned
flags
Dwarf_Bool
has_line_offset
Dwarf_Unsigned
line_offset
Dwarf_Bool
has_offset_size_64
Dwarf_Bool
has_operands_table
Dwarf_Half
opcode_count
Dwarf_Error
error
Dwarf_Debug
dbg
CHECKNULLCONTEXT
head
dbg
error
version
head
mc_version_number
mac_offset
head
mc_section_offset
mac_len
head
mc_total_length
mac_header_len
head
mc_macro_header_length
flags
head
mc_flags
line_offset
head
mc_debug_line_offset
has_line_offset
head
mc_debug_line_offset_flag
has_offset_size_64
head
mc_offset_size_flag
has_operands_table
head
mc_operands_table_flag
opcode_count
head
mc_opcode_count
return
DW_DLV_OK
int
dwarf_macro_operands_table
Dwarf_Macro_Context
head
Dwarf_Half
index
to
opcode_count
Dwarf_Half
opcode_number
Dwarf_Half
operand_count
const
Dwarf_Small
operand_array
Dwarf_Error
error
struct
Dwarf_Macro_Forms_s
ops
Dwarf_Debug
dbg
CHECKNULLCONTEXT
head
dbg
error
dbg
head
mc_dbg
if
index
head
mc_opcode_count
_dwarf_error
dbg
error
DW_DLE_BAD_MACRO_INDEX
return
DW_DLV_ERROR
ops
head
mc_opcode_forms
index
opcode_number
ops
mf_code
operand_count
ops
mf_formcount
operand_array
ops
mf_formbytes
return
DW_DLV_OK
The
base
interface
to
the
debug_macro
section
data
for
a
specific
CU
The
version
number
passed
back
by
version_out
may
be
a
gnu
extension
of
DWARF
or
int
dwarf_get_macro_context
Dwarf_Die
cu_die
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_unit_offset_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
Dwarf_Error
error
int
res
Dwarf_Bool
offset_specified
FALSE
Dwarf_Unsigned
offset
res
_dwarf_internal_macro_context
cu_die
offset_specified
offset
version_out
macro_context
macro_unit_offset_out
macro_ops_count_out
macro_ops_data_length
error
return
res
Like
dwarf_get_macro_context
but
here
we
use
a
specified
offset
instead
of
the
offset
in
the
cu_die
int
dwarf_get_macro_context_by_offset
Dwarf_Die
cu_die
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
Dwarf_Error
error
int
res
Dwarf_Bool
offset_specified
TRUE
Dwarf_Unsigned
macro_unit_offset_out
res
_dwarf_internal_macro_context
cu_die
offset_specified
offset
version_out
macro_context
macro_ops_count_out
macro_ops_data_length
error
return
res
int
dwarf_get_macro_section_name
Dwarf_Debug
dbg
const
char
sec_name_out
UNUSEDARG
Dwarf_Error
error
struct
Dwarf_Section_s
sec
sec
de_debug_macro
if
sec
dss_size
We
don
t
have
such
a
section
at
all
return
DW_DLV_NO_ENTRY
sec_name_out
sec
dss_name
return
DW_DLV_OK
void
dwarf_dealloc_macro_context
Dwarf_Macro_Context
mc
Dwarf_Debug
dbg
if
mc
return
dbg
mc
mc_dbg
See
_dwarf_macro_destructor
here
dwarf_dealloc
dbg
mc
DW_DLA_MACRO_CONTEXT
int
_dwarf_macro_constructor
Dwarf_Debug
dbg
void
m
Nothing
to
do
the
space
is
zeroed
out
Dwarf_Macro_Context
mc
Dwarf_Macro_Context
m
Arbitrary
sentinel
For
debugging
mc
mc_sentinel
MC_SENTINAL
mc
mc_dbg
dbg
return
DW_DLV_OK
Here
we
free
various
fields
of
Dwarf_Macro_Context
The
fields
do
not
get
dealloc
d
If
we
had
a
separate
destructor
for
hand
calling
meaning
when
an
error
is
detected
during
creation
of
a
Dwarf_Macro_Context
and
one
for
calling
by
dwarf_dealloc
then
we
could
have
the
hand
calling
dwarf_dealloc
the
fields
and
the
one
called
on
the
dealloc
of
a
Dwarf_Macro_Context
could
leave
the
_dwarf_get_alloc
fields
for
for
normal
dwarf_finish
cleanup
But
for
now
we
share
this
destructor
for
both
purposes
so
no
fields
are
_dwarf_get_alloc
and
all
are
free
d
here
void
_dwarf_macro_destructor
void
m
Dwarf_Macro_Context
mc
Dwarf_Macro_Context
m
dealloc_macro_srcfiles
mc
mc_srcfiles
mc
mc_srcfiles_count
mc
mc_srcfiles
mc
mc_srcfiles_count
free
void
mc
mc_file_path
mc
mc_file_path
free
mc
mc_ops
mc
mc_ops
free
mc
mc_opcode_forms
mc
mc_opcode_forms
memset
mc
sizeof
mc
Just
a
recognizable
sentinel
For
debugging
No
real
meaning
mc
mc_sentinel
Generated
routines
do
not
edit
Generated
sourcedate
BEGIN
FILE
include
dwarf
h
include
libdwarf
h
ARGSUSED
int
dwarf_get_TAG_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_TAG_array_type
s_out
DW_TAG_array_type
return
DW_DLV_OK
case
DW_TAG_class_type
s_out
DW_TAG_class_type
return
DW_DLV_OK
case
DW_TAG_entry_point
s_out
DW_TAG_entry_point
return
DW_DLV_OK
case
DW_TAG_enumeration_type
s_out
DW_TAG_enumeration_type
return
DW_DLV_OK
case
DW_TAG_formal_parameter
s_out
DW_TAG_formal_parameter
return
DW_DLV_OK
case
DW_TAG_imported_declaration
s_out
DW_TAG_imported_declaration
return
DW_DLV_OK
case
DW_TAG_label
s_out
DW_TAG_label
return
DW_DLV_OK
case
DW_TAG_lexical_block
s_out
DW_TAG_lexical_block
return
DW_DLV_OK
case
DW_TAG_member
s_out
DW_TAG_member
return
DW_DLV_OK
case
DW_TAG_pointer_type
s_out
DW_TAG_pointer_type
return
DW_DLV_OK
case
DW_TAG_reference_type
s_out
DW_TAG_reference_type
return
DW_DLV_OK
case
DW_TAG_compile_unit
s_out
DW_TAG_compile_unit
return
DW_DLV_OK
case
DW_TAG_string_type
s_out
DW_TAG_string_type
return
DW_DLV_OK
case
DW_TAG_structure_type
s_out
DW_TAG_structure_type
return
DW_DLV_OK
case
DW_TAG_subroutine_type
s_out
DW_TAG_subroutine_type
return
DW_DLV_OK
case
DW_TAG_typedef
s_out
DW_TAG_typedef
return
DW_DLV_OK
case
DW_TAG_union_type
s_out
DW_TAG_union_type
return
DW_DLV_OK
case
DW_TAG_unspecified_parameters
s_out
DW_TAG_unspecified_parameters
return
DW_DLV_OK
case
DW_TAG_variant
s_out
DW_TAG_variant
return
DW_DLV_OK
case
DW_TAG_common_block
s_out
DW_TAG_common_block
return
DW_DLV_OK
case
DW_TAG_common_inclusion
s_out
DW_TAG_common_inclusion
return
DW_DLV_OK
case
DW_TAG_inheritance
s_out
DW_TAG_inheritance
return
DW_DLV_OK
case
DW_TAG_inlined_subroutine
s_out
DW_TAG_inlined_subroutine
return
DW_DLV_OK
case
DW_TAG_module
s_out
DW_TAG_module
return
DW_DLV_OK
case
DW_TAG_ptr_to_member_type
s_out
DW_TAG_ptr_to_member_type
return
DW_DLV_OK
case
DW_TAG_set_type
s_out
DW_TAG_set_type
return
DW_DLV_OK
case
DW_TAG_subrange_type
s_out
DW_TAG_subrange_type
return
DW_DLV_OK
case
DW_TAG_with_stmt
s_out
DW_TAG_with_stmt
return
DW_DLV_OK
case
DW_TAG_access_declaration
s_out
DW_TAG_access_declaration
return
DW_DLV_OK
case
DW_TAG_base_type
s_out
DW_TAG_base_type
return
DW_DLV_OK
case
DW_TAG_catch_block
s_out
DW_TAG_catch_block
return
DW_DLV_OK
case
DW_TAG_const_type
s_out
DW_TAG_const_type
return
DW_DLV_OK
case
DW_TAG_constant
s_out
DW_TAG_constant
return
DW_DLV_OK
case
DW_TAG_enumerator
s_out
DW_TAG_enumerator
return
DW_DLV_OK
case
DW_TAG_file_type
s_out
DW_TAG_file_type
return
DW_DLV_OK
case
DW_TAG_friend
s_out
DW_TAG_friend
return
DW_DLV_OK
case
DW_TAG_namelist
s_out
DW_TAG_namelist
return
DW_DLV_OK
case
DW_TAG_namelist_item
s_out
DW_TAG_namelist_item
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_namelist_items
case
DW_TAG_packed_type
s_out
DW_TAG_packed_type
return
DW_DLV_OK
case
DW_TAG_subprogram
s_out
DW_TAG_subprogram
return
DW_DLV_OK
case
DW_TAG_template_type_parameter
s_out
DW_TAG_template_type_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_template_type_param
case
DW_TAG_template_value_parameter
s_out
DW_TAG_template_value_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_template_value_param
case
DW_TAG_thrown_type
s_out
DW_TAG_thrown_type
return
DW_DLV_OK
case
DW_TAG_try_block
s_out
DW_TAG_try_block
return
DW_DLV_OK
case
DW_TAG_variant_part
s_out
DW_TAG_variant_part
return
DW_DLV_OK
case
DW_TAG_variable
s_out
DW_TAG_variable
return
DW_DLV_OK
case
DW_TAG_volatile_type
s_out
DW_TAG_volatile_type
return
DW_DLV_OK
case
DW_TAG_dwarf_procedure
s_out
DW_TAG_dwarf_procedure
return
DW_DLV_OK
case
DW_TAG_restrict_type
s_out
DW_TAG_restrict_type
return
DW_DLV_OK
case
DW_TAG_interface_type
s_out
DW_TAG_interface_type
return
DW_DLV_OK
case
DW_TAG_namespace
s_out
DW_TAG_namespace
return
DW_DLV_OK
case
DW_TAG_imported_module
s_out
DW_TAG_imported_module
return
DW_DLV_OK
case
DW_TAG_unspecified_type
s_out
DW_TAG_unspecified_type
return
DW_DLV_OK
case
DW_TAG_partial_unit
s_out
DW_TAG_partial_unit
return
DW_DLV_OK
case
DW_TAG_imported_unit
s_out
DW_TAG_imported_unit
return
DW_DLV_OK
case
DW_TAG_mutable_type
s_out
DW_TAG_mutable_type
return
DW_DLV_OK
case
DW_TAG_condition
s_out
DW_TAG_condition
return
DW_DLV_OK
case
DW_TAG_shared_type
s_out
DW_TAG_shared_type
return
DW_DLV_OK
case
DW_TAG_type_unit
s_out
DW_TAG_type_unit
return
DW_DLV_OK
case
DW_TAG_rvalue_reference_type
s_out
DW_TAG_rvalue_reference_type
return
DW_DLV_OK
case
DW_TAG_template_alias
s_out
DW_TAG_template_alias
return
DW_DLV_OK
case
DW_TAG_coarray_type
s_out
DW_TAG_coarray_type
return
DW_DLV_OK
case
DW_TAG_generic_subrange
s_out
DW_TAG_generic_subrange
return
DW_DLV_OK
case
DW_TAG_dynamic_type
s_out
DW_TAG_dynamic_type
return
DW_DLV_OK
case
DW_TAG_atomic_type
s_out
DW_TAG_atomic_type
return
DW_DLV_OK
case
DW_TAG_call_site
s_out
DW_TAG_call_site
return
DW_DLV_OK
case
DW_TAG_call_site_parameter
s_out
DW_TAG_call_site_parameter
return
DW_DLV_OK
case
DW_TAG_skeleton_unit
s_out
DW_TAG_skeleton_unit
return
DW_DLV_OK
case
DW_TAG_immutable_type
s_out
DW_TAG_immutable_type
return
DW_DLV_OK
case
DW_TAG_lo_user
s_out
DW_TAG_lo_user
return
DW_DLV_OK
case
DW_TAG_MIPS_loop
s_out
DW_TAG_MIPS_loop
return
DW_DLV_OK
case
DW_TAG_HP_array_descriptor
s_out
DW_TAG_HP_array_descriptor
return
DW_DLV_OK
case
DW_TAG_format_label
s_out
DW_TAG_format_label
return
DW_DLV_OK
case
DW_TAG_function_template
s_out
DW_TAG_function_template
return
DW_DLV_OK
case
DW_TAG_class_template
s_out
DW_TAG_class_template
return
DW_DLV_OK
case
DW_TAG_GNU_BINCL
s_out
DW_TAG_GNU_BINCL
return
DW_DLV_OK
case
DW_TAG_GNU_EINCL
s_out
DW_TAG_GNU_EINCL
return
DW_DLV_OK
case
DW_TAG_GNU_template_template_parameter
s_out
DW_TAG_GNU_template_template_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_GNU_template_template_param
case
DW_TAG_GNU_template_parameter_pack
s_out
DW_TAG_GNU_template_parameter_pack
return
DW_DLV_OK
case
DW_TAG_GNU_formal_parameter_pack
s_out
DW_TAG_GNU_formal_parameter_pack
return
DW_DLV_OK
case
DW_TAG_GNU_call_site
s_out
DW_TAG_GNU_call_site
return
DW_DLV_OK
case
DW_TAG_GNU_call_site_parameter
s_out
DW_TAG_GNU_call_site_parameter
return
DW_DLV_OK
case
DW_TAG_SUN_function_template
s_out
DW_TAG_SUN_function_template
return
DW_DLV_OK
case
DW_TAG_SUN_class_template
s_out
DW_TAG_SUN_class_template
return
DW_DLV_OK
case
DW_TAG_SUN_struct_template
s_out
DW_TAG_SUN_struct_template
return
DW_DLV_OK
case
DW_TAG_SUN_union_template
s_out
DW_TAG_SUN_union_template
return
DW_DLV_OK
case
DW_TAG_SUN_indirect_inheritance
s_out
DW_TAG_SUN_indirect_inheritance
return
DW_DLV_OK
case
DW_TAG_SUN_codeflags
s_out
DW_TAG_SUN_codeflags
return
DW_DLV_OK
case
DW_TAG_SUN_memop_info
s_out
DW_TAG_SUN_memop_info
return
DW_DLV_OK
case
DW_TAG_SUN_omp_child_func
s_out
DW_TAG_SUN_omp_child_func
return
DW_DLV_OK
case
DW_TAG_SUN_rtti_descriptor
s_out
DW_TAG_SUN_rtti_descriptor
return
DW_DLV_OK
case
DW_TAG_SUN_dtor_info
s_out
DW_TAG_SUN_dtor_info
return
DW_DLV_OK
case
DW_TAG_SUN_dtor
s_out
DW_TAG_SUN_dtor
return
DW_DLV_OK
case
DW_TAG_SUN_f90_interface
s_out
DW_TAG_SUN_f90_interface
return
DW_DLV_OK
case
DW_TAG_SUN_fortran_vax_structure
s_out
DW_TAG_SUN_fortran_vax_structure
return
DW_DLV_OK
case
DW_TAG_SUN_hi
s_out
DW_TAG_SUN_hi
return
DW_DLV_OK
case
DW_TAG_ALTIUM_circ_type
s_out
DW_TAG_ALTIUM_circ_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_mwa_circ_type
s_out
DW_TAG_ALTIUM_mwa_circ_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_rev_carry_type
s_out
DW_TAG_ALTIUM_rev_carry_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_rom
s_out
DW_TAG_ALTIUM_rom
return
DW_DLV_OK
case
DW_TAG_ghs_namespace
s_out
DW_TAG_ghs_namespace
return
DW_DLV_OK
case
DW_TAG_ghs_using_namespace
s_out
DW_TAG_ghs_using_namespace
return
DW_DLV_OK
case
DW_TAG_ghs_using_declaration
s_out
DW_TAG_ghs_using_declaration
return
DW_DLV_OK
case
DW_TAG_ghs_template_templ_param
s_out
DW_TAG_ghs_template_templ_param
return
DW_DLV_OK
case
DW_TAG_upc_shared_type
s_out
DW_TAG_upc_shared_type
return
DW_DLV_OK
case
DW_TAG_upc_strict_type
s_out
DW_TAG_upc_strict_type
return
DW_DLV_OK
case
DW_TAG_upc_relaxed_type
s_out
DW_TAG_upc_relaxed_type
return
DW_DLV_OK
case
DW_TAG_PGI_kanji_type
s_out
DW_TAG_PGI_kanji_type
return
DW_DLV_OK
case
DW_TAG_PGI_interface_block
s_out
DW_TAG_PGI_interface_block
return
DW_DLV_OK
case
DW_TAG_BORLAND_property
s_out
DW_TAG_BORLAND_property
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_string
s_out
DW_TAG_BORLAND_Delphi_string
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_dynamic_array
s_out
DW_TAG_BORLAND_Delphi_dynamic_array
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_set
s_out
DW_TAG_BORLAND_Delphi_set
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_variant
s_out
DW_TAG_BORLAND_Delphi_variant
return
DW_DLV_OK
case
DW_TAG_hi_user
s_out
DW_TAG_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_children_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_children_no
s_out
DW_children_no
return
DW_DLV_OK
case
DW_children_yes
s_out
DW_children_yes
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_FORM_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_FORM_addr
s_out
DW_FORM_addr
return
DW_DLV_OK
case
DW_FORM_block2
s_out
DW_FORM_block2
return
DW_DLV_OK
case
DW_FORM_block4
s_out
DW_FORM_block4
return
DW_DLV_OK
case
DW_FORM_data2
s_out
DW_FORM_data2
return
DW_DLV_OK
case
DW_FORM_data4
s_out
DW_FORM_data4
return
DW_DLV_OK
case
DW_FORM_data8
s_out
DW_FORM_data8
return
DW_DLV_OK
case
DW_FORM_string
s_out
DW_FORM_string
return
DW_DLV_OK
case
DW_FORM_block
s_out
DW_FORM_block
return
DW_DLV_OK
case
DW_FORM_block1
s_out
DW_FORM_block1
return
DW_DLV_OK
case
DW_FORM_data1
s_out
DW_FORM_data1
return
DW_DLV_OK
case
DW_FORM_flag
s_out
DW_FORM_flag
return
DW_DLV_OK
case
DW_FORM_sdata
s_out
DW_FORM_sdata
return
DW_DLV_OK
case
DW_FORM_strp
s_out
DW_FORM_strp
return
DW_DLV_OK
case
DW_FORM_udata
s_out
DW_FORM_udata
return
DW_DLV_OK
case
DW_FORM_ref_addr
s_out
DW_FORM_ref_addr
return
DW_DLV_OK
case
DW_FORM_ref1
s_out
DW_FORM_ref1
return
DW_DLV_OK
case
DW_FORM_ref2
s_out
DW_FORM_ref2
return
DW_DLV_OK
case
DW_FORM_ref4
s_out
DW_FORM_ref4
return
DW_DLV_OK
case
DW_FORM_ref8
s_out
DW_FORM_ref8
return
DW_DLV_OK
case
DW_FORM_ref_udata
s_out
DW_FORM_ref_udata
return
DW_DLV_OK
case
DW_FORM_indirect
s_out
DW_FORM_indirect
return
DW_DLV_OK
case
DW_FORM_sec_offset
s_out
DW_FORM_sec_offset
return
DW_DLV_OK
case
DW_FORM_exprloc
s_out
DW_FORM_exprloc
return
DW_DLV_OK
case
DW_FORM_flag_present
s_out
DW_FORM_flag_present
return
DW_DLV_OK
case
DW_FORM_strx
s_out
DW_FORM_strx
return
DW_DLV_OK
case
DW_FORM_addrx
s_out
DW_FORM_addrx
return
DW_DLV_OK
case
DW_FORM_ref_sup4
s_out
DW_FORM_ref_sup4
return
DW_DLV_OK
case
DW_FORM_strp_sup
s_out
DW_FORM_strp_sup
return
DW_DLV_OK
case
DW_FORM_data16
s_out
DW_FORM_data16
return
DW_DLV_OK
case
DW_FORM_line_strp
s_out
DW_FORM_line_strp
return
DW_DLV_OK
case
DW_FORM_ref_sig8
s_out
DW_FORM_ref_sig8
return
DW_DLV_OK
case
DW_FORM_implicit_const
s_out
DW_FORM_implicit_const
return
DW_DLV_OK
case
DW_FORM_loclistx
s_out
DW_FORM_loclistx
return
DW_DLV_OK
case
DW_FORM_rnglistx
s_out
DW_FORM_rnglistx
return
DW_DLV_OK
case
DW_FORM_ref_sup8
s_out
DW_FORM_ref_sup8
return
DW_DLV_OK
case
DW_FORM_strx1
s_out
DW_FORM_strx1
return
DW_DLV_OK
case
DW_FORM_strx2
s_out
DW_FORM_strx2
return
DW_DLV_OK
case
DW_FORM_strx3
s_out
DW_FORM_strx3
return
DW_DLV_OK
case
DW_FORM_strx4
s_out
DW_FORM_strx4
return
DW_DLV_OK
case
DW_FORM_addrx1
s_out
DW_FORM_addrx1
return
DW_DLV_OK
case
DW_FORM_addrx2
s_out
DW_FORM_addrx2
return
DW_DLV_OK
case
DW_FORM_addrx3
s_out
DW_FORM_addrx3
return
DW_DLV_OK
case
DW_FORM_addrx4
s_out
DW_FORM_addrx4
return
DW_DLV_OK
case
DW_FORM_GNU_addr_index
s_out
DW_FORM_GNU_addr_index
return
DW_DLV_OK
case
DW_FORM_GNU_str_index
s_out
DW_FORM_GNU_str_index
return
DW_DLV_OK
case
DW_FORM_GNU_ref_alt
s_out
DW_FORM_GNU_ref_alt
return
DW_DLV_OK
case
DW_FORM_GNU_strp_alt
s_out
DW_FORM_GNU_strp_alt
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_AT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_AT_sibling
s_out
DW_AT_sibling
return
DW_DLV_OK
case
DW_AT_location
s_out
DW_AT_location
return
DW_DLV_OK
case
DW_AT_name
s_out
DW_AT_name
return
DW_DLV_OK
case
DW_AT_ordering
s_out
DW_AT_ordering
return
DW_DLV_OK
case
DW_AT_subscr_data
s_out
DW_AT_subscr_data
return
DW_DLV_OK
case
DW_AT_byte_size
s_out
DW_AT_byte_size
return
DW_DLV_OK
case
DW_AT_bit_offset
s_out
DW_AT_bit_offset
return
DW_DLV_OK
case
DW_AT_bit_size
s_out
DW_AT_bit_size
return
DW_DLV_OK
case
DW_AT_element_list
s_out
DW_AT_element_list
return
DW_DLV_OK
case
DW_AT_stmt_list
s_out
DW_AT_stmt_list
return
DW_DLV_OK
case
DW_AT_low_pc
s_out
DW_AT_low_pc
return
DW_DLV_OK
case
DW_AT_high_pc
s_out
DW_AT_high_pc
return
DW_DLV_OK
case
DW_AT_language
s_out
DW_AT_language
return
DW_DLV_OK
case
DW_AT_member
s_out
DW_AT_member
return
DW_DLV_OK
case
DW_AT_discr
s_out
DW_AT_discr
return
DW_DLV_OK
case
DW_AT_discr_value
s_out
DW_AT_discr_value
return
DW_DLV_OK
case
DW_AT_visibility
s_out
DW_AT_visibility
return
DW_DLV_OK
case
DW_AT_import
s_out
DW_AT_import
return
DW_DLV_OK
case
DW_AT_string_length
s_out
DW_AT_string_length
return
DW_DLV_OK
case
DW_AT_common_reference
s_out
DW_AT_common_reference
return
DW_DLV_OK
case
DW_AT_comp_dir
s_out
DW_AT_comp_dir
return
DW_DLV_OK
case
DW_AT_const_value
s_out
DW_AT_const_value
return
DW_DLV_OK
case
DW_AT_containing_type
s_out
DW_AT_containing_type
return
DW_DLV_OK
case
DW_AT_default_value
s_out
DW_AT_default_value
return
DW_DLV_OK
case
DW_AT_inline
s_out
DW_AT_inline
return
DW_DLV_OK
case
DW_AT_is_optional
s_out
DW_AT_is_optional
return
DW_DLV_OK
case
DW_AT_lower_bound
s_out
DW_AT_lower_bound
return
DW_DLV_OK
case
DW_AT_producer
s_out
DW_AT_producer
return
DW_DLV_OK
case
DW_AT_prototyped
s_out
DW_AT_prototyped
return
DW_DLV_OK
case
DW_AT_return_addr
s_out
DW_AT_return_addr
return
DW_DLV_OK
case
DW_AT_start_scope
s_out
DW_AT_start_scope
return
DW_DLV_OK
case
DW_AT_bit_stride
s_out
DW_AT_bit_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_stride_size
case
DW_AT_upper_bound
s_out
DW_AT_upper_bound
return
DW_DLV_OK
case
DW_AT_abstract_origin
s_out
DW_AT_abstract_origin
return
DW_DLV_OK
case
DW_AT_accessibility
s_out
DW_AT_accessibility
return
DW_DLV_OK
case
DW_AT_address_class
s_out
DW_AT_address_class
return
DW_DLV_OK
case
DW_AT_artificial
s_out
DW_AT_artificial
return
DW_DLV_OK
case
DW_AT_base_types
s_out
DW_AT_base_types
return
DW_DLV_OK
case
DW_AT_calling_convention
s_out
DW_AT_calling_convention
return
DW_DLV_OK
case
DW_AT_count
s_out
DW_AT_count
return
DW_DLV_OK
case
DW_AT_data_member_location
s_out
DW_AT_data_member_location
return
DW_DLV_OK
case
DW_AT_decl_column
s_out
DW_AT_decl_column
return
DW_DLV_OK
case
DW_AT_decl_file
s_out
DW_AT_decl_file
return
DW_DLV_OK
case
DW_AT_decl_line
s_out
DW_AT_decl_line
return
DW_DLV_OK
case
DW_AT_declaration
s_out
DW_AT_declaration
return
DW_DLV_OK
case
DW_AT_discr_list
s_out
DW_AT_discr_list
return
DW_DLV_OK
case
DW_AT_encoding
s_out
DW_AT_encoding
return
DW_DLV_OK
case
DW_AT_external
s_out
DW_AT_external
return
DW_DLV_OK
case
DW_AT_frame_base
s_out
DW_AT_frame_base
return
DW_DLV_OK
case
DW_AT_friend
s_out
DW_AT_friend
return
DW_DLV_OK
case
DW_AT_identifier_case
s_out
DW_AT_identifier_case
return
DW_DLV_OK
case
DW_AT_macro_info
s_out
DW_AT_macro_info
return
DW_DLV_OK
case
DW_AT_namelist_item
s_out
DW_AT_namelist_item
return
DW_DLV_OK
case
DW_AT_priority
s_out
DW_AT_priority
return
DW_DLV_OK
case
DW_AT_segment
s_out
DW_AT_segment
return
DW_DLV_OK
case
DW_AT_specification
s_out
DW_AT_specification
return
DW_DLV_OK
case
DW_AT_static_link
s_out
DW_AT_static_link
return
DW_DLV_OK
case
DW_AT_type
s_out
DW_AT_type
return
DW_DLV_OK
case
DW_AT_use_location
s_out
DW_AT_use_location
return
DW_DLV_OK
case
DW_AT_variable_parameter
s_out
DW_AT_variable_parameter
return
DW_DLV_OK
case
DW_AT_virtuality
s_out
DW_AT_virtuality
return
DW_DLV_OK
case
DW_AT_vtable_elem_location
s_out
DW_AT_vtable_elem_location
return
DW_DLV_OK
case
DW_AT_allocated
s_out
DW_AT_allocated
return
DW_DLV_OK
case
DW_AT_associated
s_out
DW_AT_associated
return
DW_DLV_OK
case
DW_AT_data_location
s_out
DW_AT_data_location
return
DW_DLV_OK
case
DW_AT_byte_stride
s_out
DW_AT_byte_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_stride
case
DW_AT_entry_pc
s_out
DW_AT_entry_pc
return
DW_DLV_OK
case
DW_AT_use_UTF8
s_out
DW_AT_use_UTF8
return
DW_DLV_OK
case
DW_AT_extension
s_out
DW_AT_extension
return
DW_DLV_OK
case
DW_AT_ranges
s_out
DW_AT_ranges
return
DW_DLV_OK
case
DW_AT_trampoline
s_out
DW_AT_trampoline
return
DW_DLV_OK
case
DW_AT_call_column
s_out
DW_AT_call_column
return
DW_DLV_OK
case
DW_AT_call_file
s_out
DW_AT_call_file
return
DW_DLV_OK
case
DW_AT_call_line
s_out
DW_AT_call_line
return
DW_DLV_OK
case
DW_AT_description
s_out
DW_AT_description
return
DW_DLV_OK
case
DW_AT_binary_scale
s_out
DW_AT_binary_scale
return
DW_DLV_OK
case
DW_AT_decimal_scale
s_out
DW_AT_decimal_scale
return
DW_DLV_OK
case
DW_AT_small
s_out
DW_AT_small
return
DW_DLV_OK
case
DW_AT_decimal_sign
s_out
DW_AT_decimal_sign
return
DW_DLV_OK
case
DW_AT_digit_count
s_out
DW_AT_digit_count
return
DW_DLV_OK
case
DW_AT_picture_string
s_out
DW_AT_picture_string
return
DW_DLV_OK
case
DW_AT_mutable
s_out
DW_AT_mutable
return
DW_DLV_OK
case
DW_AT_threads_scaled
s_out
DW_AT_threads_scaled
return
DW_DLV_OK
case
DW_AT_explicit
s_out
DW_AT_explicit
return
DW_DLV_OK
case
DW_AT_object_pointer
s_out
DW_AT_object_pointer
return
DW_DLV_OK
case
DW_AT_endianity
s_out
DW_AT_endianity
return
DW_DLV_OK
case
DW_AT_elemental
s_out
DW_AT_elemental
return
DW_DLV_OK
case
DW_AT_pure
s_out
DW_AT_pure
return
DW_DLV_OK
case
DW_AT_recursive
s_out
DW_AT_recursive
return
DW_DLV_OK
case
DW_AT_signature
s_out
DW_AT_signature
return
DW_DLV_OK
case
DW_AT_main_subprogram
s_out
DW_AT_main_subprogram
return
DW_DLV_OK
case
DW_AT_data_bit_offset
s_out
DW_AT_data_bit_offset
return
DW_DLV_OK
case
DW_AT_const_expr
s_out
DW_AT_const_expr
return
DW_DLV_OK
case
DW_AT_enum_class
s_out
DW_AT_enum_class
return
DW_DLV_OK
case
DW_AT_linkage_name
s_out
DW_AT_linkage_name
return
DW_DLV_OK
case
DW_AT_string_length_bit_size
s_out
DW_AT_string_length_bit_size
return
DW_DLV_OK
case
DW_AT_string_length_byte_size
s_out
DW_AT_string_length_byte_size
return
DW_DLV_OK
case
DW_AT_rank
s_out
DW_AT_rank
return
DW_DLV_OK
case
DW_AT_str_offsets_base
s_out
DW_AT_str_offsets_base
return
DW_DLV_OK
case
DW_AT_addr_base
s_out
DW_AT_addr_base
return
DW_DLV_OK
case
DW_AT_rnglists_base
s_out
DW_AT_rnglists_base
return
DW_DLV_OK
case
DW_AT_dwo_id
s_out
DW_AT_dwo_id
return
DW_DLV_OK
case
DW_AT_dwo_name
s_out
DW_AT_dwo_name
return
DW_DLV_OK
case
DW_AT_reference
s_out
DW_AT_reference
return
DW_DLV_OK
case
DW_AT_rvalue_reference
s_out
DW_AT_rvalue_reference
return
DW_DLV_OK
case
DW_AT_macros
s_out
DW_AT_macros
return
DW_DLV_OK
case
DW_AT_call_all_calls
s_out
DW_AT_call_all_calls
return
DW_DLV_OK
case
DW_AT_call_all_source_calls
s_out
DW_AT_call_all_source_calls
return
DW_DLV_OK
case
DW_AT_call_all_tail_calls
s_out
DW_AT_call_all_tail_calls
return
DW_DLV_OK
case
DW_AT_call_return_pc
s_out
DW_AT_call_return_pc
return
DW_DLV_OK
case
DW_AT_call_value
s_out
DW_AT_call_value
return
DW_DLV_OK
case
DW_AT_call_origin
s_out
DW_AT_call_origin
return
DW_DLV_OK
case
DW_AT_call_parameter
s_out
DW_AT_call_parameter
return
DW_DLV_OK
case
DW_AT_call_pc
s_out
DW_AT_call_pc
return
DW_DLV_OK
case
DW_AT_call_tail_call
s_out
DW_AT_call_tail_call
return
DW_DLV_OK
case
DW_AT_call_target
s_out
DW_AT_call_target
return
DW_DLV_OK
case
DW_AT_call_target_clobbered
s_out
DW_AT_call_target_clobbered
return
DW_DLV_OK
case
DW_AT_call_data_location
s_out
DW_AT_call_data_location
return
DW_DLV_OK
case
DW_AT_call_data_value
s_out
DW_AT_call_data_value
return
DW_DLV_OK
case
DW_AT_noreturn
s_out
DW_AT_noreturn
return
DW_DLV_OK
case
DW_AT_alignment
s_out
DW_AT_alignment
return
DW_DLV_OK
case
DW_AT_export_symbols
s_out
DW_AT_export_symbols
return
DW_DLV_OK
case
DW_AT_deleted
s_out
DW_AT_deleted
return
DW_DLV_OK
case
DW_AT_defaulted
s_out
DW_AT_defaulted
return
DW_DLV_OK
case
DW_AT_loclists_base
s_out
DW_AT_loclists_base
return
DW_DLV_OK
case
DW_AT_ghs_namespace_alias
s_out
DW_AT_ghs_namespace_alias
return
DW_DLV_OK
case
DW_AT_ghs_using_namespace
s_out
DW_AT_ghs_using_namespace
return
DW_DLV_OK
case
DW_AT_ghs_using_declaration
s_out
DW_AT_ghs_using_declaration
return
DW_DLV_OK
case
DW_AT_HP_block_index
s_out
DW_AT_HP_block_index
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_lo_user
case
DW_AT_MIPS_fde
s_out
DW_AT_MIPS_fde
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_unmodifiable
Skipping
alternate
spelling
of
value
DW_AT_CPQ_discontig_ranges
case
DW_AT_MIPS_loop_begin
s_out
DW_AT_MIPS_loop_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_semantic_events
case
DW_AT_MIPS_tail_loop_begin
s_out
DW_AT_MIPS_tail_loop_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_split_lifetimes_var
case
DW_AT_MIPS_epilog_begin
s_out
DW_AT_MIPS_epilog_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_split_lifetimes_rtn
case
DW_AT_MIPS_loop_unroll_factor
s_out
DW_AT_MIPS_loop_unroll_factor
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_prologue
Skipping
alternate
spelling
of
value
DW_AT_CPQ_prologue_length
case
DW_AT_MIPS_software_pipeline_depth
s_out
DW_AT_MIPS_software_pipeline_depth
return
DW_DLV_OK
case
DW_AT_MIPS_linkage_name
s_out
DW_AT_MIPS_linkage_name
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_ghs_mangled
case
DW_AT_MIPS_stride
s_out
DW_AT_MIPS_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_epilogue
case
DW_AT_MIPS_abstract_name
s_out
DW_AT_MIPS_abstract_name
return
DW_DLV_OK
case
DW_AT_MIPS_clone_origin
s_out
DW_AT_MIPS_clone_origin
return
DW_DLV_OK
case
DW_AT_MIPS_has_inlines
s_out
DW_AT_MIPS_has_inlines
return
DW_DLV_OK
case
DW_AT_MIPS_stride_byte
s_out
DW_AT_MIPS_stride_byte
return
DW_DLV_OK
case
DW_AT_MIPS_stride_elem
s_out
DW_AT_MIPS_stride_elem
return
DW_DLV_OK
case
DW_AT_MIPS_ptr_dopetype
s_out
DW_AT_MIPS_ptr_dopetype
return
DW_DLV_OK
case
DW_AT_MIPS_allocatable_dopetype
s_out
DW_AT_MIPS_allocatable_dopetype
return
DW_DLV_OK
case
DW_AT_MIPS_assumed_shape_dopetype
s_out
DW_AT_MIPS_assumed_shape_dopetype
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_actuals_stmt_list
case
DW_AT_MIPS_assumed_size
s_out
DW_AT_MIPS_assumed_size
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_proc_per_section
case
DW_AT_HP_raw_data_ptr
s_out
DW_AT_HP_raw_data_ptr
return
DW_DLV_OK
case
DW_AT_HP_pass_by_reference
s_out
DW_AT_HP_pass_by_reference
return
DW_DLV_OK
case
DW_AT_HP_opt_level
s_out
DW_AT_HP_opt_level
return
DW_DLV_OK
case
DW_AT_HP_prof_version_id
s_out
DW_AT_HP_prof_version_id
return
DW_DLV_OK
case
DW_AT_HP_opt_flags
s_out
DW_AT_HP_opt_flags
return
DW_DLV_OK
case
DW_AT_HP_cold_region_low_pc
s_out
DW_AT_HP_cold_region_low_pc
return
DW_DLV_OK
case
DW_AT_HP_cold_region_high_pc
s_out
DW_AT_HP_cold_region_high_pc
return
DW_DLV_OK
case
DW_AT_HP_all_variables_modifiable
s_out
DW_AT_HP_all_variables_modifiable
return
DW_DLV_OK
case
DW_AT_HP_linkage_name
s_out
DW_AT_HP_linkage_name
return
DW_DLV_OK
case
DW_AT_HP_prof_flags
s_out
DW_AT_HP_prof_flags
return
DW_DLV_OK
case
DW_AT_HP_unit_name
s_out
DW_AT_HP_unit_name
return
DW_DLV_OK
case
DW_AT_HP_unit_size
s_out
DW_AT_HP_unit_size
return
DW_DLV_OK
case
DW_AT_HP_widened_byte_size
s_out
DW_AT_HP_widened_byte_size
return
DW_DLV_OK
case
DW_AT_HP_definition_points
s_out
DW_AT_HP_definition_points
return
DW_DLV_OK
case
DW_AT_HP_default_location
s_out
DW_AT_HP_default_location
return
DW_DLV_OK
case
DW_AT_INTEL_other_endian
s_out
DW_AT_INTEL_other_endian
return
DW_DLV_OK
case
DW_AT_HP_is_result_param
s_out
DW_AT_HP_is_result_param
return
DW_DLV_OK
case
DW_AT_ghs_rsm
s_out
DW_AT_ghs_rsm
return
DW_DLV_OK
case
DW_AT_ghs_frsm
s_out
DW_AT_ghs_frsm
return
DW_DLV_OK
case
DW_AT_ghs_frames
s_out
DW_AT_ghs_frames
return
DW_DLV_OK
case
DW_AT_ghs_rso
s_out
DW_AT_ghs_rso
return
DW_DLV_OK
case
DW_AT_ghs_subcpu
s_out
DW_AT_ghs_subcpu
return
DW_DLV_OK
case
DW_AT_ghs_lbrace_line
s_out
DW_AT_ghs_lbrace_line
return
DW_DLV_OK
case
DW_AT_sf_names
s_out
DW_AT_sf_names
return
DW_DLV_OK
case
DW_AT_src_info
s_out
DW_AT_src_info
return
DW_DLV_OK
case
DW_AT_mac_info
s_out
DW_AT_mac_info
return
DW_DLV_OK
case
DW_AT_src_coords
s_out
DW_AT_src_coords
return
DW_DLV_OK
case
DW_AT_body_begin
s_out
DW_AT_body_begin
return
DW_DLV_OK
case
DW_AT_body_end
s_out
DW_AT_body_end
return
DW_DLV_OK
case
DW_AT_GNU_vector
s_out
DW_AT_GNU_vector
return
DW_DLV_OK
case
DW_AT_GNU_guarded_by
s_out
DW_AT_GNU_guarded_by
return
DW_DLV_OK
case
DW_AT_GNU_pt_guarded_by
s_out
DW_AT_GNU_pt_guarded_by
return
DW_DLV_OK
case
DW_AT_GNU_guarded
s_out
DW_AT_GNU_guarded
return
DW_DLV_OK
case
DW_AT_GNU_pt_guarded
s_out
DW_AT_GNU_pt_guarded
return
DW_DLV_OK
case
DW_AT_GNU_locks_excluded
s_out
DW_AT_GNU_locks_excluded
return
DW_DLV_OK
case
DW_AT_GNU_exclusive_locks_required
s_out
DW_AT_GNU_exclusive_locks_required
return
DW_DLV_OK
case
DW_AT_GNU_shared_locks_required
s_out
DW_AT_GNU_shared_locks_required
return
DW_DLV_OK
case
DW_AT_GNU_odr_signature
s_out
DW_AT_GNU_odr_signature
return
DW_DLV_OK
case
DW_AT_GNU_template_name
s_out
DW_AT_GNU_template_name
return
DW_DLV_OK
case
DW_AT_GNU_call_site_value
s_out
DW_AT_GNU_call_site_value
return
DW_DLV_OK
case
DW_AT_GNU_call_site_data_value
s_out
DW_AT_GNU_call_site_data_value
return
DW_DLV_OK
case
DW_AT_GNU_call_site_target
s_out
DW_AT_GNU_call_site_target
return
DW_DLV_OK
case
DW_AT_GNU_call_site_target_clobbered
s_out
DW_AT_GNU_call_site_target_clobbered
return
DW_DLV_OK
case
DW_AT_GNU_tail_call
s_out
DW_AT_GNU_tail_call
return
DW_DLV_OK
case
DW_AT_GNU_all_tail_call_sites
s_out
DW_AT_GNU_all_tail_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_all_call_sites
s_out
DW_AT_GNU_all_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_all_source_call_sites
s_out
DW_AT_GNU_all_source_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_macros
s_out
DW_AT_GNU_macros
return
DW_DLV_OK
case
DW_AT_GNU_deleted
s_out
DW_AT_GNU_deleted
return
DW_DLV_OK
case
DW_AT_GNU_dwo_name
s_out
DW_AT_GNU_dwo_name
return
DW_DLV_OK
case
DW_AT_GNU_dwo_id
s_out
DW_AT_GNU_dwo_id
return
DW_DLV_OK
case
DW_AT_GNU_ranges_base
s_out
DW_AT_GNU_ranges_base
return
DW_DLV_OK
case
DW_AT_GNU_addr_base
s_out
DW_AT_GNU_addr_base
return
DW_DLV_OK
case
DW_AT_GNU_pubnames
s_out
DW_AT_GNU_pubnames
return
DW_DLV_OK
case
DW_AT_GNU_pubtypes
s_out
DW_AT_GNU_pubtypes
return
DW_DLV_OK
case
DW_AT_GNU_discriminator
s_out
DW_AT_GNU_discriminator
return
DW_DLV_OK
case
DW_AT_GNU_locviews
s_out
DW_AT_GNU_locviews
return
DW_DLV_OK
case
DW_AT_GNU_entry_view
s_out
DW_AT_GNU_entry_view
return
DW_DLV_OK
case
DW_AT_SUN_template
s_out
DW_AT_SUN_template
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_VMS_rtnbeg_pd_address
case
DW_AT_SUN_alignment
s_out
DW_AT_SUN_alignment
return
DW_DLV_OK
case
DW_AT_SUN_vtable
s_out
DW_AT_SUN_vtable
return
DW_DLV_OK
case
DW_AT_SUN_count_guarantee
s_out
DW_AT_SUN_count_guarantee
return
DW_DLV_OK
case
DW_AT_SUN_command_line
s_out
DW_AT_SUN_command_line
return
DW_DLV_OK
case
DW_AT_SUN_vbase
s_out
DW_AT_SUN_vbase
return
DW_DLV_OK
case
DW_AT_SUN_compile_options
s_out
DW_AT_SUN_compile_options
return
DW_DLV_OK
case
DW_AT_SUN_language
s_out
DW_AT_SUN_language
return
DW_DLV_OK
case
DW_AT_SUN_browser_file
s_out
DW_AT_SUN_browser_file
return
DW_DLV_OK
case
DW_AT_SUN_vtable_abi
s_out
DW_AT_SUN_vtable_abi
return
DW_DLV_OK
case
DW_AT_SUN_func_offsets
s_out
DW_AT_SUN_func_offsets
return
DW_DLV_OK
case
DW_AT_SUN_cf_kind
s_out
DW_AT_SUN_cf_kind
return
DW_DLV_OK
case
DW_AT_SUN_vtable_index
s_out
DW_AT_SUN_vtable_index
return
DW_DLV_OK
case
DW_AT_SUN_omp_tpriv_addr
s_out
DW_AT_SUN_omp_tpriv_addr
return
DW_DLV_OK
case
DW_AT_SUN_omp_child_func
s_out
DW_AT_SUN_omp_child_func
return
DW_DLV_OK
case
DW_AT_SUN_func_offset
s_out
DW_AT_SUN_func_offset
return
DW_DLV_OK
case
DW_AT_SUN_memop_type_ref
s_out
DW_AT_SUN_memop_type_ref
return
DW_DLV_OK
case
DW_AT_SUN_profile_id
s_out
DW_AT_SUN_profile_id
return
DW_DLV_OK
case
DW_AT_SUN_memop_signature
s_out
DW_AT_SUN_memop_signature
return
DW_DLV_OK
case
DW_AT_SUN_obj_dir
s_out
DW_AT_SUN_obj_dir
return
DW_DLV_OK
case
DW_AT_SUN_obj_file
s_out
DW_AT_SUN_obj_file
return
DW_DLV_OK
case
DW_AT_SUN_original_name
s_out
DW_AT_SUN_original_name
return
DW_DLV_OK
case
DW_AT_SUN_hwcprof_signature
s_out
DW_AT_SUN_hwcprof_signature
return
DW_DLV_OK
case
DW_AT_SUN_amd64_parmdump
s_out
DW_AT_SUN_amd64_parmdump
return
DW_DLV_OK
case
DW_AT_SUN_part_link_name
s_out
DW_AT_SUN_part_link_name
return
DW_DLV_OK
case
DW_AT_SUN_link_name
s_out
DW_AT_SUN_link_name
return
DW_DLV_OK
case
DW_AT_SUN_pass_with_const
s_out
DW_AT_SUN_pass_with_const
return
DW_DLV_OK
case
DW_AT_SUN_return_with_const
s_out
DW_AT_SUN_return_with_const
return
DW_DLV_OK
case
DW_AT_SUN_import_by_name
s_out
DW_AT_SUN_import_by_name
return
DW_DLV_OK
case
DW_AT_SUN_f90_pointer
s_out
DW_AT_SUN_f90_pointer
return
DW_DLV_OK
case
DW_AT_SUN_pass_by_ref
s_out
DW_AT_SUN_pass_by_ref
return
DW_DLV_OK
case
DW_AT_SUN_f90_allocatable
s_out
DW_AT_SUN_f90_allocatable
return
DW_DLV_OK
case
DW_AT_SUN_f90_assumed_shape_array
s_out
DW_AT_SUN_f90_assumed_shape_array
return
DW_DLV_OK
case
DW_AT_SUN_c_vla
s_out
DW_AT_SUN_c_vla
return
DW_DLV_OK
case
DW_AT_SUN_return_value_ptr
s_out
DW_AT_SUN_return_value_ptr
return
DW_DLV_OK
case
DW_AT_SUN_dtor_start
s_out
DW_AT_SUN_dtor_start
return
DW_DLV_OK
case
DW_AT_SUN_dtor_length
s_out
DW_AT_SUN_dtor_length
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_initial
s_out
DW_AT_SUN_dtor_state_initial
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_final
s_out
DW_AT_SUN_dtor_state_final
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_deltas
s_out
DW_AT_SUN_dtor_state_deltas
return
DW_DLV_OK
case
DW_AT_SUN_import_by_lname
s_out
DW_AT_SUN_import_by_lname
return
DW_DLV_OK
case
DW_AT_SUN_f90_use_only
s_out
DW_AT_SUN_f90_use_only
return
DW_DLV_OK
case
DW_AT_SUN_namelist_spec
s_out
DW_AT_SUN_namelist_spec
return
DW_DLV_OK
case
DW_AT_SUN_is_omp_child_func
s_out
DW_AT_SUN_is_omp_child_func
return
DW_DLV_OK
case
DW_AT_SUN_fortran_main_alias
s_out
DW_AT_SUN_fortran_main_alias
return
DW_DLV_OK
case
DW_AT_SUN_fortran_based
s_out
DW_AT_SUN_fortran_based
return
DW_DLV_OK
case
DW_AT_ALTIUM_loclist
s_out
DW_AT_ALTIUM_loclist
return
DW_DLV_OK
case
DW_AT_use_GNAT_descriptive_type
s_out
DW_AT_use_GNAT_descriptive_type
return
DW_DLV_OK
case
DW_AT_GNAT_descriptive_type
s_out
DW_AT_GNAT_descriptive_type
return
DW_DLV_OK
case
DW_AT_GNU_numerator
s_out
DW_AT_GNU_numerator
return
DW_DLV_OK
case
DW_AT_GNU_denominator
s_out
DW_AT_GNU_denominator
return
DW_DLV_OK
case
DW_AT_GNU_bias
s_out
DW_AT_GNU_bias
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_GNU_bias
case
DW_AT_go_kind
s_out
DW_AT_go_kind
return
DW_DLV_OK
case
DW_AT_go_key
s_out
DW_AT_go_key
return
DW_DLV_OK
case
DW_AT_go_elem
s_out
DW_AT_go_elem
return
DW_DLV_OK
case
DW_AT_go_embedded_field
s_out
DW_AT_go_embedded_field
return
DW_DLV_OK
case
DW_AT_go_runtime_type
s_out
DW_AT_go_runtime_type
return
DW_DLV_OK
case
DW_AT_upc_threads_scaled
s_out
DW_AT_upc_threads_scaled
return
DW_DLV_OK
case
DW_AT_IBM_wsa_addr
s_out
DW_AT_IBM_wsa_addr
return
DW_DLV_OK
case
DW_AT_IBM_home_location
s_out
DW_AT_IBM_home_location
return
DW_DLV_OK
case
DW_AT_IBM_alt_srcview
s_out
DW_AT_IBM_alt_srcview
return
DW_DLV_OK
case
DW_AT_PGI_lbase
s_out
DW_AT_PGI_lbase
return
DW_DLV_OK
case
DW_AT_PGI_soffset
s_out
DW_AT_PGI_soffset
return
DW_DLV_OK
case
DW_AT_PGI_lstride
s_out
DW_AT_PGI_lstride
return
DW_DLV_OK
case
DW_AT_BORLAND_property_read
s_out
DW_AT_BORLAND_property_read
return
DW_DLV_OK
case
DW_AT_BORLAND_property_write
s_out
DW_AT_BORLAND_property_write
return
DW_DLV_OK
case
DW_AT_BORLAND_property_implements
s_out
DW_AT_BORLAND_property_implements
return
DW_DLV_OK
case
DW_AT_BORLAND_property_index
s_out
DW_AT_BORLAND_property_index
return
DW_DLV_OK
case
DW_AT_BORLAND_property_default
s_out
DW_AT_BORLAND_property_default
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_unit
s_out
DW_AT_BORLAND_Delphi_unit
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_class
s_out
DW_AT_BORLAND_Delphi_class
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_record
s_out
DW_AT_BORLAND_Delphi_record
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_metaclass
s_out
DW_AT_BORLAND_Delphi_metaclass
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_constructor
s_out
DW_AT_BORLAND_Delphi_constructor
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_destructor
s_out
DW_AT_BORLAND_Delphi_destructor
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_anonymous_method
s_out
DW_AT_BORLAND_Delphi_anonymous_method
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_interface
s_out
DW_AT_BORLAND_Delphi_interface
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_ABI
s_out
DW_AT_BORLAND_Delphi_ABI
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_frameptr
s_out
DW_AT_BORLAND_Delphi_frameptr
return
DW_DLV_OK
case
DW_AT_BORLAND_closure
s_out
DW_AT_BORLAND_closure
return
DW_DLV_OK
case
DW_AT_LLVM_include_path
s_out
DW_AT_LLVM_include_path
return
DW_DLV_OK
case
DW_AT_LLVM_config_macros
s_out
DW_AT_LLVM_config_macros
return
DW_DLV_OK
case
DW_AT_LLVM_sysroot
s_out
DW_AT_LLVM_sysroot
return
DW_DLV_OK
case
DW_AT_LLVM_tag_offset
s_out
DW_AT_LLVM_tag_offset
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_LLVM_apinotes
case
DW_AT_APPLE_optimized
s_out
DW_AT_APPLE_optimized
return
DW_DLV_OK
case
DW_AT_APPLE_flags
s_out
DW_AT_APPLE_flags
return
DW_DLV_OK
case
DW_AT_APPLE_isa
s_out
DW_AT_APPLE_isa
return
DW_DLV_OK
case
DW_AT_APPLE_block
s_out
DW_AT_APPLE_block
return
DW_DLV_OK
case
DW_AT_APPLE_major_runtime_vers
s_out
DW_AT_APPLE_major_runtime_vers
return
DW_DLV_OK
case
DW_AT_APPLE_runtime_class
s_out
DW_AT_APPLE_runtime_class
return
DW_DLV_OK
case
DW_AT_APPLE_omit_frame_ptr
s_out
DW_AT_APPLE_omit_frame_ptr
return
DW_DLV_OK
case
DW_AT_APPLE_property_name
s_out
DW_AT_APPLE_property_name
return
DW_DLV_OK
case
DW_AT_APPLE_property_getter
s_out
DW_AT_APPLE_property_getter
return
DW_DLV_OK
case
DW_AT_APPLE_property_setter
s_out
DW_AT_APPLE_property_setter
return
DW_DLV_OK
case
DW_AT_APPLE_property_attribute
s_out
DW_AT_APPLE_property_attribute
return
DW_DLV_OK
case
DW_AT_APPLE_objc_complete_type
s_out
DW_AT_APPLE_objc_complete_type
return
DW_DLV_OK
case
DW_AT_APPLE_property
s_out
DW_AT_APPLE_property
return
DW_DLV_OK
case
DW_AT_APPLE_objc_direct
s_out
DW_AT_APPLE_objc_direct
return
DW_DLV_OK
case
DW_AT_APPLE_sdk
s_out
DW_AT_APPLE_sdk
return
DW_DLV_OK
case
DW_AT_hi_user
s_out
DW_AT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_OP_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_OP_addr
s_out
DW_OP_addr
return
DW_DLV_OK
case
DW_OP_deref
s_out
DW_OP_deref
return
DW_DLV_OK
case
DW_OP_const1u
s_out
DW_OP_const1u
return
DW_DLV_OK
case
DW_OP_const1s
s_out
DW_OP_const1s
return
DW_DLV_OK
case
DW_OP_const2u
s_out
DW_OP_const2u
return
DW_DLV_OK
case
DW_OP_const2s
s_out
DW_OP_const2s
return
DW_DLV_OK
case
DW_OP_const4u
s_out
DW_OP_const4u
return
DW_DLV_OK
case
DW_OP_const4s
s_out
DW_OP_const4s
return
DW_DLV_OK
case
DW_OP_const8u
s_out
DW_OP_const8u
return
DW_DLV_OK
case
DW_OP_const8s
s_out
DW_OP_const8s
return
DW_DLV_OK
case
DW_OP_constu
s_out
DW_OP_constu
return
DW_DLV_OK
case
DW_OP_consts
s_out
DW_OP_consts
return
DW_DLV_OK
case
DW_OP_dup
s_out
DW_OP_dup
return
DW_DLV_OK
case
DW_OP_drop
s_out
DW_OP_drop
return
DW_DLV_OK
case
DW_OP_over
s_out
DW_OP_over
return
DW_DLV_OK
case
DW_OP_pick
s_out
DW_OP_pick
return
DW_DLV_OK
case
DW_OP_swap
s_out
DW_OP_swap
return
DW_DLV_OK
case
DW_OP_rot
s_out
DW_OP_rot
return
DW_DLV_OK
case
DW_OP_xderef
s_out
DW_OP_xderef
return
DW_DLV_OK
case
DW_OP_abs
s_out
DW_OP_abs
return
DW_DLV_OK
case
DW_OP_and
s_out
DW_OP_and
return
DW_DLV_OK
case
DW_OP_div
s_out
DW_OP_div
return
DW_DLV_OK
case
DW_OP_minus
s_out
DW_OP_minus
return
DW_DLV_OK
case
DW_OP_mod
s_out
DW_OP_mod
return
DW_DLV_OK
case
DW_OP_mul
s_out
DW_OP_mul
return
DW_DLV_OK
case
DW_OP_neg
s_out
DW_OP_neg
return
DW_DLV_OK
case
DW_OP_not
s_out
DW_OP_not
return
DW_DLV_OK
case
DW_OP_or
s_out
DW_OP_or
return
DW_DLV_OK
case
DW_OP_plus
s_out
DW_OP_plus
return
DW_DLV_OK
case
DW_OP_plus_uconst
s_out
DW_OP_plus_uconst
return
DW_DLV_OK
case
DW_OP_shl
s_out
DW_OP_shl
return
DW_DLV_OK
case
DW_OP_shr
s_out
DW_OP_shr
return
DW_DLV_OK
case
DW_OP_shra
s_out
DW_OP_shra
return
DW_DLV_OK
case
DW_OP_xor
s_out
DW_OP_xor
return
DW_DLV_OK
case
DW_OP_bra
s_out
DW_OP_bra
return
DW_DLV_OK
case
DW_OP_eq
s_out
DW_OP_eq
return
DW_DLV_OK
case
DW_OP_ge
s_out
DW_OP_ge
return
DW_DLV_OK
case
DW_OP_gt
s_out
DW_OP_gt
return
DW_DLV_OK
case
DW_OP_le
s_out
DW_OP_le
return
DW_DLV_OK
case
DW_OP_lt
s_out
DW_OP_lt
return
DW_DLV_OK
case
DW_OP_ne
s_out
DW_OP_ne
return
DW_DLV_OK
case
DW_OP_skip
s_out
DW_OP_skip
return
DW_DLV_OK
case
DW_OP_lit0
s_out
DW_OP_lit0
return
DW_DLV_OK
case
DW_OP_lit1
s_out
DW_OP_lit1
return
DW_DLV_OK
case
DW_OP_lit2
s_out
DW_OP_lit2
return
DW_DLV_OK
case
DW_OP_lit3
s_out
DW_OP_lit3
return
DW_DLV_OK
case
DW_OP_lit4
s_out
DW_OP_lit4
return
DW_DLV_OK
case
DW_OP_lit5
s_out
DW_OP_lit5
return
DW_DLV_OK
case
DW_OP_lit6
s_out
DW_OP_lit6
return
DW_DLV_OK
case
DW_OP_lit7
s_out
DW_OP_lit7
return
DW_DLV_OK
case
DW_OP_lit8
s_out
DW_OP_lit8
return
DW_DLV_OK
case
DW_OP_lit9
s_out
DW_OP_lit9
return
DW_DLV_OK
case
DW_OP_lit10
s_out
DW_OP_lit10
return
DW_DLV_OK
case
DW_OP_lit11
s_out
DW_OP_lit11
return
DW_DLV_OK
case
DW_OP_lit12
s_out
DW_OP_lit12
return
DW_DLV_OK
case
DW_OP_lit13
s_out
DW_OP_lit13
return
DW_DLV_OK
case
DW_OP_lit14
s_out
DW_OP_lit14
return
DW_DLV_OK
case
DW_OP_lit15
s_out
DW_OP_lit15
return
DW_DLV_OK
case
DW_OP_lit16
s_out
DW_OP_lit16
return
DW_DLV_OK
case
DW_OP_lit17
s_out
DW_OP_lit17
return
DW_DLV_OK
case
DW_OP_lit18
s_out
DW_OP_lit18
return
DW_DLV_OK
case
DW_OP_lit19
s_out
DW_OP_lit19
return
DW_DLV_OK
case
DW_OP_lit20
s_out
DW_OP_lit20
return
DW_DLV_OK
case
DW_OP_lit21
s_out
DW_OP_lit21
return
DW_DLV_OK
case
DW_OP_lit22
s_out
DW_OP_lit22
return
DW_DLV_OK
case
DW_OP_lit23
s_out
DW_OP_lit23
return
DW_DLV_OK
case
DW_OP_lit24
s_out
DW_OP_lit24
return
DW_DLV_OK
case
DW_OP_lit25
s_out
DW_OP_lit25
return
DW_DLV_OK
case
DW_OP_lit26
s_out
DW_OP_lit26
return
DW_DLV_OK
case
DW_OP_lit27
s_out
DW_OP_lit27
return
DW_DLV_OK
case
DW_OP_lit28
s_out
DW_OP_lit28
return
DW_DLV_OK
case
DW_OP_lit29
s_out
DW_OP_lit29
return
DW_DLV_OK
case
DW_OP_lit30
s_out
DW_OP_lit30
return
DW_DLV_OK
case
DW_OP_lit31
s_out
DW_OP_lit31
return
DW_DLV_OK
case
DW_OP_reg0
s_out
DW_OP_reg0
return
DW_DLV_OK
case
DW_OP_reg1
s_out
DW_OP_reg1
return
DW_DLV_OK
case
DW_OP_reg2
s_out
DW_OP_reg2
return
DW_DLV_OK
case
DW_OP_reg3
s_out
DW_OP_reg3
return
DW_DLV_OK
case
DW_OP_reg4
s_out
DW_OP_reg4
return
DW_DLV_OK
case
DW_OP_reg5
s_out
DW_OP_reg5
return
DW_DLV_OK
case
DW_OP_reg6
s_out
DW_OP_reg6
return
DW_DLV_OK
case
DW_OP_reg7
s_out
DW_OP_reg7
return
DW_DLV_OK
case
DW_OP_reg8
s_out
DW_OP_reg8
return
DW_DLV_OK
case
DW_OP_reg9
s_out
DW_OP_reg9
return
DW_DLV_OK
case
DW_OP_reg10
s_out
DW_OP_reg10
return
DW_DLV_OK
case
DW_OP_reg11
s_out
DW_OP_reg11
return
DW_DLV_OK
case
DW_OP_reg12
s_out
DW_OP_reg12
return
DW_DLV_OK
case
DW_OP_reg13
s_out
DW_OP_reg13
return
DW_DLV_OK
case
DW_OP_reg14
s_out
DW_OP_reg14
return
DW_DLV_OK
case
DW_OP_reg15
s_out
DW_OP_reg15
return
DW_DLV_OK
case
DW_OP_reg16
s_out
DW_OP_reg16
return
DW_DLV_OK
case
DW_OP_reg17
s_out
DW_OP_reg17
return
DW_DLV_OK
case
DW_OP_reg18
s_out
DW_OP_reg18
return
DW_DLV_OK
case
DW_OP_reg19
s_out
DW_OP_reg19
return
DW_DLV_OK
case
DW_OP_reg20
s_out
DW_OP_reg20
return
DW_DLV_OK
case
DW_OP_reg21
s_out
DW_OP_reg21
return
DW_DLV_OK
case
DW_OP_reg22
s_out
DW_OP_reg22
return
DW_DLV_OK
case
DW_OP_reg23
s_out
DW_OP_reg23
return
DW_DLV_OK
case
DW_OP_reg24
s_out
DW_OP_reg24
return
DW_DLV_OK
case
DW_OP_reg25
s_out
DW_OP_reg25
return
DW_DLV_OK
case
DW_OP_reg26
s_out
DW_OP_reg26
return
DW_DLV_OK
case
DW_OP_reg27
s_out
DW_OP_reg27
return
DW_DLV_OK
case
DW_OP_reg28
s_out
DW_OP_reg28
return
DW_DLV_OK
case
DW_OP_reg29
s_out
DW_OP_reg29
return
DW_DLV_OK
case
DW_OP_reg30
s_out
DW_OP_reg30
return
DW_DLV_OK
case
DW_OP_reg31
s_out
DW_OP_reg31
return
DW_DLV_OK
case
DW_OP_breg0
s_out
DW_OP_breg0
return
DW_DLV_OK
case
DW_OP_breg1
s_out
DW_OP_breg1
return
DW_DLV_OK
case
DW_OP_breg2
s_out
DW_OP_breg2
return
DW_DLV_OK
case
DW_OP_breg3
s_out
DW_OP_breg3
return
DW_DLV_OK
case
DW_OP_breg4
s_out
DW_OP_breg4
return
DW_DLV_OK
case
DW_OP_breg5
s_out
DW_OP_breg5
return
DW_DLV_OK
case
DW_OP_breg6
s_out
DW_OP_breg6
return
DW_DLV_OK
case
DW_OP_breg7
s_out
DW_OP_breg7
return
DW_DLV_OK
case
DW_OP_breg8
s_out
DW_OP_breg8
return
DW_DLV_OK
case
DW_OP_breg9
s_out
DW_OP_breg9
return
DW_DLV_OK
case
DW_OP_breg10
s_out
DW_OP_breg10
return
DW_DLV_OK
case
DW_OP_breg11
s_out
DW_OP_breg11
return
DW_DLV_OK
case
DW_OP_breg12
s_out
DW_OP_breg12
return
DW_DLV_OK
case
DW_OP_breg13
s_out
DW_OP_breg13
return
DW_DLV_OK
case
DW_OP_breg14
s_out
DW_OP_breg14
return
DW_DLV_OK
case
DW_OP_breg15
s_out
DW_OP_breg15
return
DW_DLV_OK
case
DW_OP_breg16
s_out
DW_OP_breg16
return
DW_DLV_OK
case
DW_OP_breg17
s_out
DW_OP_breg17
return
DW_DLV_OK
case
DW_OP_breg18
s_out
DW_OP_breg18
return
DW_DLV_OK
case
DW_OP_breg19
s_out
DW_OP_breg19
return
DW_DLV_OK
case
DW_OP_breg20
s_out
DW_OP_breg20
return
DW_DLV_OK
case
DW_OP_breg21
s_out
DW_OP_breg21
return
DW_DLV_OK
case
DW_OP_breg22
s_out
DW_OP_breg22
return
DW_DLV_OK
case
DW_OP_breg23
s_out
DW_OP_breg23
return
DW_DLV_OK
case
DW_OP_breg24
s_out
DW_OP_breg24
return
DW_DLV_OK
case
DW_OP_breg25
s_out
DW_OP_breg25
return
DW_DLV_OK
case
DW_OP_breg26
s_out
DW_OP_breg26
return
DW_DLV_OK
case
DW_OP_breg27
s_out
DW_OP_breg27
return
DW_DLV_OK
case
DW_OP_breg28
s_out
DW_OP_breg28
return
DW_DLV_OK
case
DW_OP_breg29
s_out
DW_OP_breg29
return
DW_DLV_OK
case
DW_OP_breg30
s_out
DW_OP_breg30
return
DW_DLV_OK
case
DW_OP_breg31
s_out
DW_OP_breg31
return
DW_DLV_OK
case
DW_OP_regx
s_out
DW_OP_regx
return
DW_DLV_OK
case
DW_OP_fbreg
s_out
DW_OP_fbreg
return
DW_DLV_OK
case
DW_OP_bregx
s_out
DW_OP_bregx
return
DW_DLV_OK
case
DW_OP_piece
s_out
DW_OP_piece
return
DW_DLV_OK
case
DW_OP_deref_size
s_out
DW_OP_deref_size
return
DW_DLV_OK
case
DW_OP_xderef_size
s_out
DW_OP_xderef_size
return
DW_DLV_OK
case
DW_OP_nop
s_out
DW_OP_nop
return
DW_DLV_OK
case
DW_OP_push_object_address
s_out
DW_OP_push_object_address
return
DW_DLV_OK
case
DW_OP_call2
s_out
DW_OP_call2
return
DW_DLV_OK
case
DW_OP_call4
s_out
DW_OP_call4
return
DW_DLV_OK
case
DW_OP_call_ref
s_out
DW_OP_call_ref
return
DW_DLV_OK
case
DW_OP_form_tls_address
s_out
DW_OP_form_tls_address
return
DW_DLV_OK
case
DW_OP_call_frame_cfa
s_out
DW_OP_call_frame_cfa
return
DW_DLV_OK
case
DW_OP_bit_piece
s_out
DW_OP_bit_piece
return
DW_DLV_OK
case
DW_OP_implicit_value
s_out
DW_OP_implicit_value
return
DW_DLV_OK
case
DW_OP_stack_value
s_out
DW_OP_stack_value
return
DW_DLV_OK
case
DW_OP_implicit_pointer
s_out
DW_OP_implicit_pointer
return
DW_DLV_OK
case
DW_OP_addrx
s_out
DW_OP_addrx
return
DW_DLV_OK
case
DW_OP_constx
s_out
DW_OP_constx
return
DW_DLV_OK
case
DW_OP_entry_value
s_out
DW_OP_entry_value
return
DW_DLV_OK
case
DW_OP_const_type
s_out
DW_OP_const_type
return
DW_DLV_OK
case
DW_OP_regval_type
s_out
DW_OP_regval_type
return
DW_DLV_OK
case
DW_OP_deref_type
s_out
DW_OP_deref_type
return
DW_DLV_OK
case
DW_OP_xderef_type
s_out
DW_OP_xderef_type
return
DW_DLV_OK
case
DW_OP_convert
s_out
DW_OP_convert
return
DW_DLV_OK
case
DW_OP_reinterpret
s_out
DW_OP_reinterpret
return
DW_DLV_OK
case
DW_OP_GNU_push_tls_address
s_out
DW_OP_GNU_push_tls_address
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_OP_lo_user
Skipping
alternate
spelling
of
value
DW_OP_HP_unknown
case
DW_OP_HP_is_value
s_out
DW_OP_HP_is_value
return
DW_DLV_OK
case
DW_OP_HP_fltconst4
s_out
DW_OP_HP_fltconst4
return
DW_DLV_OK
case
DW_OP_HP_fltconst8
s_out
DW_OP_HP_fltconst8
return
DW_DLV_OK
case
DW_OP_HP_mod_range
s_out
DW_OP_HP_mod_range
return
DW_DLV_OK
case
DW_OP_HP_unmod_range
s_out
DW_OP_HP_unmod_range
return
DW_DLV_OK
case
DW_OP_HP_tls
s_out
DW_OP_HP_tls
return
DW_DLV_OK
case
DW_OP_INTEL_bit_piece
s_out
DW_OP_INTEL_bit_piece
return
DW_DLV_OK
case
DW_OP_WASM_location
s_out
DW_OP_WASM_location
return
DW_DLV_OK
case
DW_OP_WASM_location_int
s_out
DW_OP_WASM_location_int
return
DW_DLV_OK
case
DW_OP_GNU_uninit
s_out
DW_OP_GNU_uninit
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_OP_APPLE_uninit
case
DW_OP_GNU_encoded_addr
s_out
DW_OP_GNU_encoded_addr
return
DW_DLV_OK
case
DW_OP_GNU_implicit_pointer
s_out
DW_OP_GNU_implicit_pointer
return
DW_DLV_OK
case
DW_OP_GNU_entry_value
s_out
DW_OP_GNU_entry_value
return
DW_DLV_OK
case
DW_OP_GNU_const_type
s_out
DW_OP_GNU_const_type
return
DW_DLV_OK
case
DW_OP_GNU_regval_type
s_out
DW_OP_GNU_regval_type
return
DW_DLV_OK
case
DW_OP_GNU_deref_type
s_out
DW_OP_GNU_deref_type
return
DW_DLV_OK
case
DW_OP_GNU_convert
s_out
DW_OP_GNU_convert
return
DW_DLV_OK
case
DW_OP_PGI_omp_thread_num
s_out
DW_OP_PGI_omp_thread_num
return
DW_DLV_OK
case
DW_OP_GNU_reinterpret
s_out
DW_OP_GNU_reinterpret
return
DW_DLV_OK
case
DW_OP_GNU_parameter_ref
s_out
DW_OP_GNU_parameter_ref
return
DW_DLV_OK
case
DW_OP_GNU_addr_index
s_out
DW_OP_GNU_addr_index
return
DW_DLV_OK
case
DW_OP_GNU_const_index
s_out
DW_OP_GNU_const_index
return
DW_DLV_OK
case
DW_OP_GNU_variable_value
s_out
DW_OP_GNU_variable_value
return
DW_DLV_OK
case
DW_OP_hi_user
s_out
DW_OP_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ATE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ATE_address
s_out
DW_ATE_address
return
DW_DLV_OK
case
DW_ATE_boolean
s_out
DW_ATE_boolean
return
DW_DLV_OK
case
DW_ATE_complex_float
s_out
DW_ATE_complex_float
return
DW_DLV_OK
case
DW_ATE_float
s_out
DW_ATE_float
return
DW_DLV_OK
case
DW_ATE_signed
s_out
DW_ATE_signed
return
DW_DLV_OK
case
DW_ATE_signed_char
s_out
DW_ATE_signed_char
return
DW_DLV_OK
case
DW_ATE_unsigned
s_out
DW_ATE_unsigned
return
DW_DLV_OK
case
DW_ATE_unsigned_char
s_out
DW_ATE_unsigned_char
return
DW_DLV_OK
case
DW_ATE_imaginary_float
s_out
DW_ATE_imaginary_float
return
DW_DLV_OK
case
DW_ATE_packed_decimal
s_out
DW_ATE_packed_decimal
return
DW_DLV_OK
case
DW_ATE_numeric_string
s_out
DW_ATE_numeric_string
return
DW_DLV_OK
case
DW_ATE_edited
s_out
DW_ATE_edited
return
DW_DLV_OK
case
DW_ATE_signed_fixed
s_out
DW_ATE_signed_fixed
return
DW_DLV_OK
case
DW_ATE_unsigned_fixed
s_out
DW_ATE_unsigned_fixed
return
DW_DLV_OK
case
DW_ATE_decimal_float
s_out
DW_ATE_decimal_float
return
DW_DLV_OK
case
DW_ATE_UTF
s_out
DW_ATE_UTF
return
DW_DLV_OK
case
DW_ATE_UCS
s_out
DW_ATE_UCS
return
DW_DLV_OK
case
DW_ATE_ASCII
s_out
DW_ATE_ASCII
return
DW_DLV_OK
case
DW_ATE_ALTIUM_fract
s_out
DW_ATE_ALTIUM_fract
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_ATE_lo_user
Skipping
alternate
spelling
of
value
DW_ATE_HP_float80
case
DW_ATE_ALTIUM_accum
s_out
DW_ATE_ALTIUM_accum
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_ATE_HP_complex_float80
case
DW_ATE_HP_float128
s_out
DW_ATE_HP_float128
return
DW_DLV_OK
case
DW_ATE_HP_complex_float128
s_out
DW_ATE_HP_complex_float128
return
DW_DLV_OK
case
DW_ATE_HP_floathpintel
s_out
DW_ATE_HP_floathpintel
return
DW_DLV_OK
case
DW_ATE_HP_imaginary_float80
s_out
DW_ATE_HP_imaginary_float80
return
DW_DLV_OK
case
DW_ATE_HP_imaginary_float128
s_out
DW_ATE_HP_imaginary_float128
return
DW_DLV_OK
case
DW_ATE_SUN_interval_float
s_out
DW_ATE_SUN_interval_float
return
DW_DLV_OK
case
DW_ATE_SUN_imaginary_float
s_out
DW_ATE_SUN_imaginary_float
return
DW_DLV_OK
case
DW_ATE_hi_user
s_out
DW_ATE_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DEFAULTED_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DEFAULTED_no
s_out
DW_DEFAULTED_no
return
DW_DLV_OK
case
DW_DEFAULTED_in_class
s_out
DW_DEFAULTED_in_class
return
DW_DLV_OK
case
DW_DEFAULTED_out_of_class
s_out
DW_DEFAULTED_out_of_class
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_IDX_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_IDX_compile_unit
s_out
DW_IDX_compile_unit
return
DW_DLV_OK
case
DW_IDX_type_unit
s_out
DW_IDX_type_unit
return
DW_DLV_OK
case
DW_IDX_die_offset
s_out
DW_IDX_die_offset
return
DW_DLV_OK
case
DW_IDX_parent
s_out
DW_IDX_parent
return
DW_DLV_OK
case
DW_IDX_type_hash
s_out
DW_IDX_type_hash
return
DW_DLV_OK
case
DW_IDX_hi_user
s_out
DW_IDX_hi_user
return
DW_DLV_OK
case
DW_IDX_lo_user
s_out
DW_IDX_lo_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LLEX_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LLEX_end_of_list_entry
s_out
DW_LLEX_end_of_list_entry
return
DW_DLV_OK
case
DW_LLEX_base_address_selection_entry
s_out
DW_LLEX_base_address_selection_entry
return
DW_DLV_OK
case
DW_LLEX_start_end_entry
s_out
DW_LLEX_start_end_entry
return
DW_DLV_OK
case
DW_LLEX_start_length_entry
s_out
DW_LLEX_start_length_entry
return
DW_DLV_OK
case
DW_LLEX_offset_pair_entry
s_out
DW_LLEX_offset_pair_entry
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LLE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LLE_end_of_list
s_out
DW_LLE_end_of_list
return
DW_DLV_OK
case
DW_LLE_base_addressx
s_out
DW_LLE_base_addressx
return
DW_DLV_OK
case
DW_LLE_startx_endx
s_out
DW_LLE_startx_endx
return
DW_DLV_OK
case
DW_LLE_startx_length
s_out
DW_LLE_startx_length
return
DW_DLV_OK
case
DW_LLE_offset_pair
s_out
DW_LLE_offset_pair
return
DW_DLV_OK
case
DW_LLE_default_location
s_out
DW_LLE_default_location
return
DW_DLV_OK
case
DW_LLE_base_address
s_out
DW_LLE_base_address
return
DW_DLV_OK
case
DW_LLE_start_end
s_out
DW_LLE_start_end
return
DW_DLV_OK
case
DW_LLE_start_length
s_out
DW_LLE_start_length
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_RLE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_RLE_end_of_list
s_out
DW_RLE_end_of_list
return
DW_DLV_OK
case
DW_RLE_base_addressx
s_out
DW_RLE_base_addressx
return
DW_DLV_OK
case
DW_RLE_startx_endx
s_out
DW_RLE_startx_endx
return
DW_DLV_OK
case
DW_RLE_startx_length
s_out
DW_RLE_startx_length
return
DW_DLV_OK
case
DW_RLE_offset_pair
s_out
DW_RLE_offset_pair
return
DW_DLV_OK
case
DW_RLE_base_address
s_out
DW_RLE_base_address
return
DW_DLV_OK
case
DW_RLE_start_end
s_out
DW_RLE_start_end
return
DW_DLV_OK
case
DW_RLE_start_length
s_out
DW_RLE_start_length
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_GNUIVIS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_GNUIVIS_global
s_out
DW_GNUIVIS_global
return
DW_DLV_OK
case
DW_GNUIVIS_static
s_out
DW_GNUIVIS_static
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_GNUIKIND_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_GNUIKIND_none
s_out
DW_GNUIKIND_none
return
DW_DLV_OK
case
DW_GNUIKIND_type
s_out
DW_GNUIKIND_type
return
DW_DLV_OK
case
DW_GNUIKIND_variable
s_out
DW_GNUIKIND_variable
return
DW_DLV_OK
case
DW_GNUIKIND_function
s_out
DW_GNUIKIND_function
return
DW_DLV_OK
case
DW_GNUIKIND_other
s_out
DW_GNUIKIND_other
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_UT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_UT_compile
s_out
DW_UT_compile
return
DW_DLV_OK
case
DW_UT_type
s_out
DW_UT_type
return
DW_DLV_OK
case
DW_UT_partial
s_out
DW_UT_partial
return
DW_DLV_OK
case
DW_UT_skeleton
s_out
DW_UT_skeleton
return
DW_DLV_OK
case
DW_UT_split_compile
s_out
DW_UT_split_compile
return
DW_DLV_OK
case
DW_UT_split_type
s_out
DW_UT_split_type
return
DW_DLV_OK
case
DW_UT_lo_user
s_out
DW_UT_lo_user
return
DW_DLV_OK
case
DW_UT_hi_user
s_out
DW_UT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_SECT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_SECT_INFO
s_out
DW_SECT_INFO
return
DW_DLV_OK
case
DW_SECT_TYPES
s_out
DW_SECT_TYPES
return
DW_DLV_OK
case
DW_SECT_ABBREV
s_out
DW_SECT_ABBREV
return
DW_DLV_OK
case
DW_SECT_LINE
s_out
DW_SECT_LINE
return
DW_DLV_OK
case
DW_SECT_LOCLISTS
s_out
DW_SECT_LOCLISTS
return
DW_DLV_OK
case
DW_SECT_STR_OFFSETS
s_out
DW_SECT_STR_OFFSETS
return
DW_DLV_OK
case
DW_SECT_MACRO
s_out
DW_SECT_MACRO
return
DW_DLV_OK
case
DW_SECT_RNGLISTS
s_out
DW_SECT_RNGLISTS
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DS_unsigned
s_out
DW_DS_unsigned
return
DW_DLV_OK
case
DW_DS_leading_overpunch
s_out
DW_DS_leading_overpunch
return
DW_DLV_OK
case
DW_DS_trailing_overpunch
s_out
DW_DS_trailing_overpunch
return
DW_DLV_OK
case
DW_DS_leading_separate
s_out
DW_DS_leading_separate
return
DW_DLV_OK
case
DW_DS_trailing_separate
s_out
DW_DS_trailing_separate
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_END_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_END_default
s_out
DW_END_default
return
DW_DLV_OK
case
DW_END_big
s_out
DW_END_big
return
DW_DLV_OK
case
DW_END_little
s_out
DW_END_little
return
DW_DLV_OK
case
DW_END_lo_user
s_out
DW_END_lo_user
return
DW_DLV_OK
case
DW_END_hi_user
s_out
DW_END_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ATCF_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ATCF_lo_user
s_out
DW_ATCF_lo_user
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_bitfield
s_out
DW_ATCF_SUN_mop_bitfield
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_spill
s_out
DW_ATCF_SUN_mop_spill
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_scopy
s_out
DW_ATCF_SUN_mop_scopy
return
DW_DLV_OK
case
DW_ATCF_SUN_func_start
s_out
DW_ATCF_SUN_func_start
return
DW_DLV_OK
case
DW_ATCF_SUN_end_ctors
s_out
DW_ATCF_SUN_end_ctors
return
DW_DLV_OK
case
DW_ATCF_SUN_branch_target
s_out
DW_ATCF_SUN_branch_target
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_stack_probe
s_out
DW_ATCF_SUN_mop_stack_probe
return
DW_DLV_OK
case
DW_ATCF_SUN_func_epilog
s_out
DW_ATCF_SUN_func_epilog
return
DW_DLV_OK
case
DW_ATCF_hi_user
s_out
DW_ATCF_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ACCESS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ACCESS_public
s_out
DW_ACCESS_public
return
DW_DLV_OK
case
DW_ACCESS_protected
s_out
DW_ACCESS_protected
return
DW_DLV_OK
case
DW_ACCESS_private
s_out
DW_ACCESS_private
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_VIS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_VIS_local
s_out
DW_VIS_local
return
DW_DLV_OK
case
DW_VIS_exported
s_out
DW_VIS_exported
return
DW_DLV_OK
case
DW_VIS_qualified
s_out
DW_VIS_qualified
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_VIRTUALITY_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_VIRTUALITY_none
s_out
DW_VIRTUALITY_none
return
DW_DLV_OK
case
DW_VIRTUALITY_virtual
s_out
DW_VIRTUALITY_virtual
return
DW_DLV_OK
case
DW_VIRTUALITY_pure_virtual
s_out
DW_VIRTUALITY_pure_virtual
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LANG_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LANG_C89
s_out
DW_LANG_C89
return
DW_DLV_OK
case
DW_LANG_C
s_out
DW_LANG_C
return
DW_DLV_OK
case
DW_LANG_Ada83
s_out
DW_LANG_Ada83
return
DW_DLV_OK
case
DW_LANG_C_plus_plus
s_out
DW_LANG_C_plus_plus
return
DW_DLV_OK
case
DW_LANG_Cobol74
s_out
DW_LANG_Cobol74
return
DW_DLV_OK
case
DW_LANG_Cobol85
s_out
DW_LANG_Cobol85
return
DW_DLV_OK
case
DW_LANG_Fortran77
s_out
DW_LANG_Fortran77
return
DW_DLV_OK
case
DW_LANG_Fortran90
s_out
DW_LANG_Fortran90
return
DW_DLV_OK
case
DW_LANG_Pascal83
s_out
DW_LANG_Pascal83
return
DW_DLV_OK
case
DW_LANG_Modula2
s_out
DW_LANG_Modula2
return
DW_DLV_OK
case
DW_LANG_Java
s_out
DW_LANG_Java
return
DW_DLV_OK
case
DW_LANG_C99
s_out
DW_LANG_C99
return
DW_DLV_OK
case
DW_LANG_Ada95
s_out
DW_LANG_Ada95
return
DW_DLV_OK
case
DW_LANG_Fortran95
s_out
DW_LANG_Fortran95
return
DW_DLV_OK
case
DW_LANG_PLI
s_out
DW_LANG_PLI
return
DW_DLV_OK
case
DW_LANG_ObjC
s_out
DW_LANG_ObjC
return
DW_DLV_OK
case
DW_LANG_ObjC_plus_plus
s_out
DW_LANG_ObjC_plus_plus
return
DW_DLV_OK
case
DW_LANG_UPC
s_out
DW_LANG_UPC
return
DW_DLV_OK
case
DW_LANG_D
s_out
DW_LANG_D
return
DW_DLV_OK
case
DW_LANG_Python
s_out
DW_LANG_Python
return
DW_DLV_OK
case
DW_LANG_OpenCL
s_out
DW_LANG_OpenCL
return
DW_DLV_OK
case
DW_LANG_Go
s_out
DW_LANG_Go
return
DW_DLV_OK
case
DW_LANG_Modula3
s_out
DW_LANG_Modula3
return
DW_DLV_OK
case
DW_LANG_Haskel
s_out
DW_LANG_Haskel
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_03
s_out
DW_LANG_C_plus_plus_03
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_11
s_out
DW_LANG_C_plus_plus_11
return
DW_DLV_OK
case
DW_LANG_OCaml
s_out
DW_LANG_OCaml
return
DW_DLV_OK
case
DW_LANG_Rust
s_out
DW_LANG_Rust
return
DW_DLV_OK
case
DW_LANG_C11
s_out
DW_LANG_C11
return
DW_DLV_OK
case
DW_LANG_Swift
s_out
DW_LANG_Swift
return
DW_DLV_OK
case
DW_LANG_Julia
s_out
DW_LANG_Julia
return
DW_DLV_OK
case
DW_LANG_Dylan
s_out
DW_LANG_Dylan
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_14
s_out
DW_LANG_C_plus_plus_14
return
DW_DLV_OK
case
DW_LANG_Fortran03
s_out
DW_LANG_Fortran03
return
DW_DLV_OK
case
DW_LANG_Fortran08
s_out
DW_LANG_Fortran08
return
DW_DLV_OK
case
DW_LANG_RenderScript
s_out
DW_LANG_RenderScript
return
DW_DLV_OK
case
DW_LANG_BLISS
s_out
DW_LANG_BLISS
return
DW_DLV_OK
case
DW_LANG_lo_user
s_out
DW_LANG_lo_user
return
DW_DLV_OK
case
DW_LANG_Mips_Assembler
s_out
DW_LANG_Mips_Assembler
return
DW_DLV_OK
case
DW_LANG_Upc
s_out
DW_LANG_Upc
return
DW_DLV_OK
case
DW_LANG_SUN_Assembler
s_out
DW_LANG_SUN_Assembler
return
DW_DLV_OK
case
DW_LANG_ALTIUM_Assembler
s_out
DW_LANG_ALTIUM_Assembler
return
DW_DLV_OK
case
DW_LANG_hi_user
s_out
DW_LANG_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ID_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ID_case_sensitive
s_out
DW_ID_case_sensitive
return
DW_DLV_OK
case
DW_ID_up_case
s_out
DW_ID_up_case
return
DW_DLV_OK
case
DW_ID_down_case
s_out
DW_ID_down_case
return
DW_DLV_OK
case
DW_ID_case_insensitive
s_out
DW_ID_case_insensitive
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CC_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CC_normal
s_out
DW_CC_normal
return
DW_DLV_OK
case
DW_CC_program
s_out
DW_CC_program
return
DW_DLV_OK
case
DW_CC_nocall
s_out
DW_CC_nocall
return
DW_DLV_OK
case
DW_CC_pass_by_reference
s_out
DW_CC_pass_by_reference
return
DW_DLV_OK
case
DW_CC_pass_by_value
s_out
DW_CC_pass_by_value
return
DW_DLV_OK
case
DW_CC_lo_user
s_out
DW_CC_lo_user
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CC_GNU_renesas_sh
case
DW_CC_GNU_borland_fastcall_i386
s_out
DW_CC_GNU_borland_fastcall_i386
return
DW_DLV_OK
case
DW_CC_ALTIUM_interrupt
s_out
DW_CC_ALTIUM_interrupt
return
DW_DLV_OK
case
DW_CC_ALTIUM_near_system_stack
s_out
DW_CC_ALTIUM_near_system_stack
return
DW_DLV_OK
case
DW_CC_ALTIUM_near_user_stack
s_out
DW_CC_ALTIUM_near_user_stack
return
DW_DLV_OK
case
DW_CC_ALTIUM_huge_user_stack
s_out
DW_CC_ALTIUM_huge_user_stack
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_safecall
s_out
DW_CC_GNU_BORLAND_safecall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_stdcall
s_out
DW_CC_GNU_BORLAND_stdcall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_pascal
s_out
DW_CC_GNU_BORLAND_pascal
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_msfastcall
s_out
DW_CC_GNU_BORLAND_msfastcall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_msreturn
s_out
DW_CC_GNU_BORLAND_msreturn
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_thiscall
s_out
DW_CC_GNU_BORLAND_thiscall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_fastcall
s_out
DW_CC_GNU_BORLAND_fastcall
return
DW_DLV_OK
case
DW_CC_LLVM_vectorcall
s_out
DW_CC_LLVM_vectorcall
return
DW_DLV_OK
case
DW_CC_LLVM_Win64
s_out
DW_CC_LLVM_Win64
return
DW_DLV_OK
case
DW_CC_LLVM_X86_64SysV
s_out
DW_CC_LLVM_X86_64SysV
return
DW_DLV_OK
case
DW_CC_LLVM_AAPCS
s_out
DW_CC_LLVM_AAPCS
return
DW_DLV_OK
case
DW_CC_LLVM_AAPCS_VFP
s_out
DW_CC_LLVM_AAPCS_VFP
return
DW_DLV_OK
case
DW_CC_LLVM_IntelOclBicc
s_out
DW_CC_LLVM_IntelOclBicc
return
DW_DLV_OK
case
DW_CC_LLVM_SpirFunction
s_out
DW_CC_LLVM_SpirFunction
return
DW_DLV_OK
case
DW_CC_LLVM_OpenCLKernel
s_out
DW_CC_LLVM_OpenCLKernel
return
DW_DLV_OK
case
DW_CC_LLVM_Swift
s_out
DW_CC_LLVM_Swift
return
DW_DLV_OK
case
DW_CC_LLVM_PreserveMost
s_out
DW_CC_LLVM_PreserveMost
return
DW_DLV_OK
case
DW_CC_LLVM_PreserveAll
s_out
DW_CC_LLVM_PreserveAll
return
DW_DLV_OK
case
DW_CC_LLVM_X86RegCall
s_out
DW_CC_LLVM_X86RegCall
return
DW_DLV_OK
case
DW_CC_GDB_IBM_OpenCL
s_out
DW_CC_GDB_IBM_OpenCL
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CC_hi_user
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_INL_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_INL_not_inlined
s_out
DW_INL_not_inlined
return
DW_DLV_OK
case
DW_INL_inlined
s_out
DW_INL_inlined
return
DW_DLV_OK
case
DW_INL_declared_not_inlined
s_out
DW_INL_declared_not_inlined
return
DW_DLV_OK
case
DW_INL_declared_inlined
s_out
DW_INL_declared_inlined
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ORD_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ORD_row_major
s_out
DW_ORD_row_major
return
DW_DLV_OK
case
DW_ORD_col_major
s_out
DW_ORD_col_major
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DSC_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DSC_label
s_out
DW_DSC_label
return
DW_DLV_OK
case
DW_DSC_range
s_out
DW_DSC_range
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNCT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNCT_path
s_out
DW_LNCT_path
return
DW_DLV_OK
case
DW_LNCT_directory_index
s_out
DW_LNCT_directory_index
return
DW_DLV_OK
case
DW_LNCT_timestamp
s_out
DW_LNCT_timestamp
return
DW_DLV_OK
case
DW_LNCT_size
s_out
DW_LNCT_size
return
DW_DLV_OK
case
DW_LNCT_MD5
s_out
DW_LNCT_MD5
return
DW_DLV_OK
case
DW_LNCT_GNU_subprogram_name
s_out
DW_LNCT_GNU_subprogram_name
return
DW_DLV_OK
case
DW_LNCT_GNU_decl_file
s_out
DW_LNCT_GNU_decl_file
return
DW_DLV_OK
case
DW_LNCT_GNU_decl_line
s_out
DW_LNCT_GNU_decl_line
return
DW_DLV_OK
case
DW_LNCT_lo_user
s_out
DW_LNCT_lo_user
return
DW_DLV_OK
case
DW_LNCT_LLVM_source
s_out
DW_LNCT_LLVM_source
return
DW_DLV_OK
case
DW_LNCT_hi_user
s_out
DW_LNCT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNS_copy
s_out
DW_LNS_copy
return
DW_DLV_OK
case
DW_LNS_advance_pc
s_out
DW_LNS_advance_pc
return
DW_DLV_OK
case
DW_LNS_advance_line
s_out
DW_LNS_advance_line
return
DW_DLV_OK
case
DW_LNS_set_file
s_out
DW_LNS_set_file
return
DW_DLV_OK
case
DW_LNS_set_column
s_out
DW_LNS_set_column
return
DW_DLV_OK
case
DW_LNS_negate_stmt
s_out
DW_LNS_negate_stmt
return
DW_DLV_OK
case
DW_LNS_set_basic_block
s_out
DW_LNS_set_basic_block
return
DW_DLV_OK
case
DW_LNS_const_add_pc
s_out
DW_LNS_const_add_pc
return
DW_DLV_OK
case
DW_LNS_fixed_advance_pc
s_out
DW_LNS_fixed_advance_pc
return
DW_DLV_OK
case
DW_LNS_set_prologue_end
s_out
DW_LNS_set_prologue_end
return
DW_DLV_OK
case
DW_LNS_set_epilogue_begin
s_out
DW_LNS_set_epilogue_begin
return
DW_DLV_OK
case
DW_LNS_set_isa
s_out
DW_LNS_set_isa
return
DW_DLV_OK
case
DW_LNS_set_address_from_logical
s_out
DW_LNS_set_address_from_logical
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_LNS_set_subprogram
case
DW_LNS_inlined_call
s_out
DW_LNS_inlined_call
return
DW_DLV_OK
case
DW_LNS_pop_context
s_out
DW_LNS_pop_context
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNE_end_sequence
s_out
DW_LNE_end_sequence
return
DW_DLV_OK
case
DW_LNE_set_address
s_out
DW_LNE_set_address
return
DW_DLV_OK
case
DW_LNE_define_file
s_out
DW_LNE_define_file
return
DW_DLV_OK
case
DW_LNE_set_discriminator
s_out
DW_LNE_set_discriminator
return
DW_DLV_OK
case
DW_LNE_HP_negate_is_UV_update
s_out
DW_LNE_HP_negate_is_UV_update
return
DW_DLV_OK
case
DW_LNE_HP_push_context
s_out
DW_LNE_HP_push_context
return
DW_DLV_OK
case
DW_LNE_HP_pop_context
s_out
DW_LNE_HP_pop_context
return
DW_DLV_OK
case
DW_LNE_HP_set_file_line_column
s_out
DW_LNE_HP_set_file_line_column
return
DW_DLV_OK
case
DW_LNE_HP_set_routine_name
s_out
DW_LNE_HP_set_routine_name
return
DW_DLV_OK
case
DW_LNE_HP_set_sequence
s_out
DW_LNE_HP_set_sequence
return
DW_DLV_OK
case
DW_LNE_HP_negate_post_semantics
s_out
DW_LNE_HP_negate_post_semantics
return
DW_DLV_OK
case
DW_LNE_HP_negate_function_exit
s_out
DW_LNE_HP_negate_function_exit
return
DW_DLV_OK
case
DW_LNE_HP_negate_front_end_logical
s_out
DW_LNE_HP_negate_front_end_logical
return
DW_DLV_OK
case
DW_LNE_HP_define_proc
s_out
DW_LNE_HP_define_proc
return
DW_DLV_OK
case
DW_LNE_HP_source_file_correlation
s_out
DW_LNE_HP_source_file_correlation
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_LNE_lo_user
case
DW_LNE_hi_user
s_out
DW_LNE_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ISA_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ISA_UNKNOWN
s_out
DW_ISA_UNKNOWN
return
DW_DLV_OK
case
DW_ISA_ARM_thumb
s_out
DW_ISA_ARM_thumb
return
DW_DLV_OK
case
DW_ISA_ARM_arm
s_out
DW_ISA_ARM_arm
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_MACRO_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_MACRO_define
s_out
DW_MACRO_define
return
DW_DLV_OK
case
DW_MACRO_undef
s_out
DW_MACRO_undef
return
DW_DLV_OK
case
DW_MACRO_start_file
s_out
DW_MACRO_start_file
return
DW_DLV_OK
case
DW_MACRO_end_file
s_out
DW_MACRO_end_file
return
DW_DLV_OK
case
DW_MACRO_define_strp
s_out
DW_MACRO_define_strp
return
DW_DLV_OK
case
DW_MACRO_undef_strp
s_out
DW_MACRO_undef_strp
return
DW_DLV_OK
case
DW_MACRO_import
s_out
DW_MACRO_import
return
DW_DLV_OK
case
DW_MACRO_define_sup
s_out
DW_MACRO_define_sup
return
DW_DLV_OK
case
DW_MACRO_undef_sup
s_out
DW_MACRO_undef_sup
return
DW_DLV_OK
case
DW_MACRO_import_sup
s_out
DW_MACRO_import_sup
return
DW_DLV_OK
case
DW_MACRO_define_strx
s_out
DW_MACRO_define_strx
return
DW_DLV_OK
case
DW_MACRO_undef_strx
s_out
DW_MACRO_undef_strx
return
DW_DLV_OK
case
DW_MACRO_lo_user
s_out
DW_MACRO_lo_user
return
DW_DLV_OK
case
DW_MACRO_hi_user
s_out
DW_MACRO_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_MACINFO_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_MACINFO_define
s_out
DW_MACINFO_define
return
DW_DLV_OK
case
DW_MACINFO_undef
s_out
DW_MACINFO_undef
return
DW_DLV_OK
case
DW_MACINFO_start_file
s_out
DW_MACINFO_start_file
return
DW_DLV_OK
case
DW_MACINFO_end_file
s_out
DW_MACINFO_end_file
return
DW_DLV_OK
case
DW_MACINFO_vendor_ext
s_out
DW_MACINFO_vendor_ext
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CFA_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CFA_extended
s_out
DW_CFA_extended
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_nop
case
DW_CFA_set_loc
s_out
DW_CFA_set_loc
return
DW_DLV_OK
case
DW_CFA_advance_loc1
s_out
DW_CFA_advance_loc1
return
DW_DLV_OK
case
DW_CFA_advance_loc2
s_out
DW_CFA_advance_loc2
return
DW_DLV_OK
case
DW_CFA_advance_loc4
s_out
DW_CFA_advance_loc4
return
DW_DLV_OK
case
DW_CFA_offset_extended
s_out
DW_CFA_offset_extended
return
DW_DLV_OK
case
DW_CFA_restore_extended
s_out
DW_CFA_restore_extended
return
DW_DLV_OK
case
DW_CFA_undefined
s_out
DW_CFA_undefined
return
DW_DLV_OK
case
DW_CFA_same_value
s_out
DW_CFA_same_value
return
DW_DLV_OK
case
DW_CFA_register
s_out
DW_CFA_register
return
DW_DLV_OK
case
DW_CFA_remember_state
s_out
DW_CFA_remember_state
return
DW_DLV_OK
case
DW_CFA_restore_state
s_out
DW_CFA_restore_state
return
DW_DLV_OK
case
DW_CFA_def_cfa
s_out
DW_CFA_def_cfa
return
DW_DLV_OK
case
DW_CFA_def_cfa_register
s_out
DW_CFA_def_cfa_register
return
DW_DLV_OK
case
DW_CFA_def_cfa_offset
s_out
DW_CFA_def_cfa_offset
return
DW_DLV_OK
case
DW_CFA_def_cfa_expression
s_out
DW_CFA_def_cfa_expression
return
DW_DLV_OK
case
DW_CFA_expression
s_out
DW_CFA_expression
return
DW_DLV_OK
case
DW_CFA_offset_extended_sf
s_out
DW_CFA_offset_extended_sf
return
DW_DLV_OK
case
DW_CFA_def_cfa_sf
s_out
DW_CFA_def_cfa_sf
return
DW_DLV_OK
case
DW_CFA_def_cfa_offset_sf
s_out
DW_CFA_def_cfa_offset_sf
return
DW_DLV_OK
case
DW_CFA_val_offset
s_out
DW_CFA_val_offset
return
DW_DLV_OK
case
DW_CFA_val_offset_sf
s_out
DW_CFA_val_offset_sf
return
DW_DLV_OK
case
DW_CFA_val_expression
s_out
DW_CFA_val_expression
return
DW_DLV_OK
case
DW_CFA_lo_user
s_out
DW_CFA_lo_user
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_low_user
case
DW_CFA_MIPS_advance_loc8
s_out
DW_CFA_MIPS_advance_loc8
return
DW_DLV_OK
case
DW_CFA_GNU_window_save
s_out
DW_CFA_GNU_window_save
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_AARCH64_negate_ra_state
case
DW_CFA_GNU_args_size
s_out
DW_CFA_GNU_args_size
return
DW_DLV_OK
case
DW_CFA_GNU_negative_offset_extended
s_out
DW_CFA_GNU_negative_offset_extended
return
DW_DLV_OK
case
DW_CFA_METAWARE_info
s_out
DW_CFA_METAWARE_info
return
DW_DLV_OK
case
DW_CFA_high_user
s_out
DW_CFA_high_user
return
DW_DLV_OK
case
DW_CFA_advance_loc
s_out
DW_CFA_advance_loc
return
DW_DLV_OK
case
DW_CFA_offset
s_out
DW_CFA_offset
return
DW_DLV_OK
case
DW_CFA_restore
s_out
DW_CFA_restore
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_EH_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_EH_PE_absptr
s_out
DW_EH_PE_absptr
return
DW_DLV_OK
case
DW_EH_PE_uleb128
s_out
DW_EH_PE_uleb128
return
DW_DLV_OK
case
DW_EH_PE_udata2
s_out
DW_EH_PE_udata2
return
DW_DLV_OK
case
DW_EH_PE_udata4
s_out
DW_EH_PE_udata4
return
DW_DLV_OK
case
DW_EH_PE_udata8
s_out
DW_EH_PE_udata8
return
DW_DLV_OK
case
DW_EH_PE_sleb128
s_out
DW_EH_PE_sleb128
return
DW_DLV_OK
case
DW_EH_PE_sdata2
s_out
DW_EH_PE_sdata2
return
DW_DLV_OK
case
DW_EH_PE_sdata4
s_out
DW_EH_PE_sdata4
return
DW_DLV_OK
case
DW_EH_PE_sdata8
s_out
DW_EH_PE_sdata8
return
DW_DLV_OK
case
DW_EH_PE_pcrel
s_out
DW_EH_PE_pcrel
return
DW_DLV_OK
case
DW_EH_PE_textrel
s_out
DW_EH_PE_textrel
return
DW_DLV_OK
case
DW_EH_PE_datarel
s_out
DW_EH_PE_datarel
return
DW_DLV_OK
case
DW_EH_PE_funcrel
s_out
DW_EH_PE_funcrel
return
DW_DLV_OK
case
DW_EH_PE_aligned
s_out
DW_EH_PE_aligned
return
DW_DLV_OK
case
DW_EH_PE_omit
s_out
DW_EH_PE_omit
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_FRAME_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_FRAME_CFA_COL
s_out
DW_FRAME_CFA_COL
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_FRAME_LAST_REG_NUM
Skipping
alternate
spelling
of
value
DW_FRAME_RA_COL
Skipping
alternate
spelling
of
value
DW_FRAME_STATIC_LINK
case
DW_FRAME_REG1
s_out
DW_FRAME_REG1
return
DW_DLV_OK
case
DW_FRAME_REG2
s_out
DW_FRAME_REG2
return
DW_DLV_OK
case
DW_FRAME_REG3
s_out
DW_FRAME_REG3
return
DW_DLV_OK
case
DW_FRAME_REG4
s_out
DW_FRAME_REG4
return
DW_DLV_OK
case
DW_FRAME_REG5
s_out
DW_FRAME_REG5
return
DW_DLV_OK
case
DW_FRAME_REG6
s_out
DW_FRAME_REG6
return
DW_DLV_OK
case
DW_FRAME_REG7
s_out
DW_FRAME_REG7
return
DW_DLV_OK
case
DW_FRAME_REG8
s_out
DW_FRAME_REG8
return
DW_DLV_OK
case
DW_FRAME_REG9
s_out
DW_FRAME_REG9
return
DW_DLV_OK
case
DW_FRAME_REG10
s_out
DW_FRAME_REG10
return
DW_DLV_OK
case
DW_FRAME_REG11
s_out
DW_FRAME_REG11
return
DW_DLV_OK
case
DW_FRAME_REG12
s_out
DW_FRAME_REG12
return
DW_DLV_OK
case
DW_FRAME_REG13
s_out
DW_FRAME_REG13
return
DW_DLV_OK
case
DW_FRAME_REG14
s_out
DW_FRAME_REG14
return
DW_DLV_OK
case
DW_FRAME_REG15
s_out
DW_FRAME_REG15
return
DW_DLV_OK
case
DW_FRAME_REG16
s_out
DW_FRAME_REG16
return
DW_DLV_OK
case
DW_FRAME_REG17
s_out
DW_FRAME_REG17
return
DW_DLV_OK
case
DW_FRAME_REG18
s_out
DW_FRAME_REG18
return
DW_DLV_OK
case
DW_FRAME_REG19
s_out
DW_FRAME_REG19
return
DW_DLV_OK
case
DW_FRAME_REG20
s_out
DW_FRAME_REG20
return
DW_DLV_OK
case
DW_FRAME_REG21
s_out
DW_FRAME_REG21
return
DW_DLV_OK
case
DW_FRAME_REG22
s_out
DW_FRAME_REG22
return
DW_DLV_OK
case
DW_FRAME_REG23
s_out
DW_FRAME_REG23
return
DW_DLV_OK
case
DW_FRAME_REG24
s_out
DW_FRAME_REG24
return
DW_DLV_OK
case
DW_FRAME_REG25
s_out
DW_FRAME_REG25
return
DW_DLV_OK
case
DW_FRAME_REG26
s_out
DW_FRAME_REG26
return
DW_DLV_OK
case
DW_FRAME_REG27
s_out
DW_FRAME_REG27
return
DW_DLV_OK
case
DW_FRAME_REG28
s_out
DW_FRAME_REG28
return
DW_DLV_OK
case
DW_FRAME_REG29
s_out
DW_FRAME_REG29
return
DW_DLV_OK
case
DW_FRAME_REG30
s_out
DW_FRAME_REG30
return
DW_DLV_OK
case
DW_FRAME_REG31
s_out
DW_FRAME_REG31
return
DW_DLV_OK
case
DW_FRAME_FREG0
s_out
DW_FRAME_FREG0
return
DW_DLV_OK
case
DW_FRAME_FREG1
s_out
DW_FRAME_FREG1
return
DW_DLV_OK
case
DW_FRAME_FREG2
s_out
DW_FRAME_FREG2
return
DW_DLV_OK
case
DW_FRAME_FREG3
s_out
DW_FRAME_FREG3
return
DW_DLV_OK
case
DW_FRAME_FREG4
s_out
DW_FRAME_FREG4
return
DW_DLV_OK
case
DW_FRAME_FREG5
s_out
DW_FRAME_FREG5
return
DW_DLV_OK
case
DW_FRAME_FREG6
s_out
DW_FRAME_FREG6
return
DW_DLV_OK
case
DW_FRAME_FREG7
s_out
DW_FRAME_FREG7
return
DW_DLV_OK
case
DW_FRAME_FREG8
s_out
DW_FRAME_FREG8
return
DW_DLV_OK
case
DW_FRAME_FREG9
s_out
DW_FRAME_FREG9
return
DW_DLV_OK
case
DW_FRAME_FREG10
s_out
DW_FRAME_FREG10
return
DW_DLV_OK
case
DW_FRAME_FREG11
s_out
DW_FRAME_FREG11
return
DW_DLV_OK
case
DW_FRAME_FREG12
s_out
DW_FRAME_FREG12
return
DW_DLV_OK
case
DW_FRAME_FREG13
s_out
DW_FRAME_FREG13
return
DW_DLV_OK
case
DW_FRAME_FREG14
s_out
DW_FRAME_FREG14
return
DW_DLV_OK
case
DW_FRAME_FREG15
s_out
DW_FRAME_FREG15
return
DW_DLV_OK
case
DW_FRAME_FREG16
s_out
DW_FRAME_FREG16
return
DW_DLV_OK
case
DW_FRAME_FREG17
s_out
DW_FRAME_FREG17
return
DW_DLV_OK
case
DW_FRAME_FREG18
s_out
DW_FRAME_FREG18
return
DW_DLV_OK
case
DW_FRAME_FREG19
s_out
DW_FRAME_FREG19
return
DW_DLV_OK
case
DW_FRAME_FREG20
s_out
DW_FRAME_FREG20
return
DW_DLV_OK
case
DW_FRAME_FREG21
s_out
DW_FRAME_FREG21
return
DW_DLV_OK
case
DW_FRAME_FREG22
s_out
DW_FRAME_FREG22
return
DW_DLV_OK
case
DW_FRAME_FREG23
s_out
DW_FRAME_FREG23
return
DW_DLV_OK
case
DW_FRAME_FREG24
s_out
DW_FRAME_FREG24
return
DW_DLV_OK
case
DW_FRAME_FREG25
s_out
DW_FRAME_FREG25
return
DW_DLV_OK
case
DW_FRAME_FREG26
s_out
DW_FRAME_FREG26
return
DW_DLV_OK
case
DW_FRAME_FREG27
s_out
DW_FRAME_FREG27
return
DW_DLV_OK
case
DW_FRAME_FREG28
s_out
DW_FRAME_FREG28
return
DW_DLV_OK
case
DW_FRAME_FREG29
s_out
DW_FRAME_FREG29
return
DW_DLV_OK
case
DW_FRAME_FREG30
s_out
DW_FRAME_FREG30
return
DW_DLV_OK
case
DW_FRAME_FREG31
s_out
DW_FRAME_FREG31
return
DW_DLV_OK
case
DW_FRAME_FREG32
s_out
DW_FRAME_FREG32
return
DW_DLV_OK
case
DW_FRAME_FREG33
s_out
DW_FRAME_FREG33
return
DW_DLV_OK
case
DW_FRAME_FREG34
s_out
DW_FRAME_FREG34
return
DW_DLV_OK
case
DW_FRAME_FREG35
s_out
DW_FRAME_FREG35
return
DW_DLV_OK
case
DW_FRAME_FREG36
s_out
DW_FRAME_FREG36
return
DW_DLV_OK
case
DW_FRAME_FREG37
s_out
DW_FRAME_FREG37
return
DW_DLV_OK
case
DW_FRAME_FREG38
s_out
DW_FRAME_FREG38
return
DW_DLV_OK
case
DW_FRAME_FREG39
s_out
DW_FRAME_FREG39
return
DW_DLV_OK
case
DW_FRAME_FREG40
s_out
DW_FRAME_FREG40
return
DW_DLV_OK
case
DW_FRAME_FREG41
s_out
DW_FRAME_FREG41
return
DW_DLV_OK
case
DW_FRAME_FREG42
s_out
DW_FRAME_FREG42
return
DW_DLV_OK
case
DW_FRAME_FREG43
s_out
DW_FRAME_FREG43
return
DW_DLV_OK
case
DW_FRAME_FREG44
s_out
DW_FRAME_FREG44
return
DW_DLV_OK
case
DW_FRAME_FREG45
s_out
DW_FRAME_FREG45
return
DW_DLV_OK
case
DW_FRAME_FREG46
s_out
DW_FRAME_FREG46
return
DW_DLV_OK
case
DW_FRAME_FREG47
s_out
DW_FRAME_FREG47
return
DW_DLV_OK
case
DW_FRAME_FREG48
s_out
DW_FRAME_FREG48
return
DW_DLV_OK
case
DW_FRAME_FREG49
s_out
DW_FRAME_FREG49
return
DW_DLV_OK
case
DW_FRAME_FREG50
s_out
DW_FRAME_FREG50
return
DW_DLV_OK
case
DW_FRAME_FREG51
s_out
DW_FRAME_FREG51
return
DW_DLV_OK
case
DW_FRAME_FREG52
s_out
DW_FRAME_FREG52
return
DW_DLV_OK
case
DW_FRAME_FREG53
s_out
DW_FRAME_FREG53
return
DW_DLV_OK
case
DW_FRAME_FREG54
s_out
DW_FRAME_FREG54
return
DW_DLV_OK
case
DW_FRAME_FREG55
s_out
DW_FRAME_FREG55
return
DW_DLV_OK
case
DW_FRAME_FREG56
s_out
DW_FRAME_FREG56
return
DW_DLV_OK
case
DW_FRAME_FREG57
s_out
DW_FRAME_FREG57
return
DW_DLV_OK
case
DW_FRAME_FREG58
s_out
DW_FRAME_FREG58
return
DW_DLV_OK
case
DW_FRAME_FREG59
s_out
DW_FRAME_FREG59
return
DW_DLV_OK
case
DW_FRAME_FREG60
s_out
DW_FRAME_FREG60
return
DW_DLV_OK
case
DW_FRAME_FREG61
s_out
DW_FRAME_FREG61
return
DW_DLV_OK
case
DW_FRAME_FREG62
s_out
DW_FRAME_FREG62
return
DW_DLV_OK
case
DW_FRAME_FREG63
s_out
DW_FRAME_FREG63
return
DW_DLV_OK
case
DW_FRAME_FREG64
s_out
DW_FRAME_FREG64
return
DW_DLV_OK
case
DW_FRAME_FREG65
s_out
DW_FRAME_FREG65
return
DW_DLV_OK
case
DW_FRAME_FREG66
s_out
DW_FRAME_FREG66
return
DW_DLV_OK
case
DW_FRAME_FREG67
s_out
DW_FRAME_FREG67
return
DW_DLV_OK
case
DW_FRAME_FREG68
s_out
DW_FRAME_FREG68
return
DW_DLV_OK
case
DW_FRAME_FREG69
s_out
DW_FRAME_FREG69
return
DW_DLV_OK
case
DW_FRAME_FREG70
s_out
DW_FRAME_FREG70
return
DW_DLV_OK
case
DW_FRAME_FREG71
s_out
DW_FRAME_FREG71
return
DW_DLV_OK
case
DW_FRAME_FREG72
s_out
DW_FRAME_FREG72
return
DW_DLV_OK
case
DW_FRAME_FREG73
s_out
DW_FRAME_FREG73
return
DW_DLV_OK
case
DW_FRAME_FREG74
s_out
DW_FRAME_FREG74
return
DW_DLV_OK
case
DW_FRAME_FREG75
s_out
DW_FRAME_FREG75
return
DW_DLV_OK
case
DW_FRAME_FREG76
s_out
DW_FRAME_FREG76
return
DW_DLV_OK
case
DW_FRAME_HIGHEST_NORMAL_REGISTER
s_out
DW_FRAME_HIGHEST_NORMAL_REGISTER
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CHILDREN_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CHILDREN_no
s_out
DW_CHILDREN_no
return
DW_DLV_OK
case
DW_CHILDREN_yes
s_out
DW_CHILDREN_yes
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ADDR_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ADDR_none
s_out
DW_ADDR_none
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
END
FILE
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
stdio
h
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
O_RDONLY
ifdef
_WIN32
include
windows
h
include
io
h
lseek
read
close
typedef
SSIZE_T
ssize_t
MSVC
does
not
have
POSIX
ssize_t
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
ifdef
HAVE_STRING_H
include
string
h
memcpy
strcpy
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
free
endif
HAVE_STDLIB_H
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf_private
h
include
dwarf
h
include
libdwarf
h
include
dwarf_base_types
h
include
dwarf_opaque
h
include
memcpy_swap
h
include
dwarf_object_read_common
h
include
dwarf_object_detector
h
include
dwarfstring
h
ifndef
O_BINARY
define
O_BINARY
endif
O_BINARY
ifndef
O_RDONLY
define
O_RDONLY
endif
TYP
SIZEOFT32
and
ASNAR
mean
we
can
use
correctly
sized
arrays
of
char
for
the
struct
members
instead
of
determining
a
proper
integer
that
size
We
are
dealing
with
carefully
constructed
structs
that
do
not
have
any
alignment
forced
hidden
unused
bytes
so
reading
lengths
from
the
real
structs
works
for
each
variable
define
TYP
n
l
char
n
l
define
SIZEOFT32
define
DW_DLV_NO_ENTRY
define
DW_DLV_OK
define
DW_DLV_ERROR
ifndef
EI_NIDENT
define
EI_NIDENT
define
EI_CLASS
define
EI_DATA
define
EI_VERSION
define
ELFCLASS32
define
ELFCLASS64
define
ELFDATA2LSB
define
ELFDATA2MSB
endif
EI_NIDENT
define
DSYM_SUFFIX
dSYM
Contents
Resources
DWARF
define
PATHSIZE
ifndef
MH_MAGIC
mach
o
define
MH_MAGIC
define
MH_CIGAM
endif
MH_MAGIC
ifndef
MH_MAGIC_64
mach
o
define
MH_MAGIC_64
define
MH_CIGAM_64
endif
MH_MAGIC_64
if
TESTING
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
if
start
printf
s
ptr
null
ignore
n
msg
return
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
static
unsigned
long
magic_copy
unsigned
char
d
unsigned
len
unsigned
i
unsigned
long
v
v
d
for
i
i
len
i
v
v
d
i
return
v
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
define
EI_NIDENT
An
incomplete
elf
header
good
for
and
elf
struct
elf_header
unsigned
char
e_ident
EI_NIDENT
TYP
e_type
TYP
e_machine
TYP
e_version
Windows
Certain
PE
objects
The
following
references
may
be
of
interest
https
msdn
microsoft
com
library
windows
desktop
ms680547
v
vs
aspx
PE
format
overview
and
various
machine
magic
numbers
https
msdn
microsoft
com
en
us
library
ms809762
aspx
describes
some
details
of
PE
headers
basically
an
overview
https
msdn
microsoft
com
en
us
library
windows
desktop
aa383751
v
vs
aspx
defines
sizes
of
various
types
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680313
v
vs
aspx
defines
IMAGE_FILE_HEADER
and
Machine
fields
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680305
v
vs
aspx
defines
IMAGE_DATA_DIRECTORY
https
msdn
microsoft
com
en
us
library
windows
desktop
ms680339
v
vs
aspx
Defines
IMAGE_OPTIONAL_HEADER
and
some
magic
numbers
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680336
v
vs
aspx
defines
_IMAGE_NT_HEADERS
https
msdn
microsoft
com
en
us
library
windows
desktop
ms680341
v
vs
aspx
defines
_IMAGE_SECTION_HEADER
START
pe
structures
struct
dos_header
TYP
dh_mz
TYP
dh_dos_data
TYP
dh_image_offset
define
IMAGE_DOS_SIGNATURE_dw
define
IMAGE_DOS_REVSIGNATURE_dw
define
IMAGE_NT_SIGNATURE_dw
define
IMAGE_FILE_MACHINE_I386_dw
define
IMAGE_FILE_MACHINE_IA64_dw
define
IMAGE_FILE_MACHINE_AMD64_dw
struct
pe_image_file_header
TYP
im_machine
TYP
im_sectioncount
TYP
im_ignoring
TYP
im_opt_header_size
TYP
im_ignoringb
END
pe
structures
For
following
MacOS
file
naming
convention
static
const
char
getseparator
const
char
f
const
char
p
const
char
q
char
c
p
NULL
q
f
do
c
q
if
c
c
c
p
q
while
c
return
p
static
const
char
getbasename
const
char
f
const
char
pseparator
getseparator
f
if
pseparator
return
f
return
pseparator
Not
a
standard
function
static
int
dw_stpcpy
char
dest
const
char
src
char
destend
char
endpoint
const
char
cp
src
char
dp
dest
for
cp
cp
dp
if
dp
endpoint
return
DW_DLV_ERROR
dp
cp
if
dp
endpoint
return
DW_DLV_ERROR
dp
destend
dp
return
DW_DLV_OK
This
started
like
Elf
so
check
initial
fields
static
int
fill_in_elf_fields
struct
elf_header
h
unsigned
endian
Size
of
the
object
file
offsets
not
DWARF
offset
size
unsigned
objoffsetsize
int
errcode
unsigned
locendian
unsigned
locoffsetsize
switch
h
e_ident
EI_CLASS
case
ELFCLASS32
locoffsetsize
break
case
ELFCLASS64
locoffsetsize
break
default
errcode
DW_DLE_ELF_CLASS_BAD
return
DW_DLV_ERROR
switch
h
e_ident
EI_DATA
case
ELFDATA2LSB
locendian
DW_ENDIAN_LITTLE
break
case
ELFDATA2MSB
locendian
DW_ENDIAN_BIG
break
default
errcode
DW_DLE_ELF_ENDIAN_BAD
return
DW_DLV_ERROR
if
h
e_ident
EI_VERSION
EV_CURRENT
errcode
DW_DLE_ELF_VERSION_BAD
return
DW_DLV_ERROR
endian
locendian
objoffsetsize
locoffsetsize
return
DW_DLV_OK
static
char
archive_magic
a
r
c
h
static
int
is_archive_magic
struct
elf_header
h
int
i
int
len
sizeof
archive_magic
const
char
cp
const
char
h
for
i
len
i
if
cp
i
archive_magic
i
return
FALSE
return
TRUE
A
bit
unusual
in
that
it
always
sets
is_pe_flag
Return
of
DW_DLV_OK
it
is
a
PE
file
we
recognize
static
int
is_pe_object
int
fd
unsigned
long
filesize
unsigned
endian
unsigned
offsetsize
int
errcode
unsigned
dos_sig
unsigned
locendian
void
word_swap
void
const
void
unsigned
long
unsigned
long
nt_address
struct
dos_header
dhinmem
char
nt_sig_array
unsigned
long
nt_sig
struct
pe_image_file_header
ifh
int
res
if
filesize
sizeof
struct
dos_header
SIZEOFT32
sizeof
struct
pe_image_file_header
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
fd
char
sizeof
dhinmem
filesize
errcode
if
res
DW_DLV_OK
return
res
No
swap
here
want
it
as
in
the
file
dos_sig
magic_copy
unsigned
char
dhinmem
dh_mz
sizeof
dhinmem
dh_mz
if
dos_sig
IMAGE_DOS_SIGNATURE_dw
IMAGE_DOS_SIGNATURE_dw
assumes
bytes
reversed
by
little
endian
load
so
we
intrepet
a
match
the
other
way
BIG
ENDIAN
From
looking
at
hex
characters
in
object
ifdef
WORDS_BIGENDIAN
word_swap
_dwarf_memcpy_noswap_bytes
else
LITTLE
ENDIAN
word_swap
_dwarf_memcpy_swap_bytes
endif
LITTLE
BIG
ENDIAN
locendian
DW_ENDIAN_BIG
else
if
dos_sig
IMAGE_DOS_REVSIGNATURE_dw
raw
load
so
intrepet
a
match
the
other
way
LITTLE
ENDIAN
ifdef
WORDS_BIGENDIAN
word_swap
_dwarf_memcpy_swap_bytes
else
LITTLE
ENDIAN
word_swap
_dwarf_memcpy_noswap_bytes
endif
LITTLE
BIG
ENDIAN
locendian
DW_ENDIAN_LITTLE
else
Not
dos
header
not
a
PE
file
we
recognize
errcode
DW_DLE_FILE_WRONG_TYPE
return
DW_DLV_ERROR
ASNAR
word_swap
nt_address
dhinmem
dh_image_offset
if
filesize
nt_address
Not
dos
header
not
a
PE
file
we
recognize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
if
filesize
nt_address
SIZEOFT32
sizeof
struct
pe_image_file_header
errcode
DW_DLE_FILE_TOO_SMALL
Not
dos
header
not
a
PE
file
we
recognize
return
DW_DLV_ERROR
res
_dwarf_object_read_random
fd
char
nt_address
sizeof
nt_sig_array
filesize
errcode
if
res
DW_DLV_OK
return
res
unsigned
long
lsig
ASNAR
word_swap
lsig
nt_sig_array
nt_sig
lsig
if
nt_sig
IMAGE_NT_SIGNATURE_dw
errcode
DW_DLE_FILE_WRONG_TYPE
return
DW_DLV_ERROR
res
_dwarf_object_read_random
fd
char
nt_address
SIZEOFT32
sizeof
struct
pe_image_file_header
filesize
errcode
if
res
DW_DLV_OK
return
res
unsigned
long
machine
ASNAR
word_swap
machine
ifh
im_machine
switch
machine
case
IMAGE_FILE_MACHINE_I386_dw
offsetsize
endian
locendian
return
DW_DLV_OK
case
IMAGE_FILE_MACHINE_IA64_dw
case
IMAGE_FILE_MACHINE_AMD64_dw
offsetsize
endian
locendian
return
DW_DLV_OK
errcode
DW_DLE_IMAGE_FILE_UNKNOWN_TYPE
return
DW_DLV_ERROR
static
int
is_mach_o_magic
struct
elf_header
h
unsigned
endian
unsigned
offsetsize
unsigned
long
magicval
unsigned
locendian
unsigned
locoffsetsize
No
swapping
here
Need
to
match
size
of
Mach
o
magic
field
magicval
magic_copy
h
e_ident
if
magicval
MH_MAGIC
locendian
DW_ENDIAN_BIG
locoffsetsize
else
if
magicval
MH_CIGAM
locendian
DW_ENDIAN_LITTLE
locoffsetsize
else
if
magicval
MH_MAGIC_64
locendian
DW_ENDIAN_BIG
locoffsetsize
else
if
magicval
MH_CIGAM_64
locendian
DW_ENDIAN_LITTLE
locoffsetsize
else
return
FALSE
endian
locendian
offsetsize
locoffsetsize
return
TRUE
int
dwarf_object_detector_fd
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
errcode
struct
elf_header
h
size_t
readlen
sizeof
h
int
res
off_t
fsize
off_t
lsval
ssize_t
readval
fsize
lseek
fd
SEEK_END
if
fsize
errcode
DW_DLE_SEEK_ERROR
return
DW_DLV_ERROR
if
fsize
off_t
readlen
Not
a
real
object
file
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
lsval
lseek
fd
SEEK_SET
if
lsval
errcode
DW_DLE_SEEK_ERROR
return
DW_DLV_ERROR
readval
read
fd
readlen
if
readval
ssize_t
readlen
errcode
DW_DLE_READ_ERROR
return
DW_DLV_ERROR
if
h
e_ident
h
e_ident
E
h
e_ident
L
h
e_ident
F
is
ELF
res
fill_in_elf_fields
endian
offsetsize
errcode
if
res
DW_DLV_OK
return
res
ftype
DW_FTYPE_ELF
filesize
size_t
fsize
return
DW_DLV_OK
if
is_mach_o_magic
endian
offsetsize
ftype
DW_FTYPE_MACH_O
filesize
size_t
fsize
return
DW_DLV_OK
if
is_archive_magic
ftype
DW_FTYPE_ARCHIVE
filesize
size_t
fsize
return
DW_DLV_OK
res
is_pe_object
fd
fsize
endian
offsetsize
errcode
if
res
DW_DLV_OK
ftype
DW_FTYPE_PE
filesize
size_t
fsize
return
DW_DLV_OK
Unknown
object
format
return
DW_DLV_NO_ENTRY
int
dwarf_object_detector_path_dSYM
const
char
path
char
outpath
unsigned
long
outpath_len
UNUSEDARG
char
gl_pathnames
UNUSEDARG
unsigned
gl_pathcount
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
char
cp
size_t
plen
strlen
path
size_t
dsprefixlen
sizeof
DSYM_SUFFIX
int
fd
int
res
int
have_outpath
outpath
outpath_len
if
have_outpath
Looking
for
MacOS
dSYM
if
plen
dsprefixlen
outpath_len
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
res
dw_stpcpy
outpath
path
outpath
outpath_len
if
res
DW_DLV_ERROR
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
res
dw_stpcpy
cp
DSYM_SUFFIX
outpath
outpath_len
if
res
DW_DLV_ERROR
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
res
dw_stpcpy
cp
getbasename
path
outpath
outpath_len
if
res
DW_DLV_ERROR
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
fd
open
outpath
O_RDONLY|O_BINARY
if
fd
outpath
return
DW_DLV_NO_ENTRY
pathsource
DW_PATHSOURCE_dsym
res
dwarf_object_detector_fd
fd
ftype
endian
offsetsize
filesize
errcode
if
res
DW_DLV_OK
return
res
close
fd
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
blockmatch
unsigned
char
l
unsigned
char
r
unsigned
length
unsigned
int
i
for
i
length
i
if
l
i
r
i
return
FALSE
return
TRUE
The
debug
version
we
expect
not
to
have
debuglink
checking
here
if
buildid
matches
Never
returns
DW_DLV_ERROR
static
int
match_buildid
unsigned
char
crc_base
unsigned
buildid_length_base
unsigned
char
buildid_base
_base
is
executable
info
while
_debug
is
the
debug
object
unsigned
char
crc_debug
unsigned
buildid_length_debug
unsigned
char
buildid_debug
if
crc_debug
crc_base
crc
available
for
both
if
blockmatch
crc_debug
crc_base
return
DW_DLV_NO_ENTRY
if
buildid_length_base
buildid_length_debug
return
DW_DLV_NO_ENTRY
if
blockmatch
buildid_base
buildid_debug
buildid_length_base
return
DW_DLV_NO_ENTRY
return
DW_DLV_OK
static
int
_dwarf_debuglink_finder_newpath
char
path_in
unsigned
char
crc_in
unsigned
buildid_len_in
unsigned
char
buildid_in
dwarfstring
m
int
fd_out
int
errcode
unsigned
char
lcrc
char
debuglinkpath
must
be
freed
unsigned
char
crc
char
debuglinkfullpath
unsigned
debuglinkfullpath_strlen
unsigned
buildid_type
char
buildidownername
unsigned
char
buildid
unsigned
buildid_length
char
paths
must
be
freed
unsigned
paths_count
Dwarf_Debug
dbg
Dwarf_Error
error
char
path
path_in
int
res
res
dwarf_init_path
path
DW_GROUPNUMBER_ANY
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
return
DW_DLV_NO_ENTRY
if
res
DW_DLV_NO_ENTRY
should
never
happen
return
DW_DLV_NO_ENTRY
res
dwarf_gnu_debuglink
dbg
if
res
DW_DLV_ERROR
errcode
dwarf_errno
error
dwarf_dealloc_error
dbg
error
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
else
if
res
DW_DLV_NO_ENTRY
There
is
no
debuglink
section
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
free
paths
paths
memset
sizeof
lcrc
if
crc_in
crc
res
dwarf_crc32
dbg
lcrc
if
res
DW_DLV_ERROR
paths
free
debuglinkfullpath
dwarf_dealloc_error
dbg
error
dwarf_finish
dbg
Cannot
match
the
crc_in
give
up
return
DW_DLV_NO_ENTRY
else
if
res
DW_DLV_OK
crc
free
debuglinkfullpath
res
match_buildid
This
is
the
executable
crc_in
buildid_len_in
buildid_in
pass
in
local
so
we
can
calculate
the
missing
crc
following
is
the
target
ie
debug
crc
buildid_length
buildid
if
res
DW_DLV_OK
dwarfstring_append
m
path
fd_out
dbg
de_fd
dbg
de_owns_fd
FALSE
dwarf_finish
dbg
return
DW_DLV_OK
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
static
int
_dwarf_debuglink_finder_internal
char
gl_pathnames
unsigned
int
gl_pathcount
char
path_in
dwarfstring
m
int
fd_out
int
errcode
int
res
This
local
dbg
is
opened
and
then
dwarf_finish
here
No
dbg
in
the
arguments
Dwarf_Debug
dbg
char
path
Dwarf_Error
error
unsigned
int
p
char
debuglinkpath
unsigned
char
crc
char
debuglinkfullpath
must
be
freed
unsigned
debuglinkfullpath_strlen
unsigned
buildid_type
char
buildidownername
unsigned
char
buildid
unsigned
buildid_length
char
paths
must
be
freed
unsigned
paths_count
unsigned
i
path
path_in
This
path
will
work
Already
know
the
file
is
there
res
dwarf_init_path
path
DW_GROUPNUMBER_ANY
if
res
DW_DLV_ERROR
errcode
dwarf_errno
error
dwarf_dealloc_error
dbg
error
error
return
res
if
res
DW_DLV_NO_ENTRY
return
res
for
p
p
gl_pathcount
p
const
char
lpath
lpath
const
char
gl_pathnames
p
res
dwarf_add_debuglink_global_path
dbg
lpath
if
res
DW_DLV_OK
errcode
dwarf_errno
error
dwarf_dealloc_error
dbg
error
dwarf_finish
dbg
return
res
res
dwarf_gnu_debuglink
dbg
if
res
DW_DLV_ERROR
errcode
dwarf_errno
error
dwarf_dealloc_error
dbg
error
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
else
if
res
DW_DLV_NO_ENTRY
There
is
no
debuglink
section
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
for
i
i
paths_count
i
char
pa
paths
i
int
pfd
First
open
the
file
to
determine
if
it
exists
If
not
loop
again
pfd
open
pa
O_RDONLY|O_BINARY
if
pfd
This
is
the
usual
path
continue
close
pfd
res
_dwarf_debuglink_finder_newpath
pa
crc
buildid_length
buildid
m
fd_out
errcode
if
res
DW_DLV_OK
free
debuglinkfullpath
free
paths
paths
dwarf_finish
dbg
return
DW_DLV_OK
errcode
continue
free
debuglinkfullpath
free
paths
paths
dwarf_finish
dbg
return
DW_DLV_NO_ENTRY
int
dwarf_object_detector_path_b
const
char
path
char
outpath
unsigned
long
outpath_len
char
gl_pathnames
unsigned
gl_pathcount
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
int
fd
int
res
int
have_outpath
outpath
outpath_len
unsigned
char
lpathsource
DW_PATHSOURCE_basic
if
pathsource
lpathsource
pathsource
if
lpathsource
DW_PATHSOURCE_basic
have_outpath
On
return
from
the
following
call
we
could
well
close
the
fd
above
and
open
a
new
one
int
debuglink_fd
unsigned
long
dllen
char
cp
dwarfstring
m
dwarfstring_constructor
res
_dwarf_debuglink_finder_internal
gl_pathnames
gl_pathcount
char
path
errcode
if
res
DW_DLV_ERROR
dwarfstring_destructor
if
debuglink_fd
close
debuglink_fd
return
res
if
res
DW_DLV_NO_ENTRY
We
did
not
find
an
alternative
path
res
dw_stpcpy
outpath
path
outpath
outpath_len
if
res
DW_DLV_OK
errcode
DW_DLE_PATH_SIZE_TOO_SMALL
return
DW_DLV_ERROR
lpathsource
DW_PATHSOURCE_basic
else
if
debuglink_fd
close
debuglink_fd
dllen
dwarfstring_strlen
if
dllen
outpath_len
close
debuglink_fd
errcode
DW_DLE_DEBUGLINK_PATH_SHORT
return
DW_DLV_ERROR
res
dw_stpcpy
outpath
dwarfstring_string
outpath
outpath_len
if
res
DW_DLV_OK
errcode
DW_DLE_DEBUGLINK_PATH_SHORT
return
DW_DLV_ERROR
lpathsource
DW_PATHSOURCE_debuglink
dwarfstring_destructor
fd
open
outpath
O_RDONLY|O_BINARY
fall
through
to
get
fsize
etc
else
lpathsource
DW_PATHSOURCE_basic
fd
open
path
O_RDONLY|O_BINARY
if
fd
if
pathsource
pathsource
DW_PATHSOURCE_unspecified
return
DW_DLV_NO_ENTRY
res
dwarf_object_detector_fd
fd
ftype
endian
offsetsize
filesize
errcode
if
res
DW_DLV_OK
lpathsource
DW_PATHSOURCE_unspecified
if
pathsource
pathsource
lpathsource
close
fd
return
res
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
config
h
include
stdio
h
ifdef
HAVE_STRING_H
include
string
h
memcpy
endif
HAVE_STRING_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
_WIN32
include
windows
h
include
io
h
lseek
read
close
typedef
SSIZE_T
ssize_t
MSVC
does
not
have
POSIX
ssize_t
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf
h
For
error
codes
include
dwarf_object_read_common
h
Neither
off_t
nor
ssize_t
is
in
C90
However
both
are
in
Posix
IEEE
Std
aka
ISO
IEC
int
_dwarf_object_read_random
int
fd
char
buf
off_t
loc
size_t
size
off_t
filesize
int
errc
off_t
scode
ssize_t
rcode
off_t
endpoint
if
loc
filesize
Seek
can
seek
off
the
end
Lets
not
allow
that
The
object
is
corrupt
errc
DW_DLE_SEEK_OFF_END
return
DW_DLV_ERROR
endpoint
loc
size
if
endpoint
filesize
Let
us
not
try
to
read
past
end
of
object
The
object
is
corrupt
errc
DW_DLE_READ_OFF_END
return
DW_DLV_ERROR
scode
lseek
fd
loc
SEEK_SET
if
scode
off_t
errc
DW_DLE_SEEK_ERROR
return
DW_DLV_ERROR
rcode
read
fd
buf
size
if
rcode
size_t
rcode
size
errc
DW_DLE_READ_ERROR
return
DW_DLV_ERROR
return
DW_DLV_OK
void
_dwarf_safe_strcpy
char
out
long
outlen
const
char
in
long
inlen
if
inlen
outlen
strncpy
out
in
outlen
out
outlen
else
strcpy
out
in
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
file
reads
the
parts
of
a
Windows
PE
file
appropriate
to
reading
DWARF
debugging
data
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
config
h
include
stdio
h
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_STRING_H
include
string
h
memcpy
endif
HAVE_STRING_H
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
open
include
time
h
ifdef
_WIN32
include
io
h
lseek
read
close
elif
defined
HAVE_UNISTD_H
include
unistd
h
lseek
read
close
endif
_WIN32
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
libdwarf
h
include
libdwarf_private
h
include
dwarf_base_types
h
include
dwarf_opaque
h
include
memcpy_swap
h
include
dwarf_error
h
for
_dwarf_error
declaration
include
dwarf_reading
h
include
dwarf_object_read_common
h
include
dwarf_object_detector
h
include
dwarf_pe_descr
h
include
dwarf_peread
h
define
DOS_HEADER_LEN
ifndef
TYP
define
TYP
n
l
char
n
l
endif
TYP
ifndef
SIZEOFT32
define
SIZEOFT32
endif
SIZEOFT32
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
len
ld
msg
len
for
cur
end
cur
printf
cur
printf
n
endif
static
int
_dwarf_pe_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
static
unsigned
long
magic_copy
char
d
unsigned
len
unsigned
i
unsigned
long
v
v
d
for
i
i
len
i
v
v
i
return
v
static
int
check_valid_string
char
tab
Dwarf_Unsigned
size
Dwarf_Unsigned
startindex
Dwarf_Unsigned
i
startindex
for
i
size
i
if
tab
i
return
DW_DLV_OK
return
DW_DLV_ERROR
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
Name_array
is
byte
string
or
it
is
supposed
to
be
anyway
static
int
pe_section_name_get
dwarf_pe_object_access_internals_t
pep
const
char
name_array
const
char
name_out
int
errcode
if
name_array
long
v
unsigned
long
u
const
char
s
char
temp_array
int
res
memcpy
temp_array
name_array
temp_array
v
atoi
temp_array
if
v
errcode
DW_DLE_STRING_OFFSET_BAD
return
DW_DLV_ERROR
u
v
if
pep
pe_string_table
errcode
DW_DLE_STRING_OFFSET_BAD
return
DW_DLV_ERROR
if
u
pep
pe_string_table_size
errcode
DW_DLE_STRING_OFFSET_BAD
return
DW_DLV_ERROR
res
check_valid_string
pep
pe_string_table
pep
pe_string_table_size
u
if
res
DW_DLV_OK
errcode
DW_DLE_STRING_OFFSET_BAD
return
DW_DLV_ERROR
s
pep
pe_string_table
u
name_out
s
return
DW_DLV_OK
name_out
name_array
return
DW_DLV_OK
static
Dwarf_Endianness
pe_get_byte_order
void
obj
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
return
pep
pe_endian
static
Dwarf_Small
pe_get_length_size
void
obj
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
return
pep
pe_offsetsize
static
Dwarf_Small
pe_get_pointer_size
void
obj
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
return
pep
pe_pointersize
static
Dwarf_Unsigned
pe_get_section_count
void
obj
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
return
pep
pe_section_count
static
int
pe_get_section_info
void
obj
Dwarf_Half
section_index
Dwarf_Obj_Access_Section
return_section
int
error
UNUSEDARG
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
if
section_index
pep
pe_section_count
struct
dwarf_pe_generic_image_section_header
sp
sp
pep
pe_sectionptr
section_index
return_section
addr
pep
pe_OptionalHeader
ImageBase
sp
VirtualAddress
return_section
type
SizeOfRawData
can
be
rounded
or
truncated
use
VirtualSize
for
the
real
analog
of
Elf
section
size
return_section
size
sp
VirtualSize
return_section
name
sp
dwarfsectname
return_section
link
return_section
info
return_section
entrysize
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
load_optional_header32
dwarf_pe_object_access_internals_t
pep
Dwarf_Unsigned
offset
int
errcode
int
res
IMAGE_OPTIONAL_HEADER32_dw
hdr
pep
pe_optional_header_size
sizeof
IMAGE_OPTIONAL_HEADER32_dw
if
pep
pe_optional_header_size
offset
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
off_t
offset
sizeof
IMAGE_OPTIONAL_HEADER32_dw
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
This
is
a
subset
of
fields
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
Magic
hdr
Magic
pep
pe_OptionalHeader
MajorLinkerVersion
hdr
MajorLinkerVersion
pep
pe_OptionalHeader
MinorLinkerVersion
hdr
MinorLinkerVersion
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
ImageBase
hdr
ImageBase
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfCode
hdr
SizeOfCode
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfImage
hdr
SizeOfImage
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfHeaders
hdr
SizeOfHeaders
pep
pe_OptionalHeader
SizeOfDataDirEntry
sizeof
IMAGE_DATA_DIRECTORY_dw
return
DW_DLV_OK
static
int
load_optional_header64
dwarf_pe_object_access_internals_t
pep
Dwarf_Unsigned
offset
int
errcode
IMAGE_OPTIONAL_HEADER64_dw
hdr
int
res
pep
pe_optional_header_size
sizeof
IMAGE_OPTIONAL_HEADER64_dw
if
pep
pe_optional_header_size
offset
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
off_t
offset
sizeof
IMAGE_OPTIONAL_HEADER64_dw
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
This
is
a
subset
of
fields
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
Magic
hdr
Magic
pep
pe_OptionalHeader
MajorLinkerVersion
hdr
MajorLinkerVersion
pep
pe_OptionalHeader
MinorLinkerVersion
hdr
MinorLinkerVersion
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
ImageBase
hdr
ImageBase
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfCode
hdr
SizeOfCode
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfImage
hdr
SizeOfImage
ASNAR
pep
pe_copy_word
pep
pe_OptionalHeader
SizeOfHeaders
hdr
SizeOfHeaders
pep
pe_OptionalHeader
SizeOfDataDirEntry
sizeof
IMAGE_DATA_DIRECTORY_dw
return
DW_DLV_OK
static
int
pe_load_section
void
obj
Dwarf_Half
section_index
Dwarf_Small
return_data
int
error
dwarf_pe_object_access_internals_t
pep
dwarf_pe_object_access_internals_t
obj
if
section_index
section_index
pep
pe_section_count
int
res
struct
dwarf_pe_generic_image_section_header
sp
pep
pe_sectionptr
section_index
Dwarf_Unsigned
read_length
if
sp
loaded_data
return_data
sp
loaded_data
return
DW_DLV_OK
if
sp
VirtualSize
return
DW_DLV_NO_ENTRY
read_length
sp
SizeOfRawData
if
sp
VirtualSize
read_length
Don
t
read
padding
that
wasn
t
allocated
in
memory
read_length
sp
VirtualSize
if
read_length
sp
PointerToRawData
pep
pe_filesize
error
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
VirtualSize
SizeOfRawData
if
trailing
zeros
in
the
section
were
not
written
to
disc
Malloc
enough
for
the
whole
section
read
in
the
bytes
we
have
sp
loaded_data
malloc
size_t
sp
VirtualSize
if
sp
loaded_data
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
sp
loaded_data
off_t
sp
PointerToRawData
size_t
read_length
off_t
pep
pe_filesize
error
if
res
DW_DLV_OK
free
sp
loaded_data
sp
loaded_data
return
res
if
sp
VirtualSize
read_length
Zero
space
that
was
allocated
but
truncated
from
the
file
memset
sp
loaded_data
read_length
size_t
sp
VirtualSize
read_length
return_data
sp
loaded_data
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
void
_dwarf_destruct_pe_access
struct
Dwarf_Obj_Access_Interface_s
aip
dwarf_pe_object_access_internals_t
pep
Dwarf_Unsigned
i
if
aip
return
pep
dwarf_pe_object_access_internals_t
aip
object
if
pep
pe_destruct_close_fd
pep
pe_fd
close
pep
pe_fd
pep
pe_fd
free
char
pep
pe_path
pep
pe_path
if
pep
pe_sectionptr
struct
dwarf_pe_generic_image_section_header
sp
sp
pep
pe_sectionptr
for
i
i
pep
pe_section_count
i
sp
if
sp
loaded_data
free
sp
loaded_data
sp
loaded_data
free
sp
name
sp
name
free
sp
dwarfsectname
sp
dwarfsectname
free
pep
pe_sectionptr
pep
pe_section_count
free
pep
pe_string_table
pep
pe_string_table
free
pep
free
aip
return
static
int
dwarf_pe_load_dwarf_section_headers
dwarf_pe_object_access_internals_t
pep
int
errcode
Dwarf_Unsigned
i
Dwarf_Unsigned
input_count
pep
pe_FileHeader
NumberOfSections
Dwarf_Unsigned
offset_in_input
pep
pe_section_table_offset
Dwarf_Unsigned
section_hdr_size
sizeof
IMAGE_SECTION_HEADER_dw
struct
dwarf_pe_generic_image_section_header
sec_outp
Dwarf_Unsigned
cur_offset
offset_in_input
Dwarf_Unsigned
past_end_hdrs
offset_in_input
section_hdr_size
input_count
internal
sections
include
null
initial
section
pep
pe_section_count
input_count
if
past_end_hdrs
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
if
offset_in_input
errcode
DW_DLE_PE_OFFSET_BAD
return
DW_DLV_ERROR
pep
pe_sectionptr
struct
dwarf_pe_generic_image_section_header
calloc
size_t
pep
pe_section_count
sizeof
struct
dwarf_pe_generic_image_section_header
if
pep
pe_sectionptr
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
sec_outp
pep
pe_sectionptr
sec_outp
name
strdup
sec_outp
dwarfsectname
strdup
sec_outp
for
i
input_count
i
cur_offset
section_hdr_size
sec_outp
int
res
IMAGE_SECTION_HEADER_dw
filesect
char
safe_name
IMAGE_SIZEOF_SHORT_NAME
const
char
expname
res
_dwarf_object_read_random
pep
pe_fd
char
off_t
cur_offset
sizeof
filesect
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
The
following
is
safe
filesect
Name
is
IMAGE_SIZEOF_SHORT_NAME
bytes
long
and
may
not
not
sure
have
a
NUL
terminator
strncpy
safe_name
filesect
Name
IMAGE_SIZEOF_SHORT_NAME
Then
add
NUL
terminator
safe_name
IMAGE_SIZEOF_SHORT_NAME
sec_outp
name
strdup
safe_name
res
pe_section_name_get
pep
safe_name
errcode
if
res
DW_DLV_OK
return
res
if
expname
sec_outp
dwarfsectname
strdup
expname
else
sec_outp
dwarfsectname
strdup
sec
name
missing
if
sec_outp
name
sec_outp
dwarfsectname
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
sec_outp
SecHeaderOffset
cur_offset
ASNAR
pep
pe_copy_word
sec_outp
VirtualSize
filesect
Misc
VirtualSize
ASNAR
pep
pe_copy_word
sec_outp
VirtualAddress
filesect
VirtualAddress
ASNAR
pep
pe_copy_word
sec_outp
SizeOfRawData
filesect
SizeOfRawData
ASNAR
pep
pe_copy_word
sec_outp
PointerToRawData
filesect
PointerToRawData
if
sec_outp
SizeOfRawData
pep
pe_filesize
sec_outp
PointerToRawData
pep
pe_filesize
sec_outp
SizeOfRawData
sec_outp
PointerToRawData
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
ASNAR
pep
pe_copy_word
sec_outp
PointerToRelocations
filesect
PointerToRelocations
ASNAR
pep
pe_copy_word
sec_outp
PointerToLinenumbers
filesect
PointerToLinenumbers
ASNAR
pep
pe_copy_word
sec_outp
NumberOfRelocations
filesect
NumberOfRelocations
ASNAR
pep
pe_copy_word
sec_outp
NumberOfLinenumbers
filesect
NumberOfLinenumbers
ASNAR
pep
pe_copy_word
sec_outp
Characteristics
filesect
Characteristics
sec_outp
loaded
data
set
when
we
load
a
section
return
DW_DLV_OK
static
int
dwarf_load_pe_sections
dwarf_pe_object_access_internals_t
pep
int
errcode
struct
dos_header_dw
dhinmem
IMAGE_FILE_HEADER_dw
ifh
void
word_swap
void
const
void
unsigned
long
unsigned
locendian
int
res
Dwarf_Unsigned
dos_sig
Dwarf_Unsigned
nt_address
char
nt_sig_array
unsigned
long
nt_signature
if
sizeof
ifh
sizeof
dhinmem
pep
pe_filesize
corrupt
object
errcode
DW_DLE_PE_SIZE_SMALL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
sizeof
dhinmem
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
dos_sig
magic_copy
char
dhinmem
dh_mz
sizeof
dhinmem
dh_mz
if
dos_sig
IMAGE_DOS_SIGNATURE_dw
IMAGE_DOS_SIGNATURE_dw
assumes
bytes
reversed
by
little
endian
load
so
we
intrepet
a
match
the
other
way
BIG
ENDIAN
From
looking
at
hex
characters
in
object
ifdef
WORDS_BIGENDIAN
word_swap
_dwarf_memcpy_noswap_bytes
else
LITTLE
ENDIAN
word_swap
_dwarf_memcpy_swap_bytes
endif
LITTLE
BIG
ENDIAN
locendian
DW_OBJECT_MSB
else
if
dos_sig
IMAGE_DOS_REVSIGNATURE_dw
raw
load
so
intrepet
a
match
the
other
way
LITTLE
ENDIAN
ifdef
WORDS_BIGENDIAN
word_swap
_dwarf_memcpy_swap_bytes
else
LITTLE
ENDIAN
word_swap
_dwarf_memcpy_noswap_bytes
endif
LITTLE
BIG
ENDIAN
locendian
DW_OBJECT_LSB
else
Not
dos
header
not
a
PE
file
we
recognize
errcode
DW_DLE_FILE_WRONG_TYPE
return
DW_DLV_ERROR
if
locendian
pep
pe_endian
Really
this
is
a
coding
botch
somewhere
here
not
an
object
corruption
errcode
DW_DLE_FILE_WRONG_TYPE
return
DW_DLV_ERROR
pep
pe_copy_word
word_swap
ASNAR
word_swap
nt_address
dhinmem
dh_image_offset
if
pep
pe_filesize
nt_address
sizeof
nt_sig_array
The
nt_address
is
really
a
file
offset
errcode
DW_DLE_FILE_TOO_SMALL
Not
dos
header
not
a
PE
file
we
recognize
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
off_t
nt_address
sizeof
nt_sig_array
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
unsigned
long
lsig
ASNAR
word_swap
lsig
nt_sig_array
nt_signature
lsig
if
nt_signature
IMAGE_NT_SIGNATURE_dw
errcode
DW_DLE_FILE_WRONG_TYPE
return
DW_DLV_ERROR
pep
pe_nt_header_offset
nt_address
SIZEOFT32
if
pep
pe_filesize
pep
pe_nt_header_offset
sizeof
ifh
errcode
DW_DLE_FILE_TOO_SMALL
Not
image
header
not
a
PE
file
we
recognize
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
off_t
pep
pe_nt_header_offset
sizeof
ifh
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
ASNAR
word_swap
pep
pe_FileHeader
Machine
ifh
Machine
ASNAR
word_swap
pep
pe_FileHeader
NumberOfSections
ifh
NumberOfSections
ASNAR
word_swap
pep
pe_FileHeader
TimeDateStamp
ifh
TimeDateStamp
ASNAR
word_swap
pep
pe_FileHeader
PointerToSymbolTable
ifh
PointerToSymbolTable
ASNAR
word_swap
pep
pe_FileHeader
NumberOfSymbols
ifh
NumberOfSymbols
ASNAR
word_swap
pep
pe_FileHeader
SizeOfOptionalHeader
ifh
SizeOfOptionalHeader
ASNAR
word_swap
pep
pe_FileHeader
Characteristics
ifh
Characteristics
pep
pe_optional_header_offset
pep
pe_nt_header_offset
sizeof
ifh
if
pep
pe_offsetsize
res
load_optional_header32
pep
pep
pe_optional_header_offset
errcode
pep
pe_optional_header_size
sizeof
IMAGE_OPTIONAL_HEADER32_dw
else
if
pep
pe_offsetsize
res
load_optional_header64
pep
pep
pe_optional_header_offset
errcode
pep
pe_optional_header_size
sizeof
IMAGE_OPTIONAL_HEADER64_dw
else
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
if
res
DW_DLV_OK
return
res
pep
pe_section_table_offset
pep
pe_optional_header_offset
pep
pe_optional_header_size
pep
pe_symbol_table_offset
pep
pe_FileHeader
PointerToSymbolTable
if
pep
pe_symbol_table_offset
pep
pe_filesize
errcode
DW_DLE_OFFSET_SIZE
return
DW_DLV_ERROR
if
pep
pe_symbol_table_offset
pep
pe_string_table_offset
pep
pe_symbol_table_offset
pep
pe_FileHeader
NumberOfSymbols
IMAGE_SIZEOF_SYMBOL
if
pep
pe_string_table_offset
pep
pe_filesize
errcode
DW_DLE_OFFSET_SIZE
pep
pe_string_table_size
return
DW_DLV_ERROR
if
pep
pe_string_table_offset
https
docs
microsoft
com
en
us
windows
desktop
debug
pe
format
coff
string
table
The
first
bytes
of
the
string
table
contain
the
size
of
the
string
table
char
size_field
if
pep
pe_string_table_offset
sizeof
size_field
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
memset
size_field
sizeof
size_field
res
_dwarf_object_read_random
pep
pe_fd
char
size_field
off_t
pep
pe_string_table_offset
sizeof
size_field
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
return
res
ASNAR
pep
pe_copy_word
pep
pe_string_table_size
size_field
if
pep
pe_string_table_size
pep
pe_filesize
errcode
DW_DLE_PE_OFFSET_BAD
return
DW_DLV_ERROR
if
pep
pe_string_table_offset
pep
pe_string_table_size
pep
pe_filesize
errcode
DW_DLE_FILE_TOO_SMALL
return
DW_DLV_ERROR
pep
pe_string_table
char
malloc
size_t
pep
pe_string_table_size
if
pep
pe_string_table
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
res
_dwarf_object_read_random
pep
pe_fd
char
pep
pe_string_table
off_t
pep
pe_string_table_offset
size_t
pep
pe_string_table_size
off_t
pep
pe_filesize
errcode
if
res
DW_DLV_OK
free
pep
pe_string_table
pep
pe_string_table
return
res
res
dwarf_pe_load_dwarf_section_headers
pep
errcode
return
res
int
_dwarf_pe_setup
int
fd
char
true_path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Obj_Access_Interface
binary_interface
dwarf_pe_object_access_internals_t
pep
int
res
DW_DLV_OK
int
localerrnum
res
_dwarf_pe_object_access_init
fd
ftype
endian
offsetsize
filesize
if
res
DW_DLV_OK
if
res
DW_DLV_NO_ENTRY
return
res
_dwarf_error
NULL
error
localerrnum
return
DW_DLV_ERROR
allocates
and
initializes
Dwarf_Debug
generic
code
res
dwarf_object_init_b
binary_interface
errhand
errarg
groupnumber
dbg
error
if
res
DW_DLV_OK
_dwarf_destruct_pe_access
binary_interface
return
res
pep
binary_interface
object
pep
pe_path
strdup
true_path
return
res
static
Dwarf_Obj_Access_Methods
pe_methods
pe_get_section_info
pe_get_byte_order
pe_get_length_size
pe_get_pointer_size
pe_get_section_count
pe_load_section
ignore
pe
relocations
On
any
error
this
frees
internals
static
int
_dwarf_pe_object_access_internals_init
dwarf_pe_object_access_internals_t
internals
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
int
errcode
dwarf_pe_object_access_internals_t
intfc
internals
struct
Dwarf_Obj_Access_Interface_s
localdoas
int
res
Must
malloc
as
_dwarf_destruct_pe_access
forces
that
due
to
other
uses
localdoas
struct
Dwarf_Obj_Access_Interface_s
malloc
sizeof
struct
Dwarf_Obj_Access_Interface_s
if
localdoas
free
internals
errcode
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
localdoas
sizeof
struct
Dwarf_Obj_Access_Interface_s
intfc
pe_ident
P
intfc
pe_ident
intfc
pe_fd
fd
intfc
pe_is_64bit
offsetsize
FALSE
intfc
pe_offsetsize
offsetsize
intfc
pe_pointersize
offsetsize
intfc
pe_filesize
filesize
intfc
pe_ftype
ftype
pe_path
set
by
caller
ifdef
WORDS_BIGENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
pe_copy_word
_dwarf_memcpy_swap_bytes
intfc
pe_endian
DW_OBJECT_LSB
else
intfc
pe_copy_word
_dwarf_memcpy_noswap_bytes
intfc
pe_endian
DW_OBJECT_MSB
else
LITTLE
ENDIAN
if
endian
DW_ENDIAN_LITTLE
intfc
pe_copy_word
_dwarf_memcpy_noswap_bytes
intfc
pe_endian
DW_OBJECT_LSB
else
intfc
pe_copy_word
_dwarf_memcpy_swap_bytes
intfc
pe_endian
DW_OBJECT_MSB
endif
LITTLE
BIG
ENDIAN
res
dwarf_load_pe_sections
intfc
errcode
if
res
DW_DLV_OK
localdoas
object
intfc
localdoas
methods
_dwarf_destruct_pe_access
localdoas
localdoas
return
res
free
localdoas
localdoas
return
DW_DLV_OK
static
int
_dwarf_pe_object_access_init
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
Dwarf_Obj_Access_Interface
binary_interface
int
localerrnum
int
res
dwarf_pe_object_access_internals_t
internals
Dwarf_Obj_Access_Interface
intfc
internals
malloc
sizeof
dwarf_pe_object_access_internals_t
if
internals
localerrnum
DW_DLE_ALLOC_FAIL
Impossible
case
we
hope
Give
up
return
DW_DLV_ERROR
memset
internals
sizeof
internals
res
_dwarf_pe_object_access_internals_init
internals
fd
ftype
endian
offsetsize
filesize
localerrnum
if
res
DW_DLV_OK
err
is
already
set
and
the
call
freed
internals
return
DW_DLV_ERROR
intfc
malloc
sizeof
Dwarf_Obj_Access_Interface
if
intfc
Impossible
case
we
hope
Give
up
free
internals
localerrnum
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Initialize
the
interface
struct
intfc
object
internals
intfc
methods
binary_interface
intfc
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
time
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_line
h
include
dwarfstring
h
define
PRINTING_DETAILS
for
dwarfstring_constructor_static
saving
lots
of
malloc
and
free
but
beware
make
sure
each
routine
using
this
DOES
NOT
call
another
routine
using
it
would
be
safer
to
have
a
buffer
per
function
but
currently
not
necessary
static
char
locallinebuf
static
void
print_line_header
Dwarf_Debug
dbg
Dwarf_Bool
is_single_tab
Dwarf_Bool
is_actuals_tab
if
is_single_tab
Ugly
indenting
follows
it
makes
lines
shorter
to
see
them
better
Best
to
use
a
wider
text
window
to
really
see
how
it
looks
if
is_actuals_tab
_dwarf_printf
dbg
nActuals
Table
n
_dwarf_printf
dbg
be
n
ls
n
ce
n
section
op
kq
n
offset
code
address
index
row
isa
n
return
else
_dwarf_printf
dbg
nLogicals
Table
n
_dwarf_printf
dbg
s
pe
n
tirp
n
msoi
n
section
op
tall
n
offset
row
code
address
indx
fil
l
ne
col
disc
cntx
subp
n
return
Single
level
table
_dwarf_printf
dbg
s
b
e
p
e
i
d
n
t
l
s
r
p
s
i
n
m
c
e
o
i
a
s
n
section
op
col
t
k
q
l
l
c
n
offset
code
address
file
line
umn
n
End
of
function
with
ugly
indenting
static
void
print_line_detail
Dwarf_Debug
dbg
const
char
prefix
int
opcode
unsigned
curr_line
struct
Dwarf_Line_Registers_s
regs
Dwarf_Bool
is_single_table
Dwarf_Bool
is_actuals_table
dwarfstring
m1
dwarfstring_constructor_static
locallinebuf
sizeof
locallinebuf
if
is_single_table
is_actuals_table
dwarfstring_append_printf_s
char
prefix
dwarfstring_append_printf_i
opcode
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
regs
lr_address
dwarfstring_append_printf_u
regs
lr_op_index
dwarfstring_append_printf_u
regs
lr_line
dwarfstring_append_printf_u
regs
lr_isa
dwarfstring_append_printf_i
regs
lr_basic_block
dwarfstring_append_printf_i
n
regs
lr_end_sequence
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
return
if
is_single_table
is_actuals_table
dwarfstring_append_printf_i
row
number
curr_line
dwarfstring_append_printf_s
char
prefix
dwarfstring_append_printf_i
opcode
dwarfstring_append_printf_u
x
DW_PR_XZEROS
DW_PR_DUx
regs
lr_address
dwarfstring_append_printf_u
regs
lr_op_index
dwarfstring_append_printf_u
regs
lr_file
dwarfstring_append_printf_u
regs
lr_line
dwarfstring_append_printf_u
regs
lr_column
if
regs
lr_discriminator
regs
lr_prologue_end
regs
lr_epilogue_begin
regs
lr_isa
regs
lr_is_stmt
regs
lr_call_context
regs
lr_subprogram
dwarfstring_append_printf_u
x
DW_PR_DUx
regs
lr_discriminator
DWARF4
dwarfstring_append_printf_u
x
DW_PR_DUx
regs
lr_call_context
EXPERIMENTAL
dwarfstring_append_printf_u
x
DW_PR_DUx
regs
lr_subprogram
EXPERIMENTAL
dwarfstring_append_printf_i
regs
lr_is_stmt
dwarfstring_append_printf_i
int
regs
lr_isa
dwarfstring_append_printf_i
regs
lr_prologue_end
DWARF3
dwarfstring_append_printf_i
regs
lr_epilogue_begin
DWARF3
dwarfstring_append
n
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
return
In
the
first
quoted
line
below
looks
better
than
but
best
to
do
that
as
separate
change
and
test
from
two
level
line
tables
dwarfstring_append_printf_s
char
prefix
dwarfstring_append_printf_i
opcode
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
regs
lr_address
dwarfstring_append_printf_u
regs
lr_file
dwarfstring_append_printf_u
regs
lr_line
dwarfstring_append_printf_u
regs
lr_column
dwarfstring_append_printf_i
regs
lr_is_stmt
dwarfstring_append_printf_i
regs
lr_basic_block
dwarfstring_append_printf_i
regs
lr_end_sequence
if
regs
lr_discriminator
regs
lr_prologue_end
regs
lr_epilogue_begin
regs
lr_isa
dwarfstring_append_printf_i
regs
lr_prologue_end
DWARF3
dwarfstring_append_printf_i
regs
lr_epilogue_begin
DWARF3
dwarfstring_append_printf_i
regs
lr_isa
DWARF3
dwarfstring_append_printf_u
DW_PR_DUx
regs
lr_discriminator
DWARF4
dwarfstring_append
n
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
include
dwarf_line_table_reader_common
h
static
void
print_include_directory_details
Dwarf_Debug
dbg
unsigned
int
line_version
Dwarf_Line_Context
line_context
Dwarf_Unsigned
u
dwarfstring
m4
Dwarf_Unsigned
indexbase
Dwarf_Unsigned
indexlimit
dwarfstring_constructor_static
locallinebuf
sizeof
locallinebuf
if
line_version
DW_LINE_VERSION5
unsigned
i
unsigned
dfcount
line_context
lc_directory_entry_format_count
dwarfstring_constructor
dwarfstring_append_printf_u
directory
entry
format
count
u
n
dfcount
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
for
i
dfcount
i
struct
Dwarf_Unsigned_Pair_s
valpair
const
char
tname
const
char
fname
int
res
valpair
line_context
lc_directory_format_values
i
dwarfstring_append_printf_u
format
i
res
dwarf_get_LNCT_name
valpair
up_first
if
res
DW_DLV_OK
tname
unknown
type
dwarfstring_append_printf_u
type
DW_PR_XZEROS
DW_PR_DUx
valpair
up_first
dwarfstring_append_printf_s
n
char
tname
res
dwarf_get_FORM_name
valpair
up_second
if
res
DW_DLV_OK
fname
unknown
form
dwarfstring_append_printf_u
code
DW_PR_XZEROS
DW_PR_DUx
valpair
up_second
dwarfstring_append_printf_s
n
char
fname
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
Common
print
of
the
directories
For
DWARF
it
has
always
started
the
indexing
at
even
though
the
directory
index
in
line
entries
starts
at
zero
meaning
current
directory
at
compile
time
That
is
odd
given
the
non
dash
v
printed
starting
at
So
lets
adjust
for
consistency
if
line_version
DW_LINE_VERSION5
dwarfstring_append_printf_i
include
directories
count
d
n
int
line_context
lc_include_directories_count
else
if
line_context
lc_include_directories_count
dwarfstring_append_printf_i
include
directories
count
d
n
int
line_context
lc_include_directories_count
else
dwarfstring_append_printf_i
include
directories
count
d
index
starts
at
n
int
line_context
lc_include_directories_count
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
if
line_version
DW_LINE_VERSION5
indexbase
indexlimit
line_context
lc_include_directories_count
else
indexbase
indexlimit
line_context
lc_include_directories_count
for
u
indexbase
u
indexlimit
u
dwarfstring_append_printf_u
include
dir
u
u
dwarfstring_append_printf_s
s
n
char
line_context
lc_include_directories
u
indexbase
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_destructor
static
void
print_just_file_entry_details
Dwarf_Debug
dbg
Dwarf_Line_Context
line_context
unsigned
fiu
Dwarf_File_Entry
fe
line_context
lc_file_entries
Dwarf_File_Entry
fe2
fe
dwarfstring
m3
unsigned
increment
if
line_context
lc_version_number
DW_LINE_VERSION5
increment
dwarfstring_constructor_static
locallinebuf
sizeof
locallinebuf
dwarfstring_append_printf_i
file
names
count
d
n
line_context
lc_file_entry_count
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
for
fiu
fe2
fe2
fe
fi_next
fiu
Dwarf_Unsigned
tlm2
unsigned
filenum
fe
fe2
tlm2
fe
fi_time_last_mod
filenum
fiu
increment
The
space
character
at
the
end
of
line
is
silly
but
lets
leave
it
there
for
the
moment
to
avoid
changing
output
if
line_context
lc_file_entry_count
dwarfstring_append_printf_u
file
fiu
else
dwarfstring_append_printf_u
file
u
fiu
DWARF5
can
have
a
null
fi_file_name
if
the
format
code
in
the
line
table
header
is
unknown
such
as
in
a
corrupt
object
file
dwarfstring_append_printf_s
fe
fi_file_name?
char
fe
fi_file_name
no
file
name
dwarfstring_append_printf_u
file
number
u
n
filenum
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
if
fe
fi_dir_index_present
Dwarf_Unsigned
di
di
fe
fi_dir_index
dwarfstring_append_printf_i
dir
index
d
n
di
if
fe
fi_time_last_mod_present
time_t
tt
time_t
tlm2
ctime
supplies
newline
dwarfstring_append_printf_u
last
time
x
tlm2
dwarfstring_append
char
ctime
if
fe
fi_file_length_present
Dwarf_Unsigned
fl
fl
fe
fi_file_length
dwarfstring_append_printf_i
file
length
ld
fl
dwarfstring_append_printf_u
lx
n
fl
if
fe
fi_md5_present
char
c
char
fi_md5_value
char
end
c
sizeof
fe
fi_md5_value
dwarfstring_append
file
md5
value
while
c
end
dwarfstring_append_printf_u
c
c
dwarfstring_append
n
if
fe
fi_llvm_source
dwarfstring_append_printf_s
n
char
fe
fi_llvm_source
if
fe
fi_gnu_subprogram_name
dwarfstring_append_printf_s
n
char
fe
fi_gnu_subprogram_name
if
fe
fi_gnu_decl_file_present
Dwarf_Unsigned
di
di
fe
fi_gnu_decl_file
dwarfstring_append_printf_i
gnu
decl
file
d
n
di
if
fe
fi_gnu_decl_line_present
Dwarf_Unsigned
di
di
fe
fi_gnu_decl_line
dwarfstring_append_printf_i
gnu
decl
line
d
n
di
if
dwarfstring_strlen
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_destructor
static
void
print_file_entry_details
Dwarf_Debug
dbg
unsigned
int
line_version
Dwarf_Line_Context
line_context
dwarfstring
m5
dwarfstring_constructor_static
locallinebuf
sizeof
locallinebuf
if
line_version
DW_LINE_VERSION5
unsigned
i
unsigned
dfcount
line_context
lc_file_name_format_count
dwarfstring_append_printf_u
file
entry
format
count
u
n
dfcount
for
i
dfcount
i
struct
Dwarf_Unsigned_Pair_s
valpair
const
char
tname
const
char
fname
int
res
valpair
line_context
lc_file_format_values
i
dwarfstring_append_printf_u
format
i
res
dwarf_get_LNCT_name
valpair
up_first
if
res
DW_DLV_OK
tname
unknown
type
dwarfstring_append_printf_u
type
DW_PR_XZEROS
DW_PR_DUx
valpair
up_first
dwarfstring_append_printf_s
n
char
tname
res
dwarf_get_FORM_name
valpair
up_second
if
res
DW_DLV_OK
fname
unknown
form
dwarfstring_append_printf_u
code
DW_PR_XZEROS
DW_PR_DUx
valpair
up_second
dwarfstring_append_printf_s
n
char
fname
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_destructor
print_just_file_entry_details
dbg
line_context
else
print_just_file_entry_details
dbg
line_context
dwarfstring_destructor
static
void
print_experimental_subprograms_list
Dwarf_Debug
dbg
Dwarf_Line_Context
line_context
Print
the
subprograms
list
Dwarf_Unsigned
count
line_context
lc_subprogs_count
Dwarf_Unsigned
exu
Dwarf_Subprog_Entry
sub
line_context
lc_subprogs
dwarfstring
m6
dwarfstring_constructor_static
locallinebuf
sizeof
locallinebuf
dwarfstring_append_printf_u
subprograms
count
DW_PR_DUu
n
count
if
count
dwarfstring_append
indx
file
line
name
n
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
for
exu
exu
count
exu
sub
dwarfstring_append_printf_u
DW_PR_DUu
exu
dwarfstring_append_printf_u
DW_PR_DUu
sub
ds_decl_file
dwarfstring_append_printf_u
DW_PR_DUu
sub
ds_decl_line
dwarfstring_append_printf_s
s
n
char
sub
ds_subprog_name
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_destructor
static
void
do_line_print_now
Dwarf_Debug
dbg
int
line_version
Dwarf_Small
comp_dir
Dwarf_Line_Context
line_context
static
void
print_experimental_counts
Dwarf_Debug
dbg
int
line_version
Dwarf_Line_Context
line_context
static
int
print_actuals_and_locals
Dwarf_Debug
dbg
Dwarf_Line_Context
line_context
Dwarf_Unsigned
bogus_bytes_count
Dwarf_Small
bogus_bytes_ptr
Dwarf_Small
orig_line_ptr
Dwarf_Small
line_ptr
Dwarf_Small
section_start
Dwarf_Small
line_ptr_actuals
Dwarf_Small
line_ptr_end
Dwarf_Half
address_size
int
err_count_out
Dwarf_Error
err
return
DW_DLV_OK
if
ok
else
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
If
err_count_out
is
non
NULL
this
is
a
special
check
call
static
int
_dwarf_internal_printlines
Dwarf_Die
die
int
err_count_out
int
only_line_header
Dwarf_Error
error
This
pointer
is
used
to
scan
the
portion
of
the
debug_line
section
for
the
current
cu
Dwarf_Small
line_ptr
Dwarf_Small
orig_line_ptr
Pointer
to
a
DW_AT_stmt_list
attribute
in
case
it
exists
in
the
die
Dwarf_Attribute
stmt_list_attr
Pointer
to
DW_AT_comp_dir
attribute
in
die
Dwarf_Attribute
comp_dir_attr
Pointer
to
name
of
compilation
directory
Dwarf_Small
comp_dir
NULL
Offset
into
debug_line
specified
by
a
DW_AT_stmt_list
attribute
Dwarf_Unsigned
line_offset
These
variables
are
used
to
decode
leb128
numbers
Leb128_num
holds
the
decoded
number
and
leb128_length
is
its
length
in
bytes
Dwarf_Half
attrform
In
case
there
are
weird
bytes
after
the
line
table
prologue
this
lets
us
print
something
This
is
a
gcc
compiler
bug
and
we
expect
the
bytes
count
to
be
Dwarf_Small
bogus_bytes_ptr
Dwarf_Unsigned
bogus_bytes_count
Dwarf_Half
address_size
Dwarf_Unsigned
fission_offset
unsigned
line_version
The
Dwarf_Debug
this
die
belongs
to
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Line_Context
line_context
int
resattr
DW_DLV_ERROR
int
lres
DW_DLV_ERROR
int
res
DW_DLV_ERROR
Dwarf_Small
line_ptr_actuals
Dwarf_Small
line_ptr_end
Dwarf_Small
section_start
BEGIN
CODE
if
error
NULL
error
NULL
CHECK_DIE
die
DW_DLV_ERROR
cu_context
die
di_cu_context
dbg
cu_context
cc_dbg
res
_dwarf_load_section
dbg
de_debug_line
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_line
dss_size
return
DW_DLV_NO_ENTRY
address_size
_dwarf_get_address_size
dbg
die
resattr
dwarf_attr
die
DW_AT_stmt_list
error
if
resattr
DW_DLV_OK
return
resattr
The
list
of
relevant
FORMs
is
small
DW_FORM_data4
DW_FORM_data8
DW_FORM_sec_offset
lres
dwarf_whatform
stmt_list_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
if
attrform
DW_FORM_data4
attrform
DW_FORM_data8
attrform
DW_FORM_sec_offset
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
lres
dwarf_global_formref
stmt_list_attr
error
if
lres
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
lres
if
line_offset
dbg
de_debug_line
dss_size
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
_dwarf_error
dbg
error
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
section_start
dbg
de_debug_line
dss_data
Dwarf_Unsigned
fission_size
int
resfis
_dwarf_get_fission_addition_die
die
DW_SECT_LINE
error
if
resfis
DW_DLV_OK
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
return
resfis
orig_line_ptr
section_start
line_offset
fission_offset
line_ptr
orig_line_ptr
dwarf_dealloc
dbg
stmt_list_attr
DW_DLA_ATTR
If
die
has
DW_AT_comp_dir
attribute
get
the
string
that
names
the
compilation
directory
resattr
dwarf_attr
die
DW_AT_comp_dir
error
if
resattr
DW_DLV_ERROR
return
resattr
if
resattr
DW_DLV_OK
int
cres
DW_DLV_ERROR
char
cdir
cres
dwarf_formstring
comp_dir_attr
error
if
cres
DW_DLV_ERROR
return
cres
else
if
cres
DW_DLV_OK
comp_dir
Dwarf_Small
cdir
if
resattr
DW_DLV_OK
dwarf_dealloc
dbg
comp_dir_attr
DW_DLA_ATTR
line_context
Dwarf_Line_Context
_dwarf_get_alloc
dbg
DW_DLA_LINE_CONTEXT
if
line_context
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Dwarf_Small
newlinep
int
dres
_dwarf_read_line_table_header
dbg
cu_context
section_start
line_ptr
dbg
de_debug_line
dss_size
line_context
error
err_count_out
if
dres
DW_DLV_ERROR
dwarf_srclines_dealloc_b
line_context
return
dres
if
dres
DW_DLV_NO_ENTRY
dwarf_srclines_dealloc_b
line_context
return
dres
line_ptr_end
line_context
lc_line_ptr_end
line_ptr
newlinep
if
line_context
lc_actuals_table_offset
line_ptr_actuals
line_context
lc_line_prologue_start
line_context
lc_actuals_table_offset
line_version
line_context
lc_version_number
line_context
lc_compilation_directory
comp_dir
if
only_line_header
Just
checking
for
header
errors
nothing
more
here
dwarf_srclines_dealloc_b
line_context
return
DW_DLV_OK
do_line_print_now
dbg
line_version
comp_dir
line_context
print_include_directory_details
dbg
line_version
line_context
print_file_entry_details
dbg
line_version
line_context
print_experimental_counts
dbg
line_version
line_context
res
print_actuals_and_locals
dbg
line_context
bogus_bytes_count
bogus_bytes_ptr
orig_line_ptr
line_ptr
section_start
line_ptr_actuals
line_ptr_end
address_size
err_count_out
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
static
void
do_line_print_now
Dwarf_Debug
dbg
int
line_version
Dwarf_Small
comp_dir
Dwarf_Line_Context
line_context
dwarfstring
m7
Dwarf_Unsigned
i
dwarfstring_constructor
dwarfstring_append_printf_i
total
line
info
length
ld
bytes
line_context
lc_total_length
dwarfstring_append_printf_u
line
offset
DW_PR_XZEROS
DW_PR_DUx
line_context
lc_section_offset
dwarfstring_append_printf_u
DW_PR_DUu
n
line_context
lc_section_offset
if
line_version
DW_LINE_VERSION5
dwarfstring_append_printf_i
line
table
version
d
n
int
line_context
lc_version_number
else
dwarfstring_append_printf_u
line
table
version
x
n
int
line_context
lc_version_number
if
line_version
DW_LINE_VERSION5
dwarfstring_append_printf_i
address
size
d
n
line_context
lc_address_size
dwarfstring_append_printf_i
segment
selector
size
d
n
line_context
lc_segment_selector_size
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_append_printf_i
line
table
length
field
length
d
n
line_context
lc_length_field_length
dwarfstring_append_printf_i
prologue
length
d
n
line_context
lc_prologue_length
dwarfstring_append_printf_s
compilation_directory
s
n
comp_dir
char
comp_dir
dwarfstring_append_printf_i
min
instruction
length
d
n
line_context
lc_minimum_instruction_length
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
if
line_version
DW_LINE_VERSION5
line_version
DW_LINE_VERSION4
line_version
EXPERIMENTAL_LINE_TABLES_VERSION
dwarfstring_append_printf_u
maximum
ops
per
instruction
u
n
line_context
lc_maximum_ops_per_instruction
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
if
line_version
EXPERIMENTAL_LINE_TABLES_VERSION
dwarfstring_append_printf_u
actuals
table
offset
DW_PR_XZEROS
DW_PR_DUx
n
line_context
lc_actuals_table_offset
dwarfstring_append_printf_u
logicals
table
offset
DW_PR_XZEROS
DW_PR_DUx
n
line_context
lc_logicals_table_offset
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_append_printf_i
default
is
stmt
d
n
int
line_context
lc_default_is_stmt
dwarfstring_append_printf_i
line
base
d
n
int
line_context
lc_line_base
dwarfstring_append_printf_i
line_range
d
n
int
line_context
lc_line_range
dwarfstring_append_printf_i
opcode
base
d
n
int
line_context
lc_opcode_base
dwarfstring_append_printf_i
standard
opcode
count
d
n
int
line_context
lc_std_op_count
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
for
i
i
line_context
lc_opcode_base
i
dwarfstring_append_printf_i
opcode
length
int
i
dwarfstring_append_printf_i
d
n
int
line_context
lc_opcode_length_table
i
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
dwarfstring_destructor
static
void
print_experimental_counts
Dwarf_Debug
dbg
int
line_version
Dwarf_Line_Context
line_context
if
line_version
EXPERIMENTAL_LINE_TABLES_VERSION
print_experimental_subprograms_list
dbg
line_context
static
int
print_actuals_and_locals
Dwarf_Debug
dbg
Dwarf_Line_Context
line_context
Dwarf_Unsigned
bogus_bytes_count
Dwarf_Small
bogus_bytes_ptr
Dwarf_Small
orig_line_ptr
Dwarf_Small
line_ptr
Dwarf_Small
section_start
Dwarf_Small
line_ptr_actuals
Dwarf_Small
line_ptr_end
Dwarf_Half
address_size
int
err_count_out
Dwarf_Error
error
int
res
dwarfstring
m8
Dwarf_Unsigned
offset
dwarfstring_constructor
if
bogus_bytes_count
Dwarf_Unsigned
wcount
bogus_bytes_count
Dwarf_Unsigned
boffset
bogus_bytes_ptr
section_start
dwarfstring_append_printf_u
DWARF
CHECK
the
line
table
prologue
header_length
is
DW_PR_DUu
too
high
we
pretend
it
is
smaller
wcount
dwarfstring_append_printf_u
Section
offset
DW_PR_XZEROS
DW_PR_DUx
boffset
dwarfstring_append_printf_u
DW_PR_DUu
n
boffset
err_count_out
offset
line_ptr
section_start
dwarfstring_append_printf_u
statement
prog
offset
in
section
DW_PR_XZEROS
DW_PR_DUx
offset
dwarfstring_append_printf_u
DW_PR_DUu
n
offset
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_reset
Dwarf_Bool
doaddrs
false
Dwarf_Bool
dolines
true
if
line_ptr_actuals
Normal
single
level
line
table
Dwarf_Bool
is_single_table
true
Dwarf_Bool
is_actuals_table
false
print_line_header
dbg
is_single_table
is_actuals_table
res
read_line_table_program
dbg
line_ptr
line_ptr_end
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
is_single_table
is_actuals_table
error
err_count_out
if
res
DW_DLV_OK
dwarfstring_destructor
dwarf_srclines_dealloc_b
line_context
return
res
else
Dwarf_Bool
is_single_table
false
Dwarf_Bool
is_actuals_table
false
if
line_context
lc_version_number
EXPERIMENTAL_LINE_TABLES_VERSION
dwarf_srclines_dealloc_b
line_context
dwarfstring_destructor
_dwarf_error
dbg
error
DW_DLE_VERSION_STAMP_ERROR
return
DW_DLV_ERROR
Read
Logicals
print_line_header
dbg
is_single_table
is_actuals_table
res
read_line_table_program
dbg
line_ptr
line_ptr_actuals
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
is_single_table
is_actuals_table
error
err_count_out
if
res
DW_DLV_OK
dwarfstring_destructor
dwarf_srclines_dealloc_b
line_context
return
res
if
line_context
lc_actuals_table_offset
is_actuals_table
true
Read
Actuals
print_line_header
dbg
is_single_table
is_actuals_table
res
read_line_table_program
dbg
line_ptr_actuals
line_ptr_end
orig_line_ptr
section_start
line_context
address_size
doaddrs
dolines
is_single_table
is_actuals_table
error
err_count_out
if
res
DW_DLV_OK
dwarfstring_destructor
dwarf_srclines_dealloc_b
line_context
return
res
dwarfstring_destructor
dwarf_srclines_dealloc_b
line_context
return
DW_DLV_OK
This
is
support
for
dwarfdump
making
it
possible
for
clients
wanting
line
detail
info
on
stdout
to
get
that
detail
without
including
internal
libdwarf
header
information
Caller
passes
in
compilation
unit
DIE
These
print_lines
functions
print
two
level
tables
in
full
even
when
the
user
is
not
asking
for
both
ie
when
the
caller
asked
for
dwarf_srclines
It
was
an
accident
but
after
a
short
reflection
this
seems
like
a
good
idea
for
vvv
int
dwarf_print_lines
Dwarf_Die
die
Dwarf_Error
error
int
error_count
int
only_line_header
int
res
_dwarf_internal_printlines
die
error_count
only_line_header
error
return
res
The
check
is
in
case
we
are
not
printing
full
line
data
this
gets
some
of
the
issues
noted
with
debug_line
but
not
all
Call
dwarf_print_lines
to
get
all
issues
Intended
for
apps
like
dwarfdump
dwarf_check_lineheader_b
new
April
int
dwarf_check_lineheader_b
Dwarf_Die
die
int
err_count_out
Dwarf_Error
err
int
res
int
only_line_header
res
_dwarf_internal_printlines
die
err_count_out
only_line_header
err
return
res
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Reads
DWARF3
debug_pubtypes
section
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_types
h
include
dwarf_global
h
int
dwarf_get_pubtypes
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
ret_type_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_pubtypes
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_pubtypes
dss_size
return
DW_DLV_NO_ENTRY
res
_dwarf_internal_get_pubnames_like_data
dbg
debug_pubtypes
dbg
de_debug_pubtypes
dss_data
dbg
de_debug_pubtypes
dss_size
Dwarf_Global
types
Type
punning
for
sections
with
identical
format
ret_type_count
error
DW_DLA_PUBTYPES_CONTEXT
DW_DLA_GLOBAL
We
don
t
have
DW_DLA_PUBTYPES
so
use
DW_DLA_GLOBAL
DW_DLE_DEBUG_PUBTYPES_LENGTH_BAD
DW_DLE_DEBUG_PUBTYPES_VERSION_ERROR
return
res
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_pubtypes_dealloc
Dwarf_Debug
dbg
Dwarf_Type
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
Dwarf_Global
dwgl
count
return
int
dwarf_pubtypename
Dwarf_Type
type_in
char
ret_name
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
if
type
NULL
_dwarf_error
NULL
error
DW_DLE_TYPE_NULL
return
DW_DLV_ERROR
ret_name
char
type
gl_name
return
DW_DLV_OK
int
dwarf_pubtype_type_die_offset
Dwarf_Type
type_in
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_die_offset
type
ret_offset
error
int
dwarf_pubtype_cu_offset
Dwarf_Type
type_in
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_cu_offset
type
ret_offset
error
int
dwarf_pubtype_name_offsets
Dwarf_Type
type_in
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_die_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_name_offsets
type
returned_name
die_offset
cu_die_offset
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
Google
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_die_deliv
h
include
dwarfstring
h
static
int
_dwarf_die_attr_unsigned_constant
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Unsigned
return_val
Dwarf_Error
error
int
dwarf_get_offset_size
Dwarf_Debug
dbg
Dwarf_Half
offset_size
Dwarf_Error
error
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
offset_size
dbg
de_length_size
return
DW_DLV_OK
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
msg
for
cur
end
cur
printf
cur
printf
n
endif
This
is
normally
reliable
But
not
always
If
different
compilation
units
have
different
address
sizes
this
may
not
give
the
correct
value
in
all
contexts
If
the
Elf
offset
size
address_size
for
example
if
address_size
but
recorded
in
elf64
object
this
may
not
give
the
correct
value
in
all
contexts
int
dwarf_get_address_size
Dwarf_Debug
dbg
Dwarf_Half
ret_addr_size
Dwarf_Error
error
Dwarf_Half
address_size
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
address_size
dbg
de_pointer_size
ret_addr_size
address_size
return
DW_DLV_OK
This
will
be
correct
in
all
contexts
where
the
CU
context
of
a
DIE
is
known
int
dwarf_get_die_address_size
Dwarf_Die
die
Dwarf_Half
ret_addr_size
Dwarf_Error
error
Dwarf_Half
address_size
CHECK_DIE
die
DW_DLV_ERROR
address_size
die
di_cu_context
cc_address_size
ret_addr_size
address_size
return
DW_DLV_OK
int
dwarf_dieoffset
Dwarf_Die
die
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Small
dataptr
Dwarf_Debug
dbg
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
dataptr
die
di_is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
ret_offset
die
di_debug_ptr
dataptr
return
DW_DLV_OK
This
function
returns
the
offset
of
the
die
relative
to
the
start
of
its
compilation
unit
rather
than
debug_info
Returns
DW_DLV_ERROR
on
error
int
dwarf_die_CU_offset
Dwarf_Die
die
Dwarf_Off
cu_off
Dwarf_Error
error
Dwarf_CU_Context
cu_context
Dwarf_Small
dataptr
Dwarf_Debug
dbg
CHECK_DIE
die
DW_DLV_ERROR
cu_context
die
di_cu_context
dbg
die
di_cu_context
cc_dbg
dataptr
die
di_is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
cu_off
die
di_debug_ptr
dataptr
cu_context
cc_debug_offset
return
DW_DLV_OK
A
common
function
to
get
both
offsets
local
and
global
It
s
unusual
in
that
it
sets
both
return
offsets
to
zero
on
entry
Normally
we
only
set
any
output
args
through
their
pointers
in
case
of
success
int
dwarf_die_offsets
Dwarf_Die
die
Dwarf_Off
off
Dwarf_Off
cu_off
Dwarf_Error
error
int
res
Dwarf_Off
lcuoff
Dwarf_Off
loff
res
dwarf_dieoffset
die
error
if
res
DW_DLV_OK
res
dwarf_die_CU_offset
die
error
if
res
DW_DLV_OK
Waiting
till
both
succeed
before
returning
any
value
at
all
to
retain
normal
libdwarf
call
semantics
off
loff
cu_off
lcuoff
else
off
cu_off
return
res
This
function
returns
the
global
offset
meaning
the
section
offset
and
length
of
the
CU
that
this
die
is
a
part
of
Used
for
correctness
checking
by
dwarfdump
int
dwarf_die_CU_offset_range
Dwarf_Die
die
Dwarf_Off
cu_off
Dwarf_Off
cu_length
Dwarf_Error
error
Dwarf_CU_Context
cu_context
CHECK_DIE
die
DW_DLV_ERROR
cu_context
die
di_cu_context
cu_off
cu_context
cc_debug_offset
cu_length
cu_context
cc_length
cu_context
cc_length_size
cu_context
cc_extension_size
return
DW_DLV_OK
int
dwarf_tag
Dwarf_Die
die
Dwarf_Half
tag
Dwarf_Error
error
CHECK_DIE
die
DW_DLV_ERROR
tag
die
di_abbrev_list
abl_tag
return
DW_DLV_OK
Returns
the
children
offsets
for
the
given
offset
int
dwarf_offset_list
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Off
offbuf
Dwarf_Unsigned
offcnt
Dwarf_Error
error
Dwarf_Die
die
Dwarf_Die
child
Dwarf_Die
sib_die
Dwarf_Die
cur_die
Dwarf_Unsigned
off_count
int
res
Temporary
counter
Dwarf_Unsigned
i
Points
to
contiguous
block
of
Dwarf_Off
s
to
be
returned
Dwarf_Off
ret_offsets
Dwarf_Chain_2
curr_chain
Dwarf_Chain_2
prev_chain
Dwarf_Chain_2
head_chain
offbuf
NULL
offcnt
Get
DIE
for
offset
res
dwarf_offdie_b
dbg
offset
is_info
error
if
DW_DLV_OK
res
return
res
Get
first
child
for
die
res
dwarf_child
die
error
if
DW_DLV_ERROR
res
DW_DLV_NO_ENTRY
res
return
res
cur_die
child
for
if
DW_DLV_OK
res
int
dres
Dwarf_Off
cur_off
Get
Global
offset
for
current
die
dres
dwarf_dieoffset
cur_die
error
if
dres
DW_DLV_OK
Normal
use
cur_off
else
if
dres
DW_DLV_ERROR
Should
be
impossible
unless
avoid
leak
Just
leave
cur_off
as
zero
dwarf_dealloc
dbg
error
DW_DLA_ERROR
error
NULL
return
DW_DLV_ERROR
else
DW_DLV_NO_ENTRY
Impossible
dwarf_dieoffset
never
returns
this
Record
offset
in
current
entry
chain
curr_chain
Dwarf_Chain_2
_dwarf_get_alloc
dbg
DW_DLA_CHAIN_2
if
curr_chain
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Put
current
offset
on
singly_linked
list
curr_chain
ch_item
cur_off
off_count
if
head_chain
NULL
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
Process
any
siblings
entries
if
any
sib_die
res
dwarf_siblingof_b
dbg
cur_die
is_info
error
if
DW_DLV_ERROR
res
return
res
if
DW_DLV_NO_ENTRY
res
Done
at
this
level
break
res
DW_DLV_OK
if
cur_die
die
dwarf_dealloc
dbg
cur_die
DW_DLA_DIE
cur_die
sib_die
Points
to
contiguous
block
of
Dwarf_Off
s
ret_offsets
Dwarf_Off
_dwarf_get_alloc
dbg
DW_DLA_ADDR
off_count
if
ret_offsets
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Store
offsets
in
contiguous
block
and
deallocate
the
chain
curr_chain
head_chain
for
i
i
off_count
i
ret_offsets
i
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN_2
offbuf
ret_offsets
offcnt
off_count
return
DW_DLV_OK
static
void
empty_local_attrlist
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_Attribute
cur
Dwarf_Attribute
next
for
cur
attr
cur
cur
next
next
cur
ar_next
dwarf_dealloc
dbg
cur
DW_DLA_ATTR
Now
we
use
_wrapper
here
We
cannot
leak
memory
int
dwarf_attrlist
Dwarf_Die
die
Dwarf_Attribute
attrbuf
Dwarf_Signed
attrcnt
Dwarf_Error
error
Dwarf_Unsigned
attr_count
Dwarf_Unsigned
attr
Dwarf_Unsigned
attr_form
Dwarf_Unsigned
i
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_end
Dwarf_Abbrev_List
abbrev_list
Dwarf_Attribute
head_attr
NULL
Dwarf_Attribute
curr_attr
NULL
Dwarf_Attribute
attr_ptr
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
info_ptr
Dwarf_Byte_Ptr
die_info_end
int
lres
Dwarf_CU_Context
context
Dwarf_Unsigned
highest_code
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dbg
context
cc_dbg
die_info_end
_dwarf_calculate_info_section_end_ptr
context
lres
_dwarf_get_abbrev_for_code
context
die
di_abbrev_list
abl_code
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ABBREV_MISSING
There
is
no
abbrev
present
for
code
u
in
this
compilation
unit
die
di_abbrev_list
abl_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_ABBREV_MISSING
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
abbrev_ptr
abbrev_list
abl_abbrev_ptr
abbrev_end
_dwarf_calculate_abbrev_section_end_ptr
context
info_ptr
die
di_debug_ptr
SKIP_LEB128
Dwarf_Unsigned
ignore_this
Dwarf_Unsigned
len
lres
dwarf_decode_leb128
char
info_ptr
char
die_info_end
if
lres
DW_DLV_ERROR
Stepped
off
the
end
SKIPping
the
leb
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DIE_BAD
In
building
an
attrlist
we
run
off
the
end
of
the
DIE
while
skipping
the
DIE
tag
seeing
the
leb
length
as
u
len
_dwarf_error_string
dbg
error
DW_DLE_DIE_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
info_ptr
len
do
Dwarf_Signed
implicit_const
Dwarf_Attribute
new_attr
int
res
The
DECODE
have
to
be
wrapped
in
functions
to
catch
errors
before
return
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp2
dbg
error
abbrev_end
res
_dwarf_leb128_uword_wrapper
dbg
abbrev_end
error
if
res
DW_DLV_ERROR
empty_local_attrlist
dbg
head_attr
return
res
if
attr
DW_AT_hi_user
empty_local_attrlist
dbg
head_attr
_dwarf_error
dbg
error
DW_DLE_ATTR_CORRUPT
return
DW_DLV_ERROR
DECODE_LEB128_UWORD_CK
abbrev_ptr
utmp2
dbg
error
abbrev_end
res
_dwarf_leb128_uword_wrapper
dbg
abbrev_end
error
if
res
DW_DLV_ERROR
empty_local_attrlist
dbg
head_attr
return
res
if
_dwarf_valid_form_we_know
attr_form
attr
empty_local_attrlist
dbg
head_attr
_dwarf_error
dbg
error
DW_DLE_UNKNOWN_FORM
return
DW_DLV_ERROR
if
attr_form
DW_FORM_implicit_const
The
value
is
here
not
in
a
DIE
res
_dwarf_leb128_sword_wrapper
dbg
abbrev_end
error
if
res
DW_DLV_ERROR
empty_local_attrlist
dbg
head_attr
return
res
DECODE_LEB128_SWORD_CK
abbrev_ptr
implicit_const
dbg
error
abbrev_end
if
_dwarf_valid_form_we_know
attr_form
attr
empty_local_attrlist
dbg
head_attr
_dwarf_error
dbg
error
DW_DLE_UNKNOWN_FORM
return
DW_DLV_ERROR
if
attr
new_attr
Dwarf_Attribute
_dwarf_get_alloc
dbg
DW_DLA_ATTR
if
new_attr
NULL
empty_local_attrlist
dbg
head_attr
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
new_attr
ar_attribute
attr
new_attr
ar_attribute_form_direct
attr_form
new_attr
ar_attribute_form
attr_form
if
attr_form
DW_FORM_indirect
Dwarf_Unsigned
utmp6
if
_dwarf_reference_outside_section
die
Dwarf_Small
info_ptr
Dwarf_Small
info_ptr
dwarf_dealloc
dbg
new_attr
DW_DLA_ATTR
empty_local_attrlist
dbg
head_attr
_dwarf_error_string
dbg
error
DW_DLE_ATTR_OUTSIDE_SECTION
DW_DLE_ATTR_OUTSIDE_SECTION
Reading
Attriutes
For
DW_FORM_indirect
there
is
no
room
for
the
form
Corrupt
Dwarf
return
DW_DLV_ERROR
DECODE_LEB128_UWORD
does
info_ptr
update
DECODE_LEB128_UWORD_CK
info_ptr
utmp6
dbg
error
die_info_end
res
_dwarf_leb128_uword_wrapper
dbg
die_info_end
error
attr_form
Dwarf_Half
utmp6
new_attr
ar_attribute_form
attr_form
Here
the
final
address
must
be
inside
the
section
as
we
will
read
from
there
and
read
at
least
one
byte
we
think
We
do
not
want
info_ptr
to
point
past
end
so
we
add
to
the
end
pointer
if
attr_form
DW_FORM_implicit_const
_dwarf_reference_outside_section
die
Dwarf_Small
info_ptr
Dwarf_Small
info_ptr
dwarf_dealloc
dbg
new_attr
DW_DLA_ATTR
empty_local_attrlist
dbg
head_attr
_dwarf_error_string
dbg
error
DW_DLE_ATTR_OUTSIDE_SECTION
DW_DLE_ATTR_OUTSIDE_SECTION
Reading
Attriutes
We
have
run
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
new_attr
ar_cu_context
die
di_cu_context
new_attr
ar_debug_ptr
info_ptr
new_attr
ar_die
die
new_attr
ar_dbg
dbg
if
attr_form
DW_FORM_implicit_const
The
value
is
here
not
in
a
DIE
Do
not
increment
info_ptr
new_attr
ar_implicit_const
implicit_const
else
Dwarf_Unsigned
sov
int
vres
vres
_dwarf_get_size_of_val
dbg
attr_form
die
di_cu_context
cc_version_stamp
die
di_cu_context
cc_address_size
info_ptr
die
di_cu_context
cc_length_size
die_info_end
error
if
vres
DW_DLV_OK
dwarf_dealloc
dbg
new_attr
DW_DLA_ATTR
empty_local_attrlist
dbg
head_attr
return
vres
info_ptr
sov
if
head_attr
NULL
head_attr
curr_attr
new_attr
else
curr_attr
ar_next
new_attr
curr_attr
new_attr
attr_count
while
attr
attr_form
if
attr_count
attrbuf
NULL
attrcnt
return
DW_DLV_NO_ENTRY
attr_ptr
Dwarf_Attribute
_dwarf_get_alloc
dbg
DW_DLA_LIST
attr_count
if
attr_ptr
NULL
empty_local_attrlist
dbg
head_attr
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_attr
head_attr
for
i
i
attr_count
i
attr_ptr
i
curr_attr
curr_attr
curr_attr
ar_next
attrbuf
attr_ptr
attrcnt
attr_count
return
DW_DLV_OK
This
function
takes
a
die
and
an
attr
and
returns
a
pointer
to
the
start
of
the
value
of
that
attr
in
the
given
die
in
the
debug_info
section
The
form
is
returned
in
attr_form
If
the
attr_form
is
DW_FORM_implicit_const
known
signed
so
most
callers
that
is
fine
but
in
that
case
we
do
not
need
to
actually
set
the
ptr_to_value
Returns
NULL
on
error
or
if
attr
is
not
found
However
attr_form
is
on
error
and
positive
otherwise
static
int
_dwarf_get_value_ptr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Half
attr_form
Dwarf_Byte_Ptr
ptr_to_value
Dwarf_Signed
implicit_const_out
Dwarf_Error
error
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_end
Dwarf_Abbrev_List
abbrev_list
Dwarf_Half
curr_attr
Dwarf_Half
curr_attr_form
Dwarf_Byte_Ptr
info_ptr
Dwarf_CU_Context
context
die
di_cu_context
Dwarf_Byte_Ptr
die_info_end
Dwarf_Debug
dbg
int
lres
Dwarf_Unsigned
highest_code
if
context
_dwarf_error
NULL
error
DW_DLE_DIE_NO_CU_CONTEXT
return
DW_DLV_ERROR
dbg
context
cc_dbg
die_info_end
_dwarf_calculate_info_section_end_ptr
context
lres
_dwarf_get_abbrev_for_code
context
die
di_abbrev_list
abl_code
error
if
lres
DW_DLV_ERROR
return
lres
if
lres
DW_DLV_NO_ENTRY
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_CU_DIE_NO_ABBREV_LIST
There
is
no
abbrev
present
for
code
u
in
this
compilation
unit
die
di_abbrev_list
abl_code
dwarfstring_append_printf_u
The
highest
known
code
in
any
compilation
unit
is
u
highest_code
_dwarf_error_string
dbg
error
DW_DLE_CU_DIE_NO_ABBREV_LIST
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
abbrev_ptr
abbrev_list
abl_abbrev_ptr
abbrev_end
_dwarf_calculate_abbrev_section_end_ptr
context
info_ptr
die
di_debug_ptr
This
ensures
and
checks
die_info_end
info_ptr
SKIP_LEB128
Dwarf_Unsigned
ignore_this
Dwarf_Unsigned
len
lres
dwarf_decode_leb128
char
info_ptr
char
die_info_end
if
lres
DW_DLV_ERROR
Stepped
off
the
end
SKIPping
the
leb
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DIE_BAD
In
building
an
attrlist
we
run
off
the
end
of
the
DIE
while
skipping
the
DIE
tag
seeing
the
leb
length
as
u
len
_dwarf_error_string
dbg
error
DW_DLE_DIE_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
info_ptr
len
do
Dwarf_Unsigned
formtmp3
Dwarf_Unsigned
atmp3
Dwarf_Unsigned
value_size
Dwarf_Signed
implicit_const
int
res
DECODE_LEB128_UWORD_CK
abbrev_ptr
atmp3
dbg
error
abbrev_end
if
atmp3
DW_AT_hi_user
_dwarf_error
dbg
error
DW_DLE_ATTR_CORRUPT
return
DW_DLV_ERROR
curr_attr
Dwarf_Half
atmp3
DECODE_LEB128_UWORD_CK
abbrev_ptr
formtmp3
dbg
error
abbrev_end
if
_dwarf_valid_form_we_know
formtmp3
curr_attr
_dwarf_error
dbg
error
DW_DLE_UNKNOWN_FORM
return
DW_DLV_ERROR
curr_attr_form
Dwarf_Half
formtmp3
if
curr_attr_form
DW_FORM_indirect
Dwarf_Unsigned
utmp6
DECODE_LEB128_UWORD
updates
info_ptr
DECODE_LEB128_UWORD_CK
info_ptr
utmp6
dbg
error
die_info_end
curr_attr_form
Dwarf_Half
utmp6
if
curr_attr_form
DW_FORM_implicit_const
The
value
is
here
not
in
a
DIE
DECODE_LEB128_SWORD_CK
abbrev_ptr
implicit_const
dbg
error
abbrev_end
if
curr_attr
attr
attr_form
curr_attr_form
if
implicit_const_out
implicit_const_out
implicit_const
ptr_to_value
info_ptr
return
DW_DLV_OK
res
_dwarf_get_size_of_val
dbg
curr_attr_form
die
di_cu_context
cc_version_stamp
die
di_cu_context
cc_address_size
info_ptr
die
di_cu_context
cc_length_size
die_info_end
error
if
res
DW_DLV_OK
return
res
Dwarf_Unsigned
len
ptrdiff_t
is
generated
but
not
named
len
die_info_end
info_ptr
die_info_end
info_ptr
if
value_size
len
Something
badly
wrong
We
point
past
end
of
debug_info
or
debug_types
or
a
section
is
unreasonably
sized
or
we
are
pointing
to
two
different
sections?
_dwarf_error
dbg
error
DW_DLE_DIE_ABBREV_BAD
return
DW_DLV_ERROR
info_ptr
value_size
while
curr_attr
curr_attr_form
return
DW_DLV_NO_ENTRY
int
dwarf_die_text
Dwarf_Die
die
Dwarf_Half
attrnum
char
ret_name
Dwarf_Error
error
Dwarf_Debug
dbg
int
res
DW_DLV_ERROR
Dwarf_Attribute
attr
Dwarf_Error
lerr
CHECK_DIE
die
DW_DLV_ERROR
res
dwarf_attr
die
attrnum
dbg
die
di_cu_context
cc_dbg
if
res
DW_DLV_ERROR
return
DW_DLV_NO_ENTRY
if
res
DW_DLV_NO_ENTRY
return
res
res
dwarf_formstring
attr
ret_name
error
dwarf_dealloc
dbg
attr
DW_DLA_ATTR
attr
return
res
int
dwarf_diename
Dwarf_Die
die
char
ret_name
Dwarf_Error
error
return
dwarf_die_text
die
DW_AT_name
ret_name
error
int
dwarf_hasattr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Bool
return_bool
Dwarf_Error
error
Dwarf_Half
attr_form
Dwarf_Byte_Ptr
info_ptr
int
res
Dwarf_Signed
implicit_const
CHECK_DIE
die
DW_DLV_ERROR
res
_dwarf_get_value_ptr
die
attr
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return_bool
false
return
DW_DLV_OK
return_bool
true
return
DW_DLV_OK
int
dwarf_attr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Attribute
ret_attr
Dwarf_Error
error
Dwarf_Half
attr_form
Dwarf_Attribute
attrib
Dwarf_Byte_Ptr
info_ptr
Dwarf_Debug
dbg
int
res
Dwarf_Signed
implicit_const
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
res
_dwarf_get_value_ptr
die
attr
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
attrib
Dwarf_Attribute
_dwarf_get_alloc
dbg
DW_DLA_ATTR
if
attrib
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
allocating
a
single
Dwarf_Attribute
in
function
dwarf_attr
return
DW_DLV_ERROR
attrib
ar_attribute
attr
attrib
ar_attribute_form
attr_form
attrib
ar_attribute_form_direct
attr_form
attrib
ar_cu_context
die
di_cu_context
Only
nonzero
if
DW_FORM_implicit_const
attrib
ar_implicit_const
implicit_const
Only
nonnull
if
not
DW_FORM_implicit_const
attrib
ar_debug_ptr
info_ptr
attrib
ar_die
die
attrib
ar_dbg
dbg
ret_attr
attrib
return
DW_DLV_OK
A
DWP
dwp
package
object
never
contains
debug_addr
only
a
normal
o
or
executable
object
Error
returned
here
is
on
dbg
not
tieddbg
This
looks
for
DW_AT_addr_base
and
if
present
adds
it
in
appropriately
You
should
use
_dwarf_look_in_local_and_tied_by_index
instead
of
this
in
general
static
int
_dwarf_extract_address_from_debug_addr
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
index_to_addr
Dwarf_Addr
addr_out
Dwarf_Error
error
Dwarf_Unsigned
address_base
Dwarf_Unsigned
addrindex
index_to_addr
Dwarf_Unsigned
addr_offset
Dwarf_Unsigned
ret_addr
int
res
Dwarf_Byte_Ptr
sectionstart
Dwarf_Byte_Ptr
sectionend
Dwarf_Unsigned
sectionsize
address_base
context
cc_addr_base
res
_dwarf_load_section
dbg
de_debug_addr
error
if
res
DW_DLV_OK
Ignore
the
inner
error
report
something
meaningful
if
res
DW_DLV_ERROR
dwarf_dealloc
dbg
error
DW_DLA_ERROR
error
_dwarf_error
dbg
error
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
return
DW_DLV_ERROR
DW_FORM_addrx
has
a
base
value
from
the
CU
die
DW_AT_addr_base
DW_OP_addrx
and
DW_OP_constx
rely
on
DW_AT_addr_base
too
DW_FORM_GNU_addr_index
relies
on
DW_AT_GNU_addr_base
which
is
in
the
CU
die
sectionstart
dbg
de_debug_addr
dss_data
addr_offset
address_base
addrindex
context
cc_address_size
The
offsets
table
is
a
series
of
address
size
entries
but
with
a
base
sectionsize
dbg
de_debug_addr
dss_size
sectionend
sectionstart
sectionsize
if
addr_offset
sectionsize
context
cc_address_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ATTR_FORM_SIZE_BAD
Extracting
an
address
from
debug_addr
fails
as
the
offset
is
x
addr_offset
dwarfstring_append_printf_u
but
the
object
section
is
just
x
bytes
long
so
there
not
enough
space
for
an
address
sectionsize
_dwarf_error_string
dbg
error
DW_DLE_ATTR_FORM_SIZE_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
ret_addr
Dwarf_Addr
sectionstart
addr_offset
context
cc_address_size
error
sectionend
addr_out
ret_addr
return
DW_DLV_OK
int
_dwarf_look_in_local_and_tied_by_index
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
index
Dwarf_Addr
return_addr
Dwarf_Error
error
int
res2
res2
_dwarf_extract_address_from_debug_addr
dbg
context
index
return_addr
error
if
res2
DW_DLV_OK
if
res2
DW_DLV_ERROR
error
dwarf_errno
error
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
dbg
de_tied_data
td_tied_object
int
res3
We
do
not
want
to
leak
error
structs
dwarf_dealloc
dbg
error
DW_DLA_ERROR
error
error
is
returned
on
dbg
not
tieddbg
res3
_dwarf_get_addr_from_tied
dbg
context
index
return_addr
error
return
res3
return
res2
return
DW_DLV_OK
The
DIE
here
can
be
any
DIE
in
the
relevant
CU
index
is
an
index
into
debug_addr
int
dwarf_debug_addr_index_to_addr
Dwarf_Die
die
Dwarf_Unsigned
index
Dwarf_Addr
return_addr
Dwarf_Error
error
Dwarf_Debug
dbg
Dwarf_CU_Context
context
int
res
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
dbg
context
cc_dbg
error
is
returned
on
dbg
not
tieddbg
res
_dwarf_look_in_local_and_tied_by_index
dbg
context
index
return_addr
error
return
res
ASSERT
attr_form
DW_FORM_GNU_addr_index
attr_form
DW_FORM_addrx
int
_dwarf_look_in_local_and_tied
Dwarf_Half
attr_form
Dwarf_CU_Context
context
Dwarf_Small
info_ptr
Dwarf_Addr
return_addr
Dwarf_Error
error
int
res2
Dwarf_Unsigned
index_to_addr
Dwarf_Debug
dbg
We
get
the
index
It
might
apply
here
or
in
tied
object
Checking
that
next
dbg
context
cc_dbg
res2
_dwarf_get_addr_index_itself
attr_form
info_ptr
dbg
context
error
if
res2
DW_DLV_OK
return
res2
error
is
returned
on
dbg
not
tieddbg
res2
_dwarf_look_in_local_and_tied_by_index
dbg
context
index_to_addr
return_addr
error
return
res2
int
dwarf_lowpc
Dwarf_Die
die
Dwarf_Addr
return_addr
Dwarf_Error
error
Dwarf_Addr
ret_addr
Dwarf_Byte_Ptr
info_ptr
Dwarf_Half
attr_form
Dwarf_Debug
dbg
Dwarf_Half
address_size
Dwarf_Half
offset_size
int
version
enum
Dwarf_Form_Class
class
DW_FORM_CLASS_UNKNOWN
int
res
Dwarf_CU_Context
context
die
di_cu_context
Dwarf_Small
die_info_end
CHECK_DIE
die
DW_DLV_ERROR
dbg
context
cc_dbg
address_size
context
cc_address_size
offset_size
context
cc_length_size
res
_dwarf_get_value_ptr
die
DW_AT_low_pc
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
version
context
cc_version_stamp
class
dwarf_get_form_class
version
DW_AT_low_pc
offset_size
attr_form
if
class
DW_FORM_CLASS_ADDRESS
Not
the
correct
form
for
DW_AT_low_pc
_dwarf_error
dbg
error
DW_DLE_LOWPC_WRONG_CLASS
return
DW_DLV_ERROR
if
attr_form
DW_FORM_GNU_addr_index
attr_form
DW_FORM_addrx
error
is
returned
on
dbg
not
tieddbg
res
_dwarf_look_in_local_and_tied
attr_form
context
info_ptr
return_addr
error
return
res
die_info_end
_dwarf_calculate_info_section_end_ptr
context
READ_UNALIGNED_CK
dbg
ret_addr
Dwarf_Addr
info_ptr
address_size
error
die_info_end
return_addr
ret_addr
return
DW_DLV_OK
This
works
for
DWARF2
and
DWARF3
but
fails
for
DWARF4
DW_AT_high_pc
attributes
of
class
constant
It
is
best
to
cease
using
this
interface
int
dwarf_highpc
Dwarf_Die
die
Dwarf_Addr
return_addr
Dwarf_Error
error
int
res
enum
Dwarf_Form_Class
class
DW_FORM_CLASS_UNKNOWN
Dwarf_Half
form
CHECK_DIE
die
DW_DLV_ERROR
res
dwarf_highpc_b
die
return_addr
error
if
res
DW_DLV_OK
return
res
if
form
DW_FORM_addr
Not
the
correct
form
for
DWARF2
DW_AT_high_pc
Dwarf_Debug
dbg
die
di_cu_context
cc_dbg
_dwarf_error
dbg
error
DW_DLE_HIGHPC_WRONG_FORM
return
DW_DLV_ERROR
return
DW_DLV_OK
If
the
giving
die
contains
the
DW_AT_type
attribute
it
returns
the
offset
referenced
by
the
attribute
In
case
of
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
it
sets
offset
zero
int
dwarf_dietype_offset
Dwarf_Die
die
Dwarf_Off
return_off
Dwarf_Error
error
int
res
Dwarf_Off
offset
Dwarf_Attribute
attr
CHECK_DIE
die
DW_DLV_ERROR
res
dwarf_attr
die
DW_AT_type
error
if
res
DW_DLV_OK
res
dwarf_global_formref
attr
error
dwarf_dealloc
die
di_cu_context
cc_dbg
attr
DW_DLA_ATTR
return_off
offset
return
res
int
_dwarf_merge_all_base_attrs_of_cu_die
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Debug
tieddbg
Dwarf_CU_Context
tiedcontext_out
Dwarf_Error
error
Dwarf_CU_Context
tiedcontext
int
res
if
tieddbg
return
DW_DLV_NO_ENTRY
if
context
cc_signature_present
return
DW_DLV_NO_ENTRY
res
_dwarf_search_for_signature
tieddbg
context
cc_signature
error
if
res
DW_DLV_ERROR
Associate
the
error
with
dbg
not
tieddbg
_dwarf_error_mv_s_to_t
tieddbg
error
dbg
error
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
if
context
cc_low_pc_present
context
cc_low_pc_present
tiedcontext
cc_low_pc_present
context
cc_low_pc
tiedcontext
cc_low_pc
if
context
cc_addr_base_present
context
cc_addr_base_present
tiedcontext
cc_addr_base_present
context
cc_addr_base
tiedcontext
cc_addr_base
if
context
cc_rnglists_base_present
context
cc_rnglists_base_present
tiedcontext
cc_rnglists_base_present
context
cc_rnglists_base
tiedcontext
cc_rnglists_base
if
context
cc_loclists_base_present
context
cc_loclists_base_present
tiedcontext
cc_loclists_base_present
context
cc_loclists_base
tiedcontext
cc_loclists_base
if
context
cc_str_offsets_base_present
context
cc_str_offsets_base_present
tiedcontext
cc_str_offsets_base_present
context
cc_str_offsets_base
tiedcontext
cc_str_offsets_base
GNU
DW4
extension
if
context
cc_ranges_base_present
context
cc_ranges_base_present
tiedcontext
cc_ranges_base_present
context
cc_ranges_base
tiedcontext
cc_ranges_base
if
tiedcontext_out
tiedcontext_out
tiedcontext
return
DW_DLV_OK
int
_dwarf_get_string_base_attr_value
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_CU_Context
context
Dwarf_Unsigned
sbase_out
Dwarf_Error
error
UNUSEDARG
if
context
cc_str_offsets_base_present
sbase_out
context
cc_str_offsets_base
return
DW_DLV_OK
sbase_out
return
DW_DLV_OK
Goes
to
the
CU
die
and
finds
the
DW_AT_GNU_addr_base
or
DW_AT_addr_base
and
gets
the
value
from
that
CU
die
and
returns
it
through
abase_out
If
we
cannot
find
the
value
it
is
a
serious
error
in
the
DWARF
This
works
for
all
versions
of
DWARF
This
is
the
preferred
interface
cease
using
dwarf_highpc
The
consumer
has
to
check
the
return_form
or
return_class
to
decide
if
the
value
returned
through
return_value
is
an
address
or
an
address
offset
See
DWARF4
section
Contiguous
Address
Range
int
dwarf_highpc_b
Dwarf_Die
die
Dwarf_Addr
return_value
Dwarf_Half
return_form
enum
Dwarf_Form_Class
return_class
Dwarf_Error
error
Dwarf_Byte_Ptr
info_ptr
Dwarf_Half
attr_form
Dwarf_Debug
dbg
Dwarf_Half
address_size
Dwarf_Half
offset_size
enum
Dwarf_Form_Class
class
DW_FORM_CLASS_UNKNOWN
Dwarf_Half
version
Dwarf_Byte_Ptr
die_info_end
int
res
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
address_size
die
di_cu_context
cc_address_size
res
_dwarf_get_value_ptr
die
DW_AT_high_pc
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
return
res
die_info_end
_dwarf_calculate_info_section_end_ptr
die
di_cu_context
version
die
di_cu_context
cc_version_stamp
offset_size
die
di_cu_context
cc_length_size
class
dwarf_get_form_class
version
DW_AT_high_pc
offset_size
attr_form
if
class
DW_FORM_CLASS_ADDRESS
Dwarf_Addr
addr
if
dwarf_addr_form_is_indexed
attr_form
Dwarf_Unsigned
addr_out
Dwarf_Unsigned
index_to_addr
int
res2
Dwarf_CU_Context
context
die
di_cu_context
index_to_addr
we
get
here
might
apply
to
this
dbg
or
to
tieddbg
error
is
returned
on
dbg
not
tied
res2
_dwarf_get_addr_index_itself
attr_form
info_ptr
dbg
context
error
if
res2
DW_DLV_OK
return
res2
res2
_dwarf_look_in_local_and_tied_by_index
dbg
context
index_to_addr
error
if
res2
DW_DLV_OK
return
res2
READ_UNALIGNED_CK
dbg
addr
Dwarf_Addr
info_ptr
address_size
error
die_info_end
return_value
addr
else
int
res3
Dwarf_Unsigned
v
res3
_dwarf_die_attr_unsigned_constant
die
DW_AT_high_pc
error
if
res3
DW_DLV_OK
Dwarf_Byte_Ptr
info_ptr2
res3
_dwarf_get_value_ptr
die
DW_AT_high_pc
error
if
res3
DW_DLV_ERROR
return
res3
if
res3
DW_DLV_NO_ENTRY
return
res3
if
attr_form
DW_FORM_sdata
Dwarf_Signed
sval
DWARF4
defines
the
value
as
an
unsigned
offset
in
section
DECODE_LEB128_UWORD_CK
info_ptr2
sval
dbg
error
die_info_end
return_value
Dwarf_Unsigned
sval
else
_dwarf_error
dbg
error
DW_DLE_HIGHPC_WRONG_FORM
return
DW_DLV_ERROR
else
return_value
v
Allow
null
args
starting
April
if
return_form
return_form
attr_form
if
return_class
return_class
class
return
DW_DLV_OK
The
dbg
and
context
here
are
a
file
with
DW_FORM_addrx
but
missing
debug_addr
So
go
to
the
tied
file
and
using
the
signature
from
the
current
context
locate
the
target
CU
in
the
tied
file
Then
get
the
address
int
_dwarf_get_addr_from_tied
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
index
Dwarf_Addr
addr_out
Dwarf_Error
error
Dwarf_Debug
tieddbg
int
res
Dwarf_Addr
local_addr
Dwarf_CU_Context
tiedcontext
if
context
cc_signature_present
_dwarf_error
dbg
error
DW_DLE_NO_SIGNATURE_TO_LOOKUP
return
DW_DLV_ERROR
tieddbg
dbg
de_tied_data
td_tied_object
if
tieddbg
_dwarf_error
dbg
error
DW_DLE_NO_TIED_ADDR_AVAILABLE
return
DW_DLV_ERROR
if
context
cc_addr_base_present
Does
not
exist
return
DW_DLV_NO_ENTRY
res
_dwarf_search_for_signature
tieddbg
context
cc_signature
error
if
res
DW_DLV_ERROR
Associate
the
error
with
dbg
not
tieddbg
_dwarf_error_mv_s_to_t
tieddbg
error
dbg
error
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
res
_dwarf_extract_address_from_debug_addr
tieddbg
tiedcontext
index
error
if
res
DW_DLV_ERROR
Associate
the
error
with
dbg
not
tidedbg
_dwarf_error_mv_s_to_t
tieddbg
error
dbg
error
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
addr_out
local_addr
return
DW_DLV_OK
Takes
a
die
an
attribute
attr
and
checks
if
attr
occurs
in
die
Attr
is
required
to
be
an
attribute
whose
form
is
in
the
constant
class
If
attr
occurs
in
die
the
value
is
returned
It
does
not
really
allow
for
a
signed
constant
and
DWARF
does
not
always
specify
that
only
non
negative
values
are
allowed
Returns
DW_DLV_OK
DW_DLV_ERROR
or
DW_DLV_NO_ENTRY
as
appropriate
Sets
the
value
thru
the
pointer
return_val
This
function
is
meant
to
do
all
the
processing
for
dwarf_bytesize
dwarf_bitsize
dwarf_bitoffset
and
dwarf_srclang
And
it
helps
in
dwarf_highpc_with_form
static
int
_dwarf_die_attr_unsigned_constant
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Unsigned
return_val
Dwarf_Error
error
Dwarf_Byte_Ptr
info_ptr
Dwarf_Half
attr_form
Dwarf_Unsigned
ret_value
Dwarf_Signed
implicit_const_value
Dwarf_Debug
dbg
int
res
Dwarf_Byte_Ptr
die_info_end
CHECK_DIE
die
DW_DLV_ERROR
die_info_end
_dwarf_calculate_info_section_end_ptr
die
di_cu_context
dbg
die
di_cu_context
cc_dbg
res
_dwarf_get_value_ptr
die
attr
error
if
res
DW_DLV_OK
return
res
switch
attr_form
case
DW_FORM_data1
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
info_ptr
sizeof
Dwarf_Small
error
die_info_end
return_val
ret_value
return
DW_DLV_OK
case
DW_FORM_data2
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
info_ptr
sizeof
Dwarf_Shalf
error
die_info_end
return_val
ret_value
return
DW_DLV_OK
case
DW_FORM_data4
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
info_ptr
DWARF_32BIT_SIZE
error
die_info_end
return_val
ret_value
return
DW_DLV_OK
case
DW_FORM_data8
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
info_ptr
DWARF_64BIT_SIZE
error
die_info_end
return_val
ret_value
return
DW_DLV_OK
case
DW_FORM_udata
Dwarf_Unsigned
v
DECODE_LEB128_UWORD_CK
info_ptr
v
dbg
error
die_info_end
return_val
v
return
DW_DLV_OK
case
DW_FORM_implicit_const
if
implicit_const_value
Dwarf_Signed
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_i
DW_DLE_NEGATIVE_SIZE
An
implicit
const
value
of
d
is
inappropriate
as
a
size
implicit_const_value
_dwarf_error_string
dbg
error
DW_DLE_NEGATIVE_SIZE
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return_val
implicit_const_value
return
DW_DLV_OK
default
_dwarf_error
dbg
error
DW_DLE_DIE_BAD
return
DW_DLV_ERROR
Size
Value
is
not
specified
in
DWARF5
but
a
negative
value
is
surely
not
meaningful
int
dwarf_bytesize
Dwarf_Die
die
Dwarf_Unsigned
ret_size
Dwarf_Error
error
Dwarf_Unsigned
luns
int
res
_dwarf_die_attr_unsigned_constant
die
DW_AT_byte_size
error
ret_size
luns
return
res
Size
Value
is
not
specified
in
DWARF5
but
a
negative
value
is
not
meaningful
int
dwarf_bitsize
Dwarf_Die
die
Dwarf_Unsigned
ret_size
Dwarf_Error
error
Dwarf_Unsigned
luns
int
res
_dwarf_die_attr_unsigned_constant
die
DW_AT_bit_size
error
ret_size
luns
return
res
Size
Value
required
DWARF5
sec5
int
dwarf_bitoffset
Dwarf_Die
die
Dwarf_Unsigned
ret_size
Dwarf_Error
error
Dwarf_Unsigned
luns
int
res
_dwarf_die_attr_unsigned_constant
die
DW_AT_bit_offset
error
ret_size
luns
return
res
Refer
section
page
in
Dwarf
Definition
Language
codes
are
always
non
negative
and
specified
in
the
DWARF
standard
int
dwarf_srclang
Dwarf_Die
die
Dwarf_Unsigned
ret_size
Dwarf_Error
error
Dwarf_Unsigned
luns
int
res
_dwarf_die_attr_unsigned_constant
die
DW_AT_language
error
ret_size
luns
return
res
Refer
section
page
in
Dwarf
Definition
array
order
values
are
always
non
negative
and
specified
in
the
DWARF
standard
int
dwarf_arrayorder
Dwarf_Die
die
Dwarf_Unsigned
ret_size
Dwarf_Error
error
Dwarf_Unsigned
luns
int
res
_dwarf_die_attr_unsigned_constant
die
DW_AT_ordering
error
ret_size
luns
return
res
Return
DW_DLV_OK
if
ok
DW_DLV_ERROR
if
failure
If
the
die
and
the
attr
are
not
related
the
result
is
meaningless
int
dwarf_attr_offset
Dwarf_Die
die
Dwarf_Attribute
attr
Dwarf_Off
offset
return
offset
thru
this
ptr
Dwarf_Error
error
Dwarf_Off
attroff
Dwarf_Small
dataptr
Dwarf_Debug
dbg
CHECK_DIE
die
DW_DLV_ERROR
dbg
die
di_cu_context
cc_dbg
dataptr
die
di_is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
attroff
attr
ar_debug_ptr
dataptr
offset
attroff
return
DW_DLV_OK
int
dwarf_die_abbrev_code
Dwarf_Die
die
return
die
di_abbrev_code
Returns
a
flag
through
ablhas_child
Non
zero
if
the
DIE
has
children
zero
if
it
does
not
It
has
no
Dwarf_Error
arg
int
dwarf_die_abbrev_children_flag
Dwarf_Die
die
Dwarf_Half
ab_has_child
if
die
di_abbrev_list
ab_has_child
die
di_abbrev_list
abl_has_child
return
DW_DLV_OK
return
DW_DLV_ERROR
Helper
function
for
finding
form
class
Only
called
for
FORMs
that
might
be
offsets
to
one
or
another
section
static
enum
Dwarf_Form_Class
dw_get_special_offset
Dwarf_Half
attrnum
Dwarf_Half
dwversion
switch
attrnum
case
DW_AT_stmt_list
return
DW_FORM_CLASS_LINEPTR
case
DW_AT_macro_info
DWARF2
DWARF4
return
DW_FORM_CLASS_MACPTR
case
DW_AT_start_scope
case
DW_AT_ranges
if
dwversion
return
DW_FORM_CLASS_RANGELISTPTR
return
DW_FORM_CLASS_RNGLIST
case
DW_AT_GNU_ranges_base
DWARF5
like
case
DW_AT_rnglists_base
DWARF5
return
DW_FORM_CLASS_RNGLISTSPTR
case
DW_AT_GNU_macros
DWARF5
like
case
DW_AT_macros
DWARF5
return
DW_FORM_CLASS_MACROPTR
case
DW_AT_loclists_base
DWARF5
return
DW_FORM_CLASS_LOCLISTSPTR
case
DW_AT_GNU_addr_base
DWARF55
like
case
DW_AT_addr_base
DWARF5
return
DW_FORM_CLASS_ADDRPTR
case
DW_AT_str_offsets_base
DWARF5
return
DW_FORM_CLASS_STROFFSETSPTR
case
DW_AT_location
case
DW_AT_string_length
case
DW_AT_return_addr
case
DW_AT_data_member_location
case
DW_AT_frame_base
case
DW_AT_segment
case
DW_AT_static_link
case
DW_AT_use_location
case
DW_AT_vtable_elem_location
if
dwversion
return
DW_FORM_CLASS_LOCLIST
return
DW_FORM_CLASS_LOCLISTPTR
case
DW_AT_sibling
case
DW_AT_byte_size
case
DW_AT_bit_offset
case
DW_AT_bit_size
case
DW_AT_discr
case
DW_AT_import
case
DW_AT_common_reference
case
DW_AT_containing_type
case
DW_AT_default_value
case
DW_AT_lower_bound
case
DW_AT_bit_stride
case
DW_AT_upper_bound
case
DW_AT_abstract_origin
case
DW_AT_base_types
case
DW_AT_count
case
DW_AT_friend
case
DW_AT_namelist_item
case
DW_AT_priority
case
DW_AT_specification
case
DW_AT_type
case
DW_AT_allocated
case
DW_AT_associated
case
DW_AT_byte_stride
case
DW_AT_extension
case
DW_AT_trampoline
case
DW_AT_small
case
DW_AT_object_pointer
case
DW_AT_signature
return
DW_FORM_CLASS_REFERENCE
case
DW_AT_MIPS_fde
SGI
IRIX
extension
return
DW_FORM_CLASS_FRAMEPTR
return
DW_FORM_CLASS_UNKNOWN
static
int
block_means_locexpr
Dwarf_Half
attr
switch
attr
case
DW_AT_bit_size
case
DW_AT_byte_size
case
DW_AT_call_data_location
case
DW_AT_call_data_value
case
DW_AT_call_value
case
DW_AT_data_member_location
case
DW_AT_frame_base
case
DW_AT_GNU_call_site_target
case
DW_AT_GNU_call_site_value
case
DW_AT_location
case
DW_AT_return_addr
case
DW_AT_segment
case
DW_AT_static_link
case
DW_AT_string_length
case
DW_AT_use_location
case
DW_AT_vtable_elem_location
return
TRUE
return
FALSE
It
takes
pieces
of
data
including
the
FORM
to
accurately
determine
the
form
class
as
documented
in
the
DWARF
spec
This
is
per
DWARF4
but
will
work
for
DWARF2
or
as
well
enum
Dwarf_Form_Class
dwarf_get_form_class
Dwarf_Half
dwversion
Dwarf_Half
attrnum
Dwarf_Half
offset_size
Dwarf_Half
form
switch
form
case
DW_FORM_addr
return
DW_FORM_CLASS_ADDRESS
case
DW_FORM_data2
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_data4
if
dwversion
offset_size
enum
Dwarf_Form_Class
class
dw_get_special_offset
attrnum
dwversion
if
class
DW_FORM_CLASS_UNKNOWN
return
class
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_data8
if
dwversion
offset_size
enum
Dwarf_Form_Class
class
dw_get_special_offset
attrnum
dwversion
if
class
DW_FORM_CLASS_UNKNOWN
return
class
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_sec_offset
enum
Dwarf_Form_Class
class
dw_get_special_offset
attrnum
dwversion
if
class
DW_FORM_CLASS_UNKNOWN
return
class
We
do
not
know
what
this
is
return
DW_FORM_CLASS_UNKNOWN
break
case
DW_FORM_string
return
DW_FORM_CLASS_STRING
case
DW_FORM_strp
return
DW_FORM_CLASS_STRING
case
DW_FORM_block
case
DW_FORM_block1
case
DW_FORM_block2
case
DW_FORM_block4
if
dwversion
if
block_means_locexpr
attrnum
return
DW_FORM_CLASS_EXPRLOC
return
DW_FORM_CLASS_BLOCK
DWARF4
and
DWARF5
case
DW_FORM_exprloc
return
DW_FORM_CLASS_EXPRLOC
case
DW_FORM_data16
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_data1
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_sdata
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_udata
return
DW_FORM_CLASS_CONSTANT
case
DW_FORM_ref_addr
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref1
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref2
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref4
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref8
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref_udata
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_ref_sig8
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_flag
return
DW_FORM_CLASS_FLAG
case
DW_FORM_flag_present
return
DW_FORM_CLASS_FLAG
case
DW_FORM_addrx
case
DW_FORM_addrx1
case
DW_FORM_addrx2
case
DW_FORM_addrx3
case
DW_FORM_addrx4
return
DW_FORM_CLASS_ADDRESS
DWARF5
case
DW_FORM_GNU_addr_index
return
DW_FORM_CLASS_ADDRESS
case
DW_FORM_strx
DWARF5
case
DW_FORM_strx1
DWARF5
case
DW_FORM_strx2
DWARF5
case
DW_FORM_strx3
DWARF5
case
DW_FORM_line_strp
DWARF5
case
DW_FORM_strp_sup
DWARF5
case
DW_FORM_GNU_strp_alt
return
DW_FORM_CLASS_STRING
case
DW_FORM_GNU_str_index
return
DW_FORM_CLASS_STRING
case
DW_FORM_rnglistx
return
DW_FORM_CLASS_RNGLIST
DWARF5
case
DW_FORM_loclistx
return
DW_FORM_CLASS_LOCLIST
DWARF5
case
DW_FORM_GNU_ref_alt
return
DW_FORM_CLASS_REFERENCE
case
DW_FORM_implicit_const
return
DW_FORM_CLASS_CONSTANT
DWARF5
case
DW_FORM_indirect
default
break
return
DW_FORM_CLASS_UNKNOWN
Given
a
DIE
figure
out
what
the
CU
s
DWARF
version
is
and
the
size
of
an
offset
and
return
it
through
the
version
pointer
and
return
DW_DLV_OK
If
we
cannot
find
a
CU
return
DW_DLV_ERROR
on
error
In
case
of
error
no
Dwarf_Debug
was
available
so
setting
a
Dwarf_Error
is
somewhat
futile
Never
returns
DW_DLV_NO_ENTRY
int
dwarf_get_version_of_die
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Half
offset_size
Dwarf_CU_Context
cucontext
if
die
return
DW_DLV_ERROR
cucontext
die
di_cu_context
if
cucontext
return
DW_DLV_ERROR
version
cucontext
cc_version_stamp
offset_size
cucontext
cc_length_size
return
DW_DLV_OK
Dwarf_Byte_Ptr
_dwarf_calculate_info_section_start_ptr
Dwarf_CU_Context
context
Dwarf_Unsigned
section_len
Dwarf_Debug
dbg
Dwarf_Small
dataptr
struct
Dwarf_Section_s
sec
dbg
context
cc_dbg
sec
context
cc_is_info?
de_debug_info
de_debug_types
dataptr
sec
dss_data
section_len
sec
dss_size
return
dataptr
Dwarf_Byte_Ptr
_dwarf_calculate_info_section_end_ptr
Dwarf_CU_Context
context
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
info_end
Dwarf_Byte_Ptr
info_start
Dwarf_Off
off2
Dwarf_Small
dataptr
dbg
context
cc_dbg
dataptr
context
cc_is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
off2
context
cc_debug_offset
info_start
dataptr
off2
info_end
info_start
context
cc_length
context
cc_length_size
context
cc_extension_size
return
info_end
Dwarf_Byte_Ptr
_dwarf_calculate_abbrev_section_end_ptr
Dwarf_CU_Context
context
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
abbrev_end
Dwarf_Byte_Ptr
abbrev_start
struct
Dwarf_Section_s
sec
dbg
context
cc_dbg
sec
de_debug_abbrev
abbrev_start
sec
dss_data
abbrev_end
abbrev_start
sec
dss_size
return
abbrev_end
New
December
Any
Dwarf_Die
will
work
The
values
returned
are
about
the
CU
itself
not
a
DIE
extension_size
is
set
zero
unless
it
offset_size
is
and
it
is
standard
Dwarf
in
which
case
extension_size
is
set
to
If
there
is
no
signature
signature
is
set
zero
offset_of_length
is
the
section
offset
of
the
first
byte
of
the
compilation
unit
length
field
total_byte_length
includes
the
length
field
and
all
the
CU
data
The
offset
of
the
first
byte
of
the
CU
is
therefore
offset_of_lenth
offset_size
extension_size
is_info
is
always
non
zero
except
if
the
section
of
the
CU
is
DWARF4
debug_types
int
dwarf_cu_header_basics
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Bool
is_info
Dwarf_Bool
is_dwo
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Off
offset_of_length
Dwarf_Unsigned
total_byte_length
Dwarf_Error
error
Dwarf_CU_Context
context
CHECK_DIE
die
DW_DLV_ERROR
context
die
di_cu_context
if
version
version
context
cc_version_stamp
if
is_info
ASSERT
matches
context
cc_is_info
is_info
die
di_is_info
if
is_dwo
is_dwo
context
cc_is_dwo
if
offset_size
offset_size
context
cc_length_size
if
address_size
address_size
context
cc_address_size
if
extension_size
extension_size
context
cc_extension_size
if
signature
if
context
cc_signature_present
signature
cc_signature
else
signature
if
offset_of_length
offset_of_length
context
cc_debug_offset
if
total_byte_length
total_byte_length
context
cc_length
context
cc_length_size
context
cc_extension_size
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
struct
ranges_entry
struct
ranges_entry
next
Dwarf_Ranges
cur
static
void
free_allocated_ranges
struct
ranges_entry
base
struct
ranges_entry
cur
struct
ranges_entry
next
for
cur
base
cur
cur
next
next
cur
next
free
cur
We
encapsulate
the
macro
use
so
we
can
free
local
malloc
resources
that
would
otherwise
leak
See
the
call
points
below
static
int
read_unaligned_addr_check
Dwarf_Debug
dbg
Dwarf_Addr
addr_out
Dwarf_Small
rangeptr
unsigned
address_size
Dwarf_Error
error
Dwarf_Small
section_end
Dwarf_Addr
a
READ_UNALIGNED_CK
dbg
a
Dwarf_Addr
rangeptr
address_size
error
section_end
addr_out
a
return
DW_DLV_OK
As
of
DWARF5
the
ranges
section
each
range
list
set
has
a
range
list
table
header
See
Range
List
Table
in
the
DWARF5
standard
For
DWARF5
the
offset
should
be
the
offset
of
the
range
list
table
header
for
that
range
list
For
DWARF3
and
DWARF4
the
offset
has
to
be
that
of
a
range
list
Ranges
and
pc
values
can
be
in
a
split
dwarf
object
In
that
case
the
appropriate
values
need
to
be
incremented
by
data
from
the
executable
in
the
compilation
unit
with
the
same
dwo_id
We
return
an
error
which
is
on
the
incoming
dbg
not
the
possibly
tied
dbg
localdbg
If
incoming
die
is
NULL
there
is
no
context
so
do
not
look
for
a
tied
file
and
address_size
is
the
size
of
the
overall
object
not
the
address_size
of
the
context
define
MAX_ADDR
address_size
New
September
to
accomodate
the
GNU
extension
of
DWARF4
split
dwarf
The
actual_offset
field
is
set
by
the
function
to
the
actual
final
offset
of
the
ranges
in
the
separate
tied
a
out
file
int
dwarf_get_ranges_b
Dwarf_Debug
dbg
Dwarf_Off
rangesoffset
Dwarf_Die
die
Dwarf_Off
actual_offset
Dwarf_Ranges
rangesbuf
Dwarf_Signed
listlen
Dwarf_Unsigned
bytecount
Dwarf_Error
error
Dwarf_Small
rangeptr
Dwarf_Small
beginrangeptr
Dwarf_Small
section_end
unsigned
entry_count
struct
ranges_entry
base
struct
ranges_entry
last
struct
ranges_entry
curre
Dwarf_Ranges
ranges_data_out
unsigned
copyindex
Dwarf_Half
address_size
int
res
DW_DLV_ERROR
Dwarf_Unsigned
ranges_base
Dwarf_Debug
localdbg
dbg
Dwarf_Error
localerror
Dwarf_Half
die_version
default
for
dwarf_get_ranges
Dwarf_Half
offset_size
UNUSEDARG
Dwarf_CU_Context
cucontext
Dwarf_Bool
rangeslocal
TRUE
if
dbg
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
address_size
localdbg
de_pointer_size
default
if
die
If
we
wind
up
using
the
tied
file
the
die_version
had
better
match
It
cannot
be
other
than
a
match
Can
return
DW_DLV_ERROR
not
DW_DLV_NO_ENTRY
Add
err
code
if
error
Version
comes
from
the
cu
context
not
the
DIE
itself
res
dwarf_get_version_of_die
die
if
res
DW_DLV_ERROR
_dwarf_error
dbg
error
DW_DLE_DIE_NO_CU_CONTEXT
return
DW_DLV_ERROR
if
die
di_cu_context
_dwarf_error
dbg
error
DW_DLE_DIE_NO_CU_CONTEXT
return
DW_DLV_ERROR
cucontext
die
di_cu_context
The
DW4
ranges
base
was
never
used
in
GNU
but
did
get
emitted
the
note
says
but
the
note
is
probably
obsolete
so
now
wrong
http
llvm
n5
nabble
com
DebugInfo
DW
AT
GNU
ranges
base
in
non
fission
td64194
html
ranges_base
was
merged
from
tied
context
ranges_base
cucontext
cc_ranges_base
address_size
cucontext
cc_address_size
localdbg
dbg
res
_dwarf_load_section
localdbg
de_debug_ranges
error
if
res
DW_DLV_ERROR
return
res
else
if
res
DW_DLV_NO_ENTRY
data
is
in
a
out
not
dwp
localdbg
dbg
de_tied_data
td_tied_object
if
localdbg
return
DW_DLV_NO_ENTRY
res
_dwarf_load_section
localdbg
de_debug_ranges
if
res
DW_DLV_ERROR
_dwarf_error_mv_s_to_t
localdbg
dbg
error
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
rangeslocal
FALSE
Be
safe
in
case
adding
rangesoffset
and
rangebase
overflows
if
rangesoffset
localdbg
de_debug_ranges
dss_size
Documented
behavior
in
libdwarf2
mm
return
DW_DLV_NO_ENTRY
if
ranges_base
localdbg
de_debug_ranges
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_RANGES_OFFSET_BAD
ranges
base
is
lx
ranges_base
dwarfstring_append_printf_u
and
section
size
is
lx
localdbg
de_debug_ranges
dss_size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_RANGES_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
rangeslocal
rangesoffset
ranges_base
localdbg
de_debug_ranges
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_DEBUG_RANGES_OFFSET_BAD
ranges
base
offset
is
lx
ranges_base
rangesoffset
dwarfstring_append_printf_u
and
section
size
is
lx
localdbg
de_debug_ranges
dss_size
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_RANGES_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
tied
address_size
must
match
the
dwo
address_size
section_end
localdbg
de_debug_ranges
dss_data
localdbg
de_debug_ranges
dss_size
rangeptr
localdbg
de_debug_ranges
dss_data
if
rangeslocal
printing
ranges
where
range
source
is
dwp
here
we
just
assume
present
rangesoffset
ranges_base
rangeptr
rangesoffset
beginrangeptr
rangeptr
for
struct
ranges_entry
re
if
rangeptr
section_end
break
if
rangeptr
section_end
dwarfstring
m
free_allocated_ranges
base
dwarfstring_constructor
dwarfstring_append
DW_DLE_DEBUG_RANGES_OFFSET_BAD
ranges
pointer
ran
off
the
end
of
the
section
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_RANGES_OFFSET_BAD
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
re
calloc
sizeof
struct
ranges_entry
if
re
free_allocated_ranges
base
_dwarf_error
dbg
error
DW_DLE_DEBUG_RANGES_OUT_OF_MEM
return
DW_DLV_ERROR
if
rangeptr
address_size
section_end
free
re
free_allocated_ranges
base
_dwarf_error_string
dbg
error
DW_DLE_DEBUG_RANGES_OFFSET_BAD
DW_DLE_DEBUG_RANGES_OFFSET_BAD
Not
at
the
end
of
the
ranges
section
but
there
is
not
enough
room
in
the
section
for
the
next
ranges
entry
return
DW_DLV_ERROR
entry_count
res
read_unaligned_addr_check
localdbg
cur
dwr_addr1
rangeptr
address_size
error
section_end
if
res
DW_DLV_OK
free
re
free_allocated_ranges
base
return
res
rangeptr
address_size
res
read_unaligned_addr_check
localdbg
cur
dwr_addr2
rangeptr
address_size
error
section_end
if
res
DW_DLV_OK
free
re
free_allocated_ranges
base
return
res
rangeptr
address_size
if
base
base
re
last
re
else
last
next
re
last
re
if
re
cur
dwr_addr1
re
cur
dwr_addr2
re
cur
dwr_type
DW_RANGES_END
break
else
if
re
cur
dwr_addr1
MAX_ADDR
re
cur
dwr_type
DW_RANGES_ADDRESS_SELECTION
else
re
cur
dwr_type
DW_RANGES_ENTRY
We
return
ranges
on
dbg
so
use
that
to
allocate
ranges_data_out
Dwarf_Ranges
_dwarf_get_alloc
dbg
DW_DLA_RANGES
entry_count
if
ranges_data_out
Error
apply
to
original
not
local
dbg
free_allocated_ranges
base
_dwarf_error
dbg
error
DW_DLE_DEBUG_RANGES_OUT_OF_MEM
return
DW_DLV_ERROR
curre
base
rangesbuf
ranges_data_out
listlen
entry_count
for
copyindex
curre
copyindex
entry_count
copyindex
ranges_data_out
ranges_data_out
curre
cur
curre
curre
next
ASSERT
curre
NULL
free_allocated_ranges
base
base
Callers
will
often
not
care
about
the
bytes
used
if
actual_offset
actual_offset
rangesoffset
if
bytecount
bytecount
rangeptr
beginrangeptr
return
DW_DLV_OK
void
dwarf_ranges_dealloc
Dwarf_Debug
dbg
Dwarf_Ranges
rangesbuf
Dwarf_Signed
rangecount
UNUSEDARG
dwarf_dealloc
dbg
rangesbuf
DW_DLA_RANGES
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_rnglists
h
define
SIZEOFT8
define
SIZEOFT16
define
SIZEOFT32
define
SIZEOFT64
if
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
Used
in
case
of
error
reading
the
rnglists
headers
not
referring
to
Dwarf_Rnglists_Head
here
to
clean
up
static
void
free_rnglists_chain
Dwarf_Debug
dbg
Dwarf_Chain
head
Dwarf_Chain
cur
head
Dwarf_Chain
next
if
head
return
for
cur
cur
next
next
cur
ch_next
if
cur
ch_item
free
cur
ch_item
cur
ch_item
dwarf_dealloc
dbg
cur
DW_DLA_CHAIN
static
int
read_single_rle_entry
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Unsigned
dataoffset
Dwarf_Small
enddata
unsigned
address_size
unsigned
bytes_count_out
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Error
err
Dwarf_Unsigned
count
unsigned
leblen
unsigned
code
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
code
data
data
count
switch
code
case
DW_RLE_end_of_list
break
case
DW_RLE_base_addressx
DECODE_LEB128_UWORD_LEN_CK
data
val1
leblen
dbg
err
enddata
count
leblen
break
case
DW_RLE_startx_endx
case
DW_RLE_startx_length
case
DW_RLE_offset_pair
DECODE_LEB128_UWORD_LEN_CK
data
val1
leblen
dbg
err
enddata
count
leblen
DECODE_LEB128_UWORD_LEN_CK
data
val2
leblen
dbg
err
enddata
count
leblen
break
case
DW_RLE_base_address
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
break
case
DW_RLE_start_end
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
READ_UNALIGNED_CK
dbg
val2
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
break
case
DW_RLE_start_length
READ_UNALIGNED_CK
dbg
val1
Dwarf_Unsigned
data
address_size
err
enddata
data
address_size
count
address_size
DECODE_LEB128_UWORD_LEN_CK
data
val2
leblen
dbg
err
enddata
count
leblen
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
The
rangelists
entry
at
debug_rnglists
offset
x
dataoffset
dwarfstring_append_printf_u
has
code
x
which
is
unknown
code
_dwarf_error_string
dbg
err
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
break
bytes_count_out
count
entry_kind
code
entry_operand1
val1
entry_operand2
val2
return
DW_DLV_OK
Reads
the
header
Determines
the
various
offsets
including
offset
of
the
next
header
Does
no
memory
allocations
here
int
_dwarf_internal_read_rnglists_header
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
sectionlength
Dwarf_Small
data
Dwarf_Small
end_data
Dwarf_Unsigned
offset
Dwarf_Rnglists_Context
buildhere
Dwarf_Unsigned
next_offset
Dwarf_Error
error
Dwarf_Small
startdata
data
Dwarf_Unsigned
arealen
int
offset_size
int
exten_size
Dwarf_Unsigned
version
unsigned
address_size
unsigned
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
localoff
Dwarf_Unsigned
lists_len
READ_AREA_LENGTH_CK
dbg
arealen
Dwarf_Unsigned
data
offset_size
exten_size
error
sectionlength
end_data
if
arealen
sectionlength
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_SECTION_SIZE_ERROR
A
debug_rnglists
area
size
of
x
arealen
dwarfstring_append_printf_u
at
offset
x
offset
dwarfstring_append_printf_u
is
larger
than
the
entire
section
size
of
x
Corrupt
DWARF
sectionlength
_dwarf_error_string
dbg
error
DW_DLE_SECTION_SIZE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
rc_length
arealen
offset_size
exten_size
buildhere
rc_dbg
dbg
buildhere
rc_index
contextnum
buildhere
rc_header_offset
offset
buildhere
rc_offset_size
offset_size
buildhere
rc_extension_size
exten_size
READ_UNALIGNED_CK
dbg
version
Dwarf_Unsigned
data
SIZEOFT16
error
end_data
if
version
DW_CU_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_VERSION_STAMP_ERROR
The
version
should
be
but
we
find
u
instead
version
_dwarf_error_string
dbg
error
DW_DLE_VERSION_STAMP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
rc_version
version
data
SIZEOFT16
READ_UNALIGNED_CK
dbg
address_size
unsigned
data
SIZEOFT8
error
end_data
if
version
DW_CU_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_VERSION_STAMP_ERROR
The
version
should
be
but
we
find
u
instead
version
_dwarf_error_string
dbg
error
DW_DLE_VERSION_STAMP_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
address_size
address_size
address_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_ADDRESS_SIZE_ERROR
The
address
size
of
u
is
not
supported
address_size
_dwarf_error_string
dbg
error
DW_DLE_ADDRESS_SIZE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
buildhere
rc_address_size
address_size
data
READ_UNALIGNED_CK
dbg
segment_selector_size
unsigned
data
SIZEOFT8
error
end_data
buildhere
rc_segment_selector_size
segment_selector_size
data
READ_UNALIGNED_CK
dbg
offset_entry_count
Dwarf_Unsigned
data
SIZEOFT32
error
end_data
buildhere
rc_offset_entry_count
offset_entry_count
data
SIZEOFT32
if
offset_entry_count
buildhere
rc_offsets_array
data
localoff
data
startdata
lists_len
offset_size
offset_entry_count
data
lists_len
buildhere
rc_offsets_off_in_sect
offset
localoff
buildhere
rc_first_rnglist_offset
offset
localoff
lists_len
buildhere
rc_rnglists_header
startdata
buildhere
rc_endaddr
startdata
buildhere
rc_length
buildhere
rc_past_last_rnglist_offset
buildhere
rc_header_offset
buildhere
rc_length
next_offset
buildhere
rc_past_last_rnglist_offset
return
DW_DLV_OK
We
return
a
pointer
to
an
array
of
contexts
not
context
pointers
through
cxt
if
we
succeed
and
are
returning
DW_DLV_OK
We
never
return
DW_DLV_NO_ENTRY
here
static
int
internal_load_rnglists_contexts
Dwarf_Debug
dbg
Dwarf_Rnglists_Context
cxt
Dwarf_Unsigned
count
Dwarf_Error
error
Dwarf_Unsigned
offset
Dwarf_Unsigned
nextoffset
Dwarf_Small
data
dbg
de_debug_rnglists
dss_data
Dwarf_Unsigned
section_size
dbg
de_debug_rnglists
dss_size
Dwarf_Small
startdata
data
Dwarf_Small
end_data
data
section_size
Dwarf_Chain
curr_chain
Dwarf_Chain
prev_chain
Dwarf_Chain
head_chain
int
res
Dwarf_Unsigned
chainlength
Dwarf_Rnglists_Context
fullarray
Dwarf_Unsigned
i
for
data
end_data
Dwarf_Rnglists_Context
newcontext
sizeof
the
context
struct
not
sizeof
a
pointer
newcontext
malloc
sizeof
newcontext
if
newcontext
free_rnglists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Allocation
of
Rnglists_Context
failed
return
DW_DLV_ERROR
memset
newcontext
sizeof
newcontext
res
_dwarf_internal_read_rnglists_header
dbg
chainlength
section_size
data
end_data
offset
newcontext
error
if
res
DW_DLV_ERROR
free
newcontext
free_rnglists_chain
dbg
head_chain
curr_chain
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
curr_chain
NULL
free_rnglists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
allocating
Rnglists_Context
chain
entry
return
DW_DLV_ERROR
curr_chain
ch_item
newcontext
chainlength
if
head_chain
NULL
head_chain
prev_chain
curr_chain
else
prev_chain
ch_next
curr_chain
prev_chain
curr_chain
data
startdata
nextoffset
offset
nextoffset
fullarray
Dwarf_Rnglists_Context
malloc
chainlength
sizeof
Dwarf_Rnglists_Context
pointer
if
fullarray
free_rnglists_chain
dbg
head_chain
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
Allocation
of
Rnglists_Context
pointer
array
failed
return
DW_DLV_ERROR
curr_chain
head_chain
for
i
i
chainlength
i
fullarray
i
Dwarf_Rnglists_Context
curr_chain
ch_item
curr_chain
ch_item
prev_chain
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
prev_chain
DW_DLA_CHAIN
ASSERT
the
chain
is
entirely
dealloc
d
and
the
array
of
pointers
points
to
individually
malloc
d
Dwarf_Rnglists_Context_s
cxt
fullarray
count
chainlength
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
rnglists
data
Loads
all
the
debug_rnglists
dwo
headers
and
returns
DW_DLV_NO_ENTRY
if
the
section
is
missing
or
empty
Intended
to
be
done
quite
early
and
done
exactly
once
Harmless
to
do
more
than
once
With
DW_DLV_OK
it
returns
the
number
of
rnglists
headers
in
the
section
through
rnglists_count
int
dwarf_load_rnglists
Dwarf_Debug
dbg
Dwarf_Unsigned
rnglists_count
Dwarf_Error
error
UNUSEDARG
int
res
DW_DLV_ERROR
Dwarf_Rnglists_Context
cxt
Dwarf_Unsigned
count
if
dbg
de_rnglists_context
if
rnglists_count
rnglists_count
dbg
de_rnglists_context_count
if
dbg
de_debug_rnglists
dss_size
nothing
there
return
DW_DLV_NO_ENTRY
if
dbg
de_debug_rnglists
dss_data
res
_dwarf_load_section
dbg
de_debug_rnglists
error
if
res
DW_DLV_OK
return
res
res
internal_load_rnglists_contexts
dbg
error
if
res
DW_DLV_ERROR
return
res
dbg
de_rnglists_context
cxt
dbg
de_rnglists_context_count
count
if
rnglists_count
rnglists_count
count
return
DW_DLV_OK
Frees
the
memory
in
use
in
all
rnglists
contexts
Done
by
dwarf_finish
void
_dwarf_dealloc_rnglists_context
Dwarf_Debug
dbg
Dwarf_Unsigned
i
Dwarf_Rnglists_Context
rngcon
if
dbg
de_rnglists_context
return
rngcon
dbg
de_rnglists_context
for
i
dbg
de_rnglists_context_count
i
rngcon
Dwarf_Rnglists_Context
con
rngcon
con
rc_offsets_array
con
rc_offset_entry_count
free
con
free
dbg
de_rnglists_context
dbg
de_rnglists_context
dbg
de_rnglists_context_count
Used
by
dwarfdump
to
print
raw
rnglists
data
int
dwarf_get_rnglist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
Dwarf_Rnglists_Context
con
unsigned
offset_len
Dwarf_Small
offsetptr
Dwarf_Unsigned
targetoffset
if
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
if
context_index
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_rnglists_context
context_index
if
offsetentry_index
con
rc_offset_entry_count
return
DW_DLV_NO_ENTRY
offset_len
con
rc_offset_size
offsetptr
con
rc_offsets_array
offsetentry_index
offset_len
READ_UNALIGNED_CK
dbg
targetoffset
Dwarf_Unsigned
offsetptr
offset_len
error
con
rc_endaddr
if
offset_value_out
offset_value_out
targetoffset
if
global_offset_value_out
global_offset_value_out
targetoffset
con
rc_offsets_off_in_sect
return
DW_DLV_OK
Used
by
dwarfdump
to
print
basic
data
from
the
data
generated
to
look
at
a
specific
rangelist
as
returned
by
dwarf_rnglists_index_get_rle_head
or
dwarf_rnglists_offset_get_rle_head
int
dwarf_get_rnglist_head_basics
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
rle_count
Dwarf_Unsigned
rle_version
Dwarf_Unsigned
rnglists_index_returned
Dwarf_Unsigned
bytes_total_in_rle
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Unsigned
overall_offset_of_this_context
Dwarf_Unsigned
total_length_of_this_context
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
Dwarf_Bool
rnglists_base_present
Dwarf_Unsigned
rnglists_base
Dwarf_Bool
rnglists_base_address_present
Dwarf_Unsigned
rnglists_base_address
Dwarf_Bool
rnglists_debug_addr_base_present
Dwarf_Unsigned
rnglists_debug_addr_base
Dwarf_Error
error
UNUSEDARG
Dwarf_Rnglists_Context
rngcontext
rle_count
head
rh_count
rle_version
head
rh_version
rnglists_index_returned
head
rh_index
bytes_total_in_rle
head
rh_bytes_total
offset_size
head
rh_offset_size
address_size
head
rh_address_size
segment_selector_size
head
rh_segment_selector_size
rngcontext
head
rh_localcontext
if
rngcontext
overall_offset_of_this_context
rngcontext
rc_header_offset
total_length_of_this_context
rngcontext
rc_length
offset_table_offset
rngcontext
rc_offsets_off_in_sect
offset_table_entrycount
rngcontext
rc_offset_entry_count
rnglists_base_present
head
rh_at_rnglists_base_present
rnglists_base
head
rh_at_rnglists_base
rnglists_base_address_present
head
rh_cu_base_address_present
rnglists_base_address
head
rh_cu_base_address
rnglists_debug_addr_base_present
head
rh_cu_addr_base_present
rnglists_debug_addr_base
head
rh_cu_addr_base
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
rnglists
data
Enables
printing
of
details
about
the
Range
List
Table
Headers
one
header
per
call
Index
starting
at
Returns
DW_DLV_NO_ENTRY
if
index
is
too
high
for
the
table
A
debug_rnglists
section
may
contain
any
number
of
Range
List
Table
Headers
with
their
details
int
dwarf_get_rnglist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_rangeentry
Dwarf_Unsigned
offset_past_last_rangeentry
Dwarf_Error
error
UNUSEDARG
Dwarf_Rnglists_Context
con
if
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
if
context_index
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_rnglists_context
context_index
if
header_offset
header_offset
con
rc_header_offset
if
offset_size
offset_size
con
rc_offset_size
if
offset_size
extension_size
con
rc_extension_size
if
version
version
con
rc_version
if
address_size
address_size
con
rc_address_size
if
segment_selector_size
segment_selector_size
con
rc_segment_selector_size
if
offset_entry_count
offset_entry_count
con
rc_offset_entry_count
if
offset_of_offset_array
offset_of_offset_array
con
rc_offsets_off_in_sect
if
offset_of_first_rangeentry
offset_of_first_rangeentry
con
rc_first_rnglist_offset
if
offset_past_last_rangeentry
offset_past_last_rangeentry
con
rc_past_last_rnglist_offset
return
DW_DLV_OK
Used
by
dwarfdump
to
print
raw
rnglists
data
entry
offset
is
offset_of_first_rangeentry
Stop
when
the
returned
next_entry_offset
is
offset_past_last_rangentry
from
dwarf_get_rnglist_context_plus
This
only
makes
sense
within
those
ranges
This
retrieves
raw
detail
from
the
section
no
base
values
or
anything
are
added
So
this
returns
raw
individual
entries
for
a
single
rnglist
header
meaning
a
a
single
Dwarf_Rnglists_Context
int
dwarf_get_rnglist_rle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
entrylen
unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Error
err
Dwarf_Rnglists_Context
con
Dwarf_Small
data
Dwarf_Small
enddata
int
res
unsigned
address_size
if
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
data
dbg
de_debug_rnglists
dss_data
entry_offset
enddata
dbg
de_debug_rnglists
dss_data
endoffset
if
contextnumber
dbg
de_rnglists_context_count
return
DW_DLV_NO_ENTRY
con
dbg
de_rnglists_context
contextnumber
address_size
con
rc_address_size
res
read_single_rle_entry
dbg
data
entry_offset
enddata
address_size
entrylen
entry_kind
entry_operand1
entry_operand2
err
return
res
static
int
_dwarf_which_rnglists_context
Dwarf_Debug
dbg
Dwarf_CU_Context
ctx
Dwarf_Unsigned
rnglist_offset
Dwarf_Unsigned
index
Dwarf_Error
error
Dwarf_Unsigned
count
Dwarf_Rnglists_Context
array
Dwarf_Unsigned
i
array
dbg
de_rnglists_context
count
dbg
de_rnglists_context_count
Using
the
slow
way
a
simple
linear
search
if
ctx
cc_rnglists_base_present
We
look
at
the
location
of
each
rnglist
context
to
find
one
with
the
offset
the
DIE
gave
us
for
i
i
count
i
Dwarf_Rnglists_Context
rcx
array
i
Dwarf_Unsigned
rcxoff
rcx
rc_header_offset
Dwarf_Unsigned
rcxend
rcxoff
rcx
rc_length
if
rnglist_offset
rcxoff
continue
if
rnglist_offset
rcxend
index
i
return
DW_DLV_OK
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
rnglist
ran
off
end
finding
target
offset
of
DW_PR_XZEROS
DW_PR_DUx
rnglist_offset
dwarfstring_append
Not
found
anywhere
in
debug_rnglists
data
Corrupted
data?
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
We
have
a
DW_AT_rnglists_base
cc_rangelists_base
let
s
use
it
Dwarf_Unsigned
lookfor
lookfor
ctx
cc_rnglists_base
for
i
i
count
i
dwarfstring
m
Dwarf_Rnglists_Context
rcx
array
i
if
rcx
rc_offsets_off_in_sect
lookfor
index
i
return
DW_DLV_OK
if
rcx
rc_offsets_off_in_sect
lookfor
continue
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
rnglists
base
of
DW_PR_XZEROS
DW_PR_DUx
lookfor
dwarfstring_append_printf_u
was
not
found
though
we
are
now
at
base
DW_PR_XZEROS
DW_PR_DUx
rcx
rc_offsets_off_in_sect
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
rnglist
base
of
DW_PR_XZEROS
DW_PR_DUx
lookfor
dwarfstring_append
was
not
found
anywhere
in
debug_rnglists
data
Corrupted
data?
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
return
DW_DLV_ERROR
int
dwarf_dealloc_rnglists_head
Dwarf_Rnglists_Head
h
Dwarf_Debug
dbg
h
rh_dbg
dwarf_dealloc
dbg
h
DW_DLA_RNGLISTS_HEAD
return
DW_DLV_OK
Caller
will
eventually
free
as
appropriate
static
int
alloc_rle_and_append_to_list
Dwarf_Debug
dbg
Dwarf_Rnglists_Head
rctx
Dwarf_Rnglists_Entry
e_out
Dwarf_Error
error
Dwarf_Rnglists_Entry
e
e
malloc
sizeof
struct
Dwarf_Rnglists_Entry_s
if
e
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Out
of
memory
in
building
list
of
rnglists
entries
on
a
DIE
return
DW_DLV_ERROR
memset
e
sizeof
struct
Dwarf_Rnglists_Entry_s
if
rctx
rh_first
rctx
rh_last
rle_next
e
rctx
rh_last
e
else
rctx
rh_first
e
rctx
rh_last
e
rctx
rh_count
e_out
e
return
DW_DLV_OK
Read
the
group
of
rangelists
entries
and
finally
build
an
array
of
Dwarf_Rnglists_Entry
records
Attach
to
rctx
here
Since
on
error
the
caller
will
destruct
the
rctx
and
we
ensure
to
attach
allocations
there
the
caller
will
destruct
the
allocations
here
in
case
we
return
DW_DLV_ERROR
static
int
build_array_of_rle
Dwarf_Debug
dbg
Dwarf_Rnglists_Head
rctx
Dwarf_Error
error
int
res
Dwarf_Small
data
rctx
rh_rlepointer
Dwarf_Unsigned
dataoffset
rctx
rh_rlearea_offset
Dwarf_Small
enddata
rctx
rh_end_data_area
unsigned
address_size
rctx
rh_address_size
Dwarf_Unsigned
bytescounttotal
Dwarf_Unsigned
latestbaseaddr
Dwarf_Bool
foundbaseaddr
FALSE
int
done
FALSE
Dwarf_Bool
no_debug_addr_available
FALSE
if
rctx
rh_cu_base_address_present
The
CU
DIE
had
DW_AT_low_pc
and
it
is
a
base
address
latestbaseaddr
rctx
rh_cu_base_address
foundbaseaddr
TRUE
for
done
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
val1
Dwarf_Unsigned
val2
Dwarf_Addr
addr1
Dwarf_Addr
addr2
Dwarf_Rnglists_Entry
e
res
read_single_rle_entry
dbg
data
dataoffset
enddata
address_size
error
if
res
DW_DLV_OK
return
res
res
alloc_rle_and_append_to_list
dbg
rctx
error
if
res
DW_DLV_OK
return
res
e
rle_code
code
e
rle_entrylen
entrylen
e
rle_raw1
val1
e
rle_raw2
val2
bytescounttotal
entrylen
data
entrylen
if
code
DW_RLE_end_of_list
done
TRUE
break
switch
code
case
DW_RLE_base_addressx
if
no_debug_addr_available
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
rctx
rh_context
val1
error
if
res
DW_DLV_OK
no_debug_addr_available
TRUE
e
rle_index_failed
TRUE
e
rle_cooked1
foundbaseaddr
FALSE
else
foundbaseaddr
TRUE
e
rle_cooked1
addr1
latestbaseaddr
addr1
break
case
DW_RLE_startx_endx
if
no_debug_addr_available
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
rctx
rh_context
val1
error
if
res
DW_DLV_OK
no_debug_addr_available
TRUE
e
rle_index_failed
TRUE
e
rle_cooked1
else
e
rle_cooked1
addr1
if
no_debug_addr_available
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
rctx
rh_context
val2
error
if
res
DW_DLV_OK
no_debug_addr_available
TRUE
e
rle_index_failed
TRUE
e
rle_cooked2
return
res
else
e
rle_cooked2
addr2
break
case
DW_RLE_startx_length
if
no_debug_addr_available
res
DW_DLV_NO_ENTRY
else
res
_dwarf_look_in_local_and_tied_by_index
dbg
rctx
rh_context
val1
error
if
res
DW_DLV_OK
no_debug_addr_available
TRUE
e
rle_index_failed
TRUE
e
rle_cooked2
e
rle_cooked1
return
res
else
e
rle_cooked1
addr1
e
rle_cooked2
val2
addr1
break
case
DW_RLE_offset_pair
if
foundbaseaddr
e
rle_cooked1
val1
latestbaseaddr
e
rle_cooked2
val2
latestbaseaddr
else
Well
something
failed
could
be
missing
debug_addr
e
rle_index_failed
TRUE
e
rle_cooked2
e
rle_cooked1
break
case
DW_RLE_base_address
foundbaseaddr
TRUE
latestbaseaddr
val1
e
rle_cooked1
val1
break
case
DW_RLE_start_end
e
rle_cooked1
val1
e
rle_cooked2
val2
break
case
DW_RLE_start_length
e
rle_cooked1
val1
e
rle_cooked2
val2
val1
break
default
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
The
debug_rnglists
rangelist
code
x
is
unknown
DWARF5
is
corrupted
code
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
rctx
rh_count
Dwarf_Rnglists_Entry
array
Dwarf_Rnglists_Entry
cur
Dwarf_Unsigned
i
Creating
an
array
of
pointers
array
Dwarf_Rnglists_Entry
malloc
rctx
rh_count
sizeof
Dwarf_Rnglists_Entry
if
array
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
DW_DLE_ALLOC_FAIL
Out
of
memory
in
turning
list
of
rnglists
entries
on
a
DIE
into
a
pointer
array
return
DW_DLV_ERROR
cur
rctx
rh_first
for
i
rctx
rh_count
i
array
i
cur
cur
cur
rle_next
rctx
rh_rnglists
array
rctx
rh_first
rctx
rh_last
rctx
rh_bytes_total
bytescounttotal
return
DW_DLV_OK
Build
a
head
with
all
the
relevent
Entries
attached
int
dwarf_rnglists_get_rle_head
Dwarf_Attribute
attr
Dwarf_Half
theform
Dwarf_Unsigned
attr_val
Dwarf_Rnglists_Head
head_out
Dwarf_Unsigned
entries_count_out
Dwarf_Unsigned
global_offset_of_rle_set
Dwarf_Error
error
int
res
Dwarf_Unsigned
rnglists_contextnum
Dwarf_Small
table_base
Dwarf_Small
table_entry
Dwarf_Small
enddata
Dwarf_Rnglists_Context
array
Dwarf_Rnglists_Context
rctx
Dwarf_Unsigned
entrycount
unsigned
offsetsize
Dwarf_Unsigned
rle_global_offset
Dwarf_Rnglists_Head
lhead
Dwarf_CU_Context
ctx
struct
Dwarf_Rnglists_Head_s
shead
Dwarf_Unsigned
offset_in_rnglists
Dwarf_Debug
dbg
Dwarf_Bool
is_rnglistx
FALSE
memset
sizeof
shead
ctx
attr
ar_cu_context
dbg
ctx
cc_dbg
array
dbg
de_rnglists_context
if
theform
DW_FORM_rnglistx
is_rnglistx
TRUE
ASSERT
the
pointers
just
set
are
non
null
the
context
cc_rnglists_base
gives
the
offset
of
the
array
of
offsets
if
cc_rnglists_base_present
offset_in_rnglists
attr_val
if
is_rnglistx
if
ctx
cc_rnglists_base_present
offset_in_rnglists
ctx
cc_rnglists_base
else
FIXME
check
in
tied
file
for
a
cc_rnglists_base
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
rnglists
table
index
of
u
attr_val
dwarfstring_append
is
unusable
unless
it
is
in
a
tied
file
Possibly
libdwarf
is
incomplete
FIXME
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
else
offset_in_rnglists
attr_val
res
_dwarf_which_rnglists_context
dbg
ctx
offset_in_rnglists
error
if
res
DW_DLV_OK
return
res
rctx
array
rnglists_contextnum
table_base
rctx
rc_offsets_array
entrycount
rctx
rc_offset_entry_count
offsetsize
rctx
rc_offset_size
enddata
rctx
rc_endaddr
if
is_rnglistx
attr_val
entrycount
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_RNGLISTS_ERROR
rnglists
table
index
of
u
attr_val
dwarfstring_append_printf_u
too
large
for
table
of
u
entries
entrycount
_dwarf_error_string
dbg
error
DW_DLE_RNGLISTS_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
shead
rh_context
ctx
shead
rh_localcontext
rctx
shead
rh_index
rnglists_contextnum
shead
rh_version
rctx
rc_version
shead
rh_offset_size
offsetsize
shead
rh_address_size
rctx
rc_address_size
shead
rh_segment_selector_size
rctx
rc_segment_selector_size
DW_AT_rnglists_base
from
CU
shead
rh_at_rnglists_base_present
ctx
cc_rnglists_base_present
shead
rh_at_rnglists_base
ctx
cc_rnglists_base
DW_AT_low_pc
if
present
From
CU
shead
rh_cu_base_address_present
ctx
cc_low_pc_present
shead
rh_cu_base_address
ctx
cc_low_pc
base
address
DW_AT_addr_base
of
our
part
of
debug_addr
from
CU
shead
rh_cu_addr_base
ctx
cc_addr_base
shead
rh_cu_addr_base_present
ctx
cc_addr_base_present
if
is_rnglistx
Dwarf_Unsigned
table_entryval
table_entry
attr_val
offsetsize
table_base
No
malloc
here
yet
so
no
leak
if
the
macro
returns
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
table_entryval
Dwarf_Unsigned
table_entry
offsetsize
error
enddata
rle_global_offset
rctx
rc_offsets_off_in_sect
table_entryval
else
rle_global_offset
attr_val
shead
rh_rlepointer
rctx
rc_offsets_array
rctx
rc_offset_entry_count
offsetsize
shead
rh_end_data_area
enddata
shead
rh_rlearea_offset
rle_global_offset
shead
rh_rlepointer
rle_global_offset
dbg
de_debug_rnglists
dss_data
lhead
Dwarf_Rnglists_Head
_dwarf_get_alloc
dbg
DW_DLA_RNGLISTS_HEAD
if
lhead
_dwarf_error_string
dbg
error
DW_DLE_ALLOC_FAIL
Allocating
a
Dwarf_Rnglists_Head
struct
fails
in
libdwarf
function
dwarf_rnglists_index_get_rle_head
return
DW_DLV_ERROR
shead
rh_dbg
dbg
lhead
shead
res
build_array_of_rle
dbg
lhead
error
if
res
DW_DLV_OK
dwarf_dealloc
dbg
lhead
DW_DLA_RNGLISTS_HEAD
return
res
if
global_offset_of_rle_set
global_offset_of_rle_set
rle_global_offset
Caller
needs
the
head
pointer
else
there
will
be
leaks
head_out
lhead
if
entries_count_out
entries_count_out
lhead
rh_count
return
DW_DLV_OK
As
of
Aug
this
ignores
null
pointer
inputs
for
the
various
pointers
returning
values
rle_value_out
etc
int
dwarf_get_rnglists_entry_fields_a
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
entrynum
unsigned
entrylen
unsigned
rle_value_out
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Bool
debug_addr_unavailable
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
Dwarf_Error
err
UNUSEDARG
Dwarf_Rnglists_Entry
e
if
entrynum
head
rh_count
return
DW_DLV_NO_ENTRY
e
head
rh_rnglists
entrynum
if
entrylen
entrylen
e
rle_entrylen
if
rle_value_out
rle_value_out
e
rle_code
if
raw1
raw1
e
rle_raw1
if
raw2
raw2
e
rle_raw2
if
debug_addr_unavailable
debug_addr_unavailable
e
rle_index_failed
if
cooked1
cooked1
e
rle_cooked1
if
cooked2
cooked2
e
rle_cooked2
return
DW_DLV_OK
Deals
with
both
fully
and
partially
build
head
static
void
_dwarf_free_rnglists_head
Dwarf_Rnglists_Head
head
if
head
rh_first
partially
built
head
ASSERT
rh_rnglists
is
NULL
Dwarf_Rnglists_Entry
cur
head
rh_first
Dwarf_Rnglists_Entry
next
for
cur
cur
next
next
cur
rle_next
free
cur
head
rh_first
head
rh_last
head
rh_count
else
ASSERT
rh_first
and
rh_last
are
NULL
fully
built
head
Dwarf_Unsigned
i
Deal
with
the
array
form
for
i
head
rh_count
i
free
head
rh_rnglists
i
free
head
rh_rnglists
head
rh_rnglists
void
_dwarf_rnglists_head_destructor
void
head
Dwarf_Rnglists_Head
h
head
_dwarf_free_rnglists_head
h
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarfstring
h
include
dwarf_str_offsets
h
define
STR_OFFSETS_MAGIC
define
VALIDATE_SOT
xsot
if
xsot
_dwarf_error
NULL
error
DW_DLE_STR_OFFSETS_NULLARGUMENT
return
DW_DLV_ERROR
if
xsot
so_dbg
_dwarf_error
NULL
error
DW_DLE_STR_OFFSETS_NULL_DBG
return
DW_DLV_ERROR
if
xsot
so_magic_value
STR_OFFSETS_MAGIC
_dwarf_error
xsot
so_dbg
error
DW_DLE_STR_OFFSETS_NO_MAGIC
return
DW_DLV_ERROR
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
msg
for
cur
end
cur
printf
cur
printf
n
endif
int
dwarf_open_str_offsets_table_access
Dwarf_Debug
dbg
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
int
res
Dwarf_Str_Offsets_Table
local_table_data
Dwarf_Small
offsets_start_ptr
Dwarf_Unsigned
sec_size
if
dbg
_dwarf_error
NULL
error
DW_DLE_STR_OFFSETS_NULL_DBG
return
DW_DLV_ERROR
if
table_data
_dwarf_error
dbg
error
DW_DLE_STR_OFFSETS_NULLARGUMENT
return
DW_DLV_ERROR
Considered
testing
for
table_data
being
NULL
but
not
doing
such
a
test
res
_dwarf_load_section
dbg
de_debug_str_offsets
error
if
res
DW_DLV_OK
return
res
offsets_start_ptr
dbg
de_debug_str_offsets
dss_data
if
offsets_start_ptr
return
DW_DLV_NO_ENTRY
sec_size
dbg
de_debug_str_offsets
dss_size
local_table_data
Dwarf_Str_Offsets_Table
_dwarf_get_alloc
dbg
DW_DLA_STR_OFFSETS
if
local_table_data
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
local_table_data
so_dbg
dbg
local_table_data
so_magic_value
STR_OFFSETS_MAGIC
local_table_data
so_section_start_ptr
offsets_start_ptr
local_table_data
so_section_end_ptr
offsets_start_ptr
sec_size
local_table_data
so_section_size
sec_size
local_table_data
so_next_table_offset
local_table_data
so_wasted_section_bytes
get_alloc
zeroed
all
the
bits
no
need
to
repeat
that
here
table_data
local_table_data
return
DW_DLV_OK
int
dwarf_close_str_offsets_table_access
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
Dwarf_Debug
dbg
VALIDATE_SOT
table_data
dbg
table_data
so_dbg
table_data
so_magic_value
dwarf_dealloc
dbg
table_data
DW_DLA_STR_OFFSETS
return
DW_DLV_OK
int
dwarf_str_offsets_value_by_index
Dwarf_Str_Offsets_Table
sot
Dwarf_Unsigned
index
Dwarf_Unsigned
stroffset
Dwarf_Error
error
Dwarf_Small
entryptr
Dwarf_Unsigned
val
VALIDATE_SOT
sot
if
index
sot
so_array_entry_count
_dwarf_error
sot
so_dbg
error
DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG
return
DW_DLV_ERROR
entryptr
sot
so_array_ptr
index
sot
so_array_entry_size
READ_UNALIGNED_CK
sot
so_dbg
val
Dwarf_Unsigned
entryptr
sot
so_array_entry_size
error
sot
so_end_cu_ptr
stroffset
val
return
DW_DLV_OK
The
minimum
possible
area
debug_str_offsets
header
define
MIN_HEADER_LENGTH
New
April
Beginning
at
starting_offset
zero
returns
data
about
the
first
table
found
The
value
next_table_offset
is
the
value
of
the
next
table
if
any
one
byte
past
the
end
of
the
table
whose
data
is
returned
Returns
DW_DLV_NO_ENTRY
if
the
starting
offset
is
past
the
end
of
valid
data
There
is
no
guarantee
that
there
are
no
non
nonsense
bytes
in
the
section
outside
of
useful
tables
so
this
can
fail
and
return
nonsense
or
DW_DLV_ERROR
if
such
garbage
exists
static
int
is_all_zeroes
Dwarf_Small
start
Dwarf_Small
end
if
start
end
We
should
not
get
here
this
is
just
a
defensive
test
return
TRUE
for
start
end
start
if
start
There
is
some
garbage
here
return
FALSE
All
just
zero
bytes
return
TRUE
int
_dwarf_trial_read_dwarf_five_hdr
Dwarf_Debug
dbg
Dwarf_Small
table_start_ptr
Dwarf_Unsigned
secsize
Dwarf_Small
secendptr
Dwarf_Unsigned
length_out
Dwarf_Half
local_offset_size_out
Dwarf_Half
local_extension_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Error
error
Dwarf_Unsigned
length
length
following
the
local_offset_size
local_extension_size
Dwarf_Unsigned
local_offset_size
Dwarf_Unsigned
local_extension_size
Dwarf_Half
version
Dwarf_Half
padding
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
table_start_ptr
local_offset_size
local_extension_size
error
secsize
secendptr
The
length
part
of
any
header
is
local_extension_size
local_offset_size
The
length
of
an
offset
in
the
section
is
just
local_offset_size
Standard
DWARF2
sums
to
Standard
DWARF3
sums
to
or
Nonstandard
SGI
IRIX
dwarf
sums
to
SGI
IRIX
was
all
DWARF2
and
could
not
have
a
debug_str_offsets
section
The
header
includes
bytes
of
version
and
two
bytes
of
padding
if
length
Usually
DW4
style
debug_str_offsets
starts
off
with
a
zero
value
to
ref
the
base
string
in
debug_str
Any
tiny
value
is
guaranteed
not
to
be
a
legal
DWARF5
debug_str_offsets
section
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_SECTION_SIZE_ERROR
header
length
x
is
too
small
to
be
a
real
debug_str_offsets
DWARF5
section
length
_dwarf_error_string
dbg
error
DW_DLE_SECTION_SIZE_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
length
secsize
secsize
is
for
the
version
and
padding
bytes
length
local_extension_size
local_offset_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_STR_OFFSETS_ARRAY_SIZE
header
length
x
is
bigger
than
length
dwarfstring_append_printf_u
debug_str_offsets
section
size
of
x
Perhaps
the
section
is
a
GNU
DWARF4
extension
with
a
different
format
secsize
_dwarf_error_string
dbg
error
DW_DLE_STR_OFFSETS_ARRAY_SIZE
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
table_start_ptr
was
incremented
past
the
length
data
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
table_start_ptr
DWARF_HALF_SIZE
error
secendptr
table_start_ptr
DWARF_HALF_SIZE
if
version
DW_STR_OFFSETS_VERSION5
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_STR_OFFSETS_VERSION_WRONG
u
Only
version
is
supported
when
reading
debug_str_offsets
Perhaps
the
section
is
a
GNU
DWARF4
extension
with
a
different
format
version
_dwarf_error_string
dbg
error
DW_DLE_STR_OFFSETS_VERSION_WRONG
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
padding
Dwarf_Half
table_start_ptr
DWARF_HALF_SIZE
error
secendptr
padding
should
be
zero
but
we
are
not
checking
it
here
at
present
length_out
length
local_offset_size_out
local_offset_size
local_extension_size_out
local_extension_size
version_out
version
padding_out
padding
return
DW_DLV_OK
Used
by
code
reading
attributes
forms
and
also
by
code
reading
the
raw
debug_str_offsets
section
hence
the
code
allows
for
output
arguments
to
be
zero
If
cucontext
is
null
it
means
the
call
part
of
trying
to
print
the
section
without
accessing
any
context
dwarfdump
option
print
str
offsets
New
August
int
_dwarf_read_str_offsets_header
Dwarf_Debug
dbg
Dwarf_Small
table_start_ptr
Dwarf_Unsigned
secsize
Dwarf_Small
secendptr
Dwarf_CU_Context
cucontext
Followed
by
return
values
error
Dwarf_Unsigned
length_out
Dwarf_Half
offset_size_out
Dwarf_Half
extension_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Unsigned
header_length_out
Dwarf_Error
error
Dwarf_Unsigned
length
Dwarf_Half
local_offset_size
Dwarf_Half
local_extension_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
headerlength
int
res
Dwarf_Bool
is_dwarf_five
TRUE
if
cucontext
if
cucontext
cc_str_offsets_header_length_present
cu_context
has
what
it
needs
already
and
we
do
not
need
the
rest
of
what
the
interface
provides
return
DW_DLV_OK
res
_dwarf_trial_read_dwarf_five_hdr
dbg
table_start_ptr
secsize
secendptr
error
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
If
it
s
really
DWARF5
but
with
a
serious
problem
this
will
think
NOT
is_dwarf_five
FALSE
if
is_dwarf_five
length
secsize
This
is
likely
GNU
Dwarf4
extension
debug_str_offsets
and
offset
size
is
not
going
to
be
de_length_size
is
most
likely
a
guess
and
not
set
properly
at
this
point
local_offset_size
local_extension_size
version
DW_STR_OFFSETS_VERSION4
padding
if
length_out
length_out
length
if
offset_size_out
offset_size_out
local_offset_size
if
extension_size_out
extension_size_out
local_extension_size
if
version_out
version_out
version
if
padding_out
padding_out
padding
if
is_dwarf_five
headerlength
local_offset_size
local_extension_size
DWARF_HALF_SIZE
else
DWARF4
headerlength
if
header_length_out
header_length_out
headerlength
if
cucontext
cucontext
cc_str_offsets_header_length_present
TRUE
cucontext
cc_str_offsets_header_length
headerlength
cucontext
cc_str_offsets_offset_size
local_offset_size
return
DW_DLV_OK
int
dwarf_next_str_offsets_table
Dwarf_Str_Offsets_Table
sot
Dwarf_Unsigned
unit_length_out
Dwarf_Unsigned
unit_length_offset_out
Dwarf_Unsigned
table_start_offset_out
Dwarf_Half
entry_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Unsigned
table_value_count_out
Dwarf_Error
error
Dwarf_Small
table_header_ptr
Dwarf_Small
array_start_ptr
Dwarf_Small
table_end_ptr
Dwarf_Unsigned
table_header_offset
Dwarf_Unsigned
table_end_offset
Dwarf_Unsigned
array_start_offset
Dwarf_Unsigned
length
Dwarf_Half
local_length_size
Dwarf_Half
local_extension_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
header_length
int
res
VALIDATE_SOT
sot
table_header_offset
sot
so_next_table_offset
if
table_header_offset
sot
so_section_size
return
DW_DLV_NO_ENTRY
table_header_ptr
sot
so_section_start_ptr
table_header_offset
sot
so_header_ptr
table_header_ptr
if
table_header_ptr
sot
so_section_end_ptr
if
table_header_ptr
sot
so_section_end_ptr
At
end
of
section
Done
return
DW_DLV_NO_ENTRY
else
bogus
table
offset
Dwarf_Unsigned
len
dwarfstring
m
ptrdiff_t
is
generated
but
not
named
len
sot
so_section_end_ptr
table_header_ptr
sot
so_section_end_ptr
table_header_ptr
dwarfstring_constructor
dwarfstring_append_printf_i
DW_DLE_STR_OFFSETS_EXTRA_BYTES
Table
Offset
is
DW_PR_DSd
bytes
past
end
of
section
len
_dwarf_error_string
sot
so_dbg
error
DW_DLE_STR_OFFSETS_EXTRA_BYTES
dwarfstring_string
dwarfstring_destructor
if
table_header_ptr
MIN_HEADER_LENGTH
sot
so_section_end_ptr
We
have
a
too
short
section
it
appears
Should
we
generate
error?
Or
ignore?
As
of
March
we
check
for
garbage
bytes
in
section
dwarfstring
m
Dwarf_Small
hend
Dwarf_Unsigned
len
if
is_all_zeroes
table_header_ptr
sot
so_section_end_ptr
return
DW_DLV_NO_ENTRY
hend
table_header_ptr
MIN_HEADER_LENGTH
ptrdiff_t
is
generated
but
not
named
len
hend
sot
so_section_end_ptr
hend
sot
so_section_end_ptr
dwarfstring_constructor
dwarfstring_append_printf_i
DW_DLE_STR_OFFSETS_EXTRA_BYTES
Table
Offset
plus
a
minimal
header
is
DW_PR_DSd
bytes
past
end
of
section
and
some
bytes
in
section
are
non
zero
len
_dwarf_error_string
sot
so_dbg
error
DW_DLE_STR_OFFSETS_EXTRA_BYTES
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
res
_dwarf_read_str_offsets_header
sot
so_dbg
table_header_ptr
sot
so_section_size
sot
so_section_end_ptr
error
if
res
DW_DLV_OK
return
res
if
version
DW_STR_OFFSETS_VERSION5
array_start_ptr
table_header_ptr
header_length
array_start_offset
table_header_offset
header_length
table_end_ptr
table_header_ptr
local_length_size
local_extension_size
length
table_end_offset
table_header_offset
local_length_size
local_extension_size
length
else
array_start_ptr
table_header_ptr
array_start_offset
table_header_offset
table_end_ptr
table_header_ptr
sot
so_section_size
table_end_offset
table_header_offset
sot
so_section_size
So
now
table_start_ptr
points
to
a
table
of
local_length_size
entries
Each
entry
in
this
table
is
local_length_size
bytes
long
or
Dwarf_Unsigned
entrycount
Dwarf_Unsigned
entrybytes
entrybytes
table_end_offset
array_start_offset
if
entrybytes
local_length_size
_dwarf_error
sot
so_dbg
error
DW_DLE_STR_OFFSETS_ARRAY_SIZE
return
DW_DLV_ERROR
entrycount
entrybytes
local_length_size
sot
so_next_table_offset
table_end_offset
sot
so_end_cu_ptr
table_end_ptr
sot
so_table_start_offset
table_header_offset
sot
so_array_ptr
array_start_ptr
sot
so_array_start_offset
array_start_offset
sot
so_array_entry_count
entrycount
sot
so_array_entry_size
local_length_size
sot
so_table_count
The
data
length
in
bytes
following
the
unit_length
field
of
the
header
unit_length_out
length
Where
the
unit_length
field
starts
in
the
section
unit_length_offset_out
sot
so_table_start_offset
Where
the
table
of
offsets
starts
in
the
section
table_start_offset_out
sot
so_array_start_offset
Entrysize
or
entry_size_out
local_length_size
Version
is
version_out
version
This
is
supposed
to
be
zero
padding_out
padding
How
many
entry_size
entries
are
in
the
array
table_value_count_out
entrycount
return
DW_DLV_OK
Meant
to
be
called
after
all
tables
accessed
using
dwarf_next_str_offsets_table
int
dwarf_str_offsets_statistics
Dwarf_Str_Offsets_Table
table_data
Dwarf_Unsigned
wasted_byte_count
Dwarf_Unsigned
table_count
Dwarf_Error
error
VALIDATE_SOT
table_data
if
wasted_byte_count
wasted_byte_count
table_data
so_wasted_section_bytes
if
table_count
table_count
table_data
so_table_count
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_util
h
int
dwarf_get_str
Dwarf_Debug
dbg
Dwarf_Off
offset
char
string
Dwarf_Signed
returned_str_len
Dwarf_Error
error
int
res
DW_DLV_ERROR
void
secptr
void
begin
void
end
if
dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
DW_DLV_ERROR
if
offset
dbg
de_debug_str
dss_size
Normal
if
we
ve
iterated
thru
the
set
of
strings
using
dwarf_get_str
and
are
at
the
end
return
DW_DLV_NO_ENTRY
if
offset
dbg
de_debug_str
dss_size
_dwarf_error
dbg
error
DW_DLE_DEBUG_STR_OFFSET_BAD
return
DW_DLV_ERROR
if
string
NULL
_dwarf_error
dbg
error
DW_DLE_STRING_PTR_NULL
return
DW_DLV_ERROR
res
_dwarf_load_section
dbg
de_debug_str
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_str
dss_size
return
DW_DLV_NO_ENTRY
secptr
dbg
de_debug_str
dss_data
begin
char
secptr
offset
end
char
secptr
dbg
de_debug_str
dss_size
res
_dwarf_check_string_valid
dbg
secptr
begin
end
DW_DLE_DEBUG_STR_OFFSET_BAD
error
if
res
DW_DLV_OK
return
res
string
char
begin
returned_str_len
strlen
string
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
dwarf_incl
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
exit
strtoul
declaration
etc
endif
include
dwarf_errmsg_list
h
This
is
just
to
help
localize
the
error
static
void
printone
int
i
int
arraysize
sizeof
_dwarf_errmsgs
sizeof
char
if
i
arraysize
printf
d
is
outside
the
array
Missing
something
n
i
else
printf
d
is
s
n
i
_dwarf_errmsgs
i
Arbitrary
A
much
smaller
max
length
value
would
work
define
MAX_NUM_LENGTH
return
TRUE
on
error
static
int
check_errnum_mismatches
unsigned
i
unsigned
nextstop
const
char
sp
_dwarf_errmsgs
i
const
char
cp
sp
unsigned
innit
FALSE
unsigned
prevchar
unsigned
value
for
cp
cp
unsigned
c
c
cp
if
c
c
innit
prevchar
Skip
number
part
of
macro
name
prevchar
c
continue
if
c
c
value
value
value
c
nextstop
if
nextstop
MAX_NUM_LENGTH
break
innit
TRUE
else
if
innit
break
prevchar
c
if
innit
if
i
value
return
TRUE
return
FALSE
There
is
no
number
to
check
Ignore
it
printf
mismatch
value
d
has
no
errnum
to
check
s
n
i
_dwarf_errmsgs
i
return
TRUE
We
don
t
allow
arbitrary
DW_DLE
line
length
define
MAXDEFINELINE
static
int
splmatches
char
base
unsigned
baselen
char
test
if
baselen
strlen
test
return
FALSE
for
test
test
base
if
test
base
return
FALSE
return
TRUE
static
void
check_dle_list
const
char
path
The
format
should
be
define
space
name
spaces
number
spaces
optional
c
comment
and
we
are
intentionally
quite
rigid
about
it
all
except
that
the
number
of
spaces
before
any
comment
is
allowed
char
buffer
MAXDEFINELINE
unsigned
linenum
unsigned
long
prevdefval
unsigned
foundlast
unsigned
foundlouser
FILE
fin
fin
fopen
path
r
if
fin
printf
Unable
to
open
define
list
to
read
s
n
path
exit
for
linenum
char
line
unsigned
linelen
char
curdefname
char
pastname
unsigned
curdefname_len
char
numstart
char
endptr
unsigned
long
v
line
fgets
buffer
MAXDEFINELINE
fin
if
line
break
linelen
strlen
line
if
linelen
unsigned
MAXDEFINELINE
printf
define
line
u
is
too
long
n
linenum
exit
if
strncmp
line
define
DW_DLE_
printf
define
line
u
has
wrong
leading
chars
n
linenum
exit
curdefname
line
ASSERT
line
ends
with
NUL
byte
for
curdefname_len
if
foundlouser
printf
define
line
u
has
stuff
after
DW_DLE_LO_USER
n
linenum
exit
pastname
curdefname
curdefname_len
if
pastname
At
end
of
line
Missing
value
printf
define
line
u
of
s
has
no
number
value
n
linenum
path
exit
if
pastname
Ok
Now
look
for
value
numstart
pastname
break
strtoul
skips
leading
whitespace
v
strtoul
numstart
This
test
is
a
bit
odd
But
is
valid
till
we
decide
it
is
inappropriate
if
v
DW_DLE_LO_USER
printf
define
line
u
number
value
unreasonable
lu
n
linenum
v
exit
if
v
endptr
numstart
printf
define
line
u
of
s
number
value
missing
n
linenum
path
printf
Leaving
a
space
as
in
define
A
B
in
libdwarf
h
in
will
cause
this
n
exit
if
endptr
endptr
n
printf
define
line
u
number
value
terminates
oddly
n
linenum
exit
if
splmatches
curdefname
curdefname_len
DW_DLE_LAST
if
foundlast
printf
duplicated
DW_DLE_LAST
line
u
n
linenum
exit
foundlast
if
v
prevdefval
printf
Invalid
Last
value
mismatch
lu
vs
lu
n
v
prevdefval
else
if
splmatches
curdefname
curdefname_len
DW_DLE_LO_USER
if
foundlast
printf
error
expected
DW_DLE_LO_USER
after
LAST
line
u
n
linenum
exit
if
foundlouser
printf
Error
duplicated
DW_DLE_LO_USER
line
u
n
linenum
exit
foundlouser
continue
else
if
linenum
if
v
prevdefval
printf
Invalid
Missing
value
lu
vs
lu
n
prevdefval
v
exit
prevdefval
v
Ignoring
rest
of
line
for
now
fclose
fin
int
main
int
argc
char
argv
unsigned
arraysize
sizeof
_dwarf_errmsgs
sizeof
char
unsigned
i
const
char
path
if
argc
printf
Expected
f
filename
of
DW_DLE
lines
from
libdwarf
h
exit
if
strcmp
argv
f
printf
Expected
f
exit
path
argv
check_dle_list
path
if
arraysize
DW_DLE_LAST
printf
Missing
or
extra
entry
in
dwarf
error
strings
array
u
expected
DW_DLE_LAST
d
n
arraysize
DW_DLE_LAST
printone
printone
printone
printone
printone
printone
printone
printone
printone
printone
printone
printone
printone
printone
exit
for
i
i
DW_DLE_LAST
i
if
check_errnum_mismatches
i
printf
mismatch
value
d
is
s
n
i
_dwarf_errmsgs
i
exit
OK
exit
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
dwarf_incl
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
free
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
stdio
h
For
debugging
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
dwarf_tsearch
h
include
dwarf_tied_decls
h
void
_dwarf_dumpsig
const
char
msg
Dwarf_Sig8
sig
int
lineno
const
char
sigv
unsigned
u
printf
s
msg
sigv
signature
for
u
u
u
printf
u
printf
line
d
n
lineno
void
_dwarf_tied_make_entry
Dwarf_Sig8
key
Dwarf_CU_Context
val
struct
Dwarf_Tied_Entry_s
e
e
calloc
sizeof
struct
Dwarf_Tied_Entry_s
if
e
e
dt_key
key
e
dt_context
val
return
e
Tied
data
Key
is
Dwarf_Sig8
A
hash
needed
because
we
are
using
a
hash
search
here
Would
not
be
needed
for
the
other
tree
searchs
like
balanced
trees
DW_TSHASHTYPE
_dwarf_tied_data_hashfunc
const
void
keyp
const
struct
Dwarf_Tied_Entry_s
enp
keyp
DW_TSHASHTYPE
hashv
Just
take
some
of
the
bytes
of
the
signature
memcpy
enp
dt_key
signature
sizeof
hashv
return
hashv
int
_dwarf_tied_compare_function
const
void
l
const
void
r
const
struct
Dwarf_Tied_Entry_s
lp
l
const
struct
Dwarf_Tied_Entry_s
rp
r
const
char
lcp
const
char
dt_key
signature
const
char
rcp
const
char
dt_key
signature
const
char
lcpend
lcp
sizeof
Dwarf_Sig8
for
lcp
lcpend
lcp
rcp
if
lcp
rcp
return
else
if
lcp
rcp
return
match
return
void
_dwarf_tied_destroy_free_node
void
nodep
struct
Dwarf_Tied_Entry_s
enp
nodep
free
enp
return
This
presumes
only
we
are
reading
the
debug_info
CUs
from
tieddbg
That
is
a
reasonable
requirement
one
hopes
Currently
it
reads
all
the
tied
CUs
at
once
up
to
the
point
of
finding
a
match
unless
there
is
an
error
This
the
only
way
we
call
_dwarf_next_cu_header
on
the
tied
file
so
safe
static
int
_dwarf_loop_reading_debug_info_for_cu
Dwarf_Debug
tieddbg
Dwarf_Error
error
unsigned
loop_count
We
will
not
find
tied
signatures
for
debug_addr
or
line
tables
in
debug_types
it
seems
Those
signatures
point
from
normal
to
dwo
dwp
DWARF4
int
is_info
TRUE
Dwarf_CU_Context
startingcontext
Dwarf_Unsigned
next_cu_offset
startingcontext
tieddbg
de_info_reading
de_cu_context
if
startingcontext
next_cu_offset
startingcontext
cc_debug_offset
startingcontext
cc_length
startingcontext
cc_length_size
startingcontext
cc_extension_size
for
loop_count
int
sres
DW_DLV_OK
Dwarf_Half
cu_type
Dwarf_CU_Context
latestcontext
Dwarf_Unsigned
cu_header_length
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
version_stamp
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Half
length_size
Dwarf_Sig8
signature
Dwarf_Bool
has_signature
FALSE
Dwarf_Unsigned
typeoffset
memset
sizeof
signature
sres
_dwarf_next_cu_header_internal
tieddbg
is_info
error
if
sres
DW_DLV_NO_ENTRY
break
latestcontext
tieddbg
de_info_reading
de_cu_context
if
has_signature
void
retval
Dwarf_Sig8
consign
latestcontext
cc_signature
void
entry
_dwarf_tied_make_entry
latestcontext
if
entry
return
DW_DLV_NO_ENTRY
Insert
this
signature
and
context
retval
dwarf_tsearch
entry
de_tied_data
td_tied_search
_dwarf_tied_compare_function
if
retval
free
entry
FAILED
might
be
out
of
memory
return
DW_DLV_NO_ENTRY
else
struct
Dwarf_Tied_Data_s
retent
struct
Dwarf_Tied_Data_s
retval
if
retent
entry
we
added
a
record
return
DW_DLV_OK
else
found
existing
no
add
free
entry
return
DW_DLV_OK
Apparently
we
never
found
the
sig
we
are
looking
for
Pretend
ok
Caller
will
check
for
success
return
DW_DLV_OK
If
out
of
memory
just
return
DW_DLV_NO_ENTRY
int
_dwarf_search_for_signature
Dwarf_Debug
tieddbg
Dwarf_Sig8
sig
Dwarf_CU_Context
context_out
Dwarf_Error
error
void
entry2
struct
Dwarf_Tied_Entry_s
entry
struct
Dwarf_Tied_Data_s
tied
de_tied_data
int
res
if
tied
td_tied_search
dwarf_initialize_search_hash
td_tied_search
_dwarf_tied_data_hashfunc
if
tied
td_tied_search
return
DW_DLV_NO_ENTRY
entry
dt_key
sig
entry
dt_context
entry2
dwarf_tfind
td_tied_search
_dwarf_tied_compare_function
if
entry2
struct
Dwarf_Tied_Entry_s
e2
struct
Dwarf_Tied_Entry_s
entry2
context_out
e2
dt_context
return
DW_DLV_OK
We
now
ensure
all
tieddbg
CUs
signatures
are
in
the
td_tied_search
The
caller
is
NOT
doing
info
section
read
operations
on
the
tieddbg
in
this
tied
dbg
so
it
cannot
goof
up
their
_dwarf_next_cu_header
res
_dwarf_loop_reading_debug_info_for_cu
tieddbg
error
if
res
DW_DLV_ERROR
return
res
entry2
dwarf_tfind
td_tied_search
_dwarf_tied_compare_function
if
entry2
struct
Dwarf_Tied_Entry_s
e2
struct
Dwarf_Tied_Entry_s
entry2
context_out
e2
dt_context
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
The
interfaces
follow
tsearch
See
the
Single
Unix
Specification
but
the
implementation
is
written
without
reference
to
the
source
of
any
version
of
tsearch
or
any
hashing
code
An
additional
interface
is
added
compared
to
a
real
tsearch
to
let
the
caller
identify
a
hash
function
with
each
hash
table
called
a
tree
below
but
that
is
a
misnomer
So
read
tree
below
as
hash
table
See
http
www
prevanders
net
tsearch
html
for
information
and
an
example
of
use
Based
on
Knuth
chapter
This
uses
a
hash
based
on
the
key
Collision
resolution
is
by
chaining
twalk
and
tdestroy
walk
in
a
random
order
The
preorder
etc
labels
mean
nothing
in
a
hash
so
everything
is
called
a
leaf
include
config
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
malloc
free
etc
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
stdio
h
for
printf
ifdef
HAVE_STDINT_H
include
stdint
h
for
uintptr_t
endif
HAVE_STDINT_H
include
libdwarf_private
h
This
must
match
the
types
and
print
options
found
in
libdwarf
h
define
Dwarf_Unsigned
unsigned
long
long
include
dwarf_tsearch
h
A
table
of
primes
used
to
size
and
resize
the
hash
table
From
public
sources
of
prime
numbers
arbitrarily
chosen
to
approximately
double
in
size
at
each
step
static
unsigned
long
primes
if
for
testing
only
endif
Here
we
are
giving
up
static
unsigned
long
allowed_fill_percent
struct
hs_base
unsigned
long
tablesize_
unsigned
long
tablesize_entry_index_
unsigned
long
allowed_fill_
Record_count
means
number
of
active
records
counting
all
records
on
chains
When
the
record_count
is
of
a
full
tablesize_
we
redo
the
table
before
adding
a
new
entry
unsigned
long
record_count_
hashtab_
is
an
array
of
hs_entry
indexes
through
tablesize_
struct
ts_entry
hashtab_
DW_TSHASHTYPE
hashfunc_
const
void
key
struct
ts_entry
const
void
keyptr
So
that
a
keyptr
of
if
added
is
not
confused
with
an
empty
hash
slot
we
must
mark
used
slots
as
used
in
the
hash
tab
unsigned
char
entryused
struct
ts_entry
next
enum
search_intent_t
want_insert
only_find
want_delete
static
struct
ts_entry
tsearch_inner
const
void
key
struct
hs_base
head
int
compar
const
void
const
void
const
enum
search_intent_t
intent
int
inserted
struct
ts_entry
parent_ptr
static
void
dwarf_tdestroy_inner
struct
hs_base
h
void
free_node
void
nodep
int
depth
A
trivial
integer
based
percentage
calculation
Percents
are
reasonable
for
a
hash
with
chains
situation
even
if
they
might
not
be
the
best
choice
for
performance
static
unsigned
long
calculate_allowed_fill
unsigned
long
fill_percent
unsigned
long
ct
unsigned
long
v
if
ct
unsigned
long
v2
ct
fill_percent
return
v2
v
ct
fill_percent
return
v
Initialize
the
hash
and
pass
in
the
hash
function
If
the
entry
count
needed
is
unknown
pass
in
as
a
count
estimate
but
if
the
number
of
hash
entries
needed
can
be
estimated
pass
in
the
estimate
which
need
not
be
prime
we
actually
use
the
nearest
higher
prime
from
the
above
table
If
the
estimated
count
is
Return
the
tree
base
or
return
NULL
if
insufficient
memory
void
dwarf_initialize_search_hash
void
treeptr
DW_TSHASHTYPE
hashfunc
const
void
key
unsigned
long
size_estimate
unsigned
long
prime_to_use
primes
unsigned
entry_index
unsigned
k
struct
hs_base
base
base
struct
hs_base
treeptr
if
base
initalized
already
return
base
base
calloc
sizeof
struct
hs_base
if
base
Out
of
memory
return
NULL
prime_to_use
primes
while
size_estimate
size_estimate
prime_to_use
k
k
prime_to_use
primes
k
if
prime_to_use
Oops
Too
large
free
base
return
NULL
entry_index
k
base
tablesize_
prime_to_use
base
allowed_fill_
calculate_allowed_fill
allowed_fill_percent
prime_to_use
if
base
allowed_fill_
base
tablesize_
free
base
Oops
We
are
in
trouble
Coding
mistake
here
return
NULL
base
record_count_
base
tablesize_entry_index_
entry_index
hashtab_
is
an
array
of
hs_entry
indexes
through
tablesize_
base
hashfunc_
hashfunc
base
hashtab_
calloc
sizeof
struct
ts_entry
base
tablesize_
if
base
hashtab_
free
base
return
NULL
treeptr
base
return
base
We
don
t
really
care
whether
hashpos
or
chainpos
are
or
bits
suffices
static
void
print_entry
struct
ts_entry
t
const
char
descr
char
keyprint
const
void
unsigned
long
hashpos
unsigned
long
chainpos
char
v
if
t
entryused
return
v
keyprint
t
keyptr
printf
DW_PR_DUx
keyptr
DW_PR_DUx
key
s
s
n
hashpos
chainpos
Dwarf_Unsigned
uintptr_t
t
Dwarf_Unsigned
uintptr_t
t
keyptr
v
descr
For
debugging
static
void
dumptree_inner
const
struct
hs_base
h
char
keyprint
const
void
const
char
descr
int
printdetails
unsigned
long
ix
unsigned
long
tsize
h
tablesize_
struct
ts_entry
p
hashtab_
unsigned
long
hashused
unsigned
long
maxchainlength
unsigned
long
chainsgt1
printf
dumptree
head
ptr
DW_PR_DUx
size
DW_PR_DUu
entries
DW_PR_DUu
allowed
DW_PR_DUu
s
n
Dwarf_Unsigned
uintptr_t
h
Dwarf_Unsigned
h
tablesize_
Dwarf_Unsigned
h
record_count_
Dwarf_Unsigned
h
allowed_fill_
descr
for
ix
tsize
ix
p
unsigned
long
chainlength
struct
ts_entry
n
int
chainpos
if
p
entryused
hashused
chainlength
if
printdetails
print_entry
p
head
keyprint
ix
chainpos
chainpos
for
n
p
next
n
n
n
next
chainlength
if
printdetails
print_entry
n
chain
keyprint
ix
chainpos
if
chainlength
maxchainlength
maxchainlength
chainlength
if
chainlength
chainsgt1
printf
Hashtable
lu
of
lu
hash
entries
used
n
hashused
tsize
printf
Hashtable
lu
chains
length
longer
than
n
chainsgt1
printf
Hashtable
lu
is
maximum
chain
length
n
maxchainlength
Dumping
the
tree
void
dwarf_tdump
const
void
headp_in
char
keyprint
const
void
const
char
msg
const
struct
hs_base
head
const
struct
hs_base
headp_in
if
head
printf
dumptree
null
tree
ptr
s
n
msg
return
dumptree_inner
head
keyprint
msg
static
struct
ts_entry
allocate_ts_entry
const
void
key
struct
ts_entry
e
e
struct
ts_entry
malloc
sizeof
struct
ts_entry
if
e
return
NULL
e
keyptr
key
e
entryused
e
next
return
e
static
void
resize_table
struct
hs_base
head
int
compar
const
void
const
void
struct
hs_base
newhead
unsigned
new_entry_index
unsigned
long
prime_to_use
Copy
the
values
we
have
newhead
head
But
drop
the
hashtab_
from
new
calloc
below
newhead
hashtab_
newhead
record_count_
new_entry_index
head
tablesize_entry_index_
prime_to_use
primes
new_entry_index
if
prime_to_use
Oops
too
large
Leave
table
size
as
is
though
it
will
get
slow
as
it
overfills
return
newhead
tablesize_
prime_to_use
newhead
allowed_fill_
calculate_allowed_fill
allowed_fill_percent
prime_to_use
if
newhead
allowed_fill_
newhead
tablesize_
Oops
We
are
in
trouble
return
newhead
tablesize_entry_index_
new_entry_index
newhead
hashtab_
calloc
sizeof
struct
ts_entry
newhead
tablesize_
if
newhead
hashtab_
Oops
too
large
Leave
table
size
as
is
though
things
will
get
slow
as
it
overfills
free
newhead
hashtab_
return
Insert
all
the
records
from
the
old
table
into
the
new
table
int
fillnewfail
unsigned
long
ix
unsigned
long
tsize
head
tablesize_
struct
ts_entry
p
hashtab_
for
ix
tsize
ix
p
int
inserted
struct
ts_entry
n
if
fillnewfail
break
if
p
keyptr
tsearch_inner
p
keyptr
compar
want_insert
if
inserted
fillnewfail
break
for
n
p
next
n
n
n
next
inserted
tsearch_inner
n
keyptr
compar
want_insert
if
inserted
fillnewfail
break
if
fillnewfail
free
newhead
hashtab_
return
Now
get
rid
of
the
chain
entries
of
the
old
table
dwarf_tdestroy_inner
head
Now
get
rid
of
the
old
table
itself
free
head
hashtab_
head
hashtab_
head
newhead
return
Inner
search
of
the
hash
and
synonym
chains
static
struct
ts_entry
tsearch_inner
const
void
key
struct
hs_base
head
int
compar
const
void
const
void
const
enum
search_intent_t
intent
int
inserted
owner_ptr
used
for
delete
Only
set
if
the
to
be
deleted
item
is
on
a
chain
not
in
the
hashtab
Points
to
the
item
pointing
to
the
to
be
deleted
item
struct
ts_entry
owner_ptr
struct
ts_entry
s
struct
ts_entry
c
struct
ts_entry
q
int
kc
DW_TSHASHTYPE
keyhash
DW_TSHASHTYPE
hindx
struct
ts_entry
chain_parent
if
head
hashfunc_
Not
fully
initialized
return
NULL
keyhash
head
hashfunc_
key
if
intent
want_insert
if
head
record_count_
head
allowed_fill_
resize_table
head
compar
hindx
keyhash
head
tablesize_
s
hashtab_
hindx
if
s
entryused
Not
found
if
intent
want_insert
return
NULL
Insert
in
the
base
hash
table
in
an
empty
slot
inserted
head
record_count_
s
keyptr
const
void
key
s
entryused
s
next
return
s
kc
compar
key
s
keyptr
if
kc
found
if
want_delete
owner_ptr
return
void
s
keyptr
chain_parent
s
for
c
s
next
c
c
c
next
kc
compar
key
c
keyptr
if
kc
found
if
want_delete
owner_ptr
chain_parent
return
void
c
keyptr
chain_parent
c
if
intent
want_insert
return
NULL
Insert
following
head
record
of
the
chain
q
allocate_ts_entry
key
if
q
return
q
q
next
s
next
s
next
q
head
record_count_
inserted
return
q
Search
and
if
missing
insert
void
dwarf_tsearch
const
void
key
void
headin
int
compar
const
void
const
void
struct
hs_base
rootp
struct
hs_base
headin
struct
hs_base
head
rootp
struct
ts_entry
r
int
inserted
nullme
won
t
be
set
struct
ts_entry
nullme
if
head
something
is
wrong
here
not
initialized
return
NULL
r
tsearch_inner
key
head
compar
want_insert
if
r
return
NULL
return
void
r
keyptr
Search
void
dwarf_tfind
const
void
key
void
const
rootp
int
compar
const
void
const
void
Nothing
will
change
but
we
discard
const
so
we
can
use
tsearch_inner
struct
hs_base
proot
struct
hs_base
rootp
struct
hs_base
head
proot
struct
ts_entry
r
inserted
flag
won
t
be
set
int
inserted
nullme
won
t
be
set
struct
ts_entry
nullme
Get
to
actual
tree
if
head
return
NULL
r
tsearch_inner
key
head
compar
only_find
if
r
return
NULL
return
void
r
keyptr
Unlike
the
simple
binary
tree
case
a
fully
empty
hash
situation
does
not
null
the
rootp
void
dwarf_tdelete
const
void
key
void
rootp
int
compar
const
void
const
void
struct
hs_base
proot
struct
hs_base
rootp
struct
hs_base
head
proot
struct
ts_entry
found
inserted
flag
won
t
be
set
int
inserted
struct
ts_entry
parentp
if
head
return
NULL
found
tsearch_inner
key
head
compar
want_delete
if
found
if
parentp
Delete
a
chain
entry
head
record_count_
parentp
next
found
next
We
free
our
storage
It
would
be
up
to
caller
to
do
a
tfind
to
find
a
record
and
delete
content
if
necessary
free
found
return
void
parentp
keyptr
So
found
is
the
head
of
a
chain
if
found
next
Delete
a
chain
entry
pull
up
to
hash
tab
freeing
up
the
chain
entry
struct
ts_entry
pullup
found
next
found
pullup
free
pullup
head
record_count_
return
void
found
keyptr
else
Delete
a
main
hash
table
entry
Problem
what
the
heck
to
return
as
a
keyptr
pointer?
Well
we
return
NULL
As
in
the
standard
tsearch
returning
NULL
does
not
mean
failure
Here
it
just
means
empty
chain
somewhere
head
record_count_
found
next
found
keyptr
found
entryused
return
NULL
return
NULL
static
void
dwarf_twalk_inner
const
struct
hs_base
h
struct
ts_entry
p
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
UNUSEDARG
unsigned
level
UNUSEDARG
unsigned
long
ix
unsigned
long
tsize
h
tablesize_
for
ix
tsize
ix
p
struct
ts_entry
n
if
p
keyptr
action
void
p
keyptr
dwarf_leaf
level
for
n
p
next
n
n
n
next
action
void
n
keyptr
dwarf_leaf
level
void
dwarf_twalk
const
void
rootp
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
UNUSEDARG
const
struct
hs_base
head
const
struct
hs_base
rootp
struct
ts_entry
root
if
head
return
root
head
hashtab_
Get
to
actual
tree
dwarf_twalk_inner
head
root
action
static
void
dwarf_tdestroy_inner
struct
hs_base
h
void
free_node
void
nodep
int
depth
UNUSEDARG
unsigned
long
ix
unsigned
long
tsize
h
tablesize_
struct
ts_entry
p
hashtab_
for
ix
tsize
ix
p
struct
ts_entry
n
struct
ts_entry
prev
if
p
keyptr
p
entryused
if
free_node
free_node
void
p
keyptr
h
record_count_
Now
walk
and
free
up
the
chain
entries
for
n
p
next
n
if
free_node
free_node
void
n
keyptr
h
record_count_
prev
n
n
n
next
free
prev
Walk
the
tree
freeing
all
space
in
the
tree
and
calling
the
user
s
callback
function
on
each
node
It
is
up
to
the
caller
to
zero
out
anything
pointing
to
head
ie
that
has
the
value
rootp
holds
after
this
returns
void
dwarf_tdestroy
void
rootp
void
free_node
void
nodep
struct
hs_base
head
struct
hs_base
rootp
struct
ts_entry
root
if
head
return
root
head
hashtab_
dwarf_tdestroy_inner
head
free_node
free
root
free
head
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_types
h
include
dwarf_global
h
int
dwarf_get_types
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
ret_type_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_typenames
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_typenames
dss_size
return
DW_DLV_NO_ENTRY
return
_dwarf_internal_get_pubnames_like_data
dbg
debug_typenames
dbg
de_debug_typenames
dss_data
dbg
de_debug_typenames
dss_size
Dwarf_Global
types
type
punning
Dwarf_Type
is
never
a
completed
type
ret_type_count
error
DW_DLA_TYPENAME_CONTEXT
DW_DLA_TYPENAME
DW_DLE_DEBUG_TYPENAMES_LENGTH_BAD
DW_DLE_DEBUG_TYPENAMES_VERSION_ERROR
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_types_dealloc
Dwarf_Debug
dbg
Dwarf_Type
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
Dwarf_Global
dwgl
count
return
int
dwarf_typename
Dwarf_Type
type_in
char
ret_name
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
if
type
NULL
_dwarf_error
NULL
error
DW_DLE_TYPE_NULL
return
DW_DLV_ERROR
ret_name
char
type
gl_name
return
DW_DLV_OK
int
dwarf_type_die_offset
Dwarf_Type
type_in
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_die_offset
type
ret_offset
error
int
dwarf_type_cu_offset
Dwarf_Type
type_in
Dwarf_Off
ret_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_cu_offset
type
ret_offset
error
int
dwarf_type_name_offsets
Dwarf_Type
type_in
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_die_offset
Dwarf_Error
error
Dwarf_Global
type
Dwarf_Global
type_in
return
dwarf_global_name_offsets
type
returned_name
die_offset
cu_die_offset
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
Google
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
stdarg
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
free
and
emergency
abort
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
_WIN32
include
io
h
elif
defined
HAVE_UNISTD_H
include
unistd
h
endif
_WIN32
ifdef
HAVE_SYS_TYPES_H
include
sys
types
h
open
off_t
size_t
ssize_t
endif
HAVE_SYS_TYPES_H
ifdef
HAVE_SYS_STAT_H
include
sys
stat
h
for
open
endif
HAVE_SYS_STAT_H
include
fcntl
h
for
open
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_abbrev
h
include
memcpy_swap
h
include
dwarf_die_deliv
h
include
dwarfstring
h
ifndef
O_BINARY
define
O_BINARY
endif
O_BINARY
define
MINBUFLEN
if
_WIN32
define
NULL_DEVICE_NAME
NUL
else
define
NULL_DEVICE_NAME
dev
null
endif
_WIN32
define
MORE_BYTES
define
DATA_MASK
define
DIGIT_WIDTH
define
SIGN_BIT
The
function
returned
allows
dwarfdump
and
other
callers
to
do
an
endian
sensitive
copy
word
with
a
chosen
source
length
typedef
void
endian_funcp_type
void
const
void
unsigned
long
const
char
dwarf_package_version
void
return
PACKAGE_VERSION
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
msg
for
cur
end
cur
printf
cur
printf
n
endif
endian_funcp_type
dwarf_get_endian_copy_function
Dwarf_Debug
dbg
if
dbg
return
dbg
de_copy_word
return
Dwarf_Bool
_dwarf_file_has_debug_fission_cu_index
Dwarf_Debug
dbg
if
dbg
return
FALSE
if
dbg
de_cu_hashindex_data
return
TRUE
return
FALSE
Dwarf_Bool
_dwarf_file_has_debug_fission_tu_index
Dwarf_Debug
dbg
if
dbg
return
FALSE
if
dbg
de_tu_hashindex_data
return
TRUE
return
FALSE
Dwarf_Bool
_dwarf_file_has_debug_fission_index
Dwarf_Debug
dbg
if
dbg
return
FALSE
if
dbg
de_cu_hashindex_data
dbg
de_tu_hashindex_data
return
return
FALSE
void
_dwarf_create_area_len_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
targ
Dwarf_Unsigned
sectionlen
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_HEADER_LEN_BIGGER_THAN_SECSIZE
The
header
length
of
x
is
larger
targ
dwarfstring_append_printf_u
than
the
section
length
of
x
sectionlen
_dwarf_error_string
dbg
error
DW_DLE_HEADER_LEN_BIGGER_THAN_SECSIZE
dwarfstring_string
dwarfstring_destructor
int
_dwarf_internal_get_die_comp_dir
Dwarf_Die
die
const
char
compdir_out
const
char
compname_out
Dwarf_Error
error
Dwarf_Attribute
comp_dir_attr
Dwarf_Attribute
comp_name_attr
int
resattr
Dwarf_Debug
dbg
dbg
die
di_cu_context
cc_dbg
resattr
dwarf_attr
die
DW_AT_name
error
if
resattr
DW_DLV_ERROR
return
resattr
if
resattr
DW_DLV_OK
int
cres
DW_DLV_ERROR
char
name
cres
dwarf_formstring
comp_name_attr
error
if
cres
DW_DLV_ERROR
dwarf_dealloc
dbg
comp_name_attr
DW_DLA_ATTR
return
cres
else
if
cres
DW_DLV_OK
compname_out
const
char
name
else
FALL
thru
if
resattr
DW_DLV_OK
dwarf_dealloc
dbg
comp_name_attr
DW_DLA_ATTR
resattr
dwarf_attr
die
DW_AT_comp_dir
error
if
resattr
DW_DLV_ERROR
return
resattr
if
resattr
DW_DLV_OK
int
cres
DW_DLV_ERROR
char
cdir
cres
dwarf_formstring
comp_dir_attr
error
if
cres
DW_DLV_ERROR
dwarf_dealloc
dbg
comp_dir_attr
DW_DLA_ATTR
return
cres
else
if
cres
DW_DLV_OK
compdir_out
const
char
cdir
else
FALL
thru
if
resattr
DW_DLV_OK
dwarf_dealloc
dbg
comp_dir_attr
DW_DLA_ATTR
return
resattr
Given
a
form
and
a
pointer
to
the
bytes
encoding
a
value
of
that
form
val_ptr
this
function
returns
the
length
in
bytes
of
a
value
of
that
form
When
using
this
function
check
for
a
return
of
a
recursive
DW_FORM_INDIRECT
value
int
_dwarf_get_size_of_val
Dwarf_Debug
dbg
Dwarf_Unsigned
form
Dwarf_Half
cu_version
Dwarf_Half
address_size
Dwarf_Small
val_ptr
int
v_length_size
Dwarf_Unsigned
size_out
Dwarf_Small
section_end_ptr
Dwarf_Error
error
Dwarf_Unsigned
length
Dwarf_Unsigned
leb128_length
Dwarf_Unsigned
form_indirect
Dwarf_Unsigned
ret_value
switch
form
When
we
encounter
a
FORM
here
that
we
know
about
but
forgot
to
enter
here
we
had
better
not
just
continue
Usually
means
we
forgot
to
update
this
function
when
implementing
form
handling
of
a
new
FORM
Disaster
results
from
using
a
bogus
value
so
generate
error
default
_dwarf_error
dbg
error
DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE
return
DW_DLV_ERROR
case
return
DW_DLV_OK
case
DW_FORM_GNU_ref_alt
case
DW_FORM_GNU_strp_alt
case
DW_FORM_strp_sup
size_out
v_length_size
return
DW_DLV_OK
case
DW_FORM_addr
if
address_size
size_out
address_size
else
This
should
never
happen
address_size
should
be
set
size_out
dbg
de_pointer_size
return
DW_DLV_OK
case
DW_FORM_ref_sig8
size_out
sizeof
Dwarf_Sig8
return
DW_DLV_OK
DWARF2
was
wrong
on
the
size
of
the
attribute
for
DW_FORM_ref_addr
We
assume
compilers
are
using
the
corrected
DWARF3
text
for
pointer
target
objects
pointer
and
offsets
are
the
same
size
anyway
It
is
clear
as
of
that
for
folks
used
the
V2
spec
in
the
way
V2
was
written
so
the
ref_addr
has
to
account
for
that
case
DW_FORM_ref_addr
if
cu_version
DW_CU_VERSION2
size_out
address_size
else
size_out
v_length_size
return
DW_DLV_OK
case
DW_FORM_block1
Dwarf_Unsigned
space_left
if
val_ptr
section_end_ptr
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_FORM_block1
itself
is
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
ret_value
Dwarf_Small
val_ptr
ptrdiff_t
is
generated
but
not
named
space_left
section_end_ptr
val_ptr
section_end_ptr
val_ptr
if
ret_value
space_left
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_FORM_block1
runs
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
size_out
ret_value
return
DW_DLV_OK
case
DW_FORM_block2
Dwarf_Unsigned
space_left
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
val_ptr
DWARF_HALF_SIZE
error
section_end_ptr
ptrdiff_t
is
generated
but
not
named
space_left
section_end_ptr
val_ptr
section_end_ptr
val_ptr
if
ret_value
space_left
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_FORM_block2
runs
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
size_out
ret_value
DWARF_HALF_SIZE
return
DW_DLV_OK
case
DW_FORM_block4
Dwarf_Unsigned
space_left
READ_UNALIGNED_CK
dbg
ret_value
Dwarf_Unsigned
val_ptr
DWARF_32BIT_SIZE
error
section_end_ptr
ptrdiff_t
is
generated
but
not
named
space_left
section_end_ptr
val_ptr
section_end_ptr
val_ptr
if
ret_value
space_left
_dwarf_error_string
dbg
error
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_DLE_FORM_BLOCK_LENGTH_ERROR
DW_FORM_block4
runs
off
the
end
of
the
section
Corrupt
Dwarf
return
DW_DLV_ERROR
size_out
ret_value
DWARF_32BIT_SIZE
return
DW_DLV_OK
case
DW_FORM_data1
size_out
return
DW_DLV_OK
case
DW_FORM_data2
size_out
return
DW_DLV_OK
case
DW_FORM_data4
size_out
return
DW_DLV_OK
case
DW_FORM_data8
size_out
return
DW_DLV_OK
case
DW_FORM_data16
size_out
return
DW_DLV_OK
case
DW_FORM_string
int
res
res
_dwarf_check_string_valid
dbg
val_ptr
val_ptr
section_end_ptr
DW_DLE_FORM_STRING_BAD_STRING
error
if
res
DW_DLV_OK
return
res
size_out
strlen
char
val_ptr
return
DW_DLV_OK
case
DW_FORM_block
case
DW_FORM_exprloc
DECODE_LEB128_UWORD_LEN_CK
val_ptr
length
leb128_length
dbg
error
section_end_ptr
size_out
length
leb128_length
return
DW_DLV_OK
case
DW_FORM_flag_present
size_out
return
DW_DLV_OK
case
DW_FORM_flag
size_out
return
DW_DLV_OK
case
DW_FORM_sec_offset
If
dwarf
is
Else
is
dwarf
and
is
size_out
v_length_size
return
DW_DLV_OK
case
DW_FORM_ref_udata
UNUSEDARG
Dwarf_Unsigned
v
Discard
the
decoded
value
we
just
want
the
length
of
the
value
DECODE_LEB128_UWORD_LEN_CK
val_ptr
v
leb128_length
dbg
error
section_end_ptr
size_out
leb128_length
return
DW_DLV_OK
case
DW_FORM_indirect
Dwarf_Unsigned
indir_len
int
res
Dwarf_Unsigned
info_data_len
DECODE_LEB128_UWORD_LEN_CK
val_ptr
form_indirect
indir_len
dbg
error
section_end_ptr
if
form_indirect
DW_FORM_indirect
We
are
in
big
trouble
The
true
form
of
DW_FORM_indirect
is
DW_FORM_indirect?
Nonsense
Should
never
happen
_dwarf_error
dbg
error
DW_DLE_NESTED_FORM_INDIRECT_ERROR
return
DW_DLV_ERROR
If
form_indirect
is
DW_FORM_implicit_const
then
the
following
call
will
set
info_data_len
res
_dwarf_get_size_of_val
dbg
form_indirect
cu_version
address_size
val_ptr
indir_len
v_length_size
section_end_ptr
error
if
res
DW_DLV_OK
return
res
size_out
indir_len
info_data_len
return
DW_DLV_OK
case
DW_FORM_ref1
size_out
return
DW_DLV_OK
case
DW_FORM_ref2
size_out
return
DW_DLV_OK
case
DW_FORM_ref4
size_out
return
DW_DLV_OK
case
DW_FORM_ref8
size_out
return
DW_DLV_OK
DW_FORM_implicit_const
is
a
value
in
the
abbreviations
not
in
the
DIEs
and
this
functions
measures
DIE
size
case
DW_FORM_implicit_const
size_out
return
DW_DLV_OK
case
DW_FORM_sdata
Discard
the
decoded
value
we
just
want
the
length
of
the
value
UNUSEDARG
Dwarf_Signed
v
Discard
the
decoded
value
we
just
want
the
length
of
the
value
DECODE_LEB128_SWORD_LEN_CK
val_ptr
v
leb128_length
dbg
error
section_end_ptr
size_out
leb128_length
return
DW_DLV_OK
case
DW_FORM_ref_sup4
size_out
return
DW_DLV_OK
case
DW_FORM_ref_sup8
size_out
return
DW_DLV_OK
case
DW_FORM_addrx1
size_out
return
DW_DLV_OK
case
DW_FORM_addrx2
size_out
return
DW_DLV_OK
case
DW_FORM_addrx3
size_out
return
DW_DLV_OK
case
DW_FORM_addrx4
size_out
return
DW_DLV_OK
case
DW_FORM_strx1
size_out
return
DW_DLV_OK
case
DW_FORM_strx2
size_out
return
DW_DLV_OK
case
DW_FORM_strx3
size_out
return
DW_DLV_OK
case
DW_FORM_strx4
size_out
return
DW_DLV_OK
case
DW_FORM_loclistx
case
DW_FORM_rnglistx
case
DW_FORM_addrx
case
DW_FORM_GNU_addr_index
case
DW_FORM_strx
case
DW_FORM_GNU_str_index
UNUSEDARG
Dwarf_Unsigned
v
DECODE_LEB128_UWORD_LEN_CK
val_ptr
v
leb128_length
dbg
error
section_end_ptr
size_out
leb128_length
return
DW_DLV_OK
case
DW_FORM_line_strp
case
DW_FORM_strp
size_out
v_length_size
return
DW_DLV_OK
case
DW_FORM_udata
Discard
the
decoded
value
we
just
want
the
length
of
the
value
UNUSEDARG
Dwarf_Unsigned
v
DECODE_LEB128_UWORD_LEN_CK
val_ptr
v
leb128_length
dbg
error
section_end_ptr
size_out
leb128_length
return
DW_DLV_OK
We
allow
an
arbitrary
number
of
HT_MULTIPLE
entries
before
resizing
It
seems
up
to
or
would
work
nearly
as
well
We
could
have
a
different
resize
multiple
than
resize
now
test
multiple
but
for
now
we
don
t
do
that
define
HT_MULTIPLE
Copy
the
old
entries
updating
each
to
be
in
a
new
list
Don
t
delete
anything
Leave
the
htin
with
stale
data
static
void
copy_abbrev_table_to_new_table
Dwarf_Hash_Table
htin
Dwarf_Hash_Table
htout
Dwarf_Hash_Table_Entry
entry_in
htin
tb_entries
unsigned
entry_in_count
htin
tb_table_entry_count
Dwarf_Hash_Table_Entry
entry_out
htout
tb_entries
unsigned
entry_out_count
htout
tb_table_entry_count
unsigned
k
for
k
entry_in_count
k
entry_in
Dwarf_Abbrev_List
listent
entry_in
at_head
Dwarf_Abbrev_List
nextlistent
for
listent
listent
nextlistent
unsigned
newtmp
listent
abl_code
unsigned
newhash
newtmp
entry_out_count
Dwarf_Hash_Table_Entry
e
nextlistent
listent
abl_next
e
entry_out
newhash
Move_entry_to_new_hash
This
reverses
the
order
of
the
entries
effectively
but
that
does
not
seem
significant
listent
abl_next
e
at_head
e
at_head
listent
htout
tb_total_abbrev_count
We
allow
zero
form
here
end
of
list
int
_dwarf_valid_form_we_know
Dwarf_Unsigned
at_form
Dwarf_Unsigned
at_name
if
at_form
at_name
return
TRUE
if
at_name
return
FALSE
if
at_form
DW_FORM_addrx4
return
TRUE
if
at_form
DW_FORM_GNU_addr_index
at_form
DW_FORM_GNU_str_index
at_form
DW_FORM_GNU_ref_alt
at_form
DW_FORM_GNU_strp_alt
return
TRUE
return
FALSE
int
_dwarf_format_TAG_err_msg
Dwarf_Debug
dbg
Dwarf_Unsigned
tag
const
char
m
Dwarf_Error
errp
dwarfstring
v
dwarfstring_constructor
dwarfstring_append
char
m
dwarfstring_append
The
value
dwarfstring_append_printf_u
DW_PR_DUx
is
outside
the
valid
TAG
range
tag
dwarfstring_append
Corrupt
DWARF
_dwarf_error_string
dbg
errp
DW_DLE_TAG_CORRUPT
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
This
function
returns
a
pointer
to
a
Dwarf_Abbrev_List_s
struct
for
the
abbrev
with
the
given
code
It
puts
the
struct
on
the
appropriate
hash
table
It
also
adds
all
the
abbrev
between
the
last
abbrev
added
and
this
one
to
the
hash
table
In
other
words
the
debug_abbrev
section
is
scanned
sequentially
from
the
top
for
an
abbrev
with
the
given
code
All
intervening
abbrevs
are
also
put
into
the
hash
table
This
function
hashes
the
given
code
and
checks
the
chain
at
that
hash
table
entry
to
see
if
a
Dwarf_Abbrev_List_s
with
the
given
code
exists
If
yes
it
returns
a
pointer
to
that
struct
Otherwise
it
scans
the
debug_abbrev
section
from
the
last
byte
scanned
for
that
CU
till
either
an
abbrev
with
the
given
code
is
found
or
an
abbrev
code
of
is
read
It
puts
Dwarf_Abbrev_List_s
entries
for
all
abbrev
s
read
till
that
point
into
the
hash
table
The
hash
table
contains
both
a
head
pointer
and
a
tail
pointer
for
each
entry
While
the
lists
can
move
and
entries
can
be
moved
between
lists
on
reallocation
any
given
Dwarf_Abbrev_list
entry
never
moves
once
allocated
so
the
pointer
is
safe
to
return
See
also
dwarf_get_abbrev
in
dwarf_abbrev
c
On
returning
DW_DLV_NO_ENTRY
as
well
as
DW_DLV_OK
it
sets
highest_known_code
as
a
side
effect
for
better
error
messages
by
callers
Returns
DW_DLV_ERROR
on
error
int
_dwarf_get_abbrev_for_code
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
code
Dwarf_Abbrev_List
list_out
Dwarf_Unsigned
highest_known_code
Dwarf_Error
error
Dwarf_Debug
dbg
cu_context
cc_dbg
Dwarf_Hash_Table
hash_table_base
cu_context
cc_abbrev_hash_table
Dwarf_Hash_Table_Entry
entry_base
Dwarf_Hash_Table_Entry
entry_cur
Dwarf_Unsigned
hash_num
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
abbrev_tag
Dwarf_Abbrev_List
hash_abbrev_entry
Dwarf_Abbrev_List
inner_list_entry
Dwarf_Hash_Table_Entry
inner_hash_entry
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
end_abbrev_ptr
unsigned
hashable_val
if
hash_table_base
tb_entries
hash_table_base
tb_table_entry_count
HT_MULTIPLE
hash_table_base
tb_total_abbrev_count
hash_table_base
tb_entries
struct
Dwarf_Hash_Table_Entry_s
_dwarf_get_alloc
dbg
DW_DLA_HASH_TABLE_ENTRY
hash_table_base
tb_table_entry_count
if
hash_table_base
tb_entries
highest_known_code
cu_context
cc_highest_known_code
return
DW_DLV_NO_ENTRY
else
if
hash_table_base
tb_total_abbrev_count
hash_table_base
tb_table_entry_count
HT_MULTIPLE
struct
Dwarf_Hash_Table_s
newht
memset
sizeof
newht
Effectively
multiplies
by
HT_MULTIPLE
newht
tb_table_entry_count
hash_table_base
tb_total_abbrev_count
newht
tb_total_abbrev_count
newht
tb_entries
struct
Dwarf_Hash_Table_Entry_s
_dwarf_get_alloc
dbg
DW_DLA_HASH_TABLE_ENTRY
newht
tb_table_entry_count
if
newht
tb_entries
highest_known_code
cu_context
cc_highest_known_code
return
DW_DLV_NO_ENTRY
Copy
the
existing
entries
to
the
new
table
rehashing
each
copy_abbrev_table_to_new_table
hash_table_base
Dealloc
only
the
entries
hash
table
array
not
the
lists
of
things
pointed
to
by
a
hash
table
entry
array
dwarf_dealloc
dbg
hash_table_base
tb_entries
DW_DLA_HASH_TABLE_ENTRY
hash_table_base
tb_entries
Now
overwrite
the
existing
table
descriptor
with
the
new
newly
valid
contents
hash_table_base
newht
Else
is
ok
as
is
add
entry
if
code
cu_context
cc_highest_known_code
cu_context
cc_highest_known_code
code
hashable_val
code
hash_num
hashable_val
hash_table_base
tb_table_entry_count
entry_base
hash_table_base
tb_entries
entry_cur
entry_base
hash_num
Determine
if
the
code
is
the
list
of
synonyms
already
for
hash_abbrev_entry
entry_cur
at_head
hash_abbrev_entry
NULL
hash_abbrev_entry
abl_code
code
hash_abbrev_entry
hash_abbrev_entry
abl_next
if
hash_abbrev_entry
This
returns
a
pointer
to
an
abbrev
list
entry
not
the
list
itself
highest_known_code
cu_context
cc_highest_known_code
list_out
hash_abbrev_entry
return
DW_DLV_OK
if
cu_context
cc_last_abbrev_ptr
abbrev_ptr
cu_context
cc_last_abbrev_ptr
end_abbrev_ptr
cu_context
cc_last_abbrev_endptr
else
This
is
ok
because
cc_abbrev_offset
includes
DWP
offset
if
appropriate
abbrev_ptr
dbg
de_debug_abbrev
dss_data
cu_context
cc_abbrev_offset
if
cu_context
cc_dwp_offsets
pcu_type
In
a
DWP
the
abbrevs
for
this
context
are
known
quite
precisely
Dwarf_Unsigned
size
Ignore
the
offset
returned
Already
in
cc_abbrev_offset
_dwarf_get_dwp_extra_offset
cc_dwp_offsets
DW_SECT_ABBREV
ASSERT
size
end_abbrev_ptr
abbrev_ptr
size
else
end_abbrev_ptr
dbg
de_debug_abbrev
dss_data
dbg
de_debug_abbrev
dss_size
End
of
abbrev
s
as
we
are
past
the
end
entirely
This
can
happen
though
it
seems
wrong
Or
we
are
at
the
end
of
the
data
block
which
we
also
take
as
meaning
done
with
abbrevs
for
this
CU
An
abbreviations
table
is
supposed
to
end
with
a
zero
byte
Not
ended
by
end
of
data
block
But
we
are
allowing
what
is
possibly
a
bit
more
flexible
end
policy
here
if
abbrev_ptr
end_abbrev_ptr
return
DW_DLV_NO_ENTRY
End
of
abbrev
s
for
this
cu
since
abbrev
code
is
if
abbrev_ptr
highest_known_code
cu_context
cc_highest_known_code
return
DW_DLV_NO_ENTRY
do
unsigned
new_hashable_val
Dwarf_Off
abb_goff
Dwarf_Unsigned
atcount
Dwarf_Byte_Ptr
abbrev_ptr2
int
res
abb_goff
abbrev_ptr
dbg
de_debug_abbrev
dss_data
DECODE_LEB128_UWORD_CK
abbrev_ptr
abbrev_code
dbg
error
end_abbrev_ptr
DECODE_LEB128_UWORD_CK
abbrev_ptr
abbrev_tag
dbg
error
end_abbrev_ptr
if
abbrev_tag
DW_TAG_hi_user
return
_dwarf_format_TAG_err_msg
dbg
abbrev_tag
DW_DLE_TAG_CORRUPT
error
if
abbrev_ptr
end_abbrev_ptr
_dwarf_error
dbg
error
DW_DLE_ABBREV_OFF_END
return
DW_DLV_ERROR
inner_list_entry
Dwarf_Abbrev_List
_dwarf_get_alloc
cu_context
cc_dbg
DW_DLA_ABBREV_LIST
if
inner_list_entry
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
new_hashable_val
abbrev_code
if
abbrev_code
cu_context
cc_highest_known_code
cu_context
cc_highest_known_code
abbrev_code
hash_num
new_hashable_val
hash_table_base
tb_table_entry_count
inner_hash_entry
entry_base
hash_num
Move_entry_to_new_hash
inner_list_entry
abl_next
inner_hash_entry
at_head
inner_hash_entry
at_head
inner_list_entry
hash_table_base
tb_total_abbrev_count
inner_list_entry
abl_code
abbrev_code
inner_list_entry
abl_tag
abbrev_tag
inner_list_entry
abl_has_child
abbrev_ptr
inner_list_entry
abl_abbrev_ptr
abbrev_ptr
inner_list_entry
abl_goffset
abb_goff
hash_table_base
tb_total_abbrev_count
Cycle
thru
the
abbrev
content
ignoring
the
content
except
to
find
the
end
of
the
content
res
_dwarf_count_abbrev_entries
dbg
abbrev_ptr
end_abbrev_ptr
error
if
res
DW_DLV_OK
highest_known_code
cu_context
cc_highest_known_code
return
res
abbrev_ptr
abbrev_ptr2
inner_list_entry
abl_count
atcount
while
abbrev_ptr
end_abbrev_ptr
abbrev_ptr
abbrev_code
code
highest_known_code
cu_context
cc_highest_known_code
cu_context
cc_last_abbrev_ptr
abbrev_ptr
cu_context
cc_last_abbrev_endptr
end_abbrev_ptr
if
abbrev_code
code
list_out
inner_list_entry
return
DW_DLV_OK
We
cannot
find
an
abbrev_code
matching
code
ERROR
will
be
declared
eventually
Might
be
better
to
declare
specific
errors
here?
return
DW_DLV_NO_ENTRY
We
check
that
areaptr
strptr
a
NUL
byte
p
exists
at
p
end
and
return
DW_DLV_ERROR
if
a
check
fails
de_assume_string_in_bounds
int
_dwarf_check_string_valid
Dwarf_Debug
dbg
void
areaptr
void
strptr
void
areaendptr
int
suggested_error
Dwarf_Error
error
Dwarf_Small
start
areaptr
Dwarf_Small
p
strptr
Dwarf_Small
end
areaendptr
if
p
start
_dwarf_error
dbg
error
suggested_error
return
DW_DLV_ERROR
if
p
end
_dwarf_error
dbg
error
suggested_error
return
DW_DLV_ERROR
if
dbg
de_assume_string_in_bounds
This
NOT
the
default
But
folks
can
choose
to
live
dangerously
and
just
assume
strings
ok
return
DW_DLV_OK
while
p
end
if
p
return
DW_DLV_OK
p
_dwarf_error
dbg
error
DW_DLE_STRING_NOT_TERMINATED
return
DW_DLV_ERROR
Return
non
zero
if
the
start
end
are
not
valid
for
the
die
s
section
If
pastend
matches
the
dss_data
dss_size
then
pastend
is
a
pointer
that
cannot
be
dereferenced
But
we
allow
it
as
valid
here
it
is
normal
for
a
pointer
to
point
one
past
end
in
various
circumstances
one
must
avoid
dereferencing
it
of
course
Return
if
valid
Return
if
invalid
int
_dwarf_reference_outside_section
Dwarf_Die
die
Dwarf_Small
startaddr
Dwarf_Small
pastend
Dwarf_Debug
dbg
Dwarf_CU_Context
contxt
struct
Dwarf_Section_s
sec
contxt
die
di_cu_context
dbg
contxt
cc_dbg
if
die
di_is_info
sec
de_debug_info
else
sec
de_debug_types
if
startaddr
sec
dss_data
return
if
pastend
sec
dss_data
sec
dss_size
return
return
A
byte
swapping
version
of
memcpy
for
cross
endian
use
Only
should
be
lengths
passed
in
void
_dwarf_memcpy_noswap_bytes
void
s1
const
void
s2
unsigned
long
len
memcpy
s1
s2
size_t
len
return
void
_dwarf_memcpy_swap_bytes
void
s1
const
void
s2
unsigned
long
len
unsigned
char
targ
unsigned
char
s1
const
unsigned
char
src
const
unsigned
char
s2
if
len
targ
src
targ
src
targ
src
targ
src
else
if
len
targ
src
targ
src
targ
src
targ
src
targ
src
targ
src
targ
src
targ
src
else
if
len
targ
src
targ
src
should
NOT
get
below
here
is
not
the
intended
use
else
if
len
targ
src
else
memcpy
s1
s2
size_t
len
return
This
calculation
used
to
be
sprinkled
all
over
Now
brought
to
one
place
We
try
to
accurately
compute
the
size
of
a
cu
header
given
a
known
cu
header
location
an
offset
in
debug_info
or
debug_types
ARGSUSED
int
_dwarf_length_of_cu_header
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Bool
is_info
Dwarf_Unsigned
area_length_out
Dwarf_Error
error
int
local_length_size
int
local_extension_size
Dwarf_Half
version
Dwarf_Unsigned
length
Dwarf_Unsigned
final_size
Dwarf_Small
section_start
is_info?
dbg
de_debug_info
dss_data
dbg
de_debug_types
dss_data
Dwarf_Small
cuptr
section_start
offset
Dwarf_Unsigned
section_length
is_info?
dbg
de_debug_info
dss_size
dbg
de_debug_types
dss_size
Dwarf_Small
section_end_ptr
section_start
section_length
READ_AREA_LENGTH_CK
dbg
length
Dwarf_Unsigned
cuptr
local_length_size
local_extension_size
error
section_length
section_end_ptr
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
cuptr
DWARF_HALF_SIZE
error
section_end_ptr
cuptr
DWARF_HALF_SIZE
if
version
Dwarf_Ubyte
unit_type
READ_UNALIGNED_CK
dbg
unit_type
Dwarf_Ubyte
cuptr
sizeof
Dwarf_Ubyte
error
section_end_ptr
switch
unit_type
case
DW_UT_compile
case
DW_UT_partial
final_size
local_extension_size
local_length_size
Size
of
cu
length
field
DWARF_HALF_SIZE
Size
of
version
stamp
field
sizeof
Dwarf_Small
Size
of
unit
type
field
sizeof
Dwarf_Small
Size
of
address
size
field
local_length_size
Size
of
abbrev
offset
field
break
case
DW_UT_type
case
DW_UT_split_type
final_size
local_extension_size
local_length_size
Size
of
type
unit
length
field
DWARF_HALF_SIZE
Size
of
version
stamp
field
sizeof
Dwarf_Small
Size
of
unit
type
field
sizeof
Dwarf_Small
Size
of
address
size
field
local_length_size
Size
of
abbrev
offset
field
sizeof
Dwarf_Sig8
Size
of
type
signature
field
local_length_size
Size
of
type
offset
field
break
case
DW_UT_skeleton
case
DW_UT_split_compile
final_size
local_extension_size
local_length_size
Size
of
unit
length
field
DWARF_HALF_SIZE
Size
of
version
stamp
field
sizeof
Dwarf_Small
Size
of
unit
type
field
sizeof
Dwarf_Small
Size
of
address
size
field
local_length_size
Size
of
abbrev
offset
field
sizeof
Dwarf_Sig8
Size
of
dwo
id
field
break
default
_dwarf_error
dbg
error
DW_DLE_UNIT_TYPE_NOT_HANDLED
return
DW_DLV_ERROR
else
if
version
final_size
local_extension_size
local_length_size
Size
of
cu
length
field
DWARF_HALF_SIZE
Size
of
version
stamp
field
local_length_size
Size
of
abbrev
offset
field
sizeof
Dwarf_Small
Size
of
address
size
field
if
is_info
final_size
type
signature
size
sizeof
Dwarf_Sig8
type
offset
size
local_length_size
else
if
version
final_size
local_extension_size
local_length_size
DWARF_HALF_SIZE
local_length_size
sizeof
Dwarf_Small
Size
of
address
size
field
area_length_out
final_size
return
DW_DLV_OK
Pretend
we
know
nothing
about
the
CU
and
just
roughly
compute
the
result
Dwarf_Unsigned
_dwarf_length_of_cu_header_simple
Dwarf_Debug
dbg
Dwarf_Bool
dinfo
Dwarf_Unsigned
finalsize
finalsize
dbg
de_length_size
Size
of
cu
length
field
DWARF_HALF_SIZE
Size
of
version
stamp
field
dbg
de_length_size
Size
of
abbrev
offset
field
sizeof
Dwarf_Small
Size
of
address
size
field
if
dinfo
finalsize
type
signature
size
sizeof
Dwarf_Sig8
type
offset
size
dbg
de_length_size
return
finalsize
Now
that
we
delay
loading
debug_info
we
need
to
do
the
load
in
more
places
So
putting
the
load
code
in
one
place
now
instead
of
replicating
it
in
multiple
places
int
_dwarf_load_debug_info
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
DW_DLV_ERROR
if
dbg
de_debug_info
dss_data
return
DW_DLV_OK
res
_dwarf_load_section
dbg
de_debug_abbrev
error
if
res
DW_DLV_OK
return
res
res
_dwarf_load_section
dbg
de_debug_info
error
if
res
DW_DLV_OK
return
res
debug_info
won
t
be
meaningful
without
debug_rnglists
and
debug_rnglists
if
there
is
one
or
both
such
sections
res
dwarf_load_rnglists
dbg
error
if
res
DW_DLV_ERROR
return
res
res
dwarf_load_loclists
dbg
error
if
res
DW_DLV_ERROR
return
res
return
DW_DLV_OK
int
_dwarf_load_debug_types
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
DW_DLV_ERROR
if
dbg
de_debug_types
dss_data
return
DW_DLV_OK
res
_dwarf_load_section
dbg
de_debug_abbrev
error
if
res
DW_DLV_OK
return
res
res
_dwarf_load_section
dbg
de_debug_types
error
return
res
void
_dwarf_free_abbrev_hash_table_contents
Dwarf_Debug
dbg
Dwarf_Hash_Table
hash_table
A
Hash
Table
is
an
array
with
tb_table_entry_count
struct
Dwarf_Hash_Table_s
entries
in
the
array
unsigned
hashnum
if
hash_table
Not
fully
set
up
yet
There
is
nothing
to
do
return
if
hash_table
tb_entries
Not
fully
set
up
yet
There
is
nothing
to
do
return
for
hashnum
hash_table
tb_table_entry_count
hashnum
struct
Dwarf_Abbrev_List_s
abbrev
struct
Dwarf_Abbrev_List_s
nextabbrev
struct
Dwarf_Hash_Table_Entry_s
tb
tb_entries
hashnum
abbrev
tb
at_head
for
abbrev
abbrev
nextabbrev
nextabbrev
abbrev
abl_next
abbrev
abl_next
dwarf_dealloc
dbg
abbrev
DW_DLA_ABBREV_LIST
tb
at_head
Frees
all
the
entries
at
once
an
array
dwarf_dealloc
dbg
hash_table
tb_entries
DW_DLA_HASH_TABLE_ENTRY
hash_table
tb_entries
If
no
die
provided
the
size
value
returned
might
be
wrong
If
different
compilation
units
have
different
address
sizes
this
may
not
give
the
correct
value
in
all
contexts
if
the
die
pointer
is
NULL
If
the
Elf
offset
size
address_size
for
example
if
address_size
but
recorded
in
elf64
object
this
may
not
give
the
correct
value
in
all
contexts
if
the
die
pointer
is
NULL
If
the
die
pointer
is
non
NULL
in
which
case
it
must
point
to
a
valid
DIE
this
will
return
the
correct
size
int
_dwarf_get_address_size
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_CU_Context
context
Dwarf_Half
addrsize
if
die
return
dbg
de_pointer_size
context
die
di_cu_context
addrsize
context
cc_address_size
return
addrsize
struct
Dwarf_Printf_Callback_Info_s
dwarf_register_printf_callback
Dwarf_Debug
dbg
struct
Dwarf_Printf_Callback_Info_s
newvalues
struct
Dwarf_Printf_Callback_Info_s
oldval
dbg
de_printf_callback
if
newvalues
return
oldval
if
newvalues
dp_buffer_user_provided
if
oldval
dp_buffer_user_provided
User
continues
to
control
the
buffer
dbg
de_printf_callback
newvalues
else
Switch
from
our
control
of
buffer
to
user
control
free
oldval
dp_buffer
oldval
dp_buffer
dbg
de_printf_callback
newvalues
else
if
oldval
dp_buffer_user_provided
Switch
from
user
control
to
our
control
dbg
de_printf_callback
newvalues
dbg
de_printf_callback
dp_buffer_len
dbg
de_printf_callback
dp_buffer
else
User
does
not
control
the
buffer
dbg
de_printf_callback
newvalues
dbg
de_printf_callback
dp_buffer_len
oldval
dp_buffer_len
dbg
de_printf_callback
dp_buffer
oldval
dp_buffer
return
oldval
No
varargs
required
int
_dwarf_printf
Dwarf_Debug
dbg
const
char
data
int
nlen
struct
Dwarf_Printf_Callback_Info_s
bufdata
de_printf_callback
dwarf_printf_callback_function_type
func
bufdata
dp_fptr
if
func
return
nlen
strlen
data
func
bufdata
dp_user_pointer
data
return
nlen
Often
errs
and
errt
point
to
the
same
Dwarf_Error
So
exercise
care
All
the
arguments
MUST
be
non
null
void
_dwarf_error_mv_s_to_t
Dwarf_Debug
dbgs
Dwarf_Error
errs
Dwarf_Debug
dbgt
Dwarf_Error
errt
if
errt
errs
return
if
dbgs
dbgt
return
if
dbgs
dbgt
if
errs
errt
Dwarf_Error
ers
errs
errs
errt
ers
else
Do
not
stomp
on
the
system
errno
variable
if
there
is
one
int
mydw_errno
dwarf_errno
errs
dwarf_dealloc
dbgs
errs
DW_DLA_ERROR
errs
_dwarf_error
dbgt
errt
mydw_errno
static
int
inthissection
struct
Dwarf_Section_s
sec
Dwarf_Small
ptr
if
sec
dss_data
return
FALSE
if
ptr
sec
dss_data
return
FALSE
if
ptr
sec
dss_data
sec
dss_size
return
FALSE
return
TRUE
define
FINDSEC
m_s
m_p
n
st
l
e
do
if
inthissection
m_s
m_p
n
m_s
dss_name
st
m_s
dss_data
l
m_s
dss_size
e
m_s
dss_data
m_s
dss_size
return
DW_DLV_OK
while
So
we
can
know
a
section
end
even
when
we
do
not
have
the
section
info
apriori
It
s
only
needed
for
a
subset
of
sections
int
_dwarf_what_section_are_we
Dwarf_Debug
dbg
Dwarf_Small
our_pointer
const
char
section_name_out
Dwarf_Small
sec_start_ptr_out
Dwarf_Unsigned
sec_len_out
Dwarf_Small
sec_end_ptr_out
UNUSEDARG
Dwarf_Error
error
FINDSEC
de_debug_info
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_loc
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_loclists
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_rnglists
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_addr
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_line
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_aranges
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_macro
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_ranges
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_str_offsets
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_addr
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_pubtypes
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_gdbindex
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_abbrev
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_cu_index
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_tu_index
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_line_str
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_types
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_sup
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_frame
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
FINDSEC
de_debug_frame_eh_gnu
our_pointer
section_name_out
sec_start_ptr_out
sec_len_out
sec_end_ptr_out
return
DW_DLV_NO_ENTRY
New
September
int
dwarf_add_file_path
Dwarf_Debug
dbg
const
char
file_name
Dwarf_Error
error
if
dbg
file_name
Pretty
much
a
disaster
Caller
error
_dwarf_error
dbg
error
DW_DLE_NULL_ARGS_DWARF_ADD_PATH
return
DW_DLV_ERROR
if
dbg
de_path
dbg
de_path
strdup
file_name
return
DW_DLV_OK
New
late
April
All
the
crucial
macros
will
surely
need
to
use
wrapper
code
to
ensure
we
do
not
leak
memory
at
certain
points
int
_dwarf_read_unaligned_ck_wrapper
Dwarf_Debug
dbg
Dwarf_Unsigned
out_value
Dwarf_Small
readfrom
int
readlength
Dwarf_Small
end_arange
Dwarf_Error
err
Dwarf_Unsigned
val
READ_UNALIGNED_CK
dbg
val
Dwarf_Unsigned
readfrom
readlength
err
end_arange
out_value
val
return
DW_DLV_OK
int
_dwarf_read_area_length_ck_wrapper
Dwarf_Debug
dbg
Dwarf_Unsigned
out_value
Dwarf_Small
readfrom
int
length_size_out
int
exten_size_out
Dwarf_Unsigned
sectionlength
Dwarf_Small
endsection
Dwarf_Error
err
Dwarf_Small
ptr
readfrom
Dwarf_Unsigned
val
int
length_size
int
exten_size
READ_AREA_LENGTH_CK
dbg
val
Dwarf_Unsigned
ptr
length_size
exten_size
err
sectionlength
endsection
readfrom
ptr
out_value
val
length_size_out
length_size
exten_size_out
exten_size
return
DW_DLV_OK
New
March
We
need
to
increment
startptr
for
the
caller
in
these
wrappers
so
the
caller
passes
in
wrappers
return
either
DW_DLV_OK
or
DW_DLV_ERROR
Never
DW_DLV_NO_ENTRY
int
_dwarf_leb128_uword_wrapper
Dwarf_Debug
dbg
Dwarf_Small
startptr
Dwarf_Small
endptr
Dwarf_Unsigned
out_value
Dwarf_Error
error
Dwarf_Unsigned
utmp2
Dwarf_Small
start
startptr
DECODE_LEB128_UWORD_CK
start
utmp2
dbg
error
endptr
out_value
utmp2
startptr
start
return
DW_DLV_OK
int
_dwarf_leb128_sword_wrapper
Dwarf_Debug
dbg
Dwarf_Small
startptr
Dwarf_Small
endptr
Dwarf_Signed
out_value
Dwarf_Error
error
Dwarf_Small
start
startptr
Dwarf_Signed
stmp2
DECODE_LEB128_SWORD_CK
start
stmp2
dbg
error
endptr
out_value
stmp2
startptr
start
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_vars
h
include
dwarf_global
h
int
dwarf_get_vars
Dwarf_Debug
dbg
Dwarf_Var
vars
Dwarf_Signed
ret_var_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_varnames
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_abbrev
dss_size
return
DW_DLV_NO_ENTRY
return
_dwarf_internal_get_pubnames_like_data
dbg
debug_varnames
dbg
de_debug_varnames
dss_data
dbg
de_debug_varnames
dss_size
Dwarf_Global
vars
Type
punning
for
sections
with
identical
format
ret_var_count
error
DW_DLA_VAR_CONTEXT
DW_DLA_VAR
DW_DLE_DEBUG_VARNAMES_LENGTH_BAD
DW_DLE_DEBUG_VARNAMES_VERSION_ERROR
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_vars_dealloc
Dwarf_Debug
dbg
Dwarf_Var
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
Dwarf_Global
dwgl
count
return
int
dwarf_varname
Dwarf_Var
var_in
char
ret_varname
Dwarf_Error
error
Dwarf_Global
var
Dwarf_Global
var_in
if
var
NULL
_dwarf_error
NULL
error
DW_DLE_VAR_NULL
return
DW_DLV_ERROR
ret_varname
char
var
gl_name
return
DW_DLV_OK
int
dwarf_var_die_offset
Dwarf_Var
var_in
Dwarf_Off
returned_offset
Dwarf_Error
error
Dwarf_Global
var
Dwarf_Global
var_in
return
dwarf_global_die_offset
var
returned_offset
error
int
dwarf_var_cu_offset
Dwarf_Var
var_in
Dwarf_Off
returned_offset
Dwarf_Error
error
Dwarf_Global
var
Dwarf_Global
var_in
return
dwarf_global_cu_offset
var
returned_offset
error
int
dwarf_var_name_offsets
Dwarf_Var
var_in
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
Dwarf_Global
var
Dwarf_Global
var_in
return
dwarf_global_name_offsets
var
returned_name
die_offset
cu_offset
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
stdio
h
include
dwarf_incl
h
include
dwarf_error
h
include
dwarf_weaks
h
include
dwarf_global
h
int
dwarf_get_weaks
Dwarf_Debug
dbg
Dwarf_Weak
weaks
Dwarf_Signed
ret_weak_count
Dwarf_Error
error
int
res
_dwarf_load_section
dbg
de_debug_weaknames
error
if
res
DW_DLV_OK
return
res
if
dbg
de_debug_weaknames
dss_size
return
DW_DLV_NO_ENTRY
return
_dwarf_internal_get_pubnames_like_data
dbg
debug_weaknames
dbg
de_debug_weaknames
dss_data
dbg
de_debug_weaknames
dss_size
Dwarf_Global
weaks
Type
punning
for
sections
with
identical
format
ret_weak_count
error
DW_DLA_WEAK_CONTEXT
DW_DLA_WEAK
DW_DLE_DEBUG_WEAKNAMES_LENGTH_BAD
DW_DLE_DEBUG_WEAKNAMES_VERSION_ERROR
Deallocating
fully
requires
deallocating
the
list
and
all
entries
But
some
internal
data
is
not
exposed
so
we
need
a
function
with
internal
knowledge
void
dwarf_weaks_dealloc
Dwarf_Debug
dbg
Dwarf_Weak
dwgl
Dwarf_Signed
count
_dwarf_internal_globals_dealloc
dbg
Dwarf_Global
dwgl
count
return
int
dwarf_weakname
Dwarf_Weak
weak_in
char
ret_name
Dwarf_Error
error
Dwarf_Global
weak
Dwarf_Global
weak_in
if
weak
NULL
_dwarf_error
NULL
error
DW_DLE_WEAK_NULL
return
DW_DLV_ERROR
ret_name
char
weak
gl_name
return
DW_DLV_OK
int
dwarf_weak_die_offset
Dwarf_Weak
weak_in
Dwarf_Off
weak_off
Dwarf_Error
error
Dwarf_Global
weak
Dwarf_Global
weak_in
return
dwarf_global_die_offset
weak
weak_off
error
int
dwarf_weak_cu_offset
Dwarf_Weak
weak_in
Dwarf_Off
weak_off
Dwarf_Error
error
Dwarf_Global
weak
Dwarf_Global
weak_in
return
dwarf_global_cu_offset
weak
weak_off
error
int
dwarf_weak_name_offsets
Dwarf_Weak
weak_in
char
weak_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
Dwarf_Global
weak
Dwarf_Global
weak_in
return
dwarf_global_name_offsets
weak
weak_name
die_offset
cu_offset
error
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
file
and
functions
have
xu
because
the
debug_cu_index
and
debug_tu_index
sections
have
the
same
layout
and
this
deals
with
both
This
is
DebugFission
part
of
DWARF5
It
allows
fast
section
access
in
a
dwp
object
file
with
debug
information
to
locate
offsets
within
and
between
sections
See
the
DWARF5
Standard
section
and
examples
in
Appendix
F
A
note
about
the
index
field
from
the
index
table
See
DWARF5
The
index
table
array
index
values
are
S
These
value
ae
used
to
call
functions
requesting
values
from
the
offset
table
and
size
table
Inside
the
code
in
this
file
we
subtract
and
use
origin
as
that
is
how
we
arranged
the
table
access
here
A
zero
in
the
index
table
is
an
unused
signature
table
signature
and
unused
index
By
subtracting
one
and
arranging
things
properly
in
the
offset
table
and
size
table
we
can
refer
to
the
tables
in
an
identical
simple
fashion
These
tables
are
thus
U
rows
and
N
columns
Technically
the
Offset
table
physically
row
zero
is
a
separate
set
of
numbers
translating
the
column
number
to
a
DW_SECT
value
so
callers
can
request
specific
bases
offsets
and
sizes
from
the
offset
and
size
tables
But
we
change
things
a
little
internally
so
both
tables
look
zero
origin
include
config
h
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
dwarf_incl
h
include
dwarf_alloc
h
include
dwarf_error
h
include
dwarf_util
h
include
dwarf_xu_index
h
include
dwarfstring
h
define
HASHSIGNATURELEN
define
LEN32BIT
The
following
actually
assumes
as
used
here
that
t
is
bytes
integer
while
s
is
also
bytes
Dwarf_Sig8
struct
ifdef
WORDS_BIGENDIAN
define
ASNAR
t
s
l
do
unsigned
tbyte
sizeof
t
l
if
sizeof
t
l
_dwarf_error
dbg
error
DW_DLE_XU_HASH_INDEX_ERROR
return
DW_DLV_ERROR
t
dbg
de_copy_word
char
tbyte
l
while
else
LITTLE
ENDIAN
define
ASNAR
t
s
l
do
t
if
sizeof
t
l
_dwarf_error
dbg
error
DW_DLE_XU_HASH_INDEX_ERROR
return
DW_DLV_ERROR
dbg
de_copy_word
l
while
endif
end
LITTLE
BIG
ENDIAN
zerohashkey
used
as
all
zero
bits
for
comparison
static
const
Dwarf_Sig8
zerohashkey
if
static
void
dump_bytes
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
msg
for
cur
end
cur
printf
cur
printf
n
endif
Precondition
headerline_offset
N
is
within
the
section
static
int
fill_in_offsets_headerline
Dwarf_Debug
dbg
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
headerline_offset
Dwarf_Unsigned
num_sects
Dwarf_Error
err
Dwarf_Small
section_start
xuhdr
gx_section_data
Dwarf_Small
section_end
xuhdr
gx_section_data
xuhdr
gx_section_length
Dwarf_Small
data
unsigned
i
data
section_start
headerline_offset
for
i
num_sects
i
Dwarf_Unsigned
v
READ_UNALIGNED_CK
dbg
v
Dwarf_Unsigned
data
LEN32BIT
err
section_end
data
LEN32BIT
if
v
DW_SECT_RNGLISTS
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
The
section
number
of
u
v
dwarfstring_append
is
too
high
Sections
are
listed
in
DWARF5
Table
_dwarf_error_string
dbg
err
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
xuhdr
gx_section_id
i
v
return
DW_DLV_OK
Read
in
a
cu
or
tu
section
and
return
overview
information
For
libdwarf
internal
lookups
dwarf_init
calls
dwarf_get_xu_index_header
when
the
object
file
is
opened
and
dwarf_xu_header_free
is
called
by
dwarf_finish
there
is
no
need
for
users
to
do
this
If
one
wants
to
call
the
various
tu
cu
functions
oneself
possibly
to
print
the
debug_cu_index
or
debug_tu_index
sections
then
you
will
need
to
call
dwarf_get_xu_index_header
and
eventually
dwarf_xu_header_free
The
libdwarf
internal
data
is
kept
in
Dwarf_Debug
fields
de_cu_hashindex_data
de_tu_hashindex_data
int
dwarf_get_xu_index_header
Dwarf_Debug
dbg
Pass
in
section_type
tu
or
cu
const
char
section_type
Dwarf_Xu_Index_Header
xuptr
Dwarf_Unsigned
version
Dwarf_Unsigned
number_of_columns
L
section
count
Dwarf_Unsigned
number_of_CUs
U
unit
count
Dwarf_Unsigned
number_of_slots
S
slot
count
Standard
says
S
U
DWARF5
sec
const
char
section_name
Dwarf_Error
error
Dwarf_Xu_Index_Header
indexptr
int
res
DW_DLV_ERROR
struct
Dwarf_Section_s
sect
Dwarf_Unsigned
local_version
Dwarf_Unsigned
num_secs
Dwarf_Unsigned
num_CUs
Dwarf_Unsigned
num_slots
Dwarf_Small
data
Dwarf_Unsigned
tables_end_offset
Dwarf_Unsigned
hash_tab_offset
Dwarf_Unsigned
indexes_tab_offset
Dwarf_Unsigned
section_offsets_tab_offset
Dwarf_Unsigned
section_offsets_headerline_offset
Dwarf_Unsigned
section_sizes_tab_offset
unsigned
datalen32
LEN32BIT
Dwarf_Small
section_end
if
strcmp
section_type
cu
sect
de_debug_cu_index
else
if
strcmp
section_type
tu
sect
de_debug_tu_index
else
_dwarf_error
dbg
error
DW_DLE_XU_TYPE_ARG_ERROR
return
DW_DLV_ERROR
if
sect
dss_size
return
DW_DLV_NO_ENTRY
if
sect
dss_data
res
_dwarf_load_section
dbg
sect
error
if
res
DW_DLV_OK
return
res
data
sect
dss_data
section_end
data
sect
dss_size
if
sect
dss_size
datalen32
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
size
of
the
s
char
section_type
dwarfstring_append_printf_u
is
just
u
bytes
much
to
small
to
be
a
correct
section
sect
dss_size
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
READ_UNALIGNED_CK
dbg
local_version
Dwarf_Unsigned
data
datalen32
error
section_end
data
datalen32
reading
N
READ_UNALIGNED_CK
dbg
num_secs
Dwarf_Unsigned
data
datalen32
error
section_end
if
num_secs
DW_SECT_RNGLISTS
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_XU_NAME_COL_ERROR
s
index
section
header
char
section_type
dwarfstring_append_printf_u
shows
N
the
sections
count
as
u
but
only
values
through
DW_SECT_RNGLISTS
are
valid
num_secs
_dwarf_error_string
dbg
error
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
data
datalen32
reading
U
READ_UNALIGNED_CK
dbg
num_CUs
Dwarf_Unsigned
data
datalen32
error
section_end
data
datalen32
reading
S
READ_UNALIGNED_CK
dbg
num_slots
Dwarf_Unsigned
data
datalen32
error
section_end
hash_tab_offset
datalen32
indexes_tab_offset
hash_tab_offset
num_slots
HASHSIGNATURELEN
Look
for
corrupt
section
data
if
num_slots
sect
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
size
of
the
s
char
section_type
dwarfstring_append_printf_u
is
just
u
bytes
sect
dss_size
dwarfstring_append_printf_u
while
the
number
of
slots
S
is
u
which
is
clearly
wrong
num_slots
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
num_slots
sect
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
size
of
the
s
char
section_type
dwarfstring_append_printf_u
is
just
u
bytes
sect
dss_size
dwarfstring_append_printf_u
while
the
number
of
slots
bytes
S
is
at
least
u
which
is
clearly
wrong
num_slots
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
This
offset
is
to
row
of
N
columns
each
section_offsets_headerline_offset
indexes_tab_offset
num_slots
datalen32
Now
we
can
make
the
real
table
part
index
normally
This
offset
is
to
U
row
of
N
columns
each
section_offsets_tab_offset
section_offsets_headerline_offset
num_secs
datalen32
if
num_secs
sect
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
size
of
the
s
char
section_type
dwarfstring_append_printf_u
is
just
u
bytes
sect
dss_size
dwarfstring_append_printf_u
while
the
number
of
sections
columns
S
is
u
which
is
clearly
wrong
num_secs
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
datalen32
num_secs
sect
dss_size
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_s
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
size
of
the
s
char
section_type
dwarfstring_append_printf_u
is
just
u
bytes
sect
dss_size
dwarfstring_append_printf_u
while
the
number
of
sections
columns
bytes
S
is
at
least
u
which
is
clearly
wrong
num_secs
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
section_sizes_tab_offset
section_offsets_tab_offset
num_CUs
num_secs
datalen32
tables_end_offset
section_sizes_tab_offset
num_CUs
num_secs
datalen32
if
tables_end_offset
sect
dss_size
Something
is
badly
wrong
here
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
as
the
end
offset
lx
is
greater
than
tables_end_offset
dwarfstring_append_printf_u
the
section
size
lx
sect
dss_size
_dwarf_error_string
dbg
error
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
indexptr
Dwarf_Xu_Index_Header
_dwarf_get_alloc
dbg
DW_DLA_XU_INDEX
if
indexptr
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Only
cu
or
tu
allowed
that
is
checked
above
But
for
safety
we
just
copy
the
allowed
bytes
indexptr
gx_type
section_type
indexptr
gx_type
section_type
indexptr
gx_type
indexptr
gx_dbg
dbg
indexptr
gx_section_length
sect
dss_size
indexptr
gx_section_data
sect
dss_data
indexptr
gx_section_name
sect
dss_name
indexptr
gx_version
local_version
indexptr
gx_column_count_sections
num_secs
indexptr
gx_units_in_index
num_CUs
indexptr
gx_slots_in_hash
num_slots
indexptr
gx_hash_table_offset
hash_tab_offset
indexptr
gx_index_table_offset
indexes_tab_offset
indexptr
gx_section_offsets_headerline_offset
section_offsets_headerline_offset
indexptr
gx_section_offsets_offset
section_offsets_tab_offset
indexptr
gx_section_sizes_offset
section_sizes_tab_offset
res
fill_in_offsets_headerline
dbg
indexptr
section_offsets_headerline_offset
num_secs
error
if
res
DW_DLV_OK
return
res
xuptr
indexptr
version
indexptr
gx_version
number_of_columns
indexptr
gx_column_count_sections
number_of_CUs
indexptr
gx_units_in_index
number_of_slots
indexptr
gx_slots_in_hash
section_name
indexptr
gx_section_name
return
DW_DLV_OK
int
dwarf_get_xu_index_section_type
Dwarf_Xu_Index_Header
xuhdr
the
function
returns
a
pointer
to
the
immutable
string
tu
or
cu
via
this
arg
Do
not
free
const
char
typename
the
function
returns
a
pointer
to
the
immutable
section
name
Do
not
free
debug_cu_index
or
debug_tu_index
const
char
sectionname
UNUSEDARG
Dwarf_Error
err
typename
gx_type
sectionname
xuhdr
gx_section_name
return
DW_DLV_OK
Index
values
to
S
are
valid
int
dwarf_get_xu_hash_entry
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
index
returns
the
hash
value
bits
Dwarf_Sig8
hash_value
returns
the
index
into
rows
of
offset
size
tables
Dwarf_Unsigned
index_to_sections
Dwarf_Error
err
Dwarf_Debug
dbg
xuhdr
gx_dbg
Dwarf_Small
hashtab
xuhdr
gx_section_data
xuhdr
gx_hash_table_offset
Dwarf_Small
indextab
xuhdr
gx_section_data
xuhdr
gx_index_table_offset
Dwarf_Small
indexentry
Dwarf_Small
hashentry
Dwarf_Sig8
hashval
Dwarf_Unsigned
indexval
Dwarf_Small
section_end
xuhdr
gx_section_data
xuhdr
gx_section_length
hashval
zerohashkey
if
xuhdr
gx_slots_in_hash
if
index
xuhdr
gx_slots_in_hash
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_XU_HASH_ROW_ERROR
the
index
passed
in
u
is
greater
than
the
number
of
slots
in
the
hash
table
index
_dwarf_error_string
dbg
err
DW_DLE_XU_HASH_ROW_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
hashentry
hashtab
index
HASHSIGNATURELEN
memcpy
hashentry
sizeof
hashval
else
_dwarf_error_string
dbg
err
DW_DLE_XU_HASH_ROW_ERROR
DW_DLE_XU_HASH_ROW_ERROR
the
number
of
slots
is
zero
which
seems
wrong
return
DW_DLV_ERROR
indexentry
indextab
index
LEN32BIT
memcpy
hash_value
sizeof
hashval
READ_UNALIGNED_CK
dbg
indexval
Dwarf_Unsigned
indexentry
LEN32BIT
err
section_end
indexentry
LEN32BIT
if
indexval
xuhdr
gx_units_in_index
_dwarf_error
dbg
err
DW_DLE_XU_HASH_INDEX_ERROR
return
DW_DLV_ERROR
index_to_sections
indexval
return
DW_DLV_OK
static
const
char
dwp_secnames
No
name
for
zero
DW_SECT_INFO
debug_info
dwo
DW_SECT_TYPES
debug_types
dwo
DW_SECT_ABBREV
debug_abbrev
dwo
DW_SECT_LINE
debug_line
dwo
DW_SECT_LOC
debug_loc
dwo
DW_SECT_STR_OFFSETS
debug_str_offsets
dwo
DW_SECT_MACRO
debug_macro
dwo
DW_SECT_RNGLISTS
debug_rnglists
dwo
No
name
Row
of
the
Table
of
Section
Offsets
columns
to
L
are
the
section
id
s
and
names
such
as
DW_SECT_INFO
ie
int
dwarf_get_xu_section_names
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
column_index
Dwarf_Unsigned
number
const
char
name
Dwarf_Error
err
Dwarf_Unsigned
sec_num
Dwarf_Debug
dbg
xuhdr
gx_dbg
if
column_index
xuhdr
gx_column_count_sections
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
as
the
column
index
of
u
column_index
dwarfstring_append_printf_u
is
too
high
There
are
u
sections
xuhdr
gx_column_count_sections
_dwarf_error_string
dbg
err
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
sec_num
xuhdr
gx_section_id
column_index
if
sec_num
return
DW_DLV_NO_ENTRY
number
sec_num
name
dwp_secnames
sec_num
return
DW_DLV_OK
Rows
to
U
col
to
L
are
section
offset
and
length
values
from
the
Table
of
Section
Offsets
and
Table
of
Section
Sizes
The
formally
the
table
of
section
offsets
is
a
header
line
of
the
section
offsets
we
subtract
from
the
incoming
irow_index
as
our
tables
are
now
zero
origin
int
dwarf_get_xu_section_offset
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
irow_index
Dwarf_Unsigned
column_index
Dwarf_Unsigned
sec_offset
Dwarf_Unsigned
sec_size
Dwarf_Error
err
We
use
zero
origin
in
the
arrays
Users
see
one
origin
from
the
hash
table
Dwarf_Debug
dbg
xuhdr
gx_dbg
get
to
base
of
tables
first
Dwarf_Small
offsetrow
xuhdr
gx_section_offsets_offset
xuhdr
gx_section_data
Dwarf_Small
sizerow
xuhdr
gx_section_sizes_offset
xuhdr
gx_section_data
Dwarf_Small
offsetentry
Dwarf_Small
sizeentry
Dwarf_Unsigned
offset
Dwarf_Unsigned
size
Dwarf_Unsigned
column_count
xuhdr
gx_column_count_sections
Dwarf_Small
section_end
xuhdr
gx_section_data
xuhdr
gx_section_length
Dwarf_Unsigned
row_index
irow_index
if
irow_index
dwarfstring
s
dwarfstring_constructor
dwarfstring_append
ERROR
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
The
row
index
passed
to
dwarf_get_xu_section_offset
is
zero
which
is
not
a
valid
row
in
the
offset
table
or
the
size
table
as
we
think
of
them
as
origin
_dwarf_error_string
dbg
err
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
row_index
xuhdr
gx_units_in_index
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
as
the
row
index
of
u
row_index
dwarfstring_append_printf_u
is
too
high
Valid
units
must
be
u
xuhdr
gx_units_in_index
_dwarf_error_string
dbg
err
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
column_index
xuhdr
gx_column_count_sections
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
as
the
column
index
of
u
column_index
dwarfstring_append_printf_u
is
too
high
Valid
column
indexes
must
be
u
xuhdr
gx_column_count_sections
_dwarf_error_string
dbg
err
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
As
noted
above
we
have
hidden
the
extra
initial
row
from
the
offsets
table
so
it
is
just
to
U
offsetrow
offsetrow
row_index
column_count
LEN32BIT
offsetentry
offsetrow
column_index
LEN32BIT
sizerow
sizerow
row_index
column_count
LEN32BIT
sizeentry
sizerow
column_index
LEN32BIT
READ_UNALIGNED_CK
dbg
offset
Dwarf_Unsigned
offsetentry
LEN32BIT
err
section_end
offsetentry
LEN32BIT
READ_UNALIGNED_CK
dbg
size
Dwarf_Unsigned
sizeentry
LEN32BIT
err
section_end
sizeentry
LEN32BIT
sec_offset
offset
sec_size
size
return
DW_DLV_OK
static
int
_dwarf_search_fission_for_key
UNUSEDARG
Dwarf_Debug
dbg
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Sig8
key_in
Dwarf_Unsigned
percu_index_out
Dwarf_Error
error
Dwarf_Unsigned
key
Dwarf_Unsigned
primary_hash
Dwarf_Unsigned
hashprime
Dwarf_Unsigned
slots
xuhdr
gx_slots_in_hash
Dwarf_Unsigned
mask
slots
Dwarf_Sig8
hashentry_key
Dwarf_Unsigned
percu_index
hashentry_key
zerohashkey
Look
for
corrupt
section
data
if
slots
xuhdr
gx_section_length
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
as
the
slots
count
of
u
slots
dwarfstring_append_printf_u
is
too
high
given
the
section
length
of
u
n
xuhdr
gx_section_length
_dwarf_error_string
dbg
error
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
slots
xuhdr
gx_section_length
dwarfstring
s
dwarfstring_constructor
dwarfstring_append_printf_u
ERROR
DW_DLE_XU_NAME_COL_ERROR
as
the
slots
count
of
u
slots
dwarfstring_append_printf_u
is
too
high
given
the
section
length
of
u
n
xuhdr
gx_section_length
_dwarf_error_string
dbg
error
DW_DLE_XU_NAME_COL_ERROR
dwarfstring_string
dwarfstring_destructor
return
DW_DLV_ERROR
if
sizeof
key
sizeof
key_in
The
hash
won
t
work
right
in
this
case
_dwarf_error
dbg
error
DW_DLE_XU_HASH_ROW_ERROR
ASNAR
key
key_in
sizeof
key_in
primary_hash
key
mask
hashprime
key
while
int
res
res
dwarf_get_xu_hash_entry
xuhdr
primary_hash
error
if
res
DW_DLV_OK
return
res
if
percu_index
memcmp
sizeof
Dwarf_Sig8
return
DW_DLV_NO_ENTRY
if
memcmp
key_in
sizeof
Dwarf_Sig8
FOUND
percu_index_out
percu_index
return
DW_DLV_OK
primary_hash
primary_hash
hashprime
slots
ASSERT
Cannot
get
here
return
DW_DLV_NO_ENTRY
Slow
Consider
tsearch
For
type
units
and
for
CUs
We
re
finding
an
index
entry
refers
to
a
global
offset
in
some
CU
and
hence
is
unique
in
the
target
static
int
_dwarf_search_fission_for_offset
Dwarf_Debug
dbg
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
offset
Dwarf_Unsigned
dfp_sect_num
DW_SECT_INFO
or
TYPES
Dwarf_Unsigned
percu_index_out
Dwarf_Sig8
key_out
Dwarf_Error
error
Dwarf_Unsigned
i
Dwarf_Unsigned
m
int
secnum_index
N
index
int
res
for
i
i
xuhdr
gx_column_count_sections
i
We
could
put
the
secnums
array
into
xuhdr
if
looping
here
is
too
slow
const
char
name
Dwarf_Unsigned
num
res
dwarf_get_xu_section_names
xuhdr
i
error
if
res
DW_DLV_OK
return
res
if
num
dfp_sect_num
secnum_index
i
break
if
secnum_index
_dwarf_error
dbg
error
DW_DLE_FISSION_SECNUM_ERR
return
DW_DLV_ERROR
for
m
m
xuhdr
gx_slots_in_hash
m
Dwarf_Sig8
hash
Dwarf_Unsigned
indexn
Dwarf_Unsigned
sec_offset
Dwarf_Unsigned
sec_size
res
dwarf_get_xu_hash_entry
xuhdr
m
error
if
res
DW_DLV_OK
return
res
if
indexn
memcmp
sizeof
Dwarf_Sig8
Empty
slot
continue
res
dwarf_get_xu_section_offset
xuhdr
indexn
secnum_index
error
if
res
DW_DLV_OK
return
res
if
sec_offset
offset
continue
percu_index_out
indexn
key_out
hash
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
static
int
_dwarf_get_xuhdr
Dwarf_Debug
dbg
const
char
sigtype
Dwarf_Xu_Index_Header
xuout
Dwarf_Error
error
if
strcmp
sigtype
tu
if
dbg
de_tu_hashindex_data
return
DW_DLV_NO_ENTRY
xuout
dbg
de_tu_hashindex_data
else
if
strcmp
sigtype
cu
if
dbg
de_cu_hashindex_data
return
DW_DLV_NO_ENTRY
xuout
dbg
de_cu_hashindex_data
else
_dwarf_error
dbg
error
DW_DLE_SIG_TYPE_WRONG_STRING
return
DW_DLV_ERROR
return
DW_DLV_OK
static
int
transform_xu_to_dfp
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
percu_index
Dwarf_Sig8
key
const
char
sig_type
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
error
unsigned
i
unsigned
l
unsigned
n
unsigned
max_cols
xuhdr
gx_column_count_sections
L
unsigned
secnums
DW_FISSION_SECT_COUNT
int
res
for
i
i
max_cols
i
We
could
put
the
secnums
array
into
xuhdr
if
recreating
it
is
too
slow
const
char
name
Dwarf_Unsigned
num
res
dwarf_get_xu_section_names
xuhdr
i
error
if
res
DW_DLV_OK
return
res
secnums
i
num
n
percu_index
for
l
l
max_cols
l
L
Dwarf_Unsigned
sec_off
Dwarf_Unsigned
sec_size
unsigned
l_as_sect
secnums
l
res
dwarf_get_xu_section_offset
xuhdr
n
l
error
if
res
DW_DLV_OK
return
res
percu_out
pcu_offset
l_as_sect
sec_off
percu_out
pcu_size
l_as_sect
sec_size
percu_out
pcu_type
sig_type
percu_out
pcu_index
percu_index
percu_out
pcu_hash
key
return
DW_DLV_OK
This
should
only
be
called
for
a
CU
never
a
TU
For
a
TU
the
type
hash
is
known
while
reading
the
TU
Header
Not
so
for
a
CU
int
_dwarf_get_debugfission_for_offset
Dwarf_Debug
dbg
Dwarf_Off
offset_wanted
const
char
key_type
cu
or
tu
struct
Dwarf_Debug_Fission_Per_CU_s
percu_out
Dwarf_Error
error
Dwarf_Xu_Index_Header
xuhdr
int
sres
Dwarf_Unsigned
percu_index
Dwarf_Unsigned
sect_index_base
Dwarf_Sig8
key
sect_index_base
DW_SECT_INFO
key
zerohashkey
sres
_dwarf_get_xuhdr
dbg
key_type
error
if
sres
DW_DLV_OK
return
sres
sres
_dwarf_search_fission_for_offset
dbg
xuhdr
offset_wanted
sect_index_base
error
if
sres
DW_DLV_OK
return
sres
sres
transform_xu_to_dfp
xuhdr
percu_index
key_type
percu_out
error
return
sres
int
dwarf_get_debugfission_for_key
Dwarf_Debug
dbg
Dwarf_Sig8
key
pointer
to
hash
signature
const
char
key_type
cu
or
tu
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
error
int
sres
Dwarf_Unsigned
percu_index
Dwarf_Xu_Index_Header
xuhdr
sres
_dwarf_load_debug_info
dbg
error
if
sres
DW_DLV_ERROR
return
sres
sres
_dwarf_load_debug_types
dbg
error
if
sres
DW_DLV_ERROR
return
sres
Returns
already
existing
xuhdr
sres
_dwarf_get_xuhdr
dbg
key_type
error
if
sres
DW_DLV_OK
return
sres
Search
in
that
xu
data
sres
_dwarf_search_fission_for_key
dbg
xuhdr
key
error
if
sres
DW_DLV_OK
return
sres
sres
transform_xu_to_dfp
xuhdr
percu_index
key
key_type
percu_out
error
return
sres
void
dwarf_xu_header_free
Dwarf_Xu_Index_Header
indexptr
if
indexptr
Dwarf_Debug
dbg
indexptr
gx_dbg
dwarf_dealloc
dbg
indexptr
DW_DLA_XU_INDEX
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
A
lighly
generalized
data
buffer
Works
for
more
than
just
strings
but
has
features
such
as
ensuring
data
always
has
a
NUL
byte
following
the
data
area
used
most
useful
for
C
strings
All
these
return
either
TRUE
the
values
altered
or
FALSE
something
went
wrong
quite
likely
the
caller
presented
a
bad
format
string
for
the
value
Normally
a
string
like
DWARFSTRINGERR
is
stuck
in
the
output
in
case
of
error
include
config
h
include
stdio
h
for
malloc
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
malloc
endif
HAVE_STDLIB_H
ifdef
HAVE_STRING_H
include
string
h
for
strlen
endif
HAVE_STRING_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
libdwarf_private
h
include
dwarfstring
h
m
must
be
a
string
like
DWARFSTRINGERR
for
this
to
work
define
DWSERR
m
dwarfstring_append_length
data
m
sizeof
m
static
unsigned
long
minimumnewlen
struct
dwarfstring_s
char
s_data
unsigned
long
s_size
unsigned
long
s_avail
unsigned
char
s_malloc
int
dwarfstring_constructor
struct
dwarfstring_s
g
g
s_data
g
s_size
g
s_avail
g
s_malloc
FALSE
return
TRUE
static
int
dwarfstring_resize_to
struct
dwarfstring_s
g
unsigned
long
newlen
char
b
unsigned
long
lastpos
g
s_size
g
s_avail
unsigned
long
malloclen
newlen
if
malloclen
minimumnewlen
malloclen
minimumnewlen
b
malloc
malloclen
if
b
return
FALSE
if
lastpos
memcpy
b
g
s_data
lastpos
if
g
s_malloc
free
g
s_data
g
s_data
g
s_data
b
g
s_data
lastpos
g
s_size
newlen
g
s_avail
newlen
lastpos
g
s_malloc
TRUE
return
TRUE
int
dwarfstring_reset
struct
dwarfstring_s
g
if
g
s_size
In
initial
condition
nothing
to
do
return
TRUE
g
s_avail
g
s_size
g
s_data
return
TRUE
int
dwarfstring_constructor_fixed
struct
dwarfstring_s
g
unsigned
long
len
int
r
FALSE
dwarfstring_constructor
g
if
len
return
TRUE
r
dwarfstring_resize_to
g
len
if
r
return
FALSE
return
TRUE
int
dwarfstring_constructor_static
struct
dwarfstring_s
g
char
space
unsigned
long
len
dwarfstring_constructor
g
g
s_data
space
g
s_data
g
s_size
len
g
s_avail
len
g
s_malloc
FALSE
return
TRUE
void
dwarfstring_destructor
struct
dwarfstring_s
g
if
g
s_malloc
free
g
s_data
g
s_data
g
s_malloc
dwarfstring_constructor
g
For
the
case
where
one
wants
just
the
first
len
characters
of
str
NUL
terminator
provided
for
you
in
s_data
int
dwarfstring_append_length
struct
dwarfstring_s
g
char
str
unsigned
long
slen
unsigned
long
lastpos
g
s_size
g
s_avail
int
r
if
str
slen
return
TRUE
if
slen
g
s_avail
unsigned
long
newlen
newlen
g
s_size
slen
r
dwarfstring_resize_to
g
newlen
if
r
Unable
to
resize
dare
not
do
anything
return
FALSE
memcpy
g
s_data
lastpos
str
slen
g
s_avail
slen
g
s_data
g
s_size
g
s_avail
return
TRUE
int
dwarfstring_append
struct
dwarfstring_s
g
char
str
unsigned
long
dlen
if
str
return
TRUE
dlen
strlen
str
return
dwarfstring_append_length
g
str
dlen
char
dwarfstring_string
struct
dwarfstring_s
g
return
g
s_data
unsigned
long
dwarfstring_strlen
struct
dwarfstring_s
g
return
g
s_size
g
s_avail
static
int
_dwarfstring_append_spaces
dwarfstring
data
size_t
count
int
res
char
spacebuf
size_t
charct
sizeof
spacebuf
size_t
l
count
while
l
charct
res
dwarfstring_append_length
data
spacebuf
charct
l
charct
if
res
TRUE
return
res
ASSERT
l
res
dwarfstring_append_length
data
spacebuf
l
return
res
static
int
_dwarfstring_append_zeros
dwarfstring
data
size_t
l
int
res
static
char
zeros
size_t
charct
sizeof
zeros
while
l
charct
res
dwarfstring_append_length
data
zeros
charct
l
charct
if
res
TRUE
return
res
ASSERT
l
dwarfstring_append_length
data
zeros
l
return
res
int
dwarfstring_append_printf_s
dwarfstring
data
char
format
char
s
size_t
stringlen
size_t
next
long
val
char
endptr
const
char
numptr
was
fixedlen
Zero
means
no
len
provided
size_t
fixedlen
was
nonzero
means
left
justify
long
leftjustify
size_t
prefixlen
int
res
if
s
DWSERR
DWARFSTRINGERR
null
string
pointer
to
dwarfstring_append_printf_s
return
FALSE
stringlen
strlen
s
if
format
DWSERR
DWARFSTRINGERR
null
format
pointer
to
dwarfstring_append_printf_s
return
FALSE
while
format
next
format
next
next
prefixlen
if
prefixlen
dwarfstring_append_length
data
format
prefixlen
if
format
next
No
operator
found
we
are
done
DWSERR
DWARFSTRINGERR
no
percent
passed
to
dwarfstring_append_printf_s
return
FALSE
next
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_s
return
FALSE
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_s
return
FALSE
if
format
next
leftjustify
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
if
format
next
s
DWSERR
DWARFSTRINGERR
no
percent
s
to
dwarfstring_append_printf_s
return
FALSE
next
if
fixedlen
stringlen
fixedlen
Ignore
leftjustify
if
any
and
the
stringlen
as
the
actual
string
overrides
those
leftjustify
if
leftjustify
dwarfstring_append_length
data
s
stringlen
if
fixedlen
size_t
trailingspaces
fixedlen
stringlen
_dwarfstring_append_spaces
data
trailingspaces
else
if
fixedlen
fixedlen
stringlen
This
lets
us
have
fixedlen
stringlen
by
taking
all
the
chars
from
s
dwarfstring_append_length
data
s
stringlen
else
if
fixedlen
size_t
leadingspaces
fixedlen
stringlen
size_t
k
for
k
leadingspaces
k
dwarfstring_append_length
data
dwarfstring_append_length
data
s
stringlen
if
format
next
return
TRUE
char
startpt
format
next
size_t
suffixlen
strlen
startpt
res
dwarfstring_append_length
data
startpt
suffixlen
return
res
static
char
v32m
static
char
v64m
static
char
dtable
static
char
xtable
a
b
c
d
e
f
static
char
Xtable
A
B
C
D
E
F
We
deal
with
formats
like
d
d
and
ld
and
lld
too
int
dwarfstring_append_printf_i
dwarfstring
data
char
format
dwarfstring_i
v
int
res
TRUE
size_t
next
long
val
char
endptr
const
char
numptr
size_t
fixedlen
int
leadingzero
int
minuscount
left
justify
int
pluscount
int
lcount
int
ucount
int
dcount
int
xcount
int
Xcount
char
ctable
dtable
size_t
prefixlen
int
done
if
format
DWSERR
DWARFSTRINGERR
null
format
pointer
to
dwarfstring_append_printf_i
return
FALSE
while
format
next
format
next
next
prefixlen
dwarfstring_append_length
data
format
prefixlen
if
format
next
No
operator
found
we
are
done
DWSERR
DWARFSTRINGERR
no
percent
passed
to
dwarfstring_append_printf_i
return
FALSE
next
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_i
return
FALSE
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_i
return
FALSE
if
format
next
minuscount
next
if
format
next
pluscount
next
if
format
next
minuscount
next
if
format
next
leadingzero
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
Following
is
lx
lu
or
u
or
llx
llu
we
take
all
this
to
mean
bits
ifdef
_WIN32
if
format
next
I
lcount
next
if
format
next
lcount
next
if
format
next
lcount
next
endif
_WIN32
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
u
ucount
next
if
format
next
d
dcount
next
if
format
next
x
xcount
next
if
format
next
X
Xcount
next
if
format
next
s
DWSERR
DWARFSTRINGERR
format
percent
s
passed
to
dwarfstring_append_printf_i
return
FALSE
if
xcount
Xcount
Use
the
printf_u
for
x
and
the
like
just
copying
the
entire
format
makes
it
easier
for
coders
to
understand
nothing
much
was
done
DWSERR
DWARFSTRINGERR
format
x
or
X
passed
to
dwarfstring_append_printf_i
return
FALSE
if
dcount
lcount
Xcount
xcount
dcount
ucount
error
DWSERR
DWARFSTRINGERR
format
has
too
many
percent
x
d
u
l
passed
to
dwarfstring_append_printf_i
return
FALSE
if
pluscount
minuscount
We
don
t
allow
format
DWSERR
DWARFSTRINGERR
format
disallowed
passed
to
dwarfstring_append_printf_i
return
FALSE
char
digbuf
char
digptr
digbuf
sizeof
digbuf
size_t
digcharlen
dwarfstring_i
remaining
v
int
vissigned
dwarfstring_i
divisor
digptr
digptr
if
v
vissigned
This
test
is
for
twos
complement
machines
and
would
be
better
done
via
configure
with
a
compile
time
check
so
we
do
not
need
a
size
test
at
runtime
if
sizeof
v
dwarfstring_u
vm
if
vm
dwarfstring_u
memcpy
digbuf
v64m
sizeof
v64m
digcharlen
sizeof
v64m
digptr
digbuf
done
else
remaining
v
else
if
sizeof
v
dwarfstring_u
vm
if
vm
dwarfstring_u
memcpy
digbuf
v32m
sizeof
v32m
digcharlen
sizeof
v32m
digptr
digbuf
done
else
remaining
v
else
DWSERR
DWARFSTRINGERR
v
passed
to
dwarfstring_append_printf_i
cannot
be
handled
integer
size
return
FALSE
if
done
for
dwarfstring_u
dig
dig
remaining
divisor
remaining
divisor
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
if
vissigned
could
check
minuscount
instead
digptr
digcharlen
digptr
else
if
pluscount
digptr
digcharlen
digptr
if
fixedlen
if
fixedlen
digcharlen
dwarfstring_append_length
data
digptr
digcharlen
else
size_t
prefixcount
fixedlen
digcharlen
if
leadingzero
_dwarfstring_append_spaces
data
prefixcount
dwarfstring_append_length
data
digptr
digcharlen
else
if
digptr
dwarfstring_append_length
data
_dwarfstring_append_zeros
data
prefixcount
digptr
dwarfstring_append_length
data
digptr
digcharlen
else
if
digptr
dwarfstring_append_length
data
_dwarfstring_append_zeros
data
prefixcount
digptr
dwarfstring_append_length
data
digptr
digcharlen
else
_dwarfstring_append_zeros
data
prefixcount
dwarfstring_append_length
data
digptr
digcharlen
else
res
dwarfstring_append_length
data
digptr
digcharlen
if
format
next
size_t
trailinglen
strlen
format
next
res
dwarfstring_append_length
data
format
next
trailinglen
return
res
if
Counts
hex
chars
divide
by
two
to
get
bytes
from
input
integer
static
unsigned
trimleadingzeros
char
ptr
unsigned
digits
unsigned
keepcount
char
cp
ptr
unsigned
leadzeroscount
unsigned
trimoff
for
cp
cp
if
cp
leadzeroscount
continue
trimoff
keepcount
digits
if
trimoff&1
trimoff
return
trimoff
endif
With
gcc
version
a
version
using
const
char
formatp
instead
of
format
next
and
deleting
the
next
variable
is
a
few
hundredths
of
a
second
slower
repeatably
We
deal
with
formats
like
u
and
ld
and
lld
too
x
and
ld
and
lld
too
int
dwarfstring_append_printf_u
dwarfstring
data
char
format
dwarfstring_u
v
size_t
next
long
val
char
endptr
const
char
numptr
size_t
fixedlen
int
leadingzero
int
lcount
int
ucount
int
dcount
int
xcount
int
Xcount
char
ctable
size_t
divisor
size_t
prefixlen
if
format
DWSERR
DWARFSTRINGERR
null
format
pointer
to
dwarfstring_append_printf_u
return
FALSE
while
format
next
format
next
next
prefixlen
dwarfstring_append_length
data
format
prefixlen
if
format
next
No
operator
found
we
are
done
DWSERR
DWARFSTRINGERR
no
percent
passed
to
dwarfstring_append_printf_u
return
FALSE
next
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_u
return
FALSE
if
format
next
DWSERR
DWARFSTRINGERR
empty
percent
to
dwarfstring_append_printf_u
return
FALSE
if
format
next
DWSERR
DWARFSTRINGERR
format
passed
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
format
next
leadingzero
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
Following
is
lx
lu
or
u
or
llx
llu
we
take
all
this
to
mean
bits
ifdef
_WIN32
if
format
next
I
lcount
next
if
format
next
lcount
next
if
format
next
lcount
next
endif
_WIN32
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
u
ucount
next
if
format
next
d
dcount
next
if
format
next
x
xcount
next
if
format
next
X
Xcount
next
if
format
next
s
DWSERR
DWARFSTRINGERR
format
percent
s
passed
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
Xcount
xcount
dcount
ucount
DWSERR
DWARFSTRINGERR
format
percent
x
X
d
u
repeats
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
Xcount
xcount
dcount
ucount
DWSERR
DWARFSTRINGERR
format
percent
x
X
d
u
missing
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
lcount
DWSERR
DWARFSTRINGERR
format
percent
lll
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
dcount
DWSERR
DWARFSTRINGERR
format
percent
d
to
dwarfstring_append_printf_u
cannot
be
handled
return
FALSE
if
ucount
divisor
ctable
dtable
else
divisor
if
xcount
ctable
xtable
else
ctable
Xtable
char
digbuf
char
digptr
unsigned
digcharlen
dwarfstring_u
remaining
v
if
divisor
digptr
digbuf
sizeof
digbuf
for
dwarfstring_u
dig
dig
remaining
remaining
remaining
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
else
digptr
digbuf
sizeof
digbuf
digptr
digptr
for
dwarfstring_u
dig
dig
remaining
divisor
remaining
divisor
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
if
fixedlen
digcharlen
dwarfstring_append_length
data
digptr
digcharlen
else
if
leadingzero
size_t
justcount
fixedlen
digcharlen
_dwarfstring_append_spaces
data
justcount
dwarfstring_append_length
data
digptr
digcharlen
else
size_t
prefixcount
fixedlen
digcharlen
_dwarfstring_append_zeros
data
prefixcount
dwarfstring_append_length
data
digptr
digcharlen
if
format
next
size_t
trailinglen
strlen
format
next
dwarfstring_append_length
data
format
next
trailinglen
return
FALSE
getopt
c
v
joerg
Exp
Modified
by
David
Anderson
to
work
with
GNU
Linux
and
freebsd
Added
for
clarity
Switched
to
standard
dwarfdump
formatting
Treatment
of
modified
so
that
gets
dwoptarg
NULL
if
space
follows
the
letter
the
dwoptarg
is
set
to
null
renamed
to
make
it
clear
this
is
a
private
version
Oct
Created
dwgetopt_long
See
dwgetopt
h
Copyright
c
The
Regents
of
the
University
of
California
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
Neither
the
name
of
the
University
nor
the
names
of
its
contributors
may
be
used
to
endorse
or
promote
products
derived
from
this
software
without
specific
prior
written
permission
THIS
SOFTWARE
IS
PROVIDED
BY
THE
REGENTS
AND
CONTRIBUTORS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
REGENTS
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
does
not
presently
handle
the
option
string
leading
or
leading
features
Such
are
not
used
by
by
libdwarfdump
Nor
does
it
understand
the
GNU
Env
var
POSIXLY_CORRECT
It
does
know
of
the
leading
in
the
option
string
See
BADCH
below
include
config
h
include
stdio
h
ifdef
HAVE_STRING_H
include
string
h
for
strchr
etc
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
exit
endif
HAVE_STDLIB_H
include
dwgetopt
h
include
libdwarf_private
h
define
STRIP_OFF_CONSTNESS
a
void
size_t
const
void
a
int
dwopterr
if
error
message
should
be
printed
dwoptind
index
into
parent
argv
vector
dwoptopt
character
checked
for
validity
dwoptreset
reset
getopt
char
dwoptarg
argument
associated
with
option
define
BADCH
int
define
BADARG
int
define
EMSG
if
FOR
DEBUGGING
ONLY
Use
for
testing
dwgetopt
only
Not
a
standard
function
void
dwgetoptresetfortestingonly
void
dwopterr
dwoptind
dwoptopt
dwoptreset
dwoptarg
endif
FOR
DEBUGGING
ONLY
static
const
char
place
EMSG
option
letter
processing
Post
Condition
if
return
FALSE
then
argerr
is
set
false
static
int
dwoptnamematches
const
struct
dwoption
dwlopt
const
char
iplace
const
char
argloc
int
argerr
const
char
eq
unsigned
namelen
unsigned
arglen
int
d
for
eq
iplace
eq
eq
if
eq
continue
Found
arg
should
follow
namelen
eq
iplace
if
namelen
unsigned
strlen
dwlopt
name
return
FALSE
eq
arglen
strlen
eq
break
if
namelen
d
strncmp
iplace
dwlopt
name
namelen
if
d
return
FALSE
if
dwlopt
has_arg
argerr
TRUE
return
TRUE
if
arglen
Discarding
const
avoiding
warning
Data
is
in
user
space
so
this
is
ok
dwoptarg
char
eq
argloc
const
char
eq
else
Has
arg
but
arg
is
empty
dwoptarg
return
TRUE
else
d
strcmp
iplace
dwlopt
name
if
d
return
FALSE
if
dwlopt
has_arg
argerr
TRUE
return
TRUE
dwoptarg
return
TRUE
dwgetopt_long
A
reimplementation
of
a
portion
of
the
getopt
GNU
Linux
getopt_long
See
dwgetopt
h
for
more
details
int
dwgetopt_long
int
nargc
char
const
nargv
const
char
ostr
const
struct
dwoption
longopts
int
longindex
char
lplace
if
dwoptreset
Not
really
supported
place
EMSG
return
if
place
int
v
dwgetopt
nargc
nargv
ostr
return
v
Use
local
lplace
in
case
we
need
to
call
getopt
just
below
lplace
nargv
dwoptind
if
dwoptind
nargc
lplace
Argument
is
absent
or
is
not
an
option
place
EMSG
return
if
lplace
Notice
place
not
disturbed
int
v
dwgetopt
nargc
nargv
ostr
return
v
Starts
with
two
dashes
Now
we
set
the
global
place
place
lplace
if
place
end
of
options
dwoptind
place
EMSG
return
We
think
this
is
a
longopt
int
lo_num
for
lo_num
const
struct
dwoption
dwlopt
longopts
lo_num
const
char
argloc
int
argerr
int
resmatch
if
dwlopt
name
dwoptind
void
fprintf
stderr
s
invalid
long
option
s
n
nargv
place
Leave
longindex
unchanged
place
EMSG
return
BADCH
resmatch
dwoptnamematches
dwlopt
place
if
resmatch
dwoptarg
if
argloc
Must
drop
const
here
Ugh
dwoptarg
char
argloc
if
argerr
resmatch
TRUE
arg
option
missing
if
required
present
but
not
allowed
GNU
Behavior
not
well
documented
Had
to
experiment
if
argument
not
allowed
and
we
have
one
do
If
argument
required
then
here
GNU
would
take
the
next
argv
as
the
argument
we
are
not
currently
doing
that
longindex
lo_num
if
dwlopt
has_arg
Missing
required
arg
this
does
not
match
GNU
getopt_long
behavior
of
taking
next
argv
as
the
arg
value
and
thus
making
getopt_long
succeed
void
fprintf
stderr
s
missing
required
long
option
argument
s
n
nargv
place
else
has
arg
but
should
not
void
fprintf
stderr
s
option
s
does
not
allow
an
argument
n
nargv
dwlopt
name
dwoptind
place
EMSG
return
BADCH
if
resmatch
longindex
lo_num
place
EMSG
dwoptind
return
dwlopt
val
Can
never
get
here
place
EMSG
dwoptind
return
getopt
Parse
argc
argv
argument
vector
a
means
afoo
a
foo
and
foo
is
returned
in
dwoptarg
b
means
b
and
dwoptarg
is
null
bother
and
dwoptarg
is
other
int
dwgetopt
int
nargc
char
const
nargv
const
char
ostr
char
oli
option
letter
list
index
if
dwoptreset
place
update
scanning
pointer
dwoptreset
place
nargv
dwoptind
if
dwoptind
nargc
place
Argument
is
absent
or
is
not
an
option
place
EMSG
return
dwoptopt
place
if
dwoptopt
place
end
of
options
dwoptind
place
EMSG
return
if
dwoptopt
Solitary
treat
as
a
option
if
the
program
eg
su
is
looking
for
it
place
EMSG
if
strchr
ostr
NULL
return
dwoptopt
else
dwoptopt
place
See
if
option
letter
is
one
the
caller
wanted
if
dwoptopt
oli
strchr
ostr
dwoptopt
NULL
if
place
dwoptind
if
dwopterr
ostr
void
fprintf
stderr
s
invalid
option
c
n
nargv
dwoptopt
return
BADCH
Does
this
option
need
an
argument?
if
oli
don
t
need
argument
dwoptarg
NULL
if
place
dwoptind
else
int
reqnextarg
if
oli
oli
Pair
of
means
special
treatment
of
dwoptarg
reqnextarg
Option
argument
is
either
the
rest
of
this
argument
or
the
entire
next
argument
if
place
Whether
or
dwoptarg
STRIP_OFF_CONSTNESS
place
else
if
reqnextarg
place
if
nargc
dwoptind
dwoptarg
nargv
dwoptind
else
place
EMSG
Next
arg
required
but
is
missing
if
ostr
Leading
in
ostr
calls
for
BADARG
return
return
BADARG
if
dwopterr
void
fprintf
stderr
s
option
requires
an
argument
c
n
nargv
dwoptopt
return
BADCH
else
place
The
key
part
of
treatment
dwoptarg
NULL
place
EMSG
dwoptind
return
dwoptopt
return
option
letter
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Used
by
scripts
libbuild
sh
Not
in
libdwarf
itself
include
config
h
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
include
errno
h
For
errno
declaration
include
ctype
h
ifdef
HAVE_STRING_H
include
string
h
endif
HAVE_STRING_H
include
dwgetopt
h
include
libdwarf_version
h
for
DW_VERSION_DATE_STR
gennames
c
Prints
routines
to
return
constant
name
for
the
associated
value
such
as
the
TAG
name
string
for
a
particular
tag
The
input
is
dwarf
h
For
each
set
of
names
with
a
common
prefix
we
create
a
routine
to
return
the
name
given
the
value
Also
print
header
file
that
gives
prototypes
of
routines
To
handle
cases
where
there
are
multiple
names
for
a
single
value
DW_AT_
has
some
due
to
ambiguities
in
the
DWARF2
spec
we
take
the
first
of
a
given
value
as
the
definitive
name
TAGs
Attributes
etc
are
given
distinct
checks
There
are
multiple
output
files
as
some
people
find
one
form
more
pleasant
than
the
other
The
doprinting
argument
is
so
that
when
used
by
tag_tree
c
and
tag_attr
c
that
we
don
t
get
irritating
messages
on
stderr
when
those
dwarfdump
built
time
applications
are
run
Some
compilers
generate
better
code
for
switch
statements
than
others
so
the
s
and
t
options
let
the
user
decide
which
is
better
for
their
compiler
when
building
dwarfdump
a
simple
switch
or
code
doing
binary
search
This
choice
affects
the
runtime
speed
of
dwarfdump
define
FAILED
static
void
OpenAllFiles
void
static
void
WriteFileTrailers
void
static
void
CloseAllFiles
void
static
void
GenerateInitialFileLines
void
static
void
GenerateOneSet
void
ifdef
TRACE_ARRAY
static
void
PrintArray
void
endif
TRACE_ARRAY
static
int
is_skippable_line
char
pLine
static
void
ParseDefinitionsAndWriteOutput
void
We
don
t
need
really
long
lines
the
input
file
is
simple
define
MAX_LINE_SIZE
We
don
t
need
a
variable
array
size
it
just
has
to
be
big
enough
define
ARRAY_SIZE
define
MAX_NAME_LEN
To
store
entries
from
dwarf
h
typedef
struct
char
name
MAX_NAME_LEN
short
name
unsigned
value
value
Original
spot
in
array
Lets
us
guarantee
a
stable
sort
unsigned
original_position
array_data
A
group_array
is
a
grouping
from
dwarf
h
All
the
TAGs
are
one
group
all
the
FORMs
are
another
group
and
so
on
static
array_data
group_array
ARRAY_SIZE
static
unsigned
array_count
typedef
int
compfn
const
void
const
void
static
int
Compare
array_data
array_data
static
const
char
prefix_root
DW_
static
const
unsigned
prefix_root_len
f_dwarf_in
is
the
input
dwarf
h
The
others
are
output
files
static
FILE
f_dwarf_in
static
FILE
f_names_h
static
FILE
f_names_c
static
FILE
f_names_enum_h
static
FILE
f_names_new_h
Size
unchecked
but
large
enough
static
char
prefix
static
const
char
usage
Usage
gennames
options
i
input
table
path
o
output
table
path
s
use
switch
in
generation
t
use
tables
in
generation
static
void
print_args
int
argc
char
argv
int
index
printf
Arguments
for
index
index
argc
index
printf
s
argv
index
printf
n
char
program_name
static
char
input_name
static
char
output_name
static
int
use_switch
TRUE
static
int
use_tables
FALSE
static
void
print_version
const
char
name
ifdef
_DEBUG
const
char
acType
Debug
else
const
char
acType
Release
endif
_DEBUG
printf
s
s
s
n
name
DW_VERSION_DATE_STR
acType
static
void
print_usage_message
const
char
options
int
index
for
index
options
index
index
printf
s
n
options
index
process
arguments
static
void
process_args
int
argc
char
argv
int
c
int
usage_error
FALSE
program_name
argv
while
c
dwgetopt
argc
argv
i
o
st
EOF
switch
c
case
i
input_name
dwoptarg
break
case
o
output_name
dwoptarg
break
case
s
use_switch
TRUE
use_tables
FALSE
break
case
t
use_switch
FALSE
use_tables
TRUE
break
default
usage_error
TRUE
break
if
usage_error
dwoptind
dwoptind
argc
print_usage_message
usage
exit
FAILED
int
main
int
argc
char
argv
print_version
argv
print_args
argc
argv
process_args
argc
argv
OpenAllFiles
GenerateInitialFileLines
ParseDefinitionsAndWriteOutput
WriteFileTrailers
CloseAllFiles
return
Print
the
array
used
to
hold
the
tags
attributes
values
ifdef
TRACE_ARRAY
static
void
PrintArray
void
int
i
for
i
i
array_count
i
printf
d
Name
s_
s
Value
n
i
prefix
array
i
name
array
i
value
endif
TRACE_ARRAY
By
including
original
position
we
force
a
stable
sort
static
int
Compare
array_data
elem1
array_data
elem2
if
elem1
value
elem2
value
return
if
elem1
value
elem2
value
return
if
elem1
original_position
elem2
original_position
return
if
elem1
original_position
elem2
original_position
return
return
static
FILE
open_path
const
char
base
const
char
file
const
char
direction
FILE
f
POSIX
PATH_MAX
would
suffice
normally
stdio
BUFSIZ
is
larger
than
PATH_MAX
static
char
path_name
BUFSIZ
space
for
and
NUL
size_t
netlen
strlen
file
strlen
base
if
netlen
BUFSIZ
printf
Error
opening
s
s
name
too
long
n
base
file
exit
strcpy
path_name
base
strcat
path_name
strcat
path_name
file
f
fopen
path_name
direction
if
f
printf
Error
opening
s
n
path_name
exit
return
f
Open
files
and
write
the
basic
headers
static
void
OpenAllFiles
void
const
char
dwarf_h
dwarf
h
const
char
names_h
dwarf_names
h
const
char
names_c
dwarf_names
c
const
char
names_enum_h
dwarf_names_enum
h
const
char
names_new_h
dwarf_names_new
h
f_dwarf_in
open_path
input_name
dwarf_h
r
f_names_enum_h
open_path
output_name
names_enum_h
w
f_names_new_h
open_path
output_name
names_new_h
w
f_names_h
open_path
output_name
names_h
w
f_names_c
open_path
output_name
names_c
w
static
void
GenerateInitialFileLines
void
Generate
entries
for
dwarf_names_enum
h
fprintf
f_names_enum_h
Automatically
generated
do
not
edit
n
fprintf
f_names_enum_h
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
f_names_enum_h
n
BEGIN
FILE
n
n
fprintf
f_names_enum_h
ifndef
__DWARF_NAMES_ENUM_H__
n
fprintf
f_names_enum_h
define
__DWARF_NAMES_ENUM_H__
n
Generate
entries
for
dwarf_names_new
h
fprintf
f_names_new_h
Automatically
generated
do
not
edit
n
fprintf
f_names_new_h
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
f_names_new_h
n
BEGIN
FILE
n
n
fprintf
f_names_new_h
define
DWARF_PRINT_PREFIX
before
this
n
fprintf
f_names_new_h
point
if
you
wish
to
n
fprintf
f_names_new_h
ifndef
DWARF_PRINT_PREFIX
n
fprintf
f_names_new_h
define
DWARF_PRINT_PREFIX
dwarf_
n
fprintf
f_names_new_h
endif
n
fprintf
f_names_new_h
define
dw_glue
x
y
x
y
n
fprintf
f_names_new_h
define
dw_glue2
x
y
dw_glue
x
y
n
fprintf
f_names_new_h
define
DWPREFIX
x
dw_glue2
DWARF_PRINT_PREFIX
x
n
Generate
entries
for
dwarf_names
h
fprintf
f_names_h
Generated
routines
do
not
edit
n
fprintf
f_names_h
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
f_names_h
n
BEGIN
FILE
n
n
fprintf
f_names_h
ifndef
DWARF_NAMES_H
n
fprintf
f_names_h
define
DWARF_NAMES_H
n
n
fprintf
f_names_h
ifdef
__cplusplus
n
fprintf
f_names_h
extern
C
n
fprintf
f_names_h
endif
__cplusplus
n
n
Generate
entries
for
dwarf_names
c
fprintf
f_names_c
Generated
routines
do
not
edit
n
fprintf
f_names_c
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
f_names_c
n
BEGIN
FILE
n
n
fprintf
f_names_c
include
dwarf
h
n
n
fprintf
f_names_c
include
libdwarf
h
n
n
if
use_tables
fprintf
f_names_c
typedef
struct
Names_Data
n
fprintf
f_names_c
const
char
l_name
n
fprintf
f_names_c
unsigned
value
n
fprintf
f_names_c
Names_Data
n
n
Generate
code
to
find
an
entry
fprintf
f_names_c
Use
standard
binary
search
to
get
entry
n
fprintf
f_names_c
static
int
nfind_entry
Names_Data
table
const
int
last
unsigned
value
const
char
s_out
n
fprintf
f_names_c
n
fprintf
f_names_c
int
low
n
fprintf
f_names_c
int
high
last
n
fprintf
f_names_c
int
mid
n
fprintf
f_names_c
unsigned
maxval
table
last
value
n
fprintf
f_names_c
n
fprintf
f_names_c
if
value
maxval
n
fprintf
f_names_c
return
DW_DLV_NO_ENTRY
n
fprintf
f_names_c
n
fprintf
f_names_c
while
low
high
n
fprintf
f_names_c
mid
low
high
low
n
fprintf
f_names_c
if
mid
last
n
fprintf
f_names_c
break
n
fprintf
f_names_c
n
fprintf
f_names_c
if
table
mid
value
value
n
fprintf
f_names_c
low
mid
n
fprintf
f_names_c
n
fprintf
f_names_c
else
n
fprintf
f_names_c
high
mid
n
fprintf
f_names_c
n
fprintf
f_names_c
n
fprintf
f_names_c
n
fprintf
f_names_c
if
low
last
table
low
value
value
n
fprintf
f_names_c
Found
low
is
the
entry
n
fprintf
f_names_c
s_out
table
low
l_name
n
fprintf
f_names_c
return
DW_DLV_OK
n
fprintf
f_names_c
n
fprintf
f_names_c
return
DW_DLV_NO_ENTRY
n
fprintf
f_names_c
n
fprintf
f_names_c
n
Close
files
and
write
basic
trailers
static
void
WriteFileTrailers
void
Generate
entries
for
dwarf_names_enum
h
fprintf
f_names_enum_h
endif
__DWARF_NAMES_ENUM_H__
n
fprintf
f_names_enum_h
n
END
FILE
n
Generate
entries
for
dwarf_names_new
h
fprintf
f_names_new_h
n
END
FILE
n
Generate
entries
for
dwarf_names
h
fprintf
f_names_h
n
ifdef
__cplusplus
n
fprintf
f_names_h
n
fprintf
f_names_h
endif
__cplusplus
n
n
fprintf
f_names_h
endif
DWARF_NAMES_H
n
fprintf
f_names_h
n
END
FILE
n
Generate
entries
for
dwarf_names
c
fprintf
f_names_c
n
END
FILE
n
static
void
CloseAllFiles
void
fclose
f_dwarf_in
fclose
f_names_enum_h
fclose
f_names_new_h
fclose
f_names_h
fclose
f_names_c
Write
the
table
and
code
for
a
common
set
of
names
static
void
GenerateOneSet
void
unsigned
u
unsigned
prev_value
size_t
len
char
prefix_id
prefix
prefix_root_len
unsigned
actual_array_count
ifdef
TRACE_ARRAY
printf
List
before
sorting
n
PrintArray
endif
TRACE_ARRAY
Sort
the
array
because
the
values
in
libdwarf
h
are
not
in
ascending
order
if
we
use
t
we
must
be
sure
the
values
are
sorted
for
the
binary
search
to
work
properly
We
want
a
stable
sort
hence
mergesort
qsort
void
array_count
sizeof
array_data
compfn
Compare
ifdef
TRACE_ARRAY
printf
nList
after
sorting
n
PrintArray
endif
TRACE_ARRAY
Generate
entries
for
dwarf_names_enum
h
fprintf
f_names_enum_h
nenum
Dwarf_
s_e
n
prefix_id
Generate
entries
for
dwarf_names_new
h
fprintf
f_names_new_h
int
DWPREFIX
get_
s_name
unsigned
int
const
char
n
prefix_id
Generate
entries
for
dwarf_names
h
and
libdwarf
h
fprintf
f_names_h
extern
int
dwarf_get_
s_name
unsigned
int
val_in
n
prefix_id
fprintf
f_names_h
const
char
s_out
n
Generate
code
for
dwarf_names
c
fprintf
f_names_c
ARGSUSED
n
fprintf
f_names_c
int
n
fprintf
f_names_c
dwarf_get_
s_name
unsigned
int
val
n
prefix_id
fprintf
f_names_c
const
char
s_out
n
fprintf
f_names_c
n
if
use_tables
fprintf
f_names_c
static
Names_Data
Dwarf_
s_n
n
prefix_id
else
fprintf
f_names_c
switch
val
n
for
u
u
array_count
u
Check
if
value
already
dumped
if
u
group_array
u
value
prev_value
fprintf
f_names_c
Skipping
alternate
spelling
of
value
n
fprintf
f_names_c
x
s_
s
n
unsigned
prev_value
prefix
group_array
u
name
continue
prev_value
group_array
u
value
Generate
entries
for
dwarf_names_enum
h
The
just
makes
nice
formatting
in
the
output
len
strlen
prefix
fprintf
f_names_enum_h
s_
s
prefix
int
len
group_array
u
name
group_array
u
value
fprintf
f_names_enum_h
u
array_count
n
n
Generate
entries
for
dwarf_names
c
if
use_tables
fprintf
f_names_c
s_
s
actual_array_count
prefix
group_array
u
name
fprintf
f_names_c
s_
s
prefix
group_array
u
name
fprintf
f_names_c
u
array_count
n
n
else
fprintf
f_names_c
case
s_
s
n
prefix
group_array
u
name
fprintf
f_names_c
s_out
s_
s
n
prefix
group_array
u
name
fprintf
f_names_c
return
DW_DLV_OK
n
actual_array_count
Closing
entries
for
dwarf_names_enum
h
fprintf
f_names_enum_h
n
if
use_tables
Closing
entries
for
dwarf_names
c
fprintf
f_names_c
n
n
Closing
code
for
dwarf_names
c
fprintf
f_names_c
const
int
last_entry
d
n
actual_array_count
fprintf
f_names_c
find
the
entry
n
fprintf
f_names_c
int
r
find_entry
Dwarf_
s_n
last_entry
val
s_out
n
prefix_id
fprintf
f_names_c
return
r
n
fprintf
f_names_c
n
else
fprintf
f_names_c
n
fprintf
f_names_c
return
DW_DLV_NO_ENTRY
n
fprintf
f_names_c
n
Mark
the
group_array
as
empty
array_count
Detect
empty
lines
and
other
lines
we
do
not
want
to
read
static
int
is_skippable_line
char
pLine
int
empty
TRUE
for
pLine
empty
pLine
empty
isspace
pLine
return
empty
static
void
safe_strncpy
char
out
unsigned
out_len
char
in
unsigned
in_len
if
in_len
out_len
fprintf
stderr
Impossible
input
line
from
dwarf
h
Giving
up
n
fprintf
stderr
Length
u
is
too
large
limited
to
u
n
in_len
out_len
exit
strncpy
out
in
in_len
Parse
the
dwarf
h
file
and
generate
the
tables
static
void
ParseDefinitionsAndWriteOutput
void
char
new_prefix
char
second_underscore
NULL
char
type
char
name
char
value
char
extra
char
line_in
MAX_LINE_SIZE
int
pending
FALSE
int
prefix_len
Process
each
line
from
dwarf
h
while
feof
f_dwarf_in
errno
is
cleared
here
so
printing
errno
after
the
fgets
is
showing
errno
as
set
by
fgets
char
fgbad
errno
fgbad
fgets
line_in
sizeof
line_in
f_dwarf_in
if
fgbad
if
feof
f_dwarf_in
break
Is
error
errno
must
be
set
fprintf
stderr
Error
reading
dwarf
h
Errno
d
n
errno
exit
if
is_skippable_line
line_in
continue
sscanf
line_in
s
s
s
s
type
name
value
extra
if
strcmp
type
define
strncmp
name
prefix_root
prefix_root_len
continue
second_underscore
strchr
name
prefix_root_len
_
prefix_len
int
second_underscore
name
safe_strncpy
new_prefix
sizeof
new_prefix
name
prefix_len
new_prefix
prefix_len
Check
for
new
prefix
set
if
strcmp
prefix
new_prefix
if
pending
Generate
current
prefix
set
GenerateOneSet
pending
TRUE
strcpy
prefix
new_prefix
Be
sure
we
have
a
valid
entry
if
array_count
ARRAY_SIZE
printf
Too
many
entries
for
current
group_array
size
of
d
ARRAY_SIZE
exit
Move
past
the
second
underscore
second_underscore
unsigned
long
v
strtoul
value
NULL
Some
values
are
duplicated
that
is
ok
After
the
sort
we
will
weed
out
the
duplicate
values
see
GenerateOneSet
Record
current
entry
if
strlen
second_underscore
MAX_NAME_LEN
printf
Too
long
a
name
s
for
max
len
d
n
second_underscore
MAX_NAME_LEN
exit
strcpy
group_array
array_count
name
second_underscore
group_array
array_count
value
v
group_array
array_count
original_position
array_count
array_count
if
pending
Generate
final
prefix
set
GenerateOneSet
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
malloc_check
c
For
checking
dealloc
completeness
This
code
is
as
simple
as
possible
and
works
ok
for
reasonable
size
allocation
counts
It
treats
allocation
as
global
and
so
will
not
work
very
well
if
an
application
opens
more
than
one
Dwarf_Debug
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
include
config
h
include
dwarf_incl
h
include
malloc_check
h
ifdef
WANT_LIBBDWARF_MALLOC_CHECK
To
turn
off
printing
every
entry
just
change
the
define
to
set
PRINT_MALLOC_DETAILS
define
PRINT_MALLOC_DETAILS
define
MC_TYPE_UNKNOWN
define
MC_TYPE_ALLOC
define
MC_TYPE_DEALLOC
struct
mc_data_s
struct
mc_data_s
mc_prev
unsigned
long
mc_address
Assumes
this
is
large
enough
to
hold
a
pointer
long
mc_alloc_number
Assigned
in
order
by
when
record
created
unsigned
char
mc_alloc_code
Allocation
code
libdwarf
unsigned
char
mc_type
unsigned
char
mc_dealloc_noted
Used
on
an
ALLOC
node
unsigned
char
mc_dealloc_noted_count
Used
on
an
ALLOC
node
define
HASH_TABLE_SIZE
static
struct
mc_data_s
mc_data_hash
HASH_TABLE_SIZE
static
long
mc_data_list_size
static
char
alloc_type_name
MAX_DW_DLA
DW_DLA_STRING
DW_DLA_LOC
DW_DLA_LOCDESC
DW_DLA_ELLIST
DW_DLA_BOUNDS
DW_DLA_BLOCK
DW_DLA_DEBUG
DW_DLA_DIE
DW_DLA_LINE
DW_DLA_ATTR
DW_DLA_TYPE
DW_DLA_SUBSCR
DW_DLA_GLOBAL
DW_DLA_ERROR
DW_DLA_LIST
DW_DLA_LINEBUF
DW_DLA_ARANGE
DW_DLA_ABBREV
DW_DLA_FRAME_OP
DW_DLA_CIE
DW_DLA_FDE
DW_DLA_LOC_BLOCK
DW_DLA_FRAME_BLOCK
DW_DLA_FUNC
DW_DLA_TYPENAME
DW_DLA_VAR
DW_DLA_WEAK
DW_DLA_ADDR
DW_DLA_ABBREV_LIST
DW_DLA_CHAIN
DW_DLA_CU_CONTEXT
DW_DLA_FRAME
DW_DLA_GLOBAL_CONTEXT
DW_DLA_FILE_ENTRY
DW_DLA_LINE_CONTEXT
DW_DLA_LOC_CHAIN
DW_DLA_HASH_TABLE
DW_DLA_FUNC_CONTEXT
DW_DLA_TYPENAME_CONTEXT
DW_DLA_VAR_CONTEXT
DW_DLA_WEAK_CONTEXT
DW_DLA_PUBTYPES_CONTEXT
Don
t
forget
to
expand
this
list
if
the
list
of
codes
expands
static
unsigned
hash_address
unsigned
long
addr
unsigned
long
a
addr
return
a
HASH_TABLE_SIZE
if
PRINT_MALLOC_DETAILS
static
void
print_alloc_dealloc_detail
unsigned
long
addr
int
code
char
whichisit
fprintf
stderr
s
addr
lx
code
d
s
entry
ld
n
whichisit
addr
code
alloc_type_name
code
mc_data_list_size
else
define
print_alloc_dealloc_detail
a
b
c
nothing
endif
Create
a
zeroed
struct
or
die
static
void
newone
void
struct
mc_data_s
newd
malloc
sizeof
struct
mc_data_s
if
newd
fprintf
stderr
out
of
memory
ld
n
mc_data_list_size
exit
memset
newd
sizeof
struct
mc_data_s
return
newd
Notify
checker
that
get_alloc
has
allocated
user
data
void
dwarf_malloc_check_alloc_data
void
addr_in
unsigned
char
code
struct
mc_data_s
newd
newone
unsigned
long
addr
unsigned
long
addr_in
struct
mc_data_s
base
hash_address
addr
print_alloc_dealloc_detail
addr
code
alloc
newd
mc_address
addr
newd
mc_alloc_code
code
newd
mc_type
MC_TYPE_ALLOC
newd
mc_alloc_number
mc_data_list_size
newd
mc_prev
base
base
newd
newd
mc_alloc_number
mc_data_list_size
mc_data_list_size
static
void
print_entry
char
msg
struct
mc_data_s
data
fprintf
stderr
s
code
s
type
s
dealloc
noted
u
ct
u
n
msg
long
data
mc_address
data
mc_alloc_code
alloc_type_name
data
mc_alloc_code
data
mc_type
MC_TYPE_ALLOC
alloc
data
mc_type
MC_TYPE_DEALLOC
dealloc
unknown
unsigned
data
mc_dealloc_noted
unsigned
data
mc_dealloc_noted_count
newd
is
a
dealloc
static
long
balanced_by_alloc_p
struct
mc_data_s
newd
long
addr_match_num
struct
mc_data_s
addr_match
struct
mc_data_s
base
struct
mc_data_s
cur
base
for
cur
cur
cur
mc_prev
if
cur
mc_address
newd
mc_address
if
cur
mc_type
MC_TYPE_ALLOC
if
cur
mc_alloc_code
newd
mc_alloc_code
addr_match
cur
addr_match_num
cur
mc_alloc_number
return
cur
mc_alloc_number
else
code
mismatch
addr_match
cur
addr_match_num
cur
mc_alloc_number
return
else
Unbalanced
new
del
addr_match
cur
addr_match_num
cur
mc_alloc_number
return
return
A
dealloc
is
to
take
place
Ensure
it
balances
an
alloc
void
dwarf_malloc_check_dealloc_data
void
addr_in
unsigned
char
code
struct
mc_data_s
newd
newone
long
prev
long
addr_match_num
struct
mc_data_s
addr_match
unsigned
long
addr
unsigned
long
addr_in
struct
mc_data_s
base
hash_address
addr
print_alloc_dealloc_detail
addr
code
dealloc
newd
mc_address
unsigned
long
addr
newd
mc_alloc_code
code
newd
mc_type
MC_TYPE_DEALLOC
newd
mc_prev
base
prev
balanced_by_alloc_p
newd
base
if
prev
fprintf
stderr
Unbalanced
dealloc
at
index
ld
n
mc_data_list_size
print_entry
new
newd
fprintf
stderr
addr
match_num?
ld
n
addr_match_num
if
addr_match
print_entry
prev
entry
addr_match
if
addr_match
mc_dealloc_noted
fprintf
stderr
Above
is
Duplicate
dealloc
n
abort
exit
addr_match
mc_dealloc_noted
addr_match
mc_dealloc_noted_count
if
addr_match
mc_dealloc_noted_count
fprintf
stderr
Double
dealloc
entry
ld
n
addr_match_num
print_entry
new
dealloc
entry
newd
print_entry
bad
alloc
entry
addr_match
base
newd
mc_data_list_size
Final
check
for
leaks
void
dwarf_malloc_check_complete
char
msg
long
i
long
total
mc_data_list_size
long
hash_slots_used
long
max_chain_length
fprintf
stderr
Run
complete
s
ld
entries
n
msg
total
for
i
HASH_TABLE_SIZE
i
struct
mc_data_s
cur
mc_data_hash
i
long
cur_chain_length
if
cur
continue
hash_slots_used
for
cur
cur
cur
mc_prev
cur_chain_length
if
cur
mc_type
MC_TYPE_ALLOC
if
cur
mc_dealloc_noted
if
cur
mc_dealloc_noted
fprintf
stderr
Duplicate
dealloc
entry
ld
n
cur
mc_alloc_number
print_entry
duplicate
dealloc
cur
continue
else
fprintf
stderr
malloc
no
dealloc
entry
ld
n
cur
mc_alloc_number
print_entry
dangle
cur
else
mc_type
is
MC_TYPE_DEALLOC
already
checked
if
cur_chain_length
max_chain_length
max_chain_length
cur_chain_length
fprintf
stderr
mc
hash
table
slots
ld
used
ld
maxchain
ld
n
long
HASH_TABLE_SIZE
hash_slots_used
max_chain_length
return
else
extern
void
libdwarf_an_unused_function_so_not_empty_c_file
void
endif
WANT_LIBBDWARF_MALLOC_CHECK
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
Typed
in
from
the
SystemV
Application
Binary
Interface
but
using
char
arrays
instead
of
variables
as
for
reading
we
don
t
need
the
struct
members
to
be
variables
This
simplifies
configure
https
www
uclibc
org
docs
elf
gen
pdf
used
as
source
of
Elf64
fields
It
is
expected
code
including
this
will
have
included
an
official
elf
h
for
various
definitions
needed
before
including
this
The
structs
were
all
officially
defined
so
files
could
be
mapped
in
Fields
are
arranged
so
there
will
not
be
gaps
and
we
need
not
deal
with
alignment
gaps
ifndef
EI_NIDENT
define
EI_NIDENT
endif
ifndef
TYP
define
TYP
n
l
char
n
l
endif
typedef
struct
unsigned
char
e_ident
EI_NIDENT
TYP
e_type
TYP
e_machine
TYP
e_version
TYP
e_entry
TYP
e_phoff
TYP
e_shoff
TYP
e_flags
TYP
e_ehsize
TYP
e_phentsize
TYP
e_phnum
TYP
e_shentsize
TYP
e_shnum
TYP
e_shstrndx
dw_elf32_ehdr
typedef
struct
unsigned
char
e_ident
EI_NIDENT
TYP
e_type
TYP
e_machine
TYP
e_version
TYP
e_entry
TYP
e_phoff
TYP
e_shoff
TYP
e_flags
TYP
e_ehsize
TYP
e_phentsize
TYP
e_phnum
TYP
e_shentsize
TYP
e_shnum
TYP
e_shstrndx
dw_elf64_ehdr
typedef
struct
TYP
p_type
TYP
p_offset
TYP
p_vaddr
TYP
p_paddr
TYP
p_filesz
TYP
p_memsz
TYP
p_flags
TYP
p_align
dw_elf32_phdr
typedef
struct
TYP
p_type
TYP
p_flags
TYP
p_offset
TYP
p_vaddr
TYP
p_paddr
TYP
p_filesz
TYP
p_memsz
TYP
p_align
dw_elf64_phdr
typedef
struct
TYP
sh_name
TYP
sh_type
TYP
sh_flags
TYP
sh_addr
TYP
sh_offset
TYP
sh_size
TYP
sh_link
TYP
sh_info
TYP
sh_addralign
TYP
sh_entsize
dw_elf32_shdr
typedef
struct
TYP
sh_name
TYP
sh_type
TYP
sh_flags
TYP
sh_addr
TYP
sh_offset
TYP
sh_size
TYP
sh_link
TYP
sh_info
TYP
sh_addralign
TYP
sh_entsize
dw_elf64_shdr
typedef
struct
TYP
r_offset
TYP
r_info
dw_elf32_rel
typedef
struct
TYP
r_offset
TYP
r_info
dw_elf64_rel
typedef
struct
TYP
r_offset
TYP
r_info
TYP
r_addend
signed
dw_elf32_rela
typedef
struct
TYP
r_offset
TYP
r_info
TYP
r_addend
signed
dw_elf64_rela
typedef
struct
TYP
st_name
TYP
st_value
TYP
st_size
unsigned
char
st_info
unsigned
char
st_other
TYP
st_shndx
dw_elf32_sym
typedef
struct
TYP
st_name
unsigned
char
st_info
unsigned
char
st_other
TYP
st_shndx
TYP
st_value
TYP
st_size
dw_elf64_sym
typedef
struct
TYP
d_tag
signed
TYP
d_val
Union
in
original
dw_elf32_dyn
typedef
struct
TYP
d_tag
signed
TYP
d_val
Union
in
original
dw_elf64_dyn
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Latest
update
with
DW_AT_ghs_
entries
ifndef
__DWARF_H
define
__DWARF_H
ifdef
__cplusplus
extern
C
endif
dwarf
h
DWARF
debugging
information
values
The
comment
DWARF3
appears
where
there
are
new
entries
from
DWARF3
as
of
DWARF3f
where
there
are
new
entries
as
of
the
November
public
review
document
and
other
comments
apply
where
extension
entries
appear
Extensions
part
of
DWARF4
are
marked
DWARF4
A
few
extension
names
have
omitted
the
vendor
id
See
chapter
Vendor
Extensibility
Please
always
use
a
vendor
id
string
in
extension
names
Vendors
should
use
a
vendor
string
in
names
and
wherever
possible
avoid
duplicating
values
used
by
other
vendor
extensions
The
DWARF1
comments
indicate
values
unused
in
DWARF2
and
later
but
used
or
reserved
in
DWARF1
define
DW_TAG_array_type
define
DW_TAG_class_type
define
DW_TAG_entry_point
define
DW_TAG_enumeration_type
define
DW_TAG_formal_parameter
TAG_global_subroutine
DWARF1
only
TAG_global_variable
DWARF1
only
define
DW_TAG_imported_declaration
reserved
by
DWARF1
DWARF1
only
define
DW_TAG_label
define
DW_TAG_lexical_block
TAG_local_variable
DWARF1
only
define
DW_TAG_member
reserved
by
DWARF1
DWARF1
only
define
DW_TAG_pointer_type
define
DW_TAG_reference_type
define
DW_TAG_compile_unit
define
DW_TAG_string_type
define
DW_TAG_structure_type
TAG_subroutine
DWARF1
only
define
DW_TAG_subroutine_type
define
DW_TAG_typedef
define
DW_TAG_union_type
define
DW_TAG_unspecified_parameters
define
DW_TAG_variant
define
DW_TAG_common_block
define
DW_TAG_common_inclusion
define
DW_TAG_inheritance
define
DW_TAG_inlined_subroutine
define
DW_TAG_module
define
DW_TAG_ptr_to_member_type
define
DW_TAG_set_type
define
DW_TAG_subrange_type
define
DW_TAG_with_stmt
define
DW_TAG_access_declaration
define
DW_TAG_base_type
define
DW_TAG_catch_block
define
DW_TAG_const_type
define
DW_TAG_constant
define
DW_TAG_enumerator
define
DW_TAG_file_type
define
DW_TAG_friend
define
DW_TAG_namelist
Early
releases
of
this
header
had
the
following
misspelled
with
a
trailing
s
define
DW_TAG_namelist_item
DWARF3
spelling
define
DW_TAG_namelist_items
SGI
misspelling
typo
define
DW_TAG_packed_type
define
DW_TAG_subprogram
The
DWARF2
document
had
two
spellings
of
the
following
two
TAGs
DWARF3
specifies
the
longer
spelling
define
DW_TAG_template_type_parameter
DWARF3
spelling
define
DW_TAG_template_type_param
DWARF2
spelling
define
DW_TAG_template_value_parameter
DWARF3
spelling
define
DW_TAG_template_value_param
DWARF2
spelling
define
DW_TAG_thrown_type
define
DW_TAG_try_block
define
DW_TAG_variant_part
define
DW_TAG_variable
define
DW_TAG_volatile_type
define
DW_TAG_dwarf_procedure
DWARF3
define
DW_TAG_restrict_type
DWARF3
define
DW_TAG_interface_type
DWARF3
define
DW_TAG_namespace
DWARF3
define
DW_TAG_imported_module
DWARF3
define
DW_TAG_unspecified_type
DWARF3
define
DW_TAG_partial_unit
DWARF3
define
DW_TAG_imported_unit
DWARF3
Do
not
use
DW_TAG_mutable_type
define
DW_TAG_mutable_type
Withdrawn
from
DWARF3
by
DWARF3f
define
DW_TAG_condition
DWARF3f
define
DW_TAG_shared_type
DWARF3f
define
DW_TAG_type_unit
DWARF4
define
DW_TAG_rvalue_reference_type
DWARF4
define
DW_TAG_template_alias
DWARF4
define
DW_TAG_coarray_type
DWARF5
define
DW_TAG_generic_subrange
DWARF5
define
DW_TAG_dynamic_type
DWARF5
define
DW_TAG_atomic_type
DWARF5
define
DW_TAG_call_site
DWARF5
define
DW_TAG_call_site_parameter
DWARF5
define
DW_TAG_skeleton_unit
DWARF5
define
DW_TAG_immutable_type
DWARF5
define
DW_TAG_lo_user
define
DW_TAG_MIPS_loop
HP
extensions
ftp
ftp
hp
com
pub
lang
tools
WDB
wdb
tar
gz
define
DW_TAG_HP_array_descriptor
HP
GNU
extensions
The
first
missing
the
GNU_
define
DW_TAG_format_label
GNU
Fortran
define
DW_TAG_function_template
GNU
For
C
define
DW_TAG_class_template
GNU
For
C
define
DW_TAG_GNU_BINCL
GNU
define
DW_TAG_GNU_EINCL
GNU
GNU
extension
http
gcc
gnu
org
wiki
TemplateParmsDwarf
define
DW_TAG_GNU_template_template_parameter
GNU
define
DW_TAG_GNU_template_template_param
GNU
define
DW_TAG_GNU_template_parameter_pack
GNU
define
DW_TAG_GNU_formal_parameter_pack
GNU
define
DW_TAG_GNU_call_site
GNU
define
DW_TAG_GNU_call_site_parameter
GNU
ALTIUM
extensions
DSP
C
Starcore
__circ
qualifier
define
DW_TAG_ALTIUM_circ_type
ALTIUM
Starcore
__mwa_circ
qualifier
define
DW_TAG_ALTIUM_mwa_circ_type
ALTIUM
Starcore
__rev_carry
qualifier
define
DW_TAG_ALTIUM_rev_carry_type
ALTIUM
M16
__rom
qualifier
define
DW_TAG_ALTIUM_rom
ALTIUM
The
following
are
extensions
to
support
UPC
define
DW_TAG_upc_shared_type
UPC
define
DW_TAG_upc_strict_type
UPC
define
DW_TAG_upc_relaxed_type
UPC
The
following
are
SUN
extensions
define
DW_TAG_SUN_function_template
SUN
define
DW_TAG_SUN_class_template
SUN
define
DW_TAG_SUN_struct_template
SUN
define
DW_TAG_SUN_union_template
SUN
define
DW_TAG_SUN_indirect_inheritance
SUN
define
DW_TAG_SUN_codeflags
SUN
define
DW_TAG_SUN_memop_info
SUN
define
DW_TAG_SUN_omp_child_func
SUN
define
DW_TAG_SUN_rtti_descriptor
SUN
define
DW_TAG_SUN_dtor_info
SUN
define
DW_TAG_SUN_dtor
SUN
define
DW_TAG_SUN_f90_interface
SUN
define
DW_TAG_SUN_fortran_vax_structure
SUN
define
DW_TAG_SUN_hi
SUN
GHS
C
define
DW_TAG_ghs_namespace
define
DW_TAG_ghs_using_namespace
define
DW_TAG_ghs_using_declaration
define
DW_TAG_ghs_template_templ_param
PGI
STMicroelectronics
extensions
define
DW_TAG_PGI_kanji_type
PGI
define
DW_TAG_PGI_interface_block
PGI
define
DW_TAG_BORLAND_property
define
DW_TAG_BORLAND_Delphi_string
define
DW_TAG_BORLAND_Delphi_dynamic_array
define
DW_TAG_BORLAND_Delphi_set
define
DW_TAG_BORLAND_Delphi_variant
define
DW_TAG_hi_user
The
following
two
are
non
standard
Use
DW_CHILDREN_yes
and
DW_CHILDREN_no
instead
These
could
probably
be
deleted
but
someone
might
be
using
them
so
they
remain
define
DW_children_no
define
DW_children_yes
define
DW_FORM_addr
FORM_REF
DWARF1
only
define
DW_FORM_block2
define
DW_FORM_block4
define
DW_FORM_data2
define
DW_FORM_data4
define
DW_FORM_data8
define
DW_FORM_string
define
DW_FORM_block
define
DW_FORM_block1
define
DW_FORM_data1
define
DW_FORM_flag
define
DW_FORM_sdata
define
DW_FORM_strp
define
DW_FORM_udata
define
DW_FORM_ref_addr
define
DW_FORM_ref1
define
DW_FORM_ref2
define
DW_FORM_ref4
define
DW_FORM_ref8
define
DW_FORM_ref_udata
define
DW_FORM_indirect
define
DW_FORM_sec_offset
DWARF4
define
DW_FORM_exprloc
DWARF4
define
DW_FORM_flag_present
DWARF4
define
DW_FORM_strx
DWARF5
define
DW_FORM_addrx
DWARF5
define
DW_FORM_ref_sup4
DWARF5
define
DW_FORM_strp_sup
DWARF5
define
DW_FORM_data16
DWARF5
define
DW_FORM_line_strp
DWARF5
define
DW_FORM_ref_sig8
DWARF4
define
DW_FORM_implicit_const
DWARF5
define
DW_FORM_loclistx
DWARF5
define
DW_FORM_rnglistx
DWARF5
define
DW_FORM_ref_sup8
DWARF5
define
DW_FORM_strx1
DWARF5
define
DW_FORM_strx2
DWARF5
define
DW_FORM_strx3
DWARF5
define
DW_FORM_strx4
DWARF5
define
DW_FORM_addrx1
DWARF5
define
DW_FORM_addrx2
DWARF5
define
DW_FORM_addrx3
DWARF5
define
DW_FORM_addrx4
DWARF5
Extensions
http
gcc
gnu
org
wiki
DebugFission
define
DW_FORM_GNU_addr_index
GNU
debug_info
dwo
GNU
somewhat
like
DW_FORM_strp
define
DW_FORM_GNU_str_index
define
DW_FORM_GNU_ref_alt
GNU
Offset
in
debug_info
GNU
extension
Offset
in
debug_str
of
another
object
file
define
DW_FORM_GNU_strp_alt
define
DW_AT_sibling
define
DW_AT_location
define
DW_AT_name
reserved
DWARF1
DWARF1
only
AT_fund_type
DWARF1
only
AT_mod_fund_type
DWARF1
only
AT_user_def_type
DWARF1
only
AT_mod_u_d_type
DWARF1
only
define
DW_AT_ordering
define
DW_AT_subscr_data
define
DW_AT_byte_size
define
DW_AT_bit_offset
define
DW_AT_bit_size
reserved
DWARF1
DWARF1
only
define
DW_AT_element_list
define
DW_AT_stmt_list
define
DW_AT_low_pc
define
DW_AT_high_pc
define
DW_AT_language
define
DW_AT_member
define
DW_AT_discr
define
DW_AT_discr_value
define
DW_AT_visibility
define
DW_AT_import
define
DW_AT_string_length
define
DW_AT_common_reference
define
DW_AT_comp_dir
define
DW_AT_const_value
define
DW_AT_containing_type
define
DW_AT_default_value
reserved
define
DW_AT_inline
define
DW_AT_is_optional
define
DW_AT_lower_bound
reserved
reserved
define
DW_AT_producer
reserved
define
DW_AT_prototyped
reserved
reserved
define
DW_AT_return_addr
reserved
define
DW_AT_start_scope
reserved
define
DW_AT_bit_stride
DWARF3
name
define
DW_AT_stride_size
DWARF2
name
define
DW_AT_upper_bound
AT_virtual
DWARF1
only
define
DW_AT_abstract_origin
define
DW_AT_accessibility
define
DW_AT_address_class
define
DW_AT_artificial
define
DW_AT_base_types
define
DW_AT_calling_convention
define
DW_AT_count
define
DW_AT_data_member_location
define
DW_AT_decl_column
define
DW_AT_decl_file
define
DW_AT_decl_line
define
DW_AT_declaration
define
DW_AT_discr_list
DWARF2
define
DW_AT_encoding
define
DW_AT_external
define
DW_AT_frame_base
define
DW_AT_friend
define
DW_AT_identifier_case
define
DW_AT_macro_info
DWARF
not
DWARF5
define
DW_AT_namelist_item
define
DW_AT_priority
define
DW_AT_segment
define
DW_AT_specification
define
DW_AT_static_link
define
DW_AT_type
define
DW_AT_use_location
define
DW_AT_variable_parameter
define
DW_AT_virtuality
define
DW_AT_vtable_elem_location
define
DW_AT_allocated
DWARF3
define
DW_AT_associated
DWARF3
define
DW_AT_data_location
DWARF3
define
DW_AT_byte_stride
DWARF3f
define
DW_AT_stride
DWARF3
do
not
use
define
DW_AT_entry_pc
DWARF3
define
DW_AT_use_UTF8
DWARF3
define
DW_AT_extension
DWARF3
define
DW_AT_ranges
DWARF3
define
DW_AT_trampoline
DWARF3
define
DW_AT_call_column
DWARF3
define
DW_AT_call_file
DWARF3
define
DW_AT_call_line
DWARF3
define
DW_AT_description
DWARF3
define
DW_AT_binary_scale
DWARF3f
define
DW_AT_decimal_scale
DWARF3f
define
DW_AT_small
DWARF3f
define
DW_AT_decimal_sign
DWARF3f
define
DW_AT_digit_count
DWARF3f
define
DW_AT_picture_string
DWARF3f
define
DW_AT_mutable
DWARF3f
define
DW_AT_threads_scaled
DWARF3f
define
DW_AT_explicit
DWARF3f
define
DW_AT_object_pointer
DWARF3f
define
DW_AT_endianity
DWARF3f
define
DW_AT_elemental
DWARF3f
define
DW_AT_pure
DWARF3f
define
DW_AT_recursive
DWARF3f
define
DW_AT_signature
DWARF4
define
DW_AT_main_subprogram
DWARF4
define
DW_AT_data_bit_offset
DWARF4
define
DW_AT_const_expr
DWARF4
define
DW_AT_enum_class
DWARF4
define
DW_AT_linkage_name
DWARF4
define
DW_AT_string_length_bit_size
DWARF5
define
DW_AT_string_length_byte_size
DWARF5
define
DW_AT_rank
DWARF5
define
DW_AT_str_offsets_base
DWARF5
define
DW_AT_addr_base
DWARF5
Use
DW_AT_rnglists_base
DW_AT_ranges_base
is
obsolete
as
it
was
only
used
in
some
DWARF5
drafts
not
the
final
DWARF5
define
DW_AT_rnglists_base
DWARF5
DW_AT_dwo_id
an
experiment
in
some
DWARF4
Not
DWARF5
define
DW_AT_dwo_id
DWARF4
define
DW_AT_dwo_name
DWARF5
define
DW_AT_reference
DWARF5
define
DW_AT_rvalue_reference
DWARF5
define
DW_AT_macros
DWARF5
define
DW_AT_call_all_calls
DWARF5
define
DW_AT_call_all_source_calls
DWARF5
define
DW_AT_call_all_tail_calls
DWARF5
define
DW_AT_call_return_pc
DWARF5
define
DW_AT_call_value
DWARF5
define
DW_AT_call_origin
DWARF5
define
DW_AT_call_parameter
DWARF5
define
DW_AT_call_pc
DWARF5
define
DW_AT_call_tail_call
DWARF5
define
DW_AT_call_target
DWARF5
define
DW_AT_call_target_clobbered
DWARF5
define
DW_AT_call_data_location
DWARF5
define
DW_AT_call_data_value
DWARF5
define
DW_AT_noreturn
DWARF5
define
DW_AT_alignment
DWARF5
define
DW_AT_export_symbols
DWARF5
define
DW_AT_deleted
DWARF5
define
DW_AT_defaulted
DWARF5
define
DW_AT_loclists_base
DWARF5
GreenHills
ghs
com
GHS
C
define
DW_AT_ghs_namespace_alias
define
DW_AT_ghs_using_namespace
define
DW_AT_ghs_using_declaration
In
extensions
we
attempt
to
include
the
vendor
extension
in
the
name
even
when
the
vendor
leaves
it
out
HP
extensions
define
DW_AT_HP_block_index
HP
Follows
extension
so
dwarfdump
prints
the
most
likely
useful
name
define
DW_AT_lo_user
define
DW_AT_MIPS_fde
MIPS
SGI
define
DW_AT_MIPS_loop_begin
MIPS
SGI
define
DW_AT_MIPS_tail_loop_begin
MIPS
SGI
define
DW_AT_MIPS_epilog_begin
MIPS
SGI
define
DW_AT_MIPS_loop_unroll_factor
MIPS
SGI
define
DW_AT_MIPS_software_pipeline_depth
MIPS
SGI
define
DW_AT_MIPS_linkage_name
MIPS
SGI
GNU
and
others
define
DW_AT_MIPS_stride
MIPS
SGI
define
DW_AT_MIPS_abstract_name
MIPS
SGI
define
DW_AT_MIPS_clone_origin
MIPS
SGI
define
DW_AT_MIPS_has_inlines
MIPS
SGI
define
DW_AT_MIPS_stride_byte
MIPS
SGI
define
DW_AT_MIPS_stride_elem
MIPS
SGI
define
DW_AT_MIPS_ptr_dopetype
MIPS
SGI
define
DW_AT_MIPS_allocatable_dopetype
MIPS
SGI
define
DW_AT_MIPS_assumed_shape_dopetype
MIPS
SGI
define
DW_AT_MIPS_assumed_size
MIPS
SGI
HP
extensions
define
DW_AT_HP_unmodifiable
conflict
MIPS
define
DW_AT_HP_prologue
conflict
MIPS
define
DW_AT_HP_epilogue
conflict
MIPS
define
DW_AT_HP_actuals_stmt_list
conflict
MIPS
define
DW_AT_HP_proc_per_section
conflict
MIPS
define
DW_AT_HP_raw_data_ptr
HP
define
DW_AT_HP_pass_by_reference
HP
define
DW_AT_HP_opt_level
HP
define
DW_AT_HP_prof_version_id
HP
define
DW_AT_HP_opt_flags
HP
define
DW_AT_HP_cold_region_low_pc
HP
define
DW_AT_HP_cold_region_high_pc
HP
define
DW_AT_HP_all_variables_modifiable
HP
define
DW_AT_HP_linkage_name
HP
define
DW_AT_HP_prof_flags
HP
define
DW_AT_HP_unit_name
define
DW_AT_HP_unit_size
define
DW_AT_HP_widened_byte_size
define
DW_AT_HP_definition_points
define
DW_AT_HP_default_location
define
DW_AT_HP_is_result_param
define
DW_AT_CPQ_discontig_ranges
COMPAQ
HP
define
DW_AT_CPQ_semantic_events
COMPAQ
HP
define
DW_AT_CPQ_split_lifetimes_var
COMPAQ
HP
define
DW_AT_CPQ_split_lifetimes_rtn
COMPAQ
HP
define
DW_AT_CPQ_prologue_length
COMPAQ
HP
From
GHS
C
GreenHills
ghs
com
define
DW_AT_ghs_mangled
conflict
MIPS
define
DW_AT_ghs_rsm
define
DW_AT_ghs_frsm
define
DW_AT_ghs_frames
define
DW_AT_ghs_rso
define
DW_AT_ghs_subcpu
define
DW_AT_ghs_lbrace_line
define
DW_AT_INTEL_other_endian
Intel
if
byte
swapped
GNU
extensions
define
DW_AT_sf_names
GNU
define
DW_AT_src_info
GNU
define
DW_AT_mac_info
GNU
define
DW_AT_src_coords
GNU
define
DW_AT_body_begin
GNU
define
DW_AT_body_end
GNU
define
DW_AT_GNU_vector
GNU
Thread
safety
see
http
gcc
gnu
org
wiki
ThreadSafetyAnnotation
The
values
here
are
from
gcc
include
dwarf2
h
The
values
are
not
given
on
the
web
page
at
all
nor
on
web
pages
it
refers
to
define
DW_AT_GNU_guarded_by
GNU
define
DW_AT_GNU_pt_guarded_by
GNU
define
DW_AT_GNU_guarded
GNU
define
DW_AT_GNU_pt_guarded
GNU
define
DW_AT_GNU_locks_excluded
GNU
define
DW_AT_GNU_exclusive_locks_required
GNU
define
DW_AT_GNU_shared_locks_required
GNU
See
http
gcc
gnu
org
wiki
DwarfSeparateTypeInfo
define
DW_AT_GNU_odr_signature
GNU
See
See
http
gcc
gnu
org
wiki
TemplateParmsDwarf
The
value
here
is
from
gcc
include
dwarf2
h
The
value
is
not
consistent
with
the
web
page
as
of
December
define
DW_AT_GNU_template_name
GNU
The
GNU
call
site
extension
See
http
www
dwarfstd
org
ShowIssue
php?
issue
open
define
DW_AT_GNU_call_site_value
GNU
define
DW_AT_GNU_call_site_data_value
GNU
define
DW_AT_GNU_call_site_target
GNU
define
DW_AT_GNU_call_site_target_clobbered
GNU
define
DW_AT_GNU_tail_call
GNU
define
DW_AT_GNU_all_tail_call_sites
GNU
define
DW_AT_GNU_all_call_sites
GNU
define
DW_AT_GNU_all_source_call_sites
GNU
Section
offset
to
debug_macro
section
define
DW_AT_GNU_macros
GNU
define
DW_AT_GNU_deleted
GNU
The
GNU
DebugFission
project
http
gcc
gnu
org
wiki
DebugFission
define
DW_AT_GNU_dwo_name
GNU
define
DW_AT_GNU_dwo_id
GNU
define
DW_AT_GNU_ranges_base
GNU
define
DW_AT_GNU_addr_base
GNU
define
DW_AT_GNU_pubnames
GNU
define
DW_AT_GNU_pubtypes
GNU
To
distinguish
distinct
basic
blocks
in
a
single
source
line
define
DW_AT_GNU_discriminator
GNU
define
DW_AT_GNU_locviews
GNU
define
DW_AT_GNU_entry_view
GNU
See
https
gcc
gnu
org
wiki
DW_AT_GNU_bias
define
DW_AT_GNU_bias
Sun
extensions
define
DW_AT_SUN_template
SUN
define
DW_AT_VMS_rtnbeg_pd_address
VMS
define
DW_AT_SUN_alignment
SUN
define
DW_AT_SUN_vtable
SUN
define
DW_AT_SUN_count_guarantee
SUN
define
DW_AT_SUN_command_line
SUN
define
DW_AT_SUN_vbase
SUN
define
DW_AT_SUN_compile_options
SUN
define
DW_AT_SUN_language
SUN
define
DW_AT_SUN_browser_file
SUN
define
DW_AT_SUN_vtable_abi
SUN
define
DW_AT_SUN_func_offsets
SUN
define
DW_AT_SUN_cf_kind
SUN
define
DW_AT_SUN_vtable_index
SUN
define
DW_AT_SUN_omp_tpriv_addr
SUN
define
DW_AT_SUN_omp_child_func
SUN
define
DW_AT_SUN_func_offset
SUN
define
DW_AT_SUN_memop_type_ref
SUN
define
DW_AT_SUN_profile_id
SUN
define
DW_AT_SUN_memop_signature
SUN
define
DW_AT_SUN_obj_dir
SUN
define
DW_AT_SUN_obj_file
SUN
define
DW_AT_SUN_original_name
SUN
define
DW_AT_SUN_hwcprof_signature
SUN
define
DW_AT_SUN_amd64_parmdump
SUN
define
DW_AT_SUN_part_link_name
SUN
define
DW_AT_SUN_link_name
SUN
define
DW_AT_SUN_pass_with_const
SUN
define
DW_AT_SUN_return_with_const
SUN
define
DW_AT_SUN_import_by_name
SUN
define
DW_AT_SUN_f90_pointer
SUN
define
DW_AT_SUN_pass_by_ref
SUN
define
DW_AT_SUN_f90_allocatable
SUN
define
DW_AT_SUN_f90_assumed_shape_array
SUN
define
DW_AT_SUN_c_vla
SUN
define
DW_AT_SUN_return_value_ptr
SUN
define
DW_AT_SUN_dtor_start
SUN
define
DW_AT_SUN_dtor_length
SUN
define
DW_AT_SUN_dtor_state_initial
SUN
define
DW_AT_SUN_dtor_state_final
SUN
define
DW_AT_SUN_dtor_state_deltas
SUN
define
DW_AT_SUN_import_by_lname
SUN
define
DW_AT_SUN_f90_use_only
SUN
define
DW_AT_SUN_namelist_spec
SUN
define
DW_AT_SUN_is_omp_child_func
SUN
define
DW_AT_SUN_fortran_main_alias
SUN
define
DW_AT_SUN_fortran_based
SUN
ALTIUM
extension
ALTIUM
Compliant
location
lists
flag
define
DW_AT_ALTIUM_loclist
ALTIUM
Ada
GNAT
gcc
attributes
constant
integer
forms
See
http
gcc
gnu
org
wiki
DW_AT_GNAT_descriptive_type
define
DW_AT_use_GNAT_descriptive_type
define
DW_AT_GNAT_descriptive_type
define
DW_AT_GNU_numerator
GNU
define
DW_AT_GNU_denominator
GNU
See
https
gcc
gnu
org
wiki
DW_AT_GNU_bias
define
DW_AT_GNU_bias
GNU
Go
specific
type
attributes
Naming
as
lower
case
go
instead
of
GO
is
a
small
mistake
by
the
Go
language
folks
it
seems
This
is
the
common
spelling
for
these
define
DW_AT_go_kind
define
DW_AT_go_key
define
DW_AT_go_elem
Attribute
for
DW_TAG_member
of
a
struct
type
Nonzero
value
indicates
the
struct
field
is
an
embedded
field
define
DW_AT_go_embedded_field
define
DW_AT_go_runtime_type
UPC
extension
define
DW_AT_upc_threads_scaled
UPC
define
DW_AT_IBM_wsa_addr
define
DW_AT_IBM_home_location
define
DW_AT_IBM_alt_srcview
PGI
STMicroelectronics
extensions
PGI
Block
constant
reference
This
attribute
is
an
ASTPLAB
extension
used
to
describe
the
array
local
base
define
DW_AT_PGI_lbase
PGI
Block
constant
reference
ASTPLAB
adds
this
attribute
to
describe
the
section
offset
or
the
offset
to
the
first
element
in
the
dimension
define
DW_AT_PGI_soffset
PGI
Block
constant
reference
ASTPLAB
adds
this
attribute
to
describe
the
linear
stride
or
the
distance
between
elements
in
the
dimension
define
DW_AT_PGI_lstride
define
DW_AT_BORLAND_property_read
define
DW_AT_BORLAND_property_write
define
DW_AT_BORLAND_property_implements
define
DW_AT_BORLAND_property_index
define
DW_AT_BORLAND_property_default
define
DW_AT_BORLAND_Delphi_unit
define
DW_AT_BORLAND_Delphi_class
define
DW_AT_BORLAND_Delphi_record
define
DW_AT_BORLAND_Delphi_metaclass
define
DW_AT_BORLAND_Delphi_constructor
define
DW_AT_BORLAND_Delphi_destructor
define
DW_AT_BORLAND_Delphi_anonymous_method
define
DW_AT_BORLAND_Delphi_interface
define
DW_AT_BORLAND_Delphi_ABI
define
DW_AT_BORLAND_Delphi_frameptr
define
DW_AT_BORLAND_closure
define
DW_AT_LLVM_include_path
define
DW_AT_LLVM_config_macros
define
DW_AT_LLVM_sysroot
define
DW_AT_LLVM_tag_offset
LLVM
intends
to
use
define
DW_AT_LLVM_apinotes
define
DW_AT_APPLE_optimized
define
DW_AT_APPLE_flags
define
DW_AT_APPLE_isa
Also
known
as
DW_AT_APPLE_closure
block
preferred
define
DW_AT_APPLE_block
The
rest
of
APPLE
here
are
in
support
of
Objective
C
define
DW_AT_APPLE_major_runtime_vers
define
DW_AT_APPLE_runtime_class
define
DW_AT_APPLE_omit_frame_ptr
define
DW_AT_APPLE_property_name
define
DW_AT_APPLE_property_getter
define
DW_AT_APPLE_property_setter
define
DW_AT_APPLE_property_attribute
define
DW_AT_APPLE_objc_complete_type
define
DW_AT_APPLE_property
define
DW_AT_APPLE_objc_direct
define
DW_AT_APPLE_sdk
define
DW_AT_hi_user
OP
values
are
DWARF1
only
define
DW_OP_addr
define
DW_OP_deref
define
DW_OP_const1u
define
DW_OP_const1s
define
DW_OP_const2u
define
DW_OP_const2s
define
DW_OP_const4u
define
DW_OP_const4s
define
DW_OP_const8u
define
DW_OP_const8s
define
DW_OP_constu
define
DW_OP_consts
define
DW_OP_dup
define
DW_OP_drop
define
DW_OP_over
define
DW_OP_pick
define
DW_OP_swap
define
DW_OP_rot
define
DW_OP_xderef
define
DW_OP_abs
define
DW_OP_and
define
DW_OP_div
define
DW_OP_minus
define
DW_OP_mod
define
DW_OP_mul
define
DW_OP_neg
define
DW_OP_not
define
DW_OP_or
define
DW_OP_plus
define
DW_OP_plus_uconst
define
DW_OP_shl
define
DW_OP_shr
define
DW_OP_shra
define
DW_OP_xor
define
DW_OP_bra
define
DW_OP_eq
define
DW_OP_ge
define
DW_OP_gt
define
DW_OP_le
define
DW_OP_lt
define
DW_OP_ne
define
DW_OP_skip
define
DW_OP_lit0
define
DW_OP_lit1
define
DW_OP_lit2
define
DW_OP_lit3
define
DW_OP_lit4
define
DW_OP_lit5
define
DW_OP_lit6
define
DW_OP_lit7
define
DW_OP_lit8
define
DW_OP_lit9
define
DW_OP_lit10
define
DW_OP_lit11
define
DW_OP_lit12
define
DW_OP_lit13
define
DW_OP_lit14
define
DW_OP_lit15
define
DW_OP_lit16
define
DW_OP_lit17
define
DW_OP_lit18
define
DW_OP_lit19
define
DW_OP_lit20
define
DW_OP_lit21
define
DW_OP_lit22
define
DW_OP_lit23
define
DW_OP_lit24
define
DW_OP_lit25
define
DW_OP_lit26
define
DW_OP_lit27
define
DW_OP_lit28
define
DW_OP_lit29
define
DW_OP_lit30
define
DW_OP_lit31
define
DW_OP_reg0
define
DW_OP_reg1
define
DW_OP_reg2
define
DW_OP_reg3
define
DW_OP_reg4
define
DW_OP_reg5
define
DW_OP_reg6
define
DW_OP_reg7
define
DW_OP_reg8
define
DW_OP_reg9
define
DW_OP_reg10
define
DW_OP_reg11
define
DW_OP_reg12
define
DW_OP_reg13
define
DW_OP_reg14
define
DW_OP_reg15
define
DW_OP_reg16
define
DW_OP_reg17
define
DW_OP_reg18
define
DW_OP_reg19
define
DW_OP_reg20
define
DW_OP_reg21
define
DW_OP_reg22
define
DW_OP_reg23
define
DW_OP_reg24
define
DW_OP_reg25
define
DW_OP_reg26
define
DW_OP_reg27
define
DW_OP_reg28
define
DW_OP_reg29
define
DW_OP_reg30
define
DW_OP_reg31
define
DW_OP_breg0
define
DW_OP_breg1
define
DW_OP_breg2
define
DW_OP_breg3
define
DW_OP_breg4
define
DW_OP_breg5
define
DW_OP_breg6
define
DW_OP_breg7
define
DW_OP_breg8
define
DW_OP_breg9
define
DW_OP_breg10
define
DW_OP_breg11
define
DW_OP_breg12
define
DW_OP_breg13
define
DW_OP_breg14
define
DW_OP_breg15
define
DW_OP_breg16
define
DW_OP_breg17
define
DW_OP_breg18
define
DW_OP_breg19
define
DW_OP_breg20
define
DW_OP_breg21
define
DW_OP_breg22
define
DW_OP_breg23
define
DW_OP_breg24
define
DW_OP_breg25
define
DW_OP_breg26
define
DW_OP_breg27
define
DW_OP_breg28
define
DW_OP_breg29
define
DW_OP_breg30
define
DW_OP_breg31
define
DW_OP_regx
define
DW_OP_fbreg
define
DW_OP_bregx
define
DW_OP_piece
define
DW_OP_deref_size
define
DW_OP_xderef_size
define
DW_OP_nop
define
DW_OP_push_object_address
DWARF3
define
DW_OP_call2
DWARF3
define
DW_OP_call4
DWARF3
define
DW_OP_call_ref
DWARF3
define
DW_OP_form_tls_address
DWARF3f
define
DW_OP_call_frame_cfa
DWARF3f
define
DW_OP_bit_piece
DWARF3f
define
DW_OP_implicit_value
DWARF4
define
DW_OP_stack_value
DWARF4
define
DW_OP_implicit_pointer
DWARF5
define
DW_OP_addrx
DWARF5
define
DW_OP_constx
DWARF5
define
DW_OP_entry_value
DWARF5
define
DW_OP_const_type
DWARF5
define
DW_OP_regval_type
DWARF5
define
DW_OP_deref_type
DWARF5
define
DW_OP_xderef_type
DWARF5
define
DW_OP_convert
DWARF5
define
DW_OP_reinterpret
DWARF5
define
DW_OP_GNU_push_tls_address
GNU
define
DW_OP_WASM_location
define
DW_OP_WASM_location_int
Follows
extension
so
dwarfdump
prints
the
most
likely
useful
name
define
DW_OP_lo_user
define
DW_OP_GNU_uninit
GNU
define
DW_OP_GNU_encoded_addr
GNU
define
DW_OP_GNU_implicit_pointer
GNU
define
DW_OP_GNU_entry_value
GNU
define
DW_OP_GNU_const_type
GNU
define
DW_OP_GNU_regval_type
GNU
define
DW_OP_GNU_deref_type
GNU
define
DW_OP_GNU_convert
GNU
define
DW_OP_GNU_reinterpret
GNU
define
DW_OP_GNU_parameter_ref
GNU
define
DW_OP_GNU_addr_index
GNU
Fission
define
DW_OP_GNU_const_index
GNU
Fission
define
DW_OP_GNU_variable_value
GNU
HP
extensions
define
DW_OP_HP_unknown
HP
conflict
GNU
define
DW_OP_HP_is_value
HP
define
DW_OP_HP_fltconst4
HP
define
DW_OP_HP_fltconst8
HP
define
DW_OP_HP_mod_range
HP
define
DW_OP_HP_unmod_range
HP
define
DW_OP_HP_tls
HP
Intel
made
obsolete
by
DW_OP_bit_piece
above
define
DW_OP_INTEL_bit_piece
Apple
extension
define
DW_OP_APPLE_uninit
Apple
define
DW_OP_PGI_omp_thread_num
PGI
STMicroelectronics
define
DW_OP_hi_user
define
DW_ATE_address
define
DW_ATE_boolean
define
DW_ATE_complex_float
define
DW_ATE_float
define
DW_ATE_signed
define
DW_ATE_signed_char
define
DW_ATE_unsigned
define
DW_ATE_unsigned_char
define
DW_ATE_imaginary_float
DWARF3
define
DW_ATE_packed_decimal
DWARF3f
define
DW_ATE_numeric_string
DWARF3f
define
DW_ATE_edited
DWARF3f
define
DW_ATE_signed_fixed
DWARF3f
define
DW_ATE_unsigned_fixed
DWARF3f
define
DW_ATE_decimal_float
DWARF3f
define
DW_ATE_UTF
DWARF4
define
DW_ATE_UCS
DWARF5
define
DW_ATE_ASCII
DWARF5
ALTIUM
extensions
x80
x81
define
DW_ATE_ALTIUM_fract
ALTIUM
__fract
type
Follows
extension
so
dwarfdump
prints
the
most
likely
useful
name
define
DW_ATE_lo_user
Shown
here
to
help
dwarfdump
build
script
define
DW_ATE_ALTIUM_accum
ALTIUM
__accum
type
HP
Floating
point
extensions
define
DW_ATE_HP_float80
bit
HP
define
DW_ATE_HP_complex_float80
Complex
bit
HP
define
DW_ATE_HP_float128
bit
HP
define
DW_ATE_HP_complex_float128
Complex
bit
HP
define
DW_ATE_HP_floathpintel
bit
IA64
HP
define
DW_ATE_HP_imaginary_float80
HP
define
DW_ATE_HP_imaginary_float128
HP
Sun
extensions
define
DW_ATE_SUN_interval_float
Obsolete
See
DW_ATE_imaginary_float
define
DW_ATE_SUN_imaginary_float
define
DW_ATE_hi_user
DWARF5
Defaulted
Member
Encodings
define
DW_DEFAULTED_no
DWARF5
define
DW_DEFAULTED_in_class
DWARF5
define
DW_DEFAULTED_out_of_class
DWARF5
define
DW_IDX_compile_unit
DWARF5
define
DW_IDX_type_unit
DWARF5
define
DW_IDX_die_offset
DWARF5
define
DW_IDX_parent
DWARF5
define
DW_IDX_type_hash
DWARF5
define
DW_IDX_lo_user
DWARF5
define
DW_IDX_hi_user
DWARF5
These
with
not
quite
the
same
names
were
used
in
DWARF4
We
call
then
DW_LLEX
Never
official
and
should
not
be
used
by
anyone
define
DW_LLEX_end_of_list_entry
define
DW_LLEX_base_address_selection_entry
define
DW_LLEX_start_end_entry
define
DW_LLEX_start_length_entry
define
DW_LLEX_offset_pair_entry
DWARF5
Location
List
Entries
in
Split
Objects
define
DW_LLE_end_of_list
DWARF5
define
DW_LLE_base_addressx
DWARF5
define
DW_LLE_startx_endx
DWARF5
define
DW_LLE_startx_length
DWARF5
define
DW_LLE_offset_pair
DWARF5
define
DW_LLE_default_location
DWARF5
define
DW_LLE_base_address
DWARF5
define
DW_LLE_start_end
DWARF5
define
DW_LLE_start_length
DWARF5
DWARF5
Range
List
Entries
define
DW_RLE_end_of_list
DWARF5
define
DW_RLE_base_addressx
DWARF5
define
DW_RLE_startx_endx
DWARF5
define
DW_RLE_startx_length
DWARF5
define
DW_RLE_offset_pair
DWARF5
define
DW_RLE_base_address
DWARF5
define
DW_RLE_start_end
DWARF5
define
DW_RLE_start_length
DWARF5
GNUIndex
encodings
non
standard
New
in
used
in
debug_gnu_pubnames
debug_gnu_pubtypes
but
no
spellings
provided
in
documentation
define
DW_GNUIVIS_global
define
DW_GNUIVIS_static
GNUIndex
encodings
non
standard
New
in
used
in
debug_gnu_pubnames
debug_gnu_pubtypes
but
no
spellings
provided
in
documentation
define
DW_GNUIKIND_none
define
DW_GNUIKIND_type
define
DW_GNUIKIND_variable
define
DW_GNUIKIND_function
define
DW_GNUIKIND_other
DWARF5
Unit
header
unit
type
encodings
define
DW_UT_compile
DWARF5
define
DW_UT_type
DWARF5
define
DW_UT_partial
DWARF5
define
DW_UT_skeleton
DWARF5
define
DW_UT_split_compile
DWARF5
define
DW_UT_split_type
DWARF5
define
DW_UT_lo_user
DWARF5
define
DW_UT_hi_user
DWARF5
DWARF5
DebugFission
object
section
id
values
for
dwp
object
section
offsets
hash
table
is
reserved
not
used
is
actually
reserved
not
used
in
DWARF5
But
may
be
seen
in
some
DWARF4
objects
define
DW_SECT_INFO
debug_info
dwo
DWARF5
define
DW_SECT_TYPES
debug_types
dwo
pre
DWARF5
define
DW_SECT_ABBREV
debug_abbrev
dwo
DWARF5
define
DW_SECT_LINE
debug_line
dwo
DWARF5
define
DW_SECT_LOCLISTS
debug_loclists
dwo
DWARF5
define
DW_SECT_STR_OFFSETS
debug_str_offsets
dwo
DWARF5
define
DW_SECT_MACRO
debug_macro
dwo
DWARF5
define
DW_SECT_RNGLISTS
debug_rnglists
dwo
DWARF5
Decimal
Sign
codes
define
DW_DS_unsigned
DWARF3f
define
DW_DS_leading_overpunch
DWARF3f
define
DW_DS_trailing_overpunch
DWARF3f
define
DW_DS_leading_separate
DWARF3f
define
DW_DS_trailing_separate
DWARF3f
Endian
code
name
define
DW_END_default
DWARF3f
define
DW_END_big
DWARF3f
define
DW_END_little
DWARF3f
define
DW_END_lo_user
DWARF3f
define
DW_END_hi_user
DWARF3f
For
use
with
DW_TAG_SUN_codeflags
If
DW_TAG_SUN_codeflags
is
accepted
as
a
dwarf
standard
then
standard
dwarf
ATCF
entries
start
at
define
DW_ATCF_lo_user
SUN
define
DW_ATCF_SUN_mop_bitfield
SUN
define
DW_ATCF_SUN_mop_spill
SUN
define
DW_ATCF_SUN_mop_scopy
SUN
define
DW_ATCF_SUN_func_start
SUN
define
DW_ATCF_SUN_end_ctors
SUN
define
DW_ATCF_SUN_branch_target
SUN
define
DW_ATCF_SUN_mop_stack_probe
SUN
define
DW_ATCF_SUN_func_epilog
SUN
define
DW_ATCF_hi_user
SUN
Accessibility
code
name
define
DW_ACCESS_public
define
DW_ACCESS_protected
define
DW_ACCESS_private
Visibility
code
name
define
DW_VIS_local
define
DW_VIS_exported
define
DW_VIS_qualified
Virtuality
code
name
define
DW_VIRTUALITY_none
define
DW_VIRTUALITY_virtual
define
DW_VIRTUALITY_pure_virtual
define
DW_LANG_C89
define
DW_LANG_C
define
DW_LANG_Ada83
define
DW_LANG_C_plus_plus
define
DW_LANG_Cobol74
define
DW_LANG_Cobol85
define
DW_LANG_Fortran77
define
DW_LANG_Fortran90
define
DW_LANG_Pascal83
define
DW_LANG_Modula2
define
DW_LANG_Java
DWARF3
define
DW_LANG_C99
DWARF3
define
DW_LANG_Ada95
DWARF3
define
DW_LANG_Fortran95
DWARF3
define
DW_LANG_PLI
DWARF3
define
DW_LANG_ObjC
DWARF3f
define
DW_LANG_ObjC_plus_plus
DWARF3f
define
DW_LANG_UPC
DWARF3f
define
DW_LANG_D
DWARF3f
define
DW_LANG_Python
DWARF4
The
following
are
not
yet
formally
approved
October
but
it
seems
extremely
likely
they
will
be
approved
as
the
committee
chair
agrees
these
should
be
ok
and
no
one
on
the
committee
has
objected
define
DW_LANG_OpenCL
DWARF5
define
DW_LANG_Go
DWARF5
define
DW_LANG_Modula3
DWARF5
define
DW_LANG_Haskel
DWARF5
define
DW_LANG_C_plus_plus_03
DWARF5
define
DW_LANG_C_plus_plus_11
DWARF5
define
DW_LANG_OCaml
DWARF5
define
DW_LANG_Rust
DWARF5
define
DW_LANG_C11
DWARF5
define
DW_LANG_Swift
DWARF5
define
DW_LANG_Julia
DWARF5
define
DW_LANG_Dylan
DWARF5
define
DW_LANG_C_plus_plus_14
DWARF5
define
DW_LANG_Fortran03
DWARF5
define
DW_LANG_Fortran08
DWARF5
define
DW_LANG_RenderScript
DWARF5
define
DW_LANG_BLISS
DWARF5
define
DW_LANG_lo_user
define
DW_LANG_Mips_Assembler
MIPS
define
DW_LANG_Upc
UPC
use
DW_LANG_UPC
instead
ALTIUM
extension
define
DW_LANG_ALTIUM_Assembler
ALTIUM
Sun
extensions
define
DW_LANG_SUN_Assembler
SUN
define
DW_LANG_hi_user
Identifier
case
name
define
DW_ID_case_sensitive
define
DW_ID_up_case
define
DW_ID_down_case
define
DW_ID_case_insensitive
Calling
Convention
Name
define
DW_CC_normal
define
DW_CC_program
define
DW_CC_nocall
define
DW_CC_pass_by_reference
DWARF5
define
DW_CC_pass_by_value
DWARF5
define
DW_CC_lo_user
define
DW_CC_GNU_renesas_sh
GNU
define
DW_CC_GNU_borland_fastcall_i386
GNU
ALTIUM
extensions
Function
is
an
interrupt
handler
return
address
on
system
stack
define
DW_CC_ALTIUM_interrupt
ALTIUM
Near
function
model
return
address
on
system
stack
define
DW_CC_ALTIUM_near_system_stack
ALTIUM
Near
function
model
return
address
on
user
stack
define
DW_CC_ALTIUM_near_user_stack
ALTIUM
Huge
function
model
return
address
on
user
stack
define
DW_CC_ALTIUM_huge_user_stack
ALTIUM
define
DW_CC_GNU_BORLAND_safecall
define
DW_CC_GNU_BORLAND_stdcall
define
DW_CC_GNU_BORLAND_pascal
define
DW_CC_GNU_BORLAND_msfastcall
define
DW_CC_GNU_BORLAND_msreturn
define
DW_CC_GNU_BORLAND_thiscall
define
DW_CC_GNU_BORLAND_fastcall
define
DW_CC_LLVM_vectorcall
define
DW_CC_LLVM_Win64
define
DW_CC_LLVM_X86_64SysV
define
DW_CC_LLVM_AAPCS
define
DW_CC_LLVM_AAPCS_VFP
define
DW_CC_LLVM_IntelOclBicc
define
DW_CC_LLVM_SpirFunction
define
DW_CC_LLVM_OpenCLKernel
define
DW_CC_LLVM_Swift
define
DW_CC_LLVM_PreserveMost
define
DW_CC_LLVM_PreserveAll
define
DW_CC_LLVM_X86RegCall
define
DW_CC_GDB_IBM_OpenCL
define
DW_CC_hi_user
Inline
Code
Name
define
DW_INL_not_inlined
define
DW_INL_inlined
define
DW_INL_declared_not_inlined
define
DW_INL_declared_inlined
Ordering
Name
define
DW_ORD_row_major
define
DW_ORD_col_major
Discriminant
Descriptor
Name
define
DW_DSC_label
define
DW_DSC_range
Line
number
header
entry
format
encodings
DWARF5
define
DW_LNCT_path
DWARF5
define
DW_LNCT_directory_index
DWARF5
define
DW_LNCT_timestamp
DWARF5
define
DW_LNCT_size
DWARF5
define
DW_LNCT_MD5
DWARF5
Experimental
two
level
line
tables
Non
standard
define
DW_LNCT_GNU_subprogram_name
define
DW_LNCT_GNU_decl_file
define
DW_LNCT_GNU_decl_line
define
DW_LNCT_lo_user
DWARF5
define
DW_LNCT_LLVM_source
define
DW_LNCT_hi_user
DWARF5
Line
number
standard
opcode
name
define
DW_LNS_copy
define
DW_LNS_advance_pc
define
DW_LNS_advance_line
define
DW_LNS_set_file
define
DW_LNS_set_column
define
DW_LNS_negate_stmt
define
DW_LNS_set_basic_block
define
DW_LNS_const_add_pc
define
DW_LNS_fixed_advance_pc
define
DW_LNS_set_prologue_end
DWARF3
define
DW_LNS_set_epilogue_begin
DWARF3
define
DW_LNS_set_isa
DWARF3
Experimental
two
level
line
tables
NOT
STD
DWARF5
Not
saying
GNU
or
anything
There
are
no
DW_LNS_lo_user
or
DW_LNS_hi_user
values
though
DW_LNS_set_address_from_logical
and
DW_LNS_set_subprogram
being
both
to
avoid
using
up
more
space
in
the
special
opcode
table
EXPERIMENTAL
DW_LNS
follow
define
DW_LNS_set_address_from_logical
Actuals
table
only
define
DW_LNS_set_subprogram
Logicals
table
only
define
DW_LNS_inlined_call
Logicals
table
only
define
DW_LNS_pop_context
Logicals
table
only
Line
number
extended
opcode
name
define
DW_LNE_end_sequence
define
DW_LNE_set_address
define
DW_LNE_define_file
DWARF4
and
earlier
only
define
DW_LNE_set_discriminator
DWARF4
HP
extensions
define
DW_LNE_HP_negate_is_UV_update
HP
define
DW_LNE_HP_push_context
HP
define
DW_LNE_HP_pop_context
HP
define
DW_LNE_HP_set_file_line_column
HP
define
DW_LNE_HP_set_routine_name
HP
define
DW_LNE_HP_set_sequence
HP
define
DW_LNE_HP_negate_post_semantics
HP
define
DW_LNE_HP_negate_function_exit
HP
define
DW_LNE_HP_negate_front_end_logical
HP
define
DW_LNE_HP_define_proc
HP
define
DW_LNE_HP_source_file_correlation
HP
define
DW_LNE_lo_user
DWARF3
define
DW_LNE_hi_user
DWARF3
These
are
known
values
for
DW_LNS_set_isa
These
identifiers
are
not
defined
by
any
DWARFn
standard
define
DW_ISA_UNKNOWN
The
following
two
are
ARM
specific
define
DW_ISA_ARM_thumb
ARM
ISA
define
DW_ISA_ARM_arm
ARM
ISA
Macro
information
DWARF5
define
DW_MACRO_define
DWARF5
define
DW_MACRO_undef
DWARF5
define
DW_MACRO_start_file
DWARF5
define
DW_MACRO_end_file
DWARF5
define
DW_MACRO_define_strp
DWARF5
define
DW_MACRO_undef_strp
DWARF5
define
DW_MACRO_import
DWARF5
define
DW_MACRO_define_sup
DWARF5
define
DW_MACRO_undef_sup
DWARF5
define
DW_MACRO_import_sup
DWARF5
define
DW_MACRO_define_strx
DWARF5
define
DW_MACRO_undef_strx
DWARF5
define
DW_MACRO_lo_user
define
DW_MACRO_hi_user
Macro
information
DWARF2
DWARF4
define
DW_MACINFO_define
define
DW_MACINFO_undef
define
DW_MACINFO_start_file
define
DW_MACINFO_end_file
define
DW_MACINFO_vendor_ext
CFA
operator
compaction
a
space
saving
measure
see
the
DWARF
standard
means
DW_CFA_extended
and
DW_CFA_nop
have
the
same
value
here
define
DW_CFA_advance_loc
define
DW_CFA_offset
define
DW_CFA_restore
define
DW_CFA_extended
define
DW_CFA_nop
define
DW_CFA_set_loc
define
DW_CFA_advance_loc1
define
DW_CFA_advance_loc2
define
DW_CFA_advance_loc4
define
DW_CFA_offset_extended
define
DW_CFA_restore_extended
define
DW_CFA_undefined
define
DW_CFA_same_value
define
DW_CFA_register
define
DW_CFA_remember_state
define
DW_CFA_restore_state
define
DW_CFA_def_cfa
define
DW_CFA_def_cfa_register
define
DW_CFA_def_cfa_offset
define
DW_CFA_def_cfa_expression
DWARF3
define
DW_CFA_expression
DWARF3
define
DW_CFA_offset_extended_sf
DWARF3
define
DW_CFA_def_cfa_sf
DWARF3
define
DW_CFA_def_cfa_offset_sf
DWARF3
define
DW_CFA_val_offset
DWARF3f
define
DW_CFA_val_offset_sf
DWARF3f
define
DW_CFA_val_expression
DWARF3f
define
DW_CFA_lo_user
define
DW_CFA_low_user
Incorrect
spelling
do
not
use
SGI
MIPS
extension
define
DW_CFA_MIPS_advance_loc8
MIPS
GNU
extensions
define
DW_CFA_GNU_window_save
GNU
define
DW_CFA_AARCH64_negate_ra_state
define
DW_CFA_GNU_args_size
GNU
define
DW_CFA_GNU_negative_offset_extended
GNU
Metaware
if
HC
is
augmentation
apparently
meaning
High
C
and
the
op
has
a
single
uleb
operand
See
http
sourceforge
net
p
elftoolchain
tickets
define
DW_CFA_METAWARE_info
define
DW_CFA_high_user
GNU
exception
header
encoding
See
the
Generic
Elf
Specification
of
the
Linux
Standard
Base
LSB
http
refspecs
freestandards
org
LSB_3
LSB
Core
generic
LSB
Core
generic
dwarfext
html
The
upper
bits
indicate
how
the
value
is
to
be
applied
The
lower
bits
indicate
the
format
of
the
data
These
identifiers
are
not
defined
by
any
DWARFn
standard
define
DW_EH_PE_absptr
GNU
define
DW_EH_PE_uleb128
GNU
define
DW_EH_PE_udata2
GNU
define
DW_EH_PE_udata4
GNU
define
DW_EH_PE_udata8
GNU
define
DW_EH_PE_sleb128
GNU
define
DW_EH_PE_sdata2
GNU
define
DW_EH_PE_sdata4
GNU
define
DW_EH_PE_sdata8
GNU
define
DW_EH_PE_pcrel
GNU
define
DW_EH_PE_textrel
GNU
define
DW_EH_PE_datarel
GNU
define
DW_EH_PE_funcrel
GNU
define
DW_EH_PE_aligned
GNU
define
DW_EH_PE_omit
GNU
Means
no
value
present
Mapping
from
machine
registers
and
pseudo
regs
into
the
debug_frame
table
DW_FRAME
entries
are
machine
specific
These
describe
MIPS
SGI
R3000
R4K
R4400
and
all
later
MIPS
SGI
IRIX
machines
They
describe
a
mapping
from
hardware
register
number
to
the
number
used
in
the
table
to
identify
that
register
The
CFA
Canonical
Frame
Address
described
in
DWARF
is
called
the
Virtual
Frame
Pointer
on
MIPS
SGI
machines
The
DW_FRAME
names
here
are
MIPS
SGI
specific
Libdwarf
interfaces
defined
in
make
the
frame
definitions
here
and
the
fixed
table
sizes
they
imply
obsolete
They
are
left
here
for
compatibility
Default
column
used
for
CFA
in
the
libdwarf
reader
client
Assumes
reg
never
appears
as
a
register
in
DWARF
information
Usable
for
MIPS
but
never
a
good
idea
really
These
identifiers
are
not
defined
by
any
DWARFn
standard
define
DW_FRAME_CFA_COL
define
DW_FRAME_REG1
integer
reg
define
DW_FRAME_REG2
integer
reg
define
DW_FRAME_REG3
integer
reg
define
DW_FRAME_REG4
integer
reg
define
DW_FRAME_REG5
integer
reg
define
DW_FRAME_REG6
integer
reg
define
DW_FRAME_REG7
integer
reg
define
DW_FRAME_REG8
integer
reg
define
DW_FRAME_REG9
integer
reg
define
DW_FRAME_REG10
integer
reg
define
DW_FRAME_REG11
integer
reg
define
DW_FRAME_REG12
integer
reg
define
DW_FRAME_REG13
integer
reg
define
DW_FRAME_REG14
integer
reg
define
DW_FRAME_REG15
integer
reg
define
DW_FRAME_REG16
integer
reg
define
DW_FRAME_REG17
integer
reg
define
DW_FRAME_REG18
integer
reg
define
DW_FRAME_REG19
integer
reg
define
DW_FRAME_REG20
integer
reg
define
DW_FRAME_REG21
integer
reg
define
DW_FRAME_REG22
integer
reg
define
DW_FRAME_REG23
integer
reg
define
DW_FRAME_REG24
integer
reg
define
DW_FRAME_REG25
integer
reg
define
DW_FRAME_REG26
integer
reg
define
DW_FRAME_REG27
integer
reg
define
DW_FRAME_REG28
integer
reg
define
DW_FRAME_REG29
integer
reg
define
DW_FRAME_REG30
integer
reg
define
DW_FRAME_REG31
integer
reg
aka
ra
MIPS1
have
only
some
of
these
bit
registers
MIPS1
save
restore
takes
instructions
per
bit
reg
and
in
that
case
the
register
is
considered
stored
after
the
second
swc1
define
DW_FRAME_FREG0
bit
floating
point
reg
define
DW_FRAME_FREG1
bit
floating
point
reg
define
DW_FRAME_FREG2
bit
floating
point
reg
define
DW_FRAME_FREG3
bit
floating
point
reg
define
DW_FRAME_FREG4
bit
floating
point
reg
define
DW_FRAME_FREG5
bit
floating
point
reg
define
DW_FRAME_FREG6
bit
floating
point
reg
define
DW_FRAME_FREG7
bit
floating
point
reg
define
DW_FRAME_FREG8
bit
floating
point
reg
define
DW_FRAME_FREG9
bit
floating
point
reg
define
DW_FRAME_FREG10
bit
floating
point
reg
define
DW_FRAME_FREG11
bit
floating
point
reg
define
DW_FRAME_FREG12
bit
floating
point
reg
define
DW_FRAME_FREG13
bit
floating
point
reg
define
DW_FRAME_FREG14
bit
floating
point
reg
define
DW_FRAME_FREG15
bit
floating
point
reg
define
DW_FRAME_FREG16
bit
floating
point
reg
define
DW_FRAME_FREG17
bit
floating
point
reg
define
DW_FRAME_FREG18
bit
floating
point
reg
define
DW_FRAME_FREG19
bit
floating
point
reg
define
DW_FRAME_FREG20
bit
floating
point
reg
define
DW_FRAME_FREG21
bit
floating
point
reg
define
DW_FRAME_FREG22
bit
floating
point
reg
define
DW_FRAME_FREG23
bit
floating
point
reg
define
DW_FRAME_FREG24
bit
floating
point
reg
define
DW_FRAME_FREG25
bit
floating
point
reg
define
DW_FRAME_FREG26
bit
floating
point
reg
define
DW_FRAME_FREG27
bit
floating
point
reg
define
DW_FRAME_FREG28
bit
floating
point
reg
define
DW_FRAME_FREG29
bit
floating
point
reg
define
DW_FRAME_FREG30
bit
floating
point
reg
define
DW_FRAME_FREG31
bit
floating
point
reg
define
DW_FRAME_FREG32
bit
floating
point
reg
define
DW_FRAME_FREG33
bit
floating
point
reg
define
DW_FRAME_FREG34
bit
floating
point
reg
define
DW_FRAME_FREG35
bit
floating
point
reg
define
DW_FRAME_FREG36
bit
floating
point
reg
define
DW_FRAME_FREG37
bit
floating
point
reg
define
DW_FRAME_FREG38
bit
floating
point
reg
define
DW_FRAME_FREG39
bit
floating
point
reg
define
DW_FRAME_FREG40
bit
floating
point
reg
define
DW_FRAME_FREG41
bit
floating
point
reg
define
DW_FRAME_FREG42
bit
floating
point
reg
define
DW_FRAME_FREG43
bit
floating
point
reg
define
DW_FRAME_FREG44
bit
floating
point
reg
define
DW_FRAME_FREG45
bit
floating
point
reg
define
DW_FRAME_FREG46
bit
floating
point
reg
define
DW_FRAME_FREG47
bit
floating
point
reg
define
DW_FRAME_FREG48
bit
floating
point
reg
define
DW_FRAME_FREG49
bit
floating
point
reg
define
DW_FRAME_FREG50
bit
floating
point
reg
define
DW_FRAME_FREG51
bit
floating
point
reg
define
DW_FRAME_FREG52
bit
floating
point
reg
define
DW_FRAME_FREG53
bit
floating
point
reg
define
DW_FRAME_FREG54
bit
floating
point
reg
define
DW_FRAME_FREG55
bit
floating
point
reg
define
DW_FRAME_FREG56
bit
floating
point
reg
define
DW_FRAME_FREG57
bit
floating
point
reg
define
DW_FRAME_FREG58
bit
floating
point
reg
define
DW_FRAME_FREG59
bit
floating
point
reg
define
DW_FRAME_FREG60
bit
floating
point
reg
define
DW_FRAME_FREG61
bit
floating
point
reg
define
DW_FRAME_FREG62
bit
floating
point
reg
define
DW_FRAME_FREG63
bit
floating
point
reg
define
DW_FRAME_FREG64
bit
floating
point
reg
define
DW_FRAME_FREG65
bit
floating
point
reg
define
DW_FRAME_FREG66
bit
floating
point
reg
define
DW_FRAME_FREG67
bit
floating
point
reg
define
DW_FRAME_FREG68
bit
floating
point
reg
define
DW_FRAME_FREG69
bit
floating
point
reg
define
DW_FRAME_FREG70
bit
floating
point
reg
define
DW_FRAME_FREG71
bit
floating
point
reg
define
DW_FRAME_FREG72
bit
floating
point
reg
define
DW_FRAME_FREG73
bit
floating
point
reg
define
DW_FRAME_FREG74
bit
floating
point
reg
define
DW_FRAME_FREG75
bit
floating
point
reg
define
DW_FRAME_FREG76
bit
floating
point
reg
IMPORTANT
NOTE
TARGET
DEPENDENCY
The
following
defines
are
dependent
on
the
target
cpu
s
that
you
apply
libdwarf
to
Ensure
that
DW_FRAME_UNDEFINED_VAL
and
DW_FRAME_SAME_VAL
do
not
conflict
with
the
range
DW_FRAME_STATIC_LINK
The
value
works
for
MIPS
cpus
at
least
up
to
the
R16000
For
a
cpu
with
more
than
real
registers
DW_FRAME_HIGHEST_NORMAL_REGISTER
must
be
increased
for
things
to
work
properly
Also
ensure
that
DW_FRAME_UNDEFINED_VAL
DW_FRAME_SAME_VAL
are
not
in
the
range
DW_FRAME_STATIC_LINK
Having
DW_FRAME_HIGHEST_NORMAL_REGISTER
be
higher
than
is
strictly
needed
is
safe
ifndef
DW_FRAME_HIGHEST_NORMAL_REGISTER
define
DW_FRAME_HIGHEST_NORMAL_REGISTER
endif
This
is
the
number
of
columns
in
the
Frame
Table
This
constant
should
be
kept
in
sync
with
DW_REG_TABLE_SIZE
defined
in
libdwarf
h
It
must
also
be
large
enough
to
be
beyond
the
highest
compiler
defined
register
meaning
DW_FRAME_RA_COL
DW_FRAME_STATIC_LINK
in
the
MIPS
IRIX
case
ifndef
DW_FRAME_LAST_REG_NUM
define
DW_FRAME_LAST_REG_NUM
DW_FRAME_HIGHEST_NORMAL_REGISTER
endif
Column
recording
ra
return
address
from
a
function
call
This
is
common
to
many
architectures
but
as
a
simple
register
is
not
necessarily
adequate
for
all
architectures
For
MIPS
IRIX
this
register
number
is
actually
recorded
on
disk
in
the
debug_frame
section
define
DW_FRAME_RA_COL
DW_FRAME_HIGHEST_NORMAL_REGISTER
Column
recording
static
link
applicable
to
up
level
addressing
as
in
IRIX
mp
code
pascal
etc
This
is
common
to
many
architectures
but
is
not
necessarily
adequate
for
all
architectures
For
MIPS
IRIX
this
register
number
is
actually
recorded
on
disk
in
the
debug_frame
section
define
DW_FRAME_STATIC_LINK
DW_FRAME_HIGHEST_NORMAL_REGISTER
DW_FRAME_UNDEFINED_VAL
and
DW_FRAME_SAME_VAL
are
never
on
disk
just
generated
by
libdwarf
See
libdwarf
h
for
their
values
define
DW_CHILDREN_no
define
DW_CHILDREN_yes
define
DW_ADDR_none
ifdef
__cplusplus
endif
endif
__DWARF_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
In
a
given
CU
one
of
these
is
eventually
set
up
for
every
abbreviation
we
need
to
find
and
for
all
those
earlier
in
the
abbreviations
for
that
CU
So
we
don
t
want
elements
needlessly
big
struct
Dwarf_Abbrev_s
No
TAG
should
exceed
DW_TAG_hi_user
but
we
do
allow
a
larger
value
here
Dwarf_Unsigned
dab_tag
Abbreviations
are
numbered
normally
sequentially
from
and
so
bits
is
not
enough
Dwarf_Unsigned
dab_code
Dwarf_Small
dab_has_child
dab_abbrev_ptr
points
to
the
abbreviations
themselves
in
memory
the
list
of
attr
form
integers
terminated
by
Dwarf_Byte_Ptr
dab_abbrev_ptr
Dwarf_Debug
dab_dbg
Section
global
offset
of
the
abbrev
Dwarf_Off
dab_goffset
dab_count
is
the
number
of
attr
form
uleb
pairs
Dwarf_Off
dab_count
When
the
caller
cycles
through
attr
form
pairs
by
index
from
zero
this
lets
the
code
read
just
one
pair
to
work
Dwarf_Byte_Ptr
dab_next_ptr
Dwarf_Unsigned
dab_next_index
int
_dwarf_count_abbrev_entries
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
abbrev_ptr
Dwarf_Byte_Ptr
abbrev_section_end
Dwarf_Unsigned
abbrev_count_out
Dwarf_Byte_Ptr
abbrev_ptr_out
Dwarf_Error
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
define
DWARF_SIMPLE_MALLOC
char
_dwarf_get_alloc
Dwarf_Debug
Dwarf_Small
Dwarf_Unsigned
Dwarf_Debug
_dwarf_get_debug
void
int
_dwarf_free_all_of_one_debug
Dwarf_Debug
struct
Dwarf_Error_s
_dwarf_special_no_dbg_error_malloc
void
void
_dwarf_error_destructor
void
Intended
for
use
in
memory
use
investigations
Not
a
public
function
void
_dwarf_alloc_tree_counts
Dwarf_Unsigned
allocount
Dwarf_Unsigned
allosum
Dwarf_Unsigned
treecount
Dwarf_Unsigned
treesum
Dwarf_Unsigned
earlydealloccount
Dwarf_Unsigned
earlydeallocsize
Dwarf_Unsigned
unused1
Dwarf_Unsigned
unused2
Dwarf_Unsigned
unused3
ALLOC_AREA_INDEX_TABLE_MAX
is
the
size
of
the
struct
ial_s
index_into_allocated
array
in
dwarf_alloc
c
define
ALLOC_AREA_INDEX_TABLE_MAX
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
structure
is
used
to
read
an
arange
into
struct
Dwarf_Arange_s
The
segment
selector
Only
non
zero
if
Dwarf4
only
meaningful
if
ar_segment_selector_size
non
zero
Dwarf_Unsigned
ar_segment_selector
Starting
address
of
the
arange
ie
low
pc
Dwarf_Addr
ar_address
Length
of
the
arange
Dwarf_Unsigned
ar_length
Offset
into
debug_info
of
the
start
of
the
compilation
unit
containing
this
set
of
aranges
Applies
only
to
debug_info
not
debug_types
Dwarf_Off
ar_info_offset
Corresponding
Dwarf_Debug
Dwarf_Debug
ar_dbg
Dwarf_Half
ar_segment_selector_size
int
_dwarf_get_aranges_addr_offsets
Dwarf_Debug
dbg
Dwarf_Addr
addrs
Dwarf_Off
offsets
Dwarf_Signed
count
Dwarf_Error
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
define
true
define
false
debug_addr
new
in
DWARF5
define
DW_ADDR_VERSION5
To
identify
a
cie
That
is
for
debug_frame
define
DW_CIE_ID
define
DW_CIE_VERSION
DWARF2
define
DW_CIE_VERSION3
DWARF3
define
DW_CIE_VERSION4
DWARF4
define
DW_CIE_VERSION5
DWARF5
For
debug_info
DWARF2
debug_types
in
DWARF4
only
and
gets
DW_CU_VERSION4
define
DW_CU_VERSION2
define
DW_CU_VERSION3
define
DW_CU_VERSION4
define
DW_CU_VERSION5
For
debug_macro
DWARF
extension
or
DWARF5
define
DW_MACRO_VERSION4
define
DW_MACRO_VERSION5
DWARF2
and
define
DW_ARANGES_VERSION2
define
DW_LINE_VERSION2
define
DW_LINE_VERSION3
define
DW_LINE_VERSION4
define
DW_LINE_VERSION5
debug_line_str
and
dwo
new
in
DWARF5
define
DW_LINE_STR_VERSION5
define
EXPERIMENTAL_LINE_TABLES_VERSION
Experimental
two
level
line
tables
debug_loc
and
dwo
First
header
version
number
is
DWARF5
define
DW_LOC_VERSION5
debug_names
new
in
DWARF5
define
DW_NAMES_VERSION5
debug_pubnames
in
DWARF2
define
DW_PUBNAMES_VERSION2
debug_pubnames
in
DWARF3
define
DW_PUBTYPES_VERSION2
debug_ranges
gets
a
version
number
in
header
in
DWARF5
define
DW_RANGES_VERSION5
debug_str_offsets
and
dwo
new
in
DWARF5
define
DW_STR_OFFSETS_VERSION5
define
DW_STR_OFFSETS_VERSION4
GNU
extension
in
DW4
debug_sup
new
in
DWARF5
define
DW_SUP_VERSION5
debug_cu_index
new
in
DWARF5
define
DW_CU_INDEX_VERSION5
debug_tu_index
new
in
DWARF5
define
DW_TU_INDEX_VERSION5
These
are
allocation
type
codes
for
structs
that
are
internal
to
the
Libdwarf
Consumer
library
define
DW_DLA_ABBREV_LIST
define
DW_DLA_CHAIN
define
DW_DLA_CU_CONTEXT
define
DW_DLA_FRAME
define
DW_DLA_GLOBAL_CONTEXT
define
DW_DLA_FILE_ENTRY
define
DW_DLA_LINE_CONTEXT
define
DW_DLA_LOC_CHAIN
define
DW_DLA_HASH_TABLE
define
DW_DLA_FUNC_CONTEXT
define
DW_DLA_TYPENAME_CONTEXT
define
DW_DLA_VAR_CONTEXT
define
DW_DLA_WEAK_CONTEXT
define
DW_DLA_PUBTYPES_CONTEXT
DWARF3
define
DW_DLA_HASH_TABLE_ENTRY
define
DW_DLA_FISSION_PERCU
define
DW_DLA_CHAIN_2
Thru
reserved
for
internal
future
use
Maximum
number
of
allocation
types
for
allocation
routines
Only
used
with
malloc_check
c
and
that
is
basically
obsolete
define
MAX_DW_DLA
typedef
signed
char
Dwarf_Sbyte
typedef
unsigned
char
Dwarf_Ubyte
typedef
signed
short
Dwarf_Shalf
typedef
Dwarf_Small
Dwarf_Byte_Ptr
define
DWARF_HALF_SIZE
define
DWARF_32BIT_SIZE
define
DWARF_64BIT_SIZE
typedef
struct
Dwarf_Abbrev_List_s
Dwarf_Abbrev_List
typedef
struct
Dwarf_File_Entry_s
Dwarf_File_Entry
typedef
struct
Dwarf_CU_Context_s
Dwarf_CU_Context
typedef
struct
Dwarf_Hash_Table_s
Dwarf_Hash_Table
typedef
struct
Dwarf_Hash_Table_Entry_s
Dwarf_Hash_Table_Entry
typedef
struct
Dwarf_Alloc_Hdr_s
Dwarf_Alloc_Hdr
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Only
abbrev
DW_IDX
defined
we
allow
three
user
defined
arbitrarily
define
ABB_PAIRS_MAX
struct
abbrev_pair_s
unsigned
ap_index
unsigned
ap_form
struct
Dwarf_D_Abbrev_s
struct
Dwarf_D_Abbrev_s
da_next
unsigned
da_abbrev_code
unsigned
da_tag
unsigned
da_pairs_count
struct
abbrev_pair_s
da_pairs
ABB_PAIRS_MAX
define
DWARF_DNAMES_VERSION5
struct
Dwarf_Dnames_index_header_s
Dwarf_Debug
din_dbg
struct
Dwarf_Dnames_index_header_s
din_next
The
debug_names
section
offset
of
byte
of
a
header
record
Dwarf_Unsigned
din_section_offset
For
offset
and
pointer
sanity
calculations
Dwarf_Small
din_indextable_data
Dwarf_Unsigned
din_indextable_length
unsigned
din_offset_size
Dwarf_Unsigned
din_version
Dwarf_Unsigned
din_comp_unit_count
Dwarf_Unsigned
din_local_type_unit_count
Dwarf_Unsigned
din_foreign_type_unit_count
Dwarf_Unsigned
din_bucket_count
Dwarf_Unsigned
din_name_count
Dwarf_Unsigned
din_abbrev_table_size
bytes
Dwarf_Unsigned
din_entry_pool_size
bytes
Dwarf_Unsigned
din_augmentation_string_size
Since
we
cannot
assume
the
string
is
NUL
terminated
we
allocate
a
sufficient
string
space
and
NUL
terminate
the
string
The
DWARF5
standard
does
not
specify
it
as
null
terminated
We
copy
it
into
calloc
area
so
not
const
char
din_augmentation_string
Dwarf_Small
din_cu_list
Dwarf_Small
din_local_tu_list
Dwarf_Small
din_foreign_tu_list
Dwarf_Small
din_buckets
Dwarf_Small
din_hash_table
Dwarf_Small
din_string_offsets
Dwarf_Small
din_entry_offsets
Dwarf_Small
din_abbreviations
Dwarf_Small
din_entry_pool
unsigned
din_abbrev_list_count
An
array
of
size
din_abbrev_list_count
struct
Dwarf_D_Abbrev_s
din_abbrev_list
struct
Dwarf_Dnames_Head_s
Dwarf_Debug
dn_dbg
Dwarf_Small
dn_section_data
Dwarf_Small
dn_section_end
Dwarf_Unsigned
dn_section_size
unsigned
dn_inhdr_count
Becomes
an
array
of
these
structs
dn_inhdr_count
of
them
struct
Dwarf_Dnames_index_header_s
dn_inhdr_first
void
_dwarf_debugnames_destructor
void
m
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_DEBUGLINK_H
define
DWARF_DEBUGLINK_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
int
_dwarf_pathjoinl
dwarfstring
target
dwarfstring
input
int
_dwarf_construct_linkedto_path
char
global_prefixes_in
unsigned
length_global_prefixes_in
char
pathname_in
char
link_string_in
from
debug
link
dwarfstring
link_string_fullpath
unsigned
char
crc_in
from
debug_link
bytes
unsigned
char
buildid
from
gnu
buildid
unsigned
buildid_length
from
gnu
buildid
char
paths_out
unsigned
paths_out_length
int
errcode
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_DEBUGLINK_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
struct
holds
information
about
an
abbreviation
It
is
put
in
the
hash
table
for
abbreviations
for
a
compile
unit
It
s
dealloced
by
dwarf_finish
struct
Dwarf_Abbrev_List_s
Dwarf_Unsigned
abl_code
Dwarf_Half
abl_tag
Dwarf_Half
abl_has_child
Section
global
offset
of
this
abbrev
entry
Dwarf_Off
abl_goffset
Singly
linked
synonym
list
in
case
of
duplicate
hash
struct
Dwarf_Abbrev_List_s
abl_next
Points
to
start
of
attribute
form
pairs
in
the
debug_abbrev
section
for
the
abbrev
Dwarf_Byte_Ptr
abl_abbrev_ptr
The
number
of
at
form
implicitvalue
pairs
in
this
abbrev
Dwarf_Unsigned
abl_count
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
dsc_type
if
then
dsc_low
is
a
single
discriminant
value
and
dsc_high
is
zero
If
then
dsc_low
dsc_high
are
a
discriminant
range
All
the
messy
complexity
here
is
so
we
can
have
both
a
set
of
values
read
as
uleb
and
as
sleb
We
make
our
own
copy
of
the
block
for
the
same
reason
struct
Dwarf_Dsc_Entry_s
Type
is
a
byte
leb
that
reads
the
same
as
sleb
or
uleb
because
its
value
can
only
be
zero
or
one
Dwarf_Half
dsc_type
Dwarf_Unsigned
dsc_low_u
Dwarf_Unsigned
dsc_high_u
Dwarf_Signed
dsc_low_s
Dwarf_Signed
dsc_high_s
struct
Dwarf_Dsc_Head_s
Dwarf_Debug
dsh_debug
Dwarf_Unsigned
dsh_count
Dwarf_Small
dsh_block
Dwarf_Unsigned
dsh_block_len
Following
two
are
flags
to
tell
us
whether
lebs
already
read
in
a
given
signedness
Dwarf_Bool
dsh_set_unsigned
Dwarf_Bool
dsh_set_signed
struct
Dwarf_Dsc_Entry_s
dsh_array
void
_dwarf_dsc_destructor
void
m
ifndef
_DWARF_ELF_PORT_H
define
_DWARF_ELF_PORT_H
Copyright
C
David
Anderson
All
rights
reserved
Portions
Copyright
Arxan
Technologies
Inc
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
libelf
object
access
for
the
generic
object
file
interface
int
dwarf_elf_object_access_init
void
elf
int
libdwarf_owns_elf
Dwarf_Obj_Access_Interface
ret_obj
int
err
void
dwarf_elf_object_access_finish
Dwarf_Obj_Access_Interface
obj
End
ELF
object
access
for
the
generic
object
file
interface
endif
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_ELF_DEFINES_H
define
DWARF_ELF_DEFINES_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Use
the
system
headers
if
they
are
available
Use
the
system
headers
if
they
are
available
ifdef
HAVE_ELF_H
include
elf
h
endif
HAVE_ELF_H
Relocation
definitions
are
in
sys
elf_
mach
h
on
Solaris
ifdef
HAVE_LIBELF_H
include
libelf
h
else
ifdef
HAVE_LIBELF_LIBELF_H
include
libelf
libelf
h
endif
HAVE_LIBELF_LIBELF_H
endif
HAVE_LIBELF_H
Standard
Elf
section
types
ifndef
SHT_NULL
define
SHT_NULL
endif
ifndef
SHT_PROGBITS
define
SHT_PROGBITS
endif
ifndef
SHT_SYMTAB
define
SHT_SYMTAB
endif
ifndef
SHT_STRTAB
define
SHT_STRTAB
endif
ifndef
SHT_RELA
define
SHT_RELA
endif
ifndef
SHT_REL
define
SHT_REL
endif
ifndef
DW_GROUPNUMBER_BASE
define
DW_GROUPNUMBER_BASE
endif
ifndef
DW_GROUPNUMBER_DWO
define
DW_GROUPNUMBER_DWO
endif
ifndef
SHF_GROUP
define
SHF_GROUP
endif
SHF_GROUP
ifndef
STN_UNDEF
define
STN_UNDEF
endif
STN_UNDEF
ifndef
SHT_HASH
define
SHT_HASH
endif
ifndef
SHT_DYNAMIC
define
SHT_DYNAMIC
endif
ifndef
SHT_NOTE
define
SHT_NOTE
endif
ifndef
SHT_NOBITS
define
SHT_NOBITS
endif
ifndef
SHT_REL
define
SHT_REL
endif
ifndef
SHT_SHLIB
define
SHT_SHLIB
endif
ifndef
SHT_DYNSYM
define
SHT_DYNSYM
endif
ifndef
SHT_GROUP
define
SHT_GROUP
endif
SHT_GROUP
Symbol
Types
Elf
standard
define
STT_NOTYPE
define
STT_OBJECT
define
STT_FUNC
define
STT_SECTION
define
STT_FILE
ifndef
PT_NULL
define
PT_NULL
endif
ifndef
PT_LOAD
define
PT_LOAD
endif
ifndef
PT_DYNAMIC
define
PT_DYNAMIC
endif
ifndef
PT_INTERP
define
PT_INTERP
endif
ifndef
PT_NOTE
define
PT_NOTE
endif
ifndef
PT_SHLIB
define
PT_SHLIB
endif
ifndef
PT_PHDR
define
PT_PHDR
endif
ifndef
PT_LOPROC
define
PT_LOPROC
endif
ifndef
PT_HIPROC
define
PT_HIPROC
endif
ifndef
PF_X
define
PF_X
endif
ifndef
PF_W
define
PF_W
endif
ifndef
PF_R
define
PF_R
endif
ifndef
PF_MASKOS
define
PF_MASKOS
endif
ifndef
PF_MASKPROC
define
PF_MASKPROC
endif
ifndef
ET_NONE
define
ET_NONE
endif
ifndef
ET_REL
define
ET_REL
endif
ifndef
ET_EXEC
define
ET_EXEC
endif
ifndef
ET_DYN
define
ET_DYN
endif
ifndef
ET_CORE
define
ET_CORE
endif
ifndef
ET_NUM
define
ET_NUM
endif
ifndef
ET_LOOS
define
ET_LOOS
endif
ifndef
ET_HIOS
define
ET_HIOS
endif
ifndef
ET_LOPROC
define
ET_LOPROC
endif
ifndef
ET_HIPROC
define
ET_HIPROC
endif
ifndef
EM_NONE
define
EM_NONE
endif
ifndef
EM_M32
define
EM_M32
endif
ifndef
EM_SPARC
define
EM_SPARC
endif
ifndef
EM_386
define
EM_386
endif
ifndef
EM_68K
define
EM_68K
endif
ifndef
EM_88K
define
EM_88K
endif
ifndef
EM_IAMCU
define
EM_IAMCU
endif
ifndef
EM_860
define
EM_860
endif
ifndef
EM_MIPS
define
EM_MIPS
endif
ifndef
EM_S370
define
EM_S370
endif
ifndef
EM_MIPS_RS3_LE
define
EM_MIPS_RS3_LE
endif
ifndef
EM_PARISC
define
EM_PARISC
endif
ifndef
EM_VPP500
define
EM_VPP500
endif
ifndef
EM_SPARC32PLUS
define
EM_SPARC32PLUS
endif
ifndef
EM_960
define
EM_960
endif
ifndef
EM_PPC
define
EM_PPC
endif
ifndef
EM_PPC64
define
EM_PPC64
endif
ifndef
EM_S390
define
EM_S390
endif
ifndef
EM_SPU
define
EM_SPU
endif
ifndef
EM_V800
define
EM_V800
endif
ifndef
EM_FR20
define
EM_FR20
endif
ifndef
EM_RH32
define
EM_RH32
endif
ifndef
EM_RCE
define
EM_RCE
endif
ifndef
EM_ARM
define
EM_ARM
endif
ifndef
EM_FAKE_ALPHA
define
EM_FAKE_ALPHA
endif
ifndef
EM_SH
define
EM_SH
endif
ifndef
EM_SPARCV9
define
EM_SPARCV9
endif
ifndef
EM_TRICORE
define
EM_TRICORE
endif
ifndef
EM_ARC
define
EM_ARC
endif
ifndef
EM_H8_300
define
EM_H8_300
endif
ifndef
EM_H8_300H
define
EM_H8_300H
endif
ifndef
EM_H8S
define
EM_H8S
endif
ifndef
EM_H8_500
define
EM_H8_500
endif
ifndef
EM_IA_64
define
EM_IA_64
endif
ifndef
EM_MIPS_X
define
EM_MIPS_X
endif
ifndef
EM_COLDFIRE
define
EM_COLDFIRE
endif
ifndef
EM_68HC12
define
EM_68HC12
endif
ifndef
EM_MMA
define
EM_MMA
endif
ifndef
EM_PCP
define
EM_PCP
endif
ifndef
EM_NCPU
define
EM_NCPU
endif
ifndef
EM_NDR1
define
EM_NDR1
endif
ifndef
EM_STARCORE
define
EM_STARCORE
endif
ifndef
EM_ME16
define
EM_ME16
endif
ifndef
EM_ST100
define
EM_ST100
endif
ifndef
EM_TINYJ
define
EM_TINYJ
endif
ifndef
EM_X86_64
define
EM_X86_64
endif
ifndef
EM_PDSP
define
EM_PDSP
endif
ifndef
EM_PDP10
define
EM_PDP10
endif
ifndef
EM_PDP11
define
EM_PDP11
endif
ifndef
EM_FX66
define
EM_FX66
endif
ifndef
EM_ST9PLUS
define
EM_ST9PLUS
endif
ifndef
EM_ST7
define
EM_ST7
endif
ifndef
EM_68HC16
define
EM_68HC16
endif
ifndef
EM_68HC11
define
EM_68HC11
endif
ifndef
EM_68HC08
define
EM_68HC08
endif
ifndef
EM_68HC05
define
EM_68HC05
endif
ifndef
EM_SVX
define
EM_SVX
endif
ifndef
EM_ST19
define
EM_ST19
endif
ifndef
EM_VAX
define
EM_VAX
endif
ifndef
EM_CRIS
define
EM_CRIS
endif
ifndef
EM_JAVELIN
define
EM_JAVELIN
endif
ifndef
EM_FIREPATH
define
EM_FIREPATH
endif
ifndef
EM_ZSP
define
EM_ZSP
endif
ifndef
EM_MMIX
define
EM_MMIX
endif
ifndef
EM_HUANY
define
EM_HUANY
endif
ifndef
EM_PRISM
define
EM_PRISM
endif
ifndef
EM_AVR
define
EM_AVR
endif
ifndef
EM_FR30
define
EM_FR30
endif
ifndef
EM_D10V
define
EM_D10V
endif
ifndef
EM_D30V
define
EM_D30V
endif
ifndef
EM_V850
define
EM_V850
endif
ifndef
EM_M32R
define
EM_M32R
endif
ifndef
EM_MN10300
define
EM_MN10300
endif
ifndef
EM_MN10200
define
EM_MN10200
endif
ifndef
EM_PJ
define
EM_PJ
endif
ifndef
EM_OPENRISC
define
EM_OPENRISC
endif
ifndef
EM_ARC_COMPACT
define
EM_ARC_COMPACT
endif
ifndef
EM_XTENSA
define
EM_XTENSA
endif
ifndef
EM_VIDEOCORE
define
EM_VIDEOCORE
endif
ifndef
EM_TMM_GPP
define
EM_TMM_GPP
endif
ifndef
EM_NS32K
define
EM_NS32K
endif
ifndef
EM_TPC
define
EM_TPC
endif
ifndef
EM_SNP1K
define
EM_SNP1K
endif
ifndef
EM_ST200
define
EM_ST200
endif
ifndef
EM_IP2K
define
EM_IP2K
endif
ifndef
EM_MAX
define
EM_MAX
endif
ifndef
EM_CR
define
EM_CR
endif
ifndef
EM_F2MC16
define
EM_F2MC16
endif
ifndef
EM_MSP430
define
EM_MSP430
endif
ifndef
EM_BLACKFIN
define
EM_BLACKFIN
endif
ifndef
EM_SE_C33
define
EM_SE_C33
endif
ifndef
EM_SEP
define
EM_SEP
endif
ifndef
EM_ARCA
define
EM_ARCA
endif
ifndef
EM_UNICORE
define
EM_UNICORE
endif
ifndef
EM_EXCESS
define
EM_EXCESS
endif
ifndef
EM_DXP
define
EM_DXP
endif
ifndef
EM_ALTERA_NIOS2
define
EM_ALTERA_NIOS2
endif
ifndef
EM_CRX
define
EM_CRX
endif
ifndef
EM_XGATE
define
EM_XGATE
endif
ifndef
EM_C166
define
EM_C166
endif
ifndef
EM_M16C
define
EM_M16C
endif
ifndef
EM_DSPIC30F
define
EM_DSPIC30F
endif
ifndef
EM_CE
define
EM_CE
endif
ifndef
EM_M32C
define
EM_M32C
endif
ifndef
EM_TSK3000
define
EM_TSK3000
endif
ifndef
EM_RS08
define
EM_RS08
endif
ifndef
EM_SHARC
define
EM_SHARC
endif
ifndef
EM_ECOG2
define
EM_ECOG2
endif
ifndef
EM_SCORE7
define
EM_SCORE7
endif
ifndef
EM_DSP24
define
EM_DSP24
endif
ifndef
EM_VIDEOCORE3
define
EM_VIDEOCORE3
endif
ifndef
EM_LATTICEMICO32
define
EM_LATTICEMICO32
endif
ifndef
EM_SE_C17
define
EM_SE_C17
endif
ifndef
EM_TI_C6000
define
EM_TI_C6000
endif
ifndef
EM_TI_C2000
define
EM_TI_C2000
endif
ifndef
EM_TI_C5500
define
EM_TI_C5500
endif
ifndef
EM_TI_ARP32
define
EM_TI_ARP32
endif
ifndef
EM_TI_PRU
define
EM_TI_PRU
endif
ifndef
EM_MMDSP_PLUS
define
EM_MMDSP_PLUS
endif
ifndef
EM_CYPRESS_M8C
define
EM_CYPRESS_M8C
endif
ifndef
EM_R32C
define
EM_R32C
endif
ifndef
EM_TRIMEDIA
define
EM_TRIMEDIA
endif
ifndef
EM_QDSP6
define
EM_QDSP6
endif
ifndef
EM_QUALCOMM_DSP6
define
EM_QUALCOMM_DSP6
endif
ifndef
EM_8051
define
EM_8051
endif
ifndef
EM_STXP7X
define
EM_STXP7X
endif
ifndef
EM_NDS32
define
EM_NDS32
endif
ifndef
EM_ECOG1X
define
EM_ECOG1X
endif
ifndef
EM_MAXQ30
define
EM_MAXQ30
endif
ifndef
EM_XIMO16
define
EM_XIMO16
endif
ifndef
EM_MANIK
define
EM_MANIK
endif
ifndef
EM_CRAYNV2
define
EM_CRAYNV2
endif
ifndef
EM_RX
define
EM_RX
endif
ifndef
EM_METAG
define
EM_METAG
endif
ifndef
EM_MCST_ELBRUS
define
EM_MCST_ELBRUS
endif
ifndef
EM_ECOG16
define
EM_ECOG16
endif
ifndef
EM_CR16
define
EM_CR16
endif
ifndef
EM_ETPU
define
EM_ETPU
endif
ifndef
EM_SLE9X
define
EM_SLE9X
endif
ifndef
EM_L10M
define
EM_L10M
endif
ifndef
EM_K10M
define
EM_K10M
endif
ifndef
EM_AARCH64
define
EM_AARCH64
endif
ifndef
EM_AVR32
define
EM_AVR32
endif
ifndef
EM_STM8
define
EM_STM8
endif
ifndef
EM_TILE64
define
EM_TILE64
endif
ifndef
EM_TILEPRO
define
EM_TILEPRO
endif
ifndef
EM_MICROBLAZE
define
EM_MICROBLAZE
endif
ifndef
EM_CUDA
define
EM_CUDA
endif
ifndef
EM_TILEGX
define
EM_TILEGX
endif
ifndef
EM_CLOUDSHIELD
define
EM_CLOUDSHIELD
endif
ifndef
EM_COREA_1ST
define
EM_COREA_1ST
endif
ifndef
EM_COREA_2ND
define
EM_COREA_2ND
endif
ifndef
EM_ARC_COMPACT2
define
EM_ARC_COMPACT2
endif
ifndef
EM_OPEN8
define
EM_OPEN8
endif
ifndef
EM_RL78
define
EM_RL78
endif
ifndef
EM_VIDEOCORE5
define
EM_VIDEOCORE5
endif
ifndef
EM_78KOR
define
EM_78KOR
endif
ifndef
EM_56800EX
define
EM_56800EX
endif
ifndef
EM_BA1
define
EM_BA1
endif
ifndef
EM_BA2
define
EM_BA2
endif
ifndef
EM_XCORE
define
EM_XCORE
endif
ifndef
EM_MCHP_PIC
define
EM_MCHP_PIC
endif
ifndef
EM_KM32
define
EM_KM32
endif
ifndef
EM_KMX32
define
EM_KMX32
endif
ifndef
EM_EMX16
define
EM_EMX16
endif
ifndef
EM_EMX8
define
EM_EMX8
endif
ifndef
EM_KVARC
define
EM_KVARC
endif
ifndef
EM_CDP
define
EM_CDP
endif
ifndef
EM_COGE
define
EM_COGE
endif
ifndef
EM_COOL
define
EM_COOL
endif
ifndef
EM_NORC
define
EM_NORC
endif
ifndef
EM_CSR_KALIMBA
define
EM_CSR_KALIMBA
endif
ifndef
EM_Z80
define
EM_Z80
endif
ifndef
EM_VISIUM
define
EM_VISIUM
endif
ifndef
EM_FT32
define
EM_FT32
endif
ifndef
EM_MOXIE
define
EM_MOXIE
endif
ifndef
EM_AMDGPU
define
EM_AMDGPU
endif
ifndef
EM_RISCV
define
EM_RISCV
endif
ifndef
EM_BPF
define
EM_BPF
endif
Standard
Elf
dynamic
tags
ifndef
DT_NULL
define
DT_NULL
endif
ifndef
DT_NEEDED
define
DT_NEEDED
endif
ifndef
DT_PLTRELSZ
define
DT_PLTRELSZ
endif
ifndef
DT_PLTGOT
define
DT_PLTGOT
endif
ifndef
DT_HASH
define
DT_HASH
endif
ifndef
DT_STRTAB
define
DT_STRTAB
endif
ifndef
DT_SYMTAB
define
DT_SYMTAB
endif
ifndef
DT_RELA
define
DT_RELA
endif
ifndef
DT_REL
define
DT_REL
endif
ifndef
DT_RELASZ
define
DT_RELASZ
endif
ifndef
DT_RELAENT
define
DT_RELAENT
endif
ifndef
DT_STRSZ
define
DT_STRSZ
endif
ifndef
DT_SYMENT
define
DT_SYMENT
endif
ifndef
DT_INIT
define
DT_INIT
endif
ifndef
DT_FINI
define
DT_FINI
endif
ifndef
DT_SONAME
define
DT_SONAME
endif
ifndef
DT_RPATH
define
DT_RPATH
endif
ifndef
DT_SYMBOLIC
define
DT_SYMBOLIC
endif
ifndef
DT_REL
define
DT_REL
endif
ifndef
DT_RELSZ
define
DT_RELSZ
endif
ifndef
DT_RELENT
define
DT_RELENT
endif
ifndef
DT_PLTREL
define
DT_PLTREL
endif
ifndef
DT_DEBUG
define
DT_DEBUG
endif
ifndef
DT_TEXTREL
define
DT_TEXTREL
endif
ifndef
DT_JMPREL
define
DT_JMPREL
endif
ifndef
SHN_UNDEF
define
SHN_UNDEF
endif
ifndef
SHN_LORESERVE
define
SHN_LORESERVE
endif
ifndef
SHN_LOPROC
define
SHN_LOPROC
endif
ifndef
SHN_HIPROC
define
SHN_HIPROC
endif
ifndef
SHN_ABS
define
SHN_ABS
endif
ifndef
SHN_COMMON
define
SHN_COMMON
endif
ifndef
SHN_HIRESERVE
define
SHN_HIRESERVE
endif
ifndef
EV_CURRENT
define
EV_CURRENT
endif
ifndef
EV_NONE
define
EV_NONE
endif
ifndef
EI_MAG0
define
EI_MAG0
endif
ifndef
EI_MAG1
define
EI_MAG1
endif
ifndef
EI_MAG2
define
EI_MAG2
endif
ifndef
EI_MAG3
define
EI_MAG3
endif
ifndef
EI_CLASS
define
EI_CLASS
endif
ifndef
EI_DATA
define
EI_DATA
endif
ifndef
EI_VERSION
define
EI_VERSION
endif
ifndef
EI_PAD
define
EI_PAD
endif
ifndef
EI_OSABI
define
EI_OSABI
endif
ifndef
EI_NIDENT
define
EI_NIDENT
endif
ifndef
EI_ABIVERSION
define
EI_ABIVERSION
endif
ifndef
ELFMAG0
define
ELFMAG0
endif
ifndef
ELFMAG1
define
ELFMAG1
E
endif
ifndef
ELFMAG2
define
ELFMAG2
L
endif
ifndef
ELFMAG3
define
ELFMAG3
F
endif
ifndef
ELFCLASSNONE
define
ELFCLASSNONE
endif
ifndef
ELFCLASS32
define
ELFCLASS32
endif
ifndef
ELFCLASS64
define
ELFCLASS64
endif
ifndef
ELFDATANONE
define
ELFDATANONE
endif
ifndef
ELFDATA2LSB
define
ELFDATA2LSB
endif
ifndef
ELFDATA2MSB
define
ELFDATA2MSB
endif
ifndef
ELFOSABI_NONE
define
ELFOSABI_NONE
endif
ifndef
ELFOSABI_SYSV
define
ELFOSABI_SYSV
endif
ifndef
ELFOSABI_HPUX
define
ELFOSABI_HPUX
endif
ifndef
ELFOSABI_NETBSD
define
ELFOSABI_NETBSD
endif
ifndef
ELFOSABI_GNU
define
ELFOSABI_GNU
endif
ifndef
ELFOSABI_LINUX
define
ELFOSABI_LINUX
ELFOSABI_GNU
endif
ifndef
ELFOSABI_SOLARIS
define
ELFOSABI_SOLARIS
endif
ifndef
ELFOSABI_AIX
define
ELFOSABI_AIX
endif
ifndef
ELFOSABI_IRIX
define
ELFOSABI_IRIX
endif
ifndef
ELFOSABI_FREEBSD
define
ELFOSABI_FREEBSD
endif
ifndef
ELFOSABI_TRU64
define
ELFOSABI_TRU64
endif
ifndef
ELFOSABI_MODESTO
define
ELFOSABI_MODESTO
endif
ifndef
ELFOSABI_OPENBSD
define
ELFOSABI_OPENBSD
endif
ifndef
ELFOSABI_ARM_AEABI
define
ELFOSABI_ARM_AEABI
endif
ifndef
ELFOSABI_ARM
define
ELFOSABI_ARM
endif
ifndef
ELFOSABI_STANDALONE
define
ELFOSABI_STANDALONE
endif
for
the
producer
code
ifndef
R_MIPS_NONE
define
R_MIPS_NONE
endif
ifndef
R_QUALCOMM_REL32
define
R_QUALCOMM_REL32
endif
For
Freebsd
ifndef
R_PPC64_ADDR32
define
R_PPC64_ADDR32
endif
ifndef
R_PPC64_DTPREL32
define
R_PPC64_DTPREL32
endif
ifndef
R_PPC64_DTPREL64
define
R_PPC64_DTPREL64
endif
ifndef
R_PPC_DTPREL32
define
R_PPC_DTPREL32
endif
The
following
two
probably
useless
ifndef
R_X86_64_PC32_BND
define
R_X86_64_PC32_BND
endif
ifndef
R_X86_64_PLT32_BND
define
R_X86_64_PLT32_BND
endif
Seen
in
a
Linux
Kernel
Means
nothing
to
do
ifndef
R_X86_64_NONE
define
R_X86_64_NONE
endif
R_X86_64_NONE
ifndef
R_386_32
define
R_386_32
endif
R_386_32
ifndef
R_386_GOTPC
define
R_386_GOTPC
endif
R_386_GOTPC
ifndef
R_386_PC32
define
R_386_PC32
endif
R_386_PC32
ifndef
R_386_TLS_DTPOFF32
define
R_386_TLS_DTPOFF32
endif
R_386_TLS_DTPOFF32
ifndef
R_386_TLS_LDO_32
define
R_386_TLS_LDO_32
endif
R_386_TLS_LDO_32
ifndef
R_390_32
define
R_390_32
endif
R_390_32
ifndef
R_390_64
define
R_390_64
endif
R_390_64
ifndef
R_390_TLS_LDO32
define
R_390_TLS_LDO32
endif
R_390_TLS_LDO32
ifndef
R_390_TLS_LDO64
define
R_390_TLS_LDO64
endif
R_390_TLS_LDO64
ifndef
R_AARCH64_ABS32
define
R_AARCH64_ABS32
endif
R_AARCH64_ABS32
ifndef
R_AARCH64_ABS64
define
R_AARCH64_ABS64
endif
R_AARCH64_ABS64
ifndef
R_ARM_ABS32
define
R_ARM_ABS32
endif
R_ARM_ABS32
ifndef
R_ARM_TLS_LDO32
define
R_ARM_TLS_LDO32
endif
R_ARM_TLS_LDO32
ifndef
R_IA64_DIR32LSB
define
R_IA64_DIR32LSB
endif
R_IA64_DIR32LSB
ifndef
R_IA64_DIR64LSB
define
R_IA64_DIR64LSB
endif
R_IA64_DIR64LSB
ifndef
R_IA64_DTPREL32LSB
define
R_IA64_DTPREL32LSB
endif
R_IA64_DTPREL32LSB
ifndef
R_IA64_DTPREL64LSB
define
R_IA64_DTPREL64LSB
endif
R_IA64_DTPREL64LSB
ifndef
R_IA64_REL32LSB
define
R_IA64_REL32LSB
endif
R_IA64_REL32LSB
ifndef
R_IA64_SECREL32LSB
define
R_IA64_SECREL32LSB
endif
R_IA64_SECREL32LSB
ifndef
R_IA64_SECREL64LSB
define
R_IA64_SECREL64LSB
endif
R_IA64_SECREL64LSB
ifndef
R_MIPS_32
define
R_MIPS_32
endif
R_MIPS_32
ifndef
R_MIPS_64
define
R_MIPS_64
endif
R_MIPS_64
ifndef
R_MIPS_TLS_DTPREL32
define
R_MIPS_TLS_DTPREL32
endif
R_MIPS_TLS_DTPREL32
ifndef
R_MIPS_TLS_DTPREL64
define
R_MIPS_TLS_DTPREL64
endif
R_MIPS_TLS_DTPREL64
ifndef
R_PPC64_ADDR64
define
R_PPC64_ADDR64
endif
R_PPC64_ADDR64
ifndef
R_PPC64_DTPREL32
define
R_PPC64_DTPREL32
endif
R_PPC64_DTPREL32
ifndef
R_PPC64_DTPREL64
define
R_PPC64_DTPREL64
endif
R_PPC64_DTPREL64
ifndef
R_PPC_ADDR32
define
R_PPC_ADDR32
endif
R_PPC_ADDR32
ifndef
R_PPC_DTPREL32
define
R_PPC_DTPREL32
endif
R_PPC_DTPREL32
ifndef
R_QUALCOMM_REL32
define
R_QUALCOMM_REL32
endif
R_QUALCOMM_REL32
ifndef
R_SH_DIR32
define
R_SH_DIR32
endif
R_SH_DIR32
ifndef
R_SH_TLS_DTPOFF32
define
R_SH_TLS_DTPOFF32
endif
R_SH_TLS_DTPOFF32
ifndef
R_SPARC_TLS_DTPOFF32
define
R_SPARC_TLS_DTPOFF32
endif
R_SPARC_TLS_DTPOFF32
ifndef
R_SPARC_TLS_DTPOFF64
define
R_SPARC_TLS_DTPOFF64
endif
R_SPARC_TLS_DTPOFF64
ifndef
R_SPARC_UA32
define
R_SPARC_UA32
endif
R_SPARC_UA32
ifndef
R_SPARC_UA64
define
R_SPARC_UA64
endif
R_SPARC_UA64
ifndef
R_X86_64_32
define
R_X86_64_32
endif
R_X86_64_32
ifndef
R_X86_64_64
define
R_X86_64_64
endif
R_X86_64_64
ifndef
R_X86_64_PC64
define
R_X86_64_PC64
endif
R_X86_64_PC64
ifndef
R_X86_64_DTPOFF32
define
R_X86_64_DTPOFF32
endif
R_X86_64_DTPOFF32
ifndef
R_X86_64_DTPOFF64
define
R_X86_64_DTPOFF64
endif
R_X86_64_DTPOFF64
ifndef
R_X86_64_PC32
define
R_X86_64_PC32
endif
R_X86_64_PC32
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_ELF_DEFINES_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_ELF_REL_DETECTOR_H
define
DWARF_ELF_REL_DETECTOR_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
unsigned
_dwarf_is_32bit_abs_reloc
unsigned
int
type
unsigned
machine
unsigned
_dwarf_is_64bit_abs_reloc
unsigned
int
type
unsigned
machine
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_ELF_REL_DETECTOR_H
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_386
unsigned
long
ifndef
R_386_NONE
define
R_386_NONE
endif
R_386_NONE
ifndef
R_386_32
define
R_386_32
endif
R_386_32
ifndef
R_386_PC32
define
R_386_PC32
endif
R_386_PC32
ifndef
R_386_GOT32
define
R_386_GOT32
endif
R_386_GOT32
ifndef
R_386_PLT32
define
R_386_PLT32
endif
R_386_PLT32
ifndef
R_386_COPY
define
R_386_COPY
endif
R_386_COPY
ifndef
R_386_GLOB_DAT
define
R_386_GLOB_DAT
endif
R_386_GLOB_DAT
ifndef
R_386_JMP_SLOT
define
R_386_JMP_SLOT
endif
R_386_JMP_SLOT
ifndef
R_386_RELATIVE
define
R_386_RELATIVE
endif
R_386_RELATIVE
ifndef
R_386_GOTOFF
define
R_386_GOTOFF
endif
R_386_GOTOFF
ifndef
R_386_GOTPC
define
R_386_GOTPC
endif
R_386_GOTPC
ifndef
R_386_32PLT
define
R_386_32PLT
endif
R_386_32PLT
ifndef
R_386_TLS_TPOFF
define
R_386_TLS_TPOFF
endif
R_386_TLS_TPOFF
ifndef
R_386_TLS_IE
define
R_386_TLS_IE
endif
R_386_TLS_IE
ifndef
R_386_TLS_GOTIE
define
R_386_TLS_GOTIE
endif
R_386_TLS_GOTIE
ifndef
R_386_TLS_LE
define
R_386_TLS_LE
endif
R_386_TLS_LE
ifndef
R_386_TLS_LDM
define
R_386_TLS_LDM
endif
R_386_TLS_LDM
ifndef
R_386_16
define
R_386_16
endif
R_386_16
ifndef
R_386_PC16
define
R_386_PC16
endif
R_386_PC16
ifndef
R_386_8
define
R_386_8
endif
R_386_8
ifndef
R_386_PC8
define
R_386_PC8
endif
R_386_PC8
ifndef
R_386_TLS_GD_32
define
R_386_TLS_GD_32
endif
R_386_TLS_GD_32
ifndef
R_386_TLS_GD_PUSH
define
R_386_TLS_GD_PUSH
endif
R_386_TLS_GD_PUSH
ifndef
R_386_TLS_GD_CALL
define
R_386_TLS_GD_CALL
endif
R_386_TLS_GD_CALL
ifndef
R_386_TLS_GD_POP
define
R_386_TLS_GD_POP
endif
R_386_TLS_GD_POP
ifndef
R_386_TLS_LDM_32
define
R_386_TLS_LDM_32
endif
R_386_TLS_LDM_32
ifndef
R_386_TLS_LDM_PUSH
define
R_386_TLS_LDM_PUSH
endif
R_386_TLS_LDM_PUSH
ifndef
R_386_TLS_LDM_CALL
define
R_386_TLS_LDM_CALL
endif
R_386_TLS_LDM_CALL
ifndef
R_386_TLS_LDM_POP
define
R_386_TLS_LDM_POP
endif
R_386_TLS_LDM_POP
ifndef
R_386_TLS_LDO_32
define
R_386_TLS_LDO_32
endif
R_386_TLS_LDO_32
ifndef
R_386_TLS_IE_32
define
R_386_TLS_IE_32
endif
R_386_TLS_IE_32
ifndef
R_386_TLS_LE_32
define
R_386_TLS_LE_32
endif
R_386_TLS_LE_32
ifndef
R_386_TLS_DTPMOD32
define
R_386_TLS_DTPMOD32
endif
R_386_TLS_DTPMOD32
ifndef
R_386_TLS_DTPOFF32
define
R_386_TLS_DTPOFF32
endif
R_386_TLS_DTPOFF32
ifndef
R_386_TLS_TPOFF32
define
R_386_TLS_TPOFF32
endif
R_386_TLS_TPOFF32
ifndef
R_386_SIZE32
define
R_386_SIZE32
endif
R_386_SIZE32
ifndef
R_386_TLS_GOTDESC
define
R_386_TLS_GOTDESC
endif
R_386_TLS_GOTDESC
ifndef
R_386_TLS_DESC_CALL
define
R_386_TLS_DESC_CALL
endif
R_386_TLS_DESC_CALL
ifndef
R_386_TLS_DESC
define
R_386_TLS_DESC
endif
R_386_TLS_DESC
ifndef
R_386_IRELATIVE
define
R_386_IRELATIVE
endif
R_386_IRELATIVE
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_aarch64
unsigned
long
ifndef
R_AARCH64_NONE
define
R_AARCH64_NONE
endif
R_AARCH64_NONE
ifndef
R_AARCH64_P32_ABS32
define
R_AARCH64_P32_ABS32
endif
R_AARCH64_P32_ABS32
ifndef
R_AARCH64_P32_COPY
define
R_AARCH64_P32_COPY
endif
R_AARCH64_P32_COPY
ifndef
R_AARCH64_P32_GLOB_DAT
define
R_AARCH64_P32_GLOB_DAT
endif
R_AARCH64_P32_GLOB_DAT
ifndef
R_AARCH64_P32_JUMP_SLOT
define
R_AARCH64_P32_JUMP_SLOT
endif
R_AARCH64_P32_JUMP_SLOT
ifndef
R_AARCH64_P32_RELATIVE
define
R_AARCH64_P32_RELATIVE
endif
R_AARCH64_P32_RELATIVE
ifndef
R_AARCH64_P32_TLS_DTPMOD
define
R_AARCH64_P32_TLS_DTPMOD
endif
R_AARCH64_P32_TLS_DTPMOD
ifndef
R_AARCH64_P32_TLS_DTPREL
define
R_AARCH64_P32_TLS_DTPREL
endif
R_AARCH64_P32_TLS_DTPREL
ifndef
R_AARCH64_P32_TLS_TPREL
define
R_AARCH64_P32_TLS_TPREL
endif
R_AARCH64_P32_TLS_TPREL
ifndef
R_AARCH64_P32_TLSDESC
define
R_AARCH64_P32_TLSDESC
endif
R_AARCH64_P32_TLSDESC
ifndef
R_AARCH64_P32_IRELATIVE
define
R_AARCH64_P32_IRELATIVE
endif
R_AARCH64_P32_IRELATIVE
ifndef
R_AARCH64_ABS64
define
R_AARCH64_ABS64
endif
R_AARCH64_ABS64
ifndef
R_AARCH64_ABS32
define
R_AARCH64_ABS32
endif
R_AARCH64_ABS32
ifndef
R_AARCH64_ABS16
define
R_AARCH64_ABS16
endif
R_AARCH64_ABS16
ifndef
R_AARCH64_PREL64
define
R_AARCH64_PREL64
endif
R_AARCH64_PREL64
ifndef
R_AARCH64_PREL32
define
R_AARCH64_PREL32
endif
R_AARCH64_PREL32
ifndef
R_AARCH64_PREL16
define
R_AARCH64_PREL16
endif
R_AARCH64_PREL16
ifndef
R_AARCH64_MOVW_UABS_G0
define
R_AARCH64_MOVW_UABS_G0
endif
R_AARCH64_MOVW_UABS_G0
ifndef
R_AARCH64_MOVW_UABS_G0_NC
define
R_AARCH64_MOVW_UABS_G0_NC
endif
R_AARCH64_MOVW_UABS_G0_NC
ifndef
R_AARCH64_MOVW_UABS_G1
define
R_AARCH64_MOVW_UABS_G1
endif
R_AARCH64_MOVW_UABS_G1
ifndef
R_AARCH64_MOVW_UABS_G1_NC
define
R_AARCH64_MOVW_UABS_G1_NC
endif
R_AARCH64_MOVW_UABS_G1_NC
ifndef
R_AARCH64_MOVW_UABS_G2
define
R_AARCH64_MOVW_UABS_G2
endif
R_AARCH64_MOVW_UABS_G2
ifndef
R_AARCH64_MOVW_UABS_G2_NC
define
R_AARCH64_MOVW_UABS_G2_NC
endif
R_AARCH64_MOVW_UABS_G2_NC
ifndef
R_AARCH64_MOVW_UABS_G3
define
R_AARCH64_MOVW_UABS_G3
endif
R_AARCH64_MOVW_UABS_G3
ifndef
R_AARCH64_MOVW_SABS_G0
define
R_AARCH64_MOVW_SABS_G0
endif
R_AARCH64_MOVW_SABS_G0
ifndef
R_AARCH64_MOVW_SABS_G1
define
R_AARCH64_MOVW_SABS_G1
endif
R_AARCH64_MOVW_SABS_G1
ifndef
R_AARCH64_MOVW_SABS_G2
define
R_AARCH64_MOVW_SABS_G2
endif
R_AARCH64_MOVW_SABS_G2
ifndef
R_AARCH64_LD_PREL_LO19
define
R_AARCH64_LD_PREL_LO19
endif
R_AARCH64_LD_PREL_LO19
ifndef
R_AARCH64_ADR_PREL_LO21
define
R_AARCH64_ADR_PREL_LO21
endif
R_AARCH64_ADR_PREL_LO21
ifndef
R_AARCH64_ADR_PREL_PG_HI21
define
R_AARCH64_ADR_PREL_PG_HI21
endif
R_AARCH64_ADR_PREL_PG_HI21
ifndef
R_AARCH64_ADR_PREL_PG_HI21_NC
define
R_AARCH64_ADR_PREL_PG_HI21_NC
endif
R_AARCH64_ADR_PREL_PG_HI21_NC
ifndef
R_AARCH64_ADD_ABS_LO12_NC
define
R_AARCH64_ADD_ABS_LO12_NC
endif
R_AARCH64_ADD_ABS_LO12_NC
ifndef
R_AARCH64_LDST8_ABS_LO12_NC
define
R_AARCH64_LDST8_ABS_LO12_NC
endif
R_AARCH64_LDST8_ABS_LO12_NC
ifndef
R_AARCH64_TSTBR14
define
R_AARCH64_TSTBR14
endif
R_AARCH64_TSTBR14
ifndef
R_AARCH64_CONDBR19
define
R_AARCH64_CONDBR19
endif
R_AARCH64_CONDBR19
ifndef
R_AARCH64_JUMP26
define
R_AARCH64_JUMP26
endif
R_AARCH64_JUMP26
ifndef
R_AARCH64_CALL26
define
R_AARCH64_CALL26
endif
R_AARCH64_CALL26
ifndef
R_AARCH64_LDST16_ABS_LO12_NC
define
R_AARCH64_LDST16_ABS_LO12_NC
endif
R_AARCH64_LDST16_ABS_LO12_NC
ifndef
R_AARCH64_LDST32_ABS_LO12_NC
define
R_AARCH64_LDST32_ABS_LO12_NC
endif
R_AARCH64_LDST32_ABS_LO12_NC
ifndef
R_AARCH64_LDST64_ABS_LO12_NC
define
R_AARCH64_LDST64_ABS_LO12_NC
endif
R_AARCH64_LDST64_ABS_LO12_NC
ifndef
R_AARCH64_MOVW_PREL_G0
define
R_AARCH64_MOVW_PREL_G0
endif
R_AARCH64_MOVW_PREL_G0
ifndef
R_AARCH64_MOVW_PREL_G0_NC
define
R_AARCH64_MOVW_PREL_G0_NC
endif
R_AARCH64_MOVW_PREL_G0_NC
ifndef
R_AARCH64_MOVW_PREL_G1
define
R_AARCH64_MOVW_PREL_G1
endif
R_AARCH64_MOVW_PREL_G1
ifndef
R_AARCH64_MOVW_PREL_G1_NC
define
R_AARCH64_MOVW_PREL_G1_NC
endif
R_AARCH64_MOVW_PREL_G1_NC
ifndef
R_AARCH64_MOVW_PREL_G2
define
R_AARCH64_MOVW_PREL_G2
endif
R_AARCH64_MOVW_PREL_G2
ifndef
R_AARCH64_MOVW_PREL_G2_NC
define
R_AARCH64_MOVW_PREL_G2_NC
endif
R_AARCH64_MOVW_PREL_G2_NC
ifndef
R_AARCH64_MOVW_PREL_G3
define
R_AARCH64_MOVW_PREL_G3
endif
R_AARCH64_MOVW_PREL_G3
ifndef
R_AARCH64_LDST128_ABS_LO12_NC
define
R_AARCH64_LDST128_ABS_LO12_NC
endif
R_AARCH64_LDST128_ABS_LO12_NC
ifndef
R_AARCH64_MOVW_GOTOFF_G0
define
R_AARCH64_MOVW_GOTOFF_G0
endif
R_AARCH64_MOVW_GOTOFF_G0
ifndef
R_AARCH64_MOVW_GOTOFF_G0_NC
define
R_AARCH64_MOVW_GOTOFF_G0_NC
endif
R_AARCH64_MOVW_GOTOFF_G0_NC
ifndef
R_AARCH64_MOVW_GOTOFF_G1
define
R_AARCH64_MOVW_GOTOFF_G1
endif
R_AARCH64_MOVW_GOTOFF_G1
ifndef
R_AARCH64_MOVW_GOTOFF_G1_NC
define
R_AARCH64_MOVW_GOTOFF_G1_NC
endif
R_AARCH64_MOVW_GOTOFF_G1_NC
ifndef
R_AARCH64_MOVW_GOTOFF_G2
define
R_AARCH64_MOVW_GOTOFF_G2
endif
R_AARCH64_MOVW_GOTOFF_G2
ifndef
R_AARCH64_MOVW_GOTOFF_G2_NC
define
R_AARCH64_MOVW_GOTOFF_G2_NC
endif
R_AARCH64_MOVW_GOTOFF_G2_NC
ifndef
R_AARCH64_MOVW_GOTOFF_G3
define
R_AARCH64_MOVW_GOTOFF_G3
endif
R_AARCH64_MOVW_GOTOFF_G3
ifndef
R_AARCH64_GOTREL64
define
R_AARCH64_GOTREL64
endif
R_AARCH64_GOTREL64
ifndef
R_AARCH64_GOTREL32
define
R_AARCH64_GOTREL32
endif
R_AARCH64_GOTREL32
ifndef
R_AARCH64_GOT_LD_PREL19
define
R_AARCH64_GOT_LD_PREL19
endif
R_AARCH64_GOT_LD_PREL19
ifndef
R_AARCH64_LD64_GOTOFF_LO15
define
R_AARCH64_LD64_GOTOFF_LO15
endif
R_AARCH64_LD64_GOTOFF_LO15
ifndef
R_AARCH64_ADR_GOT_PAGE
define
R_AARCH64_ADR_GOT_PAGE
endif
R_AARCH64_ADR_GOT_PAGE
ifndef
R_AARCH64_LD64_GOT_LO12_NC
define
R_AARCH64_LD64_GOT_LO12_NC
endif
R_AARCH64_LD64_GOT_LO12_NC
ifndef
R_AARCH64_LD64_GOTPAGE_LO15
define
R_AARCH64_LD64_GOTPAGE_LO15
endif
R_AARCH64_LD64_GOTPAGE_LO15
ifndef
R_AARCH64_TLSGD_ADR_PREL21
define
R_AARCH64_TLSGD_ADR_PREL21
endif
R_AARCH64_TLSGD_ADR_PREL21
ifndef
R_AARCH64_TLSGD_ADR_PAGE21
define
R_AARCH64_TLSGD_ADR_PAGE21
endif
R_AARCH64_TLSGD_ADR_PAGE21
ifndef
R_AARCH64_TLSGD_ADD_LO12_NC
define
R_AARCH64_TLSGD_ADD_LO12_NC
endif
R_AARCH64_TLSGD_ADD_LO12_NC
ifndef
R_AARCH64_TLSGD_MOVW_G1
define
R_AARCH64_TLSGD_MOVW_G1
endif
R_AARCH64_TLSGD_MOVW_G1
ifndef
R_AARCH64_TLSGD_MOVW_G0_NC
define
R_AARCH64_TLSGD_MOVW_G0_NC
endif
R_AARCH64_TLSGD_MOVW_G0_NC
ifndef
R_AARCH64_TLSLD_ADR_PREL21
define
R_AARCH64_TLSLD_ADR_PREL21
endif
R_AARCH64_TLSLD_ADR_PREL21
ifndef
R_AARCH64_TLSLD_ADR_PAGE21
define
R_AARCH64_TLSLD_ADR_PAGE21
endif
R_AARCH64_TLSLD_ADR_PAGE21
ifndef
R_AARCH64_TLSLD_ADD_LO12_NC
define
R_AARCH64_TLSLD_ADD_LO12_NC
endif
R_AARCH64_TLSLD_ADD_LO12_NC
ifndef
R_AARCH64_TLSLD_MOVW_G1
define
R_AARCH64_TLSLD_MOVW_G1
endif
R_AARCH64_TLSLD_MOVW_G1
ifndef
R_AARCH64_TLSLD_MOVW_G0_NC
define
R_AARCH64_TLSLD_MOVW_G0_NC
endif
R_AARCH64_TLSLD_MOVW_G0_NC
ifndef
R_AARCH64_TLSLD_LD_PREL19
define
R_AARCH64_TLSLD_LD_PREL19
endif
R_AARCH64_TLSLD_LD_PREL19
ifndef
R_AARCH64_TLSLD_MOVW_DTPREL_G2
define
R_AARCH64_TLSLD_MOVW_DTPREL_G2
endif
R_AARCH64_TLSLD_MOVW_DTPREL_G2
ifndef
R_AARCH64_TLSLD_MOVW_DTPREL_G1
define
R_AARCH64_TLSLD_MOVW_DTPREL_G1
endif
R_AARCH64_TLSLD_MOVW_DTPREL_G1
ifndef
R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
define
R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
endif
R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC
ifndef
R_AARCH64_TLSLD_MOVW_DTPREL_G0
define
R_AARCH64_TLSLD_MOVW_DTPREL_G0
endif
R_AARCH64_TLSLD_MOVW_DTPREL_G0
ifndef
R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
define
R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
endif
R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC
ifndef
R_AARCH64_TLSLD_ADD_DTPREL_HI12
define
R_AARCH64_TLSLD_ADD_DTPREL_HI12
endif
R_AARCH64_TLSLD_ADD_DTPREL_HI12
ifndef
R_AARCH64_TLSLD_ADD_DTPREL_LO12
define
R_AARCH64_TLSLD_ADD_DTPREL_LO12
endif
R_AARCH64_TLSLD_ADD_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC
ifndef
R_AARCH64_TLSLD_LDST8_DTPREL_LO12
define
R_AARCH64_TLSLD_LDST8_DTPREL_LO12
endif
R_AARCH64_TLSLD_LDST8_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC
ifndef
R_AARCH64_TLSLD_LDST16_DTPREL_LO12
define
R_AARCH64_TLSLD_LDST16_DTPREL_LO12
endif
R_AARCH64_TLSLD_LDST16_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC
ifndef
R_AARCH64_TLSLD_LDST32_DTPREL_LO12
define
R_AARCH64_TLSLD_LDST32_DTPREL_LO12
endif
R_AARCH64_TLSLD_LDST32_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC
ifndef
R_AARCH64_TLSLD_LDST64_DTPREL_LO12
define
R_AARCH64_TLSLD_LDST64_DTPREL_LO12
endif
R_AARCH64_TLSLD_LDST64_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC
ifndef
R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
define
R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
endif
R_AARCH64_TLSIE_MOVW_GOTTPREL_G1
ifndef
R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
define
R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
endif
R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC
ifndef
R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
define
R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
endif
R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21
ifndef
R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
define
R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
endif
R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC
ifndef
R_AARCH64_TLSIE_LD_GOTTPREL_PREL19
define
R_AARCH64_TLSIE_LD_GOTTPREL_PREL19
endif
R_AARCH64_TLSIE_LD_GOTTPREL_PREL19
ifndef
R_AARCH64_TLSLE_MOVW_TPREL_G2
define
R_AARCH64_TLSLE_MOVW_TPREL_G2
endif
R_AARCH64_TLSLE_MOVW_TPREL_G2
ifndef
R_AARCH64_TLSLE_MOVW_TPREL_G1
define
R_AARCH64_TLSLE_MOVW_TPREL_G1
endif
R_AARCH64_TLSLE_MOVW_TPREL_G1
ifndef
R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
define
R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
endif
R_AARCH64_TLSLE_MOVW_TPREL_G1_NC
ifndef
R_AARCH64_TLSLE_MOVW_TPREL_G0
define
R_AARCH64_TLSLE_MOVW_TPREL_G0
endif
R_AARCH64_TLSLE_MOVW_TPREL_G0
ifndef
R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
define
R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
endif
R_AARCH64_TLSLE_MOVW_TPREL_G0_NC
ifndef
R_AARCH64_TLSLE_ADD_TPREL_HI12
define
R_AARCH64_TLSLE_ADD_TPREL_HI12
endif
R_AARCH64_TLSLE_ADD_TPREL_HI12
ifndef
R_AARCH64_TLSLE_ADD_TPREL_LO12
define
R_AARCH64_TLSLE_ADD_TPREL_LO12
endif
R_AARCH64_TLSLE_ADD_TPREL_LO12
ifndef
R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
define
R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_ADD_TPREL_LO12_NC
ifndef
R_AARCH64_TLSLE_LDST8_TPREL_LO12
define
R_AARCH64_TLSLE_LDST8_TPREL_LO12
endif
R_AARCH64_TLSLE_LDST8_TPREL_LO12
ifndef
R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
define
R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC
ifndef
R_AARCH64_TLSLE_LDST16_TPREL_LO12
define
R_AARCH64_TLSLE_LDST16_TPREL_LO12
endif
R_AARCH64_TLSLE_LDST16_TPREL_LO12
ifndef
R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
define
R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC
ifndef
R_AARCH64_TLSLE_LDST32_TPREL_LO12
define
R_AARCH64_TLSLE_LDST32_TPREL_LO12
endif
R_AARCH64_TLSLE_LDST32_TPREL_LO12
ifndef
R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
define
R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC
ifndef
R_AARCH64_TLSLE_LDST64_TPREL_LO12
define
R_AARCH64_TLSLE_LDST64_TPREL_LO12
endif
R_AARCH64_TLSLE_LDST64_TPREL_LO12
ifndef
R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC
define
R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC
ifndef
R_AARCH64_TLSDESC_LD_PREL19
define
R_AARCH64_TLSDESC_LD_PREL19
endif
R_AARCH64_TLSDESC_LD_PREL19
ifndef
R_AARCH64_TLSDESC_ADR_PREL21
define
R_AARCH64_TLSDESC_ADR_PREL21
endif
R_AARCH64_TLSDESC_ADR_PREL21
ifndef
R_AARCH64_TLSDESC_ADR_PAGE21
define
R_AARCH64_TLSDESC_ADR_PAGE21
endif
R_AARCH64_TLSDESC_ADR_PAGE21
ifndef
R_AARCH64_TLSDESC_LD64_LO12
define
R_AARCH64_TLSDESC_LD64_LO12
endif
R_AARCH64_TLSDESC_LD64_LO12
ifndef
R_AARCH64_TLSDESC_ADD_LO12
define
R_AARCH64_TLSDESC_ADD_LO12
endif
R_AARCH64_TLSDESC_ADD_LO12
ifndef
R_AARCH64_TLSDESC_OFF_G1
define
R_AARCH64_TLSDESC_OFF_G1
endif
R_AARCH64_TLSDESC_OFF_G1
ifndef
R_AARCH64_TLSDESC_OFF_G0_NC
define
R_AARCH64_TLSDESC_OFF_G0_NC
endif
R_AARCH64_TLSDESC_OFF_G0_NC
ifndef
R_AARCH64_TLSDESC_LDR
define
R_AARCH64_TLSDESC_LDR
endif
R_AARCH64_TLSDESC_LDR
ifndef
R_AARCH64_TLSDESC_ADD
define
R_AARCH64_TLSDESC_ADD
endif
R_AARCH64_TLSDESC_ADD
ifndef
R_AARCH64_TLSDESC_CALL
define
R_AARCH64_TLSDESC_CALL
endif
R_AARCH64_TLSDESC_CALL
ifndef
R_AARCH64_TLSLE_LDST128_TPREL_LO12
define
R_AARCH64_TLSLE_LDST128_TPREL_LO12
endif
R_AARCH64_TLSLE_LDST128_TPREL_LO12
ifndef
R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC
define
R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC
endif
R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC
ifndef
R_AARCH64_TLSLD_LDST128_DTPREL_LO12
define
R_AARCH64_TLSLD_LDST128_DTPREL_LO12
endif
R_AARCH64_TLSLD_LDST128_DTPREL_LO12
ifndef
R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC
define
R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC
endif
R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC
ifndef
R_AARCH64_COPY
define
R_AARCH64_COPY
endif
R_AARCH64_COPY
ifndef
R_AARCH64_GLOB_DAT
define
R_AARCH64_GLOB_DAT
endif
R_AARCH64_GLOB_DAT
ifndef
R_AARCH64_JUMP_SLOT
define
R_AARCH64_JUMP_SLOT
endif
R_AARCH64_JUMP_SLOT
ifndef
R_AARCH64_RELATIVE
define
R_AARCH64_RELATIVE
endif
R_AARCH64_RELATIVE
ifndef
R_AARCH64_TLS_DTPMOD
define
R_AARCH64_TLS_DTPMOD
endif
R_AARCH64_TLS_DTPMOD
ifndef
R_AARCH64_TLS_DTPREL
define
R_AARCH64_TLS_DTPREL
endif
R_AARCH64_TLS_DTPREL
ifndef
R_AARCH64_TLS_TPREL
define
R_AARCH64_TLS_TPREL
endif
R_AARCH64_TLS_TPREL
ifndef
R_AARCH64_TLSDESC
define
R_AARCH64_TLSDESC
endif
R_AARCH64_TLSDESC
ifndef
R_AARCH64_IRELATIVE
define
R_AARCH64_IRELATIVE
endif
R_AARCH64_IRELATIVE
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_arm
unsigned
long
ifndef
R_ARM_NONE
define
R_ARM_NONE
endif
R_ARM_NONE
ifndef
R_ARM_PC24
define
R_ARM_PC24
endif
R_ARM_PC24
ifndef
R_ARM_ABS32
define
R_ARM_ABS32
endif
R_ARM_ABS32
ifndef
R_ARM_REL32
define
R_ARM_REL32
endif
R_ARM_REL32
ifndef
R_ARM_LDR_PC_G0
define
R_ARM_LDR_PC_G0
endif
R_ARM_LDR_PC_G0
ifndef
R_ARM_ABS16
define
R_ARM_ABS16
endif
R_ARM_ABS16
ifndef
R_ARM_ABS12
define
R_ARM_ABS12
endif
R_ARM_ABS12
ifndef
R_ARM_THM_ABS5
define
R_ARM_THM_ABS5
endif
R_ARM_THM_ABS5
ifndef
R_ARM_ABS8
define
R_ARM_ABS8
endif
R_ARM_ABS8
ifndef
R_ARM_SBREL32
define
R_ARM_SBREL32
endif
R_ARM_SBREL32
ifndef
R_ARM_THM_CALL
define
R_ARM_THM_CALL
endif
R_ARM_THM_CALL
ifndef
R_ARM_THM_PC8
define
R_ARM_THM_PC8
endif
R_ARM_THM_PC8
ifndef
R_ARM_BREL_ADJ
define
R_ARM_BREL_ADJ
endif
R_ARM_BREL_ADJ
ifndef
R_ARM_TLS_DESC
define
R_ARM_TLS_DESC
endif
R_ARM_TLS_DESC
ifndef
R_ARM_THM_SWI8
define
R_ARM_THM_SWI8
endif
R_ARM_THM_SWI8
ifndef
R_ARM_XPC25
define
R_ARM_XPC25
endif
R_ARM_XPC25
ifndef
R_ARM_THM_XPC22
define
R_ARM_THM_XPC22
endif
R_ARM_THM_XPC22
ifndef
R_ARM_TLS_DTPMOD32
define
R_ARM_TLS_DTPMOD32
endif
R_ARM_TLS_DTPMOD32
ifndef
R_ARM_TLS_DTPOFF32
define
R_ARM_TLS_DTPOFF32
endif
R_ARM_TLS_DTPOFF32
ifndef
R_ARM_TLS_TPOFF32
define
R_ARM_TLS_TPOFF32
endif
R_ARM_TLS_TPOFF32
ifndef
R_ARM_COPY
define
R_ARM_COPY
endif
R_ARM_COPY
ifndef
R_ARM_GLOB_DAT
define
R_ARM_GLOB_DAT
endif
R_ARM_GLOB_DAT
ifndef
R_ARM_JUMP_SLOT
define
R_ARM_JUMP_SLOT
endif
R_ARM_JUMP_SLOT
ifndef
R_ARM_RELATIVE
define
R_ARM_RELATIVE
endif
R_ARM_RELATIVE
ifndef
R_ARM_GOTOFF32
define
R_ARM_GOTOFF32
endif
R_ARM_GOTOFF32
ifndef
R_ARM_BASE_PREL
define
R_ARM_BASE_PREL
endif
R_ARM_BASE_PREL
ifndef
R_ARM_GOT_BREL
define
R_ARM_GOT_BREL
endif
R_ARM_GOT_BREL
ifndef
R_ARM_PLT32
define
R_ARM_PLT32
endif
R_ARM_PLT32
ifndef
R_ARM_CALL
define
R_ARM_CALL
endif
R_ARM_CALL
ifndef
R_ARM_JUMP24
define
R_ARM_JUMP24
endif
R_ARM_JUMP24
ifndef
R_ARM_THM_JUMP24
define
R_ARM_THM_JUMP24
endif
R_ARM_THM_JUMP24
ifndef
R_ARM_BASE_ABS
define
R_ARM_BASE_ABS
endif
R_ARM_BASE_ABS
ifndef
R_ARM_ALU_PCREL_7_0
define
R_ARM_ALU_PCREL_7_0
endif
R_ARM_ALU_PCREL_7_0
ifndef
R_ARM_ALU_PCREL_15_8
define
R_ARM_ALU_PCREL_15_8
endif
R_ARM_ALU_PCREL_15_8
ifndef
R_ARM_ALU_PCREL_23_15
define
R_ARM_ALU_PCREL_23_15
endif
R_ARM_ALU_PCREL_23_15
ifndef
R_ARM_LDR_SBREL_11_0_NC
define
R_ARM_LDR_SBREL_11_0_NC
endif
R_ARM_LDR_SBREL_11_0_NC
ifndef
R_ARM_ALU_SBREL_19_12_NC
define
R_ARM_ALU_SBREL_19_12_NC
endif
R_ARM_ALU_SBREL_19_12_NC
ifndef
R_ARM_ALU_SBREL_27_20_CK
define
R_ARM_ALU_SBREL_27_20_CK
endif
R_ARM_ALU_SBREL_27_20_CK
ifndef
R_ARM_TARGET1
define
R_ARM_TARGET1
endif
R_ARM_TARGET1
ifndef
R_ARM_SBREL31
define
R_ARM_SBREL31
endif
R_ARM_SBREL31
ifndef
R_ARM_V4BX
define
R_ARM_V4BX
endif
R_ARM_V4BX
ifndef
R_ARM_TARGET2
define
R_ARM_TARGET2
endif
R_ARM_TARGET2
ifndef
R_ARM_PREL31
define
R_ARM_PREL31
endif
R_ARM_PREL31
ifndef
R_ARM_MOVW_ABS_NC
define
R_ARM_MOVW_ABS_NC
endif
R_ARM_MOVW_ABS_NC
ifndef
R_ARM_MOVT_ABS
define
R_ARM_MOVT_ABS
endif
R_ARM_MOVT_ABS
ifndef
R_ARM_MOVW_PREL_NC
define
R_ARM_MOVW_PREL_NC
endif
R_ARM_MOVW_PREL_NC
ifndef
R_ARM_MOVT_PREL
define
R_ARM_MOVT_PREL
endif
R_ARM_MOVT_PREL
ifndef
R_ARM_THM_MOVW_ABS_NC
define
R_ARM_THM_MOVW_ABS_NC
endif
R_ARM_THM_MOVW_ABS_NC
ifndef
R_ARM_THM_MOVT_ABS
define
R_ARM_THM_MOVT_ABS
endif
R_ARM_THM_MOVT_ABS
ifndef
R_ARM_THM_MOVW_PREL_NC
define
R_ARM_THM_MOVW_PREL_NC
endif
R_ARM_THM_MOVW_PREL_NC
ifndef
R_ARM_THM_MOVT_PREL
define
R_ARM_THM_MOVT_PREL
endif
R_ARM_THM_MOVT_PREL
ifndef
R_ARM_THM_JUMP19
define
R_ARM_THM_JUMP19
endif
R_ARM_THM_JUMP19
ifndef
R_ARM_THM_JUMP6
define
R_ARM_THM_JUMP6
endif
R_ARM_THM_JUMP6
ifndef
R_ARM_THM_ALU_PREL_11_0
define
R_ARM_THM_ALU_PREL_11_0
endif
R_ARM_THM_ALU_PREL_11_0
ifndef
R_ARM_THM_PC12
define
R_ARM_THM_PC12
endif
R_ARM_THM_PC12
ifndef
R_ARM_ABS32_NOI
define
R_ARM_ABS32_NOI
endif
R_ARM_ABS32_NOI
ifndef
R_ARM_REL32_NOI
define
R_ARM_REL32_NOI
endif
R_ARM_REL32_NOI
ifndef
R_ARM_ALU_PC_G0_NC
define
R_ARM_ALU_PC_G0_NC
endif
R_ARM_ALU_PC_G0_NC
ifndef
R_ARM_ALU_PC_G0
define
R_ARM_ALU_PC_G0
endif
R_ARM_ALU_PC_G0
ifndef
R_ARM_ALU_PC_G1_NC
define
R_ARM_ALU_PC_G1_NC
endif
R_ARM_ALU_PC_G1_NC
ifndef
R_ARM_ALU_PC_G1
define
R_ARM_ALU_PC_G1
endif
R_ARM_ALU_PC_G1
ifndef
R_ARM_ALU_PC_G2
define
R_ARM_ALU_PC_G2
endif
R_ARM_ALU_PC_G2
ifndef
R_ARM_LDR_PC_G1
define
R_ARM_LDR_PC_G1
endif
R_ARM_LDR_PC_G1
ifndef
R_ARM_LDR_PC_G2
define
R_ARM_LDR_PC_G2
endif
R_ARM_LDR_PC_G2
ifndef
R_ARM_LDRS_PC_G0
define
R_ARM_LDRS_PC_G0
endif
R_ARM_LDRS_PC_G0
ifndef
R_ARM_LDRS_PC_G1
define
R_ARM_LDRS_PC_G1
endif
R_ARM_LDRS_PC_G1
ifndef
R_ARM_LDRS_PC_G2
define
R_ARM_LDRS_PC_G2
endif
R_ARM_LDRS_PC_G2
ifndef
R_ARM_LDC_PC_G0
define
R_ARM_LDC_PC_G0
endif
R_ARM_LDC_PC_G0
ifndef
R_ARM_LDC_PC_G1
define
R_ARM_LDC_PC_G1
endif
R_ARM_LDC_PC_G1
ifndef
R_ARM_LDC_PC_G2
define
R_ARM_LDC_PC_G2
endif
R_ARM_LDC_PC_G2
ifndef
R_ARM_ALU_SB_G0_NC
define
R_ARM_ALU_SB_G0_NC
endif
R_ARM_ALU_SB_G0_NC
ifndef
R_ARM_ALU_SB_G0
define
R_ARM_ALU_SB_G0
endif
R_ARM_ALU_SB_G0
ifndef
R_ARM_ALU_SB_G1_NC
define
R_ARM_ALU_SB_G1_NC
endif
R_ARM_ALU_SB_G1_NC
ifndef
R_ARM_ALU_SB_G1
define
R_ARM_ALU_SB_G1
endif
R_ARM_ALU_SB_G1
ifndef
R_ARM_ALU_SB_G2
define
R_ARM_ALU_SB_G2
endif
R_ARM_ALU_SB_G2
ifndef
R_ARM_LDR_SB_G0
define
R_ARM_LDR_SB_G0
endif
R_ARM_LDR_SB_G0
ifndef
R_ARM_LDR_SB_G1
define
R_ARM_LDR_SB_G1
endif
R_ARM_LDR_SB_G1
ifndef
R_ARM_LDR_SB_G2
define
R_ARM_LDR_SB_G2
endif
R_ARM_LDR_SB_G2
ifndef
R_ARM_LDRS_SB_G0
define
R_ARM_LDRS_SB_G0
endif
R_ARM_LDRS_SB_G0
ifndef
R_ARM_LDRS_SB_G1
define
R_ARM_LDRS_SB_G1
endif
R_ARM_LDRS_SB_G1
ifndef
R_ARM_LDRS_SB_G2
define
R_ARM_LDRS_SB_G2
endif
R_ARM_LDRS_SB_G2
ifndef
R_ARM_LDC_SB_G0
define
R_ARM_LDC_SB_G0
endif
R_ARM_LDC_SB_G0
ifndef
R_ARM_LDC_SB_G1
define
R_ARM_LDC_SB_G1
endif
R_ARM_LDC_SB_G1
ifndef
R_ARM_LDC_SB_G2
define
R_ARM_LDC_SB_G2
endif
R_ARM_LDC_SB_G2
ifndef
R_ARM_MOVW_BREL_NC
define
R_ARM_MOVW_BREL_NC
endif
R_ARM_MOVW_BREL_NC
ifndef
R_ARM_MOVT_BREL
define
R_ARM_MOVT_BREL
endif
R_ARM_MOVT_BREL
ifndef
R_ARM_MOVW_BREL
define
R_ARM_MOVW_BREL
endif
R_ARM_MOVW_BREL
ifndef
R_ARM_THM_MOVW_BREL_NC
define
R_ARM_THM_MOVW_BREL_NC
endif
R_ARM_THM_MOVW_BREL_NC
ifndef
R_ARM_THM_MOVT_BREL
define
R_ARM_THM_MOVT_BREL
endif
R_ARM_THM_MOVT_BREL
ifndef
R_ARM_THM_MOVW_BREL
define
R_ARM_THM_MOVW_BREL
endif
R_ARM_THM_MOVW_BREL
ifndef
R_ARM_TLS_GOTDESC
define
R_ARM_TLS_GOTDESC
endif
R_ARM_TLS_GOTDESC
ifndef
R_ARM_TLS_CALL
define
R_ARM_TLS_CALL
endif
R_ARM_TLS_CALL
ifndef
R_ARM_TLS_DESCSEQ
define
R_ARM_TLS_DESCSEQ
endif
R_ARM_TLS_DESCSEQ
ifndef
R_ARM_THM_TLS_CALL
define
R_ARM_THM_TLS_CALL
endif
R_ARM_THM_TLS_CALL
ifndef
R_ARM_PLT32_ABS
define
R_ARM_PLT32_ABS
endif
R_ARM_PLT32_ABS
ifndef
R_ARM_GOT_ABS
define
R_ARM_GOT_ABS
endif
R_ARM_GOT_ABS
ifndef
R_ARM_GOT_PREL
define
R_ARM_GOT_PREL
endif
R_ARM_GOT_PREL
ifndef
R_ARM_GOT_BREL12
define
R_ARM_GOT_BREL12
endif
R_ARM_GOT_BREL12
ifndef
R_ARM_GOTOFF12
define
R_ARM_GOTOFF12
endif
R_ARM_GOTOFF12
ifndef
R_ARM_GOTRELAX
define
R_ARM_GOTRELAX
endif
R_ARM_GOTRELAX
ifndef
R_ARM_GNU_VTENTRY
define
R_ARM_GNU_VTENTRY
endif
R_ARM_GNU_VTENTRY
ifndef
R_ARM_GNU_VTINHERIT
define
R_ARM_GNU_VTINHERIT
endif
R_ARM_GNU_VTINHERIT
ifndef
R_ARM_THM_JUMP11
define
R_ARM_THM_JUMP11
endif
R_ARM_THM_JUMP11
ifndef
R_ARM_THM_JUMP8
define
R_ARM_THM_JUMP8
endif
R_ARM_THM_JUMP8
ifndef
R_ARM_TLS_GD32
define
R_ARM_TLS_GD32
endif
R_ARM_TLS_GD32
ifndef
R_ARM_TLS_LDM32
define
R_ARM_TLS_LDM32
endif
R_ARM_TLS_LDM32
ifndef
R_ARM_TLS_LDO32
define
R_ARM_TLS_LDO32
endif
R_ARM_TLS_LDO32
ifndef
R_ARM_TLS_IE32
define
R_ARM_TLS_IE32
endif
R_ARM_TLS_IE32
ifndef
R_ARM_TLS_LE32
define
R_ARM_TLS_LE32
endif
R_ARM_TLS_LE32
ifndef
R_ARM_TLS_LDO12
define
R_ARM_TLS_LDO12
endif
R_ARM_TLS_LDO12
ifndef
R_ARM_TLS_LE12
define
R_ARM_TLS_LE12
endif
R_ARM_TLS_LE12
ifndef
R_ARM_TLS_IE12GP
define
R_ARM_TLS_IE12GP
endif
R_ARM_TLS_IE12GP
ifndef
R_ARM_ME_TOO
define
R_ARM_ME_TOO
endif
R_ARM_ME_TOO
ifndef
R_ARM_THM_TLS_DESCSEQ16
define
R_ARM_THM_TLS_DESCSEQ16
endif
R_ARM_THM_TLS_DESCSEQ16
ifndef
R_ARM_THM_TLS_DESCSEQ32
define
R_ARM_THM_TLS_DESCSEQ32
endif
R_ARM_THM_TLS_DESCSEQ32
ifndef
R_ARM_RXPC25
define
R_ARM_RXPC25
endif
R_ARM_RXPC25
ifndef
R_ARM_RSBREL32
define
R_ARM_RSBREL32
endif
R_ARM_RSBREL32
ifndef
R_ARM_THM_RPC22
define
R_ARM_THM_RPC22
endif
R_ARM_THM_RPC22
ifndef
R_ARM_RREL32
define
R_ARM_RREL32
endif
R_ARM_RREL32
ifndef
R_ARM_RABS32
define
R_ARM_RABS32
endif
R_ARM_RABS32
ifndef
R_ARM_RPC24
define
R_ARM_RPC24
endif
R_ARM_RPC24
ifndef
R_ARM_RBASE
define
R_ARM_RBASE
endif
R_ARM_RBASE
ifndef
R_ARM_NUM
define
R_ARM_NUM
endif
R_ARM_NUM
ifndef
R_AARCH64_ABS64
define
R_AARCH64_ABS64
endif
R_AARCH64_ABS64
ifndef
R_AARCH64_ABS32
define
R_AARCH64_ABS32
endif
R_AARCH64_ABS32
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_mips
unsigned
long
ifndef
R_MIPS_NONE
define
R_MIPS_NONE
endif
R_MIPS_NONE
ifndef
R_MIPS_16
define
R_MIPS_16
endif
R_MIPS_16
ifndef
R_MIPS_32
define
R_MIPS_32
endif
R_MIPS_32
ifndef
R_MIPS_REL
define
R_MIPS_REL
endif
R_MIPS_REL
ifndef
R_MIPS_26
define
R_MIPS_26
endif
R_MIPS_26
ifndef
R_MIPS_HI16
define
R_MIPS_HI16
endif
R_MIPS_HI16
ifndef
R_MIPS_LO16
define
R_MIPS_LO16
endif
R_MIPS_LO16
ifndef
R_MIPS_GPREL
define
R_MIPS_GPREL
endif
R_MIPS_GPREL
ifndef
R_MIPS_LITERAL
define
R_MIPS_LITERAL
endif
R_MIPS_LITERAL
ifndef
R_MIPS_GOT
define
R_MIPS_GOT
endif
R_MIPS_GOT
ifndef
R_MIPS_PC16
define
R_MIPS_PC16
endif
R_MIPS_PC16
ifndef
R_MIPS_CALL
define
R_MIPS_CALL
endif
R_MIPS_CALL
ifndef
R_MIPS_GPREL32
define
R_MIPS_GPREL32
endif
R_MIPS_GPREL32
ifndef
R_MIPS_UNUSED1
define
R_MIPS_UNUSED1
endif
R_MIPS_UNUSED1
ifndef
R_MIPS_UNUSED2
define
R_MIPS_UNUSED2
endif
R_MIPS_UNUSED2
ifndef
R_MIPS_UNUSED3
define
R_MIPS_UNUSED3
endif
R_MIPS_UNUSED3
ifndef
R_MIPS_SHIFT5
define
R_MIPS_SHIFT5
endif
R_MIPS_SHIFT5
ifndef
R_MIPS_SHIFT6
define
R_MIPS_SHIFT6
endif
R_MIPS_SHIFT6
ifndef
R_MIPS_64
define
R_MIPS_64
endif
R_MIPS_64
ifndef
R_MIPS_GOT_DISP
define
R_MIPS_GOT_DISP
endif
R_MIPS_GOT_DISP
ifndef
R_MIPS_GOT_PAGE
define
R_MIPS_GOT_PAGE
endif
R_MIPS_GOT_PAGE
ifndef
R_MIPS_GOT_OFST
define
R_MIPS_GOT_OFST
endif
R_MIPS_GOT_OFST
ifndef
R_MIPS_GOT_HI16
define
R_MIPS_GOT_HI16
endif
R_MIPS_GOT_HI16
ifndef
R_MIPS_GOT_LO16
define
R_MIPS_GOT_LO16
endif
R_MIPS_GOT_LO16
ifndef
R_MIPS_SUB
define
R_MIPS_SUB
endif
R_MIPS_SUB
ifndef
R_MIPS_INSERT_A
define
R_MIPS_INSERT_A
endif
R_MIPS_INSERT_A
ifndef
R_MIPS_INSERT_B
define
R_MIPS_INSERT_B
endif
R_MIPS_INSERT_B
ifndef
R_MIPS_DELETE
define
R_MIPS_DELETE
endif
R_MIPS_DELETE
ifndef
R_MIPS_HIGHER
define
R_MIPS_HIGHER
endif
R_MIPS_HIGHER
ifndef
R_MIPS_HIGHEST
define
R_MIPS_HIGHEST
endif
R_MIPS_HIGHEST
ifndef
R_MIPS_CALL_HI16
define
R_MIPS_CALL_HI16
endif
R_MIPS_CALL_HI16
ifndef
R_MIPS_CALL_LO16
define
R_MIPS_CALL_LO16
endif
R_MIPS_CALL_LO16
ifndef
R_MIPS_SCN_DISP
define
R_MIPS_SCN_DISP
endif
R_MIPS_SCN_DISP
ifndef
R_MIPS_REL16
define
R_MIPS_REL16
endif
R_MIPS_REL16
ifndef
R_MIPS_ADD_IMMEDIATE
define
R_MIPS_ADD_IMMEDIATE
endif
R_MIPS_ADD_IMMEDIATE
ifndef
R_MIPS_PJUMP
define
R_MIPS_PJUMP
endif
R_MIPS_PJUMP
ifndef
R_MIPS_RELGOT
define
R_MIPS_RELGOT
endif
R_MIPS_RELGOT
ifndef
R_MIPS_JALR
define
R_MIPS_JALR
endif
R_MIPS_JALR
ifndef
R_MIPS_TLS_DTPMOD32
define
R_MIPS_TLS_DTPMOD32
endif
R_MIPS_TLS_DTPMOD32
ifndef
R_MIPS_TLS_DTPREL32
define
R_MIPS_TLS_DTPREL32
endif
R_MIPS_TLS_DTPREL32
ifndef
R_MIPS_TLS_DTPMOD64
define
R_MIPS_TLS_DTPMOD64
endif
R_MIPS_TLS_DTPMOD64
ifndef
R_MIPS_TLS_DTPREL64
define
R_MIPS_TLS_DTPREL64
endif
R_MIPS_TLS_DTPREL64
ifndef
R_MIPS_TLS_GD
define
R_MIPS_TLS_GD
endif
R_MIPS_TLS_GD
ifndef
R_MIPS_TLS_LDM
define
R_MIPS_TLS_LDM
endif
R_MIPS_TLS_LDM
ifndef
R_MIPS_TLS_DTPREL_HI16
define
R_MIPS_TLS_DTPREL_HI16
endif
R_MIPS_TLS_DTPREL_HI16
ifndef
R_MIPS_TLS_DTPREL_LO16
define
R_MIPS_TLS_DTPREL_LO16
endif
R_MIPS_TLS_DTPREL_LO16
ifndef
R_MIPS_TLS_GOTTPREL
define
R_MIPS_TLS_GOTTPREL
endif
R_MIPS_TLS_GOTTPREL
ifndef
R_MIPS_TLS_TPREL32
define
R_MIPS_TLS_TPREL32
endif
R_MIPS_TLS_TPREL32
ifndef
R_MIPS_TLS_TPREL_HI16
define
R_MIPS_TLS_TPREL_HI16
endif
R_MIPS_TLS_TPREL_HI16
ifndef
R_MIPS_TLS_TPREL_LO16
define
R_MIPS_TLS_TPREL_LO16
endif
R_MIPS_TLS_TPREL_LO16
ifndef
R_MIPS_GLOB_DAT
define
R_MIPS_GLOB_DAT
endif
R_MIPS_GLOB_DAT
ifndef
R_MIPS_COPY
define
R_MIPS_COPY
endif
R_MIPS_COPY
ifndef
R_MIPS_JUMP_SLOT
define
R_MIPS_JUMP_SLOT
endif
R_MIPS_JUMP_SLOT
ifndef
R_MIPS_NUM
define
R_MIPS_NUM
endif
R_MIPS_NUM
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_ppc
unsigned
long
ifndef
R_PPC_NONE
define
R_PPC_NONE
endif
R_PPC_NONE
ifndef
R_PPC_ADDR32
define
R_PPC_ADDR32
endif
R_PPC_ADDR32
ifndef
R_PPC_ADDR24
define
R_PPC_ADDR24
endif
R_PPC_ADDR24
ifndef
R_PPC_ADDR16
define
R_PPC_ADDR16
endif
R_PPC_ADDR16
ifndef
R_PPC_ADDR16_LO
define
R_PPC_ADDR16_LO
endif
R_PPC_ADDR16_LO
ifndef
R_PPC_ADDR16_HI
define
R_PPC_ADDR16_HI
endif
R_PPC_ADDR16_HI
ifndef
R_PPC_ADDR16_HA
define
R_PPC_ADDR16_HA
endif
R_PPC_ADDR16_HA
ifndef
R_PPC_ADDR14
define
R_PPC_ADDR14
endif
R_PPC_ADDR14
ifndef
R_PPC_ADDR14_BRTAKEN
define
R_PPC_ADDR14_BRTAKEN
endif
R_PPC_ADDR14_BRTAKEN
ifndef
R_PPC_ADDR14_BRNTAKEN
define
R_PPC_ADDR14_BRNTAKEN
endif
R_PPC_ADDR14_BRNTAKEN
ifndef
R_PPC_REL24
define
R_PPC_REL24
endif
R_PPC_REL24
ifndef
R_PPC_REL14
define
R_PPC_REL14
endif
R_PPC_REL14
ifndef
R_PPC_REL14_BRTAKEN
define
R_PPC_REL14_BRTAKEN
endif
R_PPC_REL14_BRTAKEN
ifndef
R_PPC_REL14_BRNTAKEN
define
R_PPC_REL14_BRNTAKEN
endif
R_PPC_REL14_BRNTAKEN
ifndef
R_PPC_GOT16
define
R_PPC_GOT16
endif
R_PPC_GOT16
ifndef
R_PPC_GOT16_LO
define
R_PPC_GOT16_LO
endif
R_PPC_GOT16_LO
ifndef
R_PPC_GOT16_HI
define
R_PPC_GOT16_HI
endif
R_PPC_GOT16_HI
ifndef
R_PPC_GOT16_HA
define
R_PPC_GOT16_HA
endif
R_PPC_GOT16_HA
ifndef
R_PPC_PLTREL24
define
R_PPC_PLTREL24
endif
R_PPC_PLTREL24
ifndef
R_PPC_COPY
define
R_PPC_COPY
endif
R_PPC_COPY
ifndef
R_PPC_GLOB_DAT
define
R_PPC_GLOB_DAT
endif
R_PPC_GLOB_DAT
ifndef
R_PPC_JMP_SLOT
define
R_PPC_JMP_SLOT
endif
R_PPC_JMP_SLOT
ifndef
R_PPC_RELATIVE
define
R_PPC_RELATIVE
endif
R_PPC_RELATIVE
ifndef
R_PPC_LOCAL24PC
define
R_PPC_LOCAL24PC
endif
R_PPC_LOCAL24PC
ifndef
R_PPC_UADDR32
define
R_PPC_UADDR32
endif
R_PPC_UADDR32
ifndef
R_PPC_UADDR16
define
R_PPC_UADDR16
endif
R_PPC_UADDR16
ifndef
R_PPC_REL32
define
R_PPC_REL32
endif
R_PPC_REL32
ifndef
R_PPC_PLT32
define
R_PPC_PLT32
endif
R_PPC_PLT32
ifndef
R_PPC_PLTREL32
define
R_PPC_PLTREL32
endif
R_PPC_PLTREL32
ifndef
R_PPC_PLT16_LO
define
R_PPC_PLT16_LO
endif
R_PPC_PLT16_LO
ifndef
R_PPC_PLT16_HI
define
R_PPC_PLT16_HI
endif
R_PPC_PLT16_HI
ifndef
R_PPC_PLT16_HA
define
R_PPC_PLT16_HA
endif
R_PPC_PLT16_HA
ifndef
R_PPC_SDAREL16
define
R_PPC_SDAREL16
endif
R_PPC_SDAREL16
ifndef
R_PPC_SECTOFF
define
R_PPC_SECTOFF
endif
R_PPC_SECTOFF
ifndef
R_PPC_SECTOFF_LO
define
R_PPC_SECTOFF_LO
endif
R_PPC_SECTOFF_LO
ifndef
R_PPC_SECTOFF_HI
define
R_PPC_SECTOFF_HI
endif
R_PPC_SECTOFF_HI
ifndef
R_PPC_SECTOFF_HA
define
R_PPC_SECTOFF_HA
endif
R_PPC_SECTOFF_HA
ifndef
R_PPC_37
define
R_PPC_37
endif
R_PPC_37
ifndef
R_PPC_38
define
R_PPC_38
endif
R_PPC_38
ifndef
R_PPC_39
define
R_PPC_39
endif
R_PPC_39
ifndef
R_PPC_40
define
R_PPC_40
endif
R_PPC_40
ifndef
R_PPC_41
define
R_PPC_41
endif
R_PPC_41
ifndef
R_PPC_42
define
R_PPC_42
endif
R_PPC_42
ifndef
R_PPC_43
define
R_PPC_43
endif
R_PPC_43
ifndef
R_PPC_44
define
R_PPC_44
endif
R_PPC_44
ifndef
R_PPC_45
define
R_PPC_45
endif
R_PPC_45
ifndef
R_PPC_46
define
R_PPC_46
endif
R_PPC_46
ifndef
R_PPC_47
define
R_PPC_47
endif
R_PPC_47
ifndef
R_PPC_48
define
R_PPC_48
endif
R_PPC_48
ifndef
R_PPC_49
define
R_PPC_49
endif
R_PPC_49
ifndef
R_PPC_50
define
R_PPC_50
endif
R_PPC_50
ifndef
R_PPC_51
define
R_PPC_51
endif
R_PPC_51
ifndef
R_PPC_52
define
R_PPC_52
endif
R_PPC_52
ifndef
R_PPC_53
define
R_PPC_53
endif
R_PPC_53
ifndef
R_PPC_54
define
R_PPC_54
endif
R_PPC_54
ifndef
R_PPC_55
define
R_PPC_55
endif
R_PPC_55
ifndef
R_PPC_56
define
R_PPC_56
endif
R_PPC_56
ifndef
R_PPC_57
define
R_PPC_57
endif
R_PPC_57
ifndef
R_PPC_58
define
R_PPC_58
endif
R_PPC_58
ifndef
R_PPC_59
define
R_PPC_59
endif
R_PPC_59
ifndef
R_PPC_60
define
R_PPC_60
endif
R_PPC_60
ifndef
R_PPC_61
define
R_PPC_61
endif
R_PPC_61
ifndef
R_PPC_62
define
R_PPC_62
endif
R_PPC_62
ifndef
R_PPC_63
define
R_PPC_63
endif
R_PPC_63
ifndef
R_PPC_64
define
R_PPC_64
endif
R_PPC_64
ifndef
R_PPC_65
define
R_PPC_65
endif
R_PPC_65
ifndef
R_PPC_66
define
R_PPC_66
endif
R_PPC_66
ifndef
R_PPC_TLS
define
R_PPC_TLS
endif
R_PPC_TLS
ifndef
R_PPC_DTPMOD32
define
R_PPC_DTPMOD32
endif
R_PPC_DTPMOD32
ifndef
R_PPC_TPREL16
define
R_PPC_TPREL16
endif
R_PPC_TPREL16
ifndef
R_PPC_TPREL16_LO
define
R_PPC_TPREL16_LO
endif
R_PPC_TPREL16_LO
ifndef
R_PPC_TPREL16_HI
define
R_PPC_TPREL16_HI
endif
R_PPC_TPREL16_HI
ifndef
R_PPC_TPREL16_HA
define
R_PPC_TPREL16_HA
endif
R_PPC_TPREL16_HA
ifndef
R_PPC_TPREL32
define
R_PPC_TPREL32
endif
R_PPC_TPREL32
ifndef
R_PPC_DTPREL16
define
R_PPC_DTPREL16
endif
R_PPC_DTPREL16
ifndef
R_PPC_DTPREL16_LO
define
R_PPC_DTPREL16_LO
endif
R_PPC_DTPREL16_LO
ifndef
R_PPC_DTPREL16_HI
define
R_PPC_DTPREL16_HI
endif
R_PPC_DTPREL16_HI
ifndef
R_PPC_DTPREL16_HA
define
R_PPC_DTPREL16_HA
endif
R_PPC_DTPREL16_HA
ifndef
R_PPC_DTPREL32
define
R_PPC_DTPREL32
endif
R_PPC_DTPREL32
ifndef
R_PPC_GOT_TLSGD16
define
R_PPC_GOT_TLSGD16
endif
R_PPC_GOT_TLSGD16
ifndef
R_PPC_GOT_TLSGD16_LO
define
R_PPC_GOT_TLSGD16_LO
endif
R_PPC_GOT_TLSGD16_LO
ifndef
R_PPC_GOT_TLSGD16_HI
define
R_PPC_GOT_TLSGD16_HI
endif
R_PPC_GOT_TLSGD16_HI
ifndef
R_PPC_GOT_TLSGD16_HA
define
R_PPC_GOT_TLSGD16_HA
endif
R_PPC_GOT_TLSGD16_HA
ifndef
R_PPC_GOT_TLSLD16
define
R_PPC_GOT_TLSLD16
endif
R_PPC_GOT_TLSLD16
ifndef
R_PPC_GOT_TLSLD16_LO
define
R_PPC_GOT_TLSLD16_LO
endif
R_PPC_GOT_TLSLD16_LO
ifndef
R_PPC_GOT_TLSLD16_HI
define
R_PPC_GOT_TLSLD16_HI
endif
R_PPC_GOT_TLSLD16_HI
ifndef
R_PPC_GOT_TLSLD16_HA
define
R_PPC_GOT_TLSLD16_HA
endif
R_PPC_GOT_TLSLD16_HA
ifndef
R_PPC_GOT_TPREL16
define
R_PPC_GOT_TPREL16
endif
R_PPC_GOT_TPREL16
ifndef
R_PPC_GOT_TPREL16_LO
define
R_PPC_GOT_TPREL16_LO
endif
R_PPC_GOT_TPREL16_LO
ifndef
R_PPC_GOT_TPREL16_HI
define
R_PPC_GOT_TPREL16_HI
endif
R_PPC_GOT_TPREL16_HI
ifndef
R_PPC_GOT_TPREL16_HA
define
R_PPC_GOT_TPREL16_HA
endif
R_PPC_GOT_TPREL16_HA
ifndef
R_PPC_GOT_DTPREL16
define
R_PPC_GOT_DTPREL16
endif
R_PPC_GOT_DTPREL16
ifndef
R_PPC_GOT_DTPREL16_LO
define
R_PPC_GOT_DTPREL16_LO
endif
R_PPC_GOT_DTPREL16_LO
ifndef
R_PPC_GOT_DTPREL16_HI
define
R_PPC_GOT_DTPREL16_HI
endif
R_PPC_GOT_DTPREL16_HI
ifndef
R_PPC_GOT_DTPREL16_HA
define
R_PPC_GOT_DTPREL16_HA
endif
R_PPC_GOT_DTPREL16_HA
ifndef
R_PPC_TLSGD
define
R_PPC_TLSGD
endif
R_PPC_TLSGD
ifndef
R_PPC_TLSLD
define
R_PPC_TLSLD
endif
R_PPC_TLSLD
ifndef
R_PPC_EMB_NADDR32
define
R_PPC_EMB_NADDR32
endif
R_PPC_EMB_NADDR32
ifndef
R_PPC_EMB_NADDR16
define
R_PPC_EMB_NADDR16
endif
R_PPC_EMB_NADDR16
ifndef
R_PPC_EMB_NADDR16_LO
define
R_PPC_EMB_NADDR16_LO
endif
R_PPC_EMB_NADDR16_LO
ifndef
R_PPC_EMB_NADDR16_HI
define
R_PPC_EMB_NADDR16_HI
endif
R_PPC_EMB_NADDR16_HI
ifndef
R_PPC_EMB_NADDR16_HA
define
R_PPC_EMB_NADDR16_HA
endif
R_PPC_EMB_NADDR16_HA
ifndef
R_PPC_EMB_SDAI16
define
R_PPC_EMB_SDAI16
endif
R_PPC_EMB_SDAI16
ifndef
R_PPC_EMB_SDA2I16
define
R_PPC_EMB_SDA2I16
endif
R_PPC_EMB_SDA2I16
ifndef
R_PPC_EMB_SDA2REL
define
R_PPC_EMB_SDA2REL
endif
R_PPC_EMB_SDA2REL
ifndef
R_PPC_EMB_SDA21
define
R_PPC_EMB_SDA21
endif
R_PPC_EMB_SDA21
ifndef
R_PPC_EMB_MRKREF
define
R_PPC_EMB_MRKREF
endif
R_PPC_EMB_MRKREF
ifndef
R_PPC_EMB_RELSEC16
define
R_PPC_EMB_RELSEC16
endif
R_PPC_EMB_RELSEC16
ifndef
R_PPC_EMB_RELST_LO
define
R_PPC_EMB_RELST_LO
endif
R_PPC_EMB_RELST_LO
ifndef
R_PPC_EMB_RELST_HI
define
R_PPC_EMB_RELST_HI
endif
R_PPC_EMB_RELST_HI
ifndef
R_PPC_EMB_RELST_HA
define
R_PPC_EMB_RELST_HA
endif
R_PPC_EMB_RELST_HA
ifndef
R_PPC_EMB_BIT_FLD
define
R_PPC_EMB_BIT_FLD
endif
R_PPC_EMB_BIT_FLD
ifndef
R_PPC_EMB_RELSDA
define
R_PPC_EMB_RELSDA
endif
R_PPC_EMB_RELSDA
ifndef
R_PPC_DIAB_SDA21_LO
define
R_PPC_DIAB_SDA21_LO
endif
R_PPC_DIAB_SDA21_LO
ifndef
R_PPC_DIAB_SDA21_HI
define
R_PPC_DIAB_SDA21_HI
endif
R_PPC_DIAB_SDA21_HI
ifndef
R_PPC_DIAB_SDA21_HA
define
R_PPC_DIAB_SDA21_HA
endif
R_PPC_DIAB_SDA21_HA
ifndef
R_PPC_DIAB_RELSDA_LO
define
R_PPC_DIAB_RELSDA_LO
endif
R_PPC_DIAB_RELSDA_LO
ifndef
R_PPC_DIAB_RELSDA_HI
define
R_PPC_DIAB_RELSDA_HI
endif
R_PPC_DIAB_RELSDA_HI
ifndef
R_PPC_DIAB_RELSDA_HA
define
R_PPC_DIAB_RELSDA_HA
endif
R_PPC_DIAB_RELSDA_HA
ifndef
R_PPC_IRELATIVE
define
R_PPC_IRELATIVE
endif
R_PPC_IRELATIVE
ifndef
R_PPC_REL16
define
R_PPC_REL16
endif
R_PPC_REL16
ifndef
R_PPC_REL16_LO
define
R_PPC_REL16_LO
endif
R_PPC_REL16_LO
ifndef
R_PPC_REL16_HI
define
R_PPC_REL16_HI
endif
R_PPC_REL16_HI
ifndef
R_PPC_REL16_HA
define
R_PPC_REL16_HA
endif
R_PPC_REL16_HA
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_ppc64
unsigned
long
ifndef
R_PPC64_ADDR30
define
R_PPC64_ADDR30
endif
R_PPC64_ADDR30
ifndef
R_PPC64_ADDR64
define
R_PPC64_ADDR64
endif
R_PPC64_ADDR64
ifndef
R_PPC64_ADDR16_HIGHER
define
R_PPC64_ADDR16_HIGHER
endif
R_PPC64_ADDR16_HIGHER
ifndef
R_PPC64_ADDR16_HIGHERA
define
R_PPC64_ADDR16_HIGHERA
endif
R_PPC64_ADDR16_HIGHERA
ifndef
R_PPC64_ADDR16_HIGHEST
define
R_PPC64_ADDR16_HIGHEST
endif
R_PPC64_ADDR16_HIGHEST
ifndef
R_PPC64_ADDR16_HIGHESTA
define
R_PPC64_ADDR16_HIGHESTA
endif
R_PPC64_ADDR16_HIGHESTA
ifndef
R_PPC64_UADDR64
define
R_PPC64_UADDR64
endif
R_PPC64_UADDR64
ifndef
R_PPC64_REL64
define
R_PPC64_REL64
endif
R_PPC64_REL64
ifndef
R_PPC64_PLT64
define
R_PPC64_PLT64
endif
R_PPC64_PLT64
ifndef
R_PPC64_PLTREL64
define
R_PPC64_PLTREL64
endif
R_PPC64_PLTREL64
ifndef
R_PPC64_TOC16
define
R_PPC64_TOC16
endif
R_PPC64_TOC16
ifndef
R_PPC64_TOC16_LO
define
R_PPC64_TOC16_LO
endif
R_PPC64_TOC16_LO
ifndef
R_PPC64_TOC16_HI
define
R_PPC64_TOC16_HI
endif
R_PPC64_TOC16_HI
ifndef
R_PPC64_TOC16_HA
define
R_PPC64_TOC16_HA
endif
R_PPC64_TOC16_HA
ifndef
R_PPC64_TOC
define
R_PPC64_TOC
endif
R_PPC64_TOC
ifndef
R_PPC64_PLTGOT16
define
R_PPC64_PLTGOT16
endif
R_PPC64_PLTGOT16
ifndef
R_PPC64_PLTGOT16_LO
define
R_PPC64_PLTGOT16_LO
endif
R_PPC64_PLTGOT16_LO
ifndef
R_PPC64_PLTGOT16_HI
define
R_PPC64_PLTGOT16_HI
endif
R_PPC64_PLTGOT16_HI
ifndef
R_PPC64_PLTGOT16_HA
define
R_PPC64_PLTGOT16_HA
endif
R_PPC64_PLTGOT16_HA
ifndef
R_PPC64_ADDR16_DS
define
R_PPC64_ADDR16_DS
endif
R_PPC64_ADDR16_DS
ifndef
R_PPC64_ADDR16_LO_DS
define
R_PPC64_ADDR16_LO_DS
endif
R_PPC64_ADDR16_LO_DS
ifndef
R_PPC64_GOT16_DS
define
R_PPC64_GOT16_DS
endif
R_PPC64_GOT16_DS
ifndef
R_PPC64_GOT16_LO_DS
define
R_PPC64_GOT16_LO_DS
endif
R_PPC64_GOT16_LO_DS
ifndef
R_PPC64_PLT16_LO_DS
define
R_PPC64_PLT16_LO_DS
endif
R_PPC64_PLT16_LO_DS
ifndef
R_PPC64_SECTOFF_DS
define
R_PPC64_SECTOFF_DS
endif
R_PPC64_SECTOFF_DS
ifndef
R_PPC64_SECTOFF_LO_DS
define
R_PPC64_SECTOFF_LO_DS
endif
R_PPC64_SECTOFF_LO_DS
ifndef
R_PPC64_TOC16_DS
define
R_PPC64_TOC16_DS
endif
R_PPC64_TOC16_DS
ifndef
R_PPC64_TOC16_LO_DS
define
R_PPC64_TOC16_LO_DS
endif
R_PPC64_TOC16_LO_DS
ifndef
R_PPC64_PLTGOT16_DS
define
R_PPC64_PLTGOT16_DS
endif
R_PPC64_PLTGOT16_DS
ifndef
R_PPC64_PLTGOT16_LO_DS
define
R_PPC64_PLTGOT16_LO_DS
endif
R_PPC64_PLTGOT16_LO_DS
ifndef
R_PPC64_TLS
define
R_PPC64_TLS
endif
R_PPC64_TLS
ifndef
R_PPC64_DTPMOD64
define
R_PPC64_DTPMOD64
endif
R_PPC64_DTPMOD64
ifndef
R_PPC64_TPREL16
define
R_PPC64_TPREL16
endif
R_PPC64_TPREL16
ifndef
R_PPC64_TPREL16_LO
define
R_PPC64_TPREL16_LO
endif
R_PPC64_TPREL16_LO
ifndef
R_PPC64_TPREL16_HI
define
R_PPC64_TPREL16_HI
endif
R_PPC64_TPREL16_HI
ifndef
R_PPC64_TPREL16_HA
define
R_PPC64_TPREL16_HA
endif
R_PPC64_TPREL16_HA
ifndef
R_PPC64_TPREL64
define
R_PPC64_TPREL64
endif
R_PPC64_TPREL64
ifndef
R_PPC64_DTPREL16
define
R_PPC64_DTPREL16
endif
R_PPC64_DTPREL16
ifndef
R_PPC64_DTPREL16_LO
define
R_PPC64_DTPREL16_LO
endif
R_PPC64_DTPREL16_LO
ifndef
R_PPC64_DTPREL16_HI
define
R_PPC64_DTPREL16_HI
endif
R_PPC64_DTPREL16_HI
ifndef
R_PPC64_DTPREL16_HA
define
R_PPC64_DTPREL16_HA
endif
R_PPC64_DTPREL16_HA
ifndef
R_PPC64_DTPREL64
define
R_PPC64_DTPREL64
endif
R_PPC64_DTPREL64
ifndef
R_PPC64_GOT_TLSGD16
define
R_PPC64_GOT_TLSGD16
endif
R_PPC64_GOT_TLSGD16
ifndef
R_PPC64_GOT_TLSGD16_LO
define
R_PPC64_GOT_TLSGD16_LO
endif
R_PPC64_GOT_TLSGD16_LO
ifndef
R_PPC64_GOT_TLSGD16_HI
define
R_PPC64_GOT_TLSGD16_HI
endif
R_PPC64_GOT_TLSGD16_HI
ifndef
R_PPC64_GOT_TLSGD16_HA
define
R_PPC64_GOT_TLSGD16_HA
endif
R_PPC64_GOT_TLSGD16_HA
ifndef
R_PPC64_GOT_TLSLD16
define
R_PPC64_GOT_TLSLD16
endif
R_PPC64_GOT_TLSLD16
ifndef
R_PPC64_GOT_TLSLD16_LO
define
R_PPC64_GOT_TLSLD16_LO
endif
R_PPC64_GOT_TLSLD16_LO
ifndef
R_PPC64_GOT_TLSLD16_HI
define
R_PPC64_GOT_TLSLD16_HI
endif
R_PPC64_GOT_TLSLD16_HI
ifndef
R_PPC64_GOT_TLSLD16_HA
define
R_PPC64_GOT_TLSLD16_HA
endif
R_PPC64_GOT_TLSLD16_HA
ifndef
R_PPC64_GOT_TPREL16_DS
define
R_PPC64_GOT_TPREL16_DS
endif
R_PPC64_GOT_TPREL16_DS
ifndef
R_PPC64_GOT_TPREL16_LO_DS
define
R_PPC64_GOT_TPREL16_LO_DS
endif
R_PPC64_GOT_TPREL16_LO_DS
ifndef
R_PPC64_GOT_TPREL16_HI
define
R_PPC64_GOT_TPREL16_HI
endif
R_PPC64_GOT_TPREL16_HI
ifndef
R_PPC64_GOT_TPREL16_HA
define
R_PPC64_GOT_TPREL16_HA
endif
R_PPC64_GOT_TPREL16_HA
ifndef
R_PPC64_GOT_DTPREL16_DS
define
R_PPC64_GOT_DTPREL16_DS
endif
R_PPC64_GOT_DTPREL16_DS
ifndef
R_PPC64_GOT_DTPREL16_LO_DS
define
R_PPC64_GOT_DTPREL16_LO_DS
endif
R_PPC64_GOT_DTPREL16_LO_DS
ifndef
R_PPC64_GOT_DTPREL16_HI
define
R_PPC64_GOT_DTPREL16_HI
endif
R_PPC64_GOT_DTPREL16_HI
ifndef
R_PPC64_GOT_DTPREL16_HA
define
R_PPC64_GOT_DTPREL16_HA
endif
R_PPC64_GOT_DTPREL16_HA
ifndef
R_PPC64_TPREL16_DS
define
R_PPC64_TPREL16_DS
endif
R_PPC64_TPREL16_DS
ifndef
R_PPC64_TPREL16_LO_DS
define
R_PPC64_TPREL16_LO_DS
endif
R_PPC64_TPREL16_LO_DS
ifndef
R_PPC64_TPREL16_HIGHER
define
R_PPC64_TPREL16_HIGHER
endif
R_PPC64_TPREL16_HIGHER
ifndef
R_PPC64_TPREL16_HIGHERA
define
R_PPC64_TPREL16_HIGHERA
endif
R_PPC64_TPREL16_HIGHERA
ifndef
R_PPC64_TPREL16_HIGHEST
define
R_PPC64_TPREL16_HIGHEST
endif
R_PPC64_TPREL16_HIGHEST
ifndef
R_PPC64_TPREL16_HIGHESTA
define
R_PPC64_TPREL16_HIGHESTA
endif
R_PPC64_TPREL16_HIGHESTA
ifndef
R_PPC64_DTPREL16_DS
define
R_PPC64_DTPREL16_DS
endif
R_PPC64_DTPREL16_DS
ifndef
R_PPC64_DTPREL16_LO_DS
define
R_PPC64_DTPREL16_LO_DS
endif
R_PPC64_DTPREL16_LO_DS
ifndef
R_PPC64_DTPREL16_HIGHER
define
R_PPC64_DTPREL16_HIGHER
endif
R_PPC64_DTPREL16_HIGHER
ifndef
R_PPC64_DTPREL16_HIGHERA
define
R_PPC64_DTPREL16_HIGHERA
endif
R_PPC64_DTPREL16_HIGHERA
ifndef
R_PPC64_DTPREL16_HIGHEST
define
R_PPC64_DTPREL16_HIGHEST
endif
R_PPC64_DTPREL16_HIGHEST
ifndef
R_PPC64_DTPREL16_HIGHESTA
define
R_PPC64_DTPREL16_HIGHESTA
endif
R_PPC64_DTPREL16_HIGHESTA
ifndef
R_PPC64_TOC32
define
R_PPC64_TOC32
endif
R_PPC64_TOC32
ifndef
R_PPC64_DTPMOD32
define
R_PPC64_DTPMOD32
endif
R_PPC64_DTPMOD32
ifndef
R_PPC64_TPREL32
define
R_PPC64_TPREL32
endif
R_PPC64_TPREL32
ifndef
R_PPC64_DTPREL32
define
R_PPC64_DTPREL32
endif
R_PPC64_DTPREL32
ifndef
R_PPC64_ADDR16_HIGHA
define
R_PPC64_ADDR16_HIGHA
endif
R_PPC64_ADDR16_HIGHA
ifndef
R_PPC64_TPREL16_HIGH
define
R_PPC64_TPREL16_HIGH
endif
R_PPC64_TPREL16_HIGH
ifndef
R_PPC64_TPREL16_HIGHA
define
R_PPC64_TPREL16_HIGHA
endif
R_PPC64_TPREL16_HIGHA
ifndef
R_PPC64_DTPREL16_HIGH
define
R_PPC64_DTPREL16_HIGH
endif
R_PPC64_DTPREL16_HIGH
ifndef
R_PPC64_DTPREL16_HIGHA
define
R_PPC64_DTPREL16_HIGHA
endif
R_PPC64_DTPREL16_HIGHA
ifndef
R_PPC64_JMP_IREL
define
R_PPC64_JMP_IREL
endif
R_PPC64_JMP_IREL
ifndef
R_PPC64_IRELATIVE
define
R_PPC64_IRELATIVE
endif
R_PPC64_IRELATIVE
ifndef
R_PPC64_REL16
define
R_PPC64_REL16
endif
R_PPC64_REL16
ifndef
R_PPC64_REL16_LO
define
R_PPC64_REL16_LO
endif
R_PPC64_REL16_LO
ifndef
R_PPC64_REL16_HI
define
R_PPC64_REL16_HI
endif
R_PPC64_REL16_HI
ifndef
R_PPC64_REL16_HA
define
R_PPC64_REL16_HA
endif
R_PPC64_REL16_HA
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_sparc
unsigned
long
ifndef
R_SPARC_NONE
define
R_SPARC_NONE
endif
R_SPARC_NONE
ifndef
R_SPARC_8
define
R_SPARC_8
endif
R_SPARC_8
ifndef
R_SPARC_16
define
R_SPARC_16
endif
R_SPARC_16
ifndef
R_SPARC_32
define
R_SPARC_32
endif
R_SPARC_32
ifndef
R_SPARC_DISP8
define
R_SPARC_DISP8
endif
R_SPARC_DISP8
ifndef
R_SPARC_DISP16
define
R_SPARC_DISP16
endif
R_SPARC_DISP16
ifndef
R_SPARC_DISP32
define
R_SPARC_DISP32
endif
R_SPARC_DISP32
ifndef
R_SPARC_WDISP30
define
R_SPARC_WDISP30
endif
R_SPARC_WDISP30
ifndef
R_SPARC_WDISP22
define
R_SPARC_WDISP22
endif
R_SPARC_WDISP22
ifndef
R_SPARC_HI22
define
R_SPARC_HI22
endif
R_SPARC_HI22
ifndef
R_SPARC_22
define
R_SPARC_22
endif
R_SPARC_22
ifndef
R_SPARC_13
define
R_SPARC_13
endif
R_SPARC_13
ifndef
R_SPARC_LO10
define
R_SPARC_LO10
endif
R_SPARC_LO10
ifndef
R_SPARC_GOT10
define
R_SPARC_GOT10
endif
R_SPARC_GOT10
ifndef
R_SPARC_GOT13
define
R_SPARC_GOT13
endif
R_SPARC_GOT13
ifndef
R_SPARC_GOT22
define
R_SPARC_GOT22
endif
R_SPARC_GOT22
ifndef
R_SPARC_PC10
define
R_SPARC_PC10
endif
R_SPARC_PC10
ifndef
R_SPARC_PC22
define
R_SPARC_PC22
endif
R_SPARC_PC22
ifndef
R_SPARC_WPLT30
define
R_SPARC_WPLT30
endif
R_SPARC_WPLT30
ifndef
R_SPARC_COPY
define
R_SPARC_COPY
endif
R_SPARC_COPY
ifndef
R_SPARC_GLOB_DAT
define
R_SPARC_GLOB_DAT
endif
R_SPARC_GLOB_DAT
ifndef
R_SPARC_JMP_SLOT
define
R_SPARC_JMP_SLOT
endif
R_SPARC_JMP_SLOT
ifndef
R_SPARC_RELATIVE
define
R_SPARC_RELATIVE
endif
R_SPARC_RELATIVE
ifndef
R_SPARC_UA32
define
R_SPARC_UA32
endif
R_SPARC_UA32
ifndef
R_SPARC_PLT32
define
R_SPARC_PLT32
endif
R_SPARC_PLT32
ifndef
R_SPARC_HIPLT22
define
R_SPARC_HIPLT22
endif
R_SPARC_HIPLT22
ifndef
R_SPARC_LOPLT10
define
R_SPARC_LOPLT10
endif
R_SPARC_LOPLT10
ifndef
R_SPARC_PCPLT32
define
R_SPARC_PCPLT32
endif
R_SPARC_PCPLT32
ifndef
R_SPARC_PCPLT22
define
R_SPARC_PCPLT22
endif
R_SPARC_PCPLT22
ifndef
R_SPARC_PCPLT10
define
R_SPARC_PCPLT10
endif
R_SPARC_PCPLT10
ifndef
R_SPARC_10
define
R_SPARC_10
endif
R_SPARC_10
ifndef
R_SPARC_11
define
R_SPARC_11
endif
R_SPARC_11
ifndef
R_SPARC_64
define
R_SPARC_64
endif
R_SPARC_64
ifndef
R_SPARC_OLO10
define
R_SPARC_OLO10
endif
R_SPARC_OLO10
ifndef
R_SPARC_HH22
define
R_SPARC_HH22
endif
R_SPARC_HH22
ifndef
R_SPARC_HM10
define
R_SPARC_HM10
endif
R_SPARC_HM10
ifndef
R_SPARC_LM22
define
R_SPARC_LM22
endif
R_SPARC_LM22
ifndef
R_SPARC_PC_HH22
define
R_SPARC_PC_HH22
endif
R_SPARC_PC_HH22
ifndef
R_SPARC_PC_HM10
define
R_SPARC_PC_HM10
endif
R_SPARC_PC_HM10
ifndef
R_SPARC_PC_LM22
define
R_SPARC_PC_LM22
endif
R_SPARC_PC_LM22
ifndef
R_SPARC_WDISP16
define
R_SPARC_WDISP16
endif
R_SPARC_WDISP16
ifndef
R_SPARC_WDISP19
define
R_SPARC_WDISP19
endif
R_SPARC_WDISP19
ifndef
R_SPARC_GLOB_JMP
define
R_SPARC_GLOB_JMP
endif
R_SPARC_GLOB_JMP
ifndef
R_SPARC_7
define
R_SPARC_7
endif
R_SPARC_7
ifndef
R_SPARC_5
define
R_SPARC_5
endif
R_SPARC_5
ifndef
R_SPARC_6
define
R_SPARC_6
endif
R_SPARC_6
ifndef
R_SPARC_DISP64
define
R_SPARC_DISP64
endif
R_SPARC_DISP64
ifndef
R_SPARC_PLT64
define
R_SPARC_PLT64
endif
R_SPARC_PLT64
ifndef
R_SPARC_HIX22
define
R_SPARC_HIX22
endif
R_SPARC_HIX22
ifndef
R_SPARC_LOX10
define
R_SPARC_LOX10
endif
R_SPARC_LOX10
ifndef
R_SPARC_H44
define
R_SPARC_H44
endif
R_SPARC_H44
ifndef
R_SPARC_M44
define
R_SPARC_M44
endif
R_SPARC_M44
ifndef
R_SPARC_L44
define
R_SPARC_L44
endif
R_SPARC_L44
ifndef
R_SPARC_REGISTER
define
R_SPARC_REGISTER
endif
R_SPARC_REGISTER
ifndef
R_SPARC_UA64
define
R_SPARC_UA64
endif
R_SPARC_UA64
ifndef
R_SPARC_UA16
define
R_SPARC_UA16
endif
R_SPARC_UA16
ifndef
R_SPARC_TLS_GD_HI22
define
R_SPARC_TLS_GD_HI22
endif
R_SPARC_TLS_GD_HI22
ifndef
R_SPARC_TLS_GD_LO10
define
R_SPARC_TLS_GD_LO10
endif
R_SPARC_TLS_GD_LO10
ifndef
R_SPARC_TLS_GD_ADD
define
R_SPARC_TLS_GD_ADD
endif
R_SPARC_TLS_GD_ADD
ifndef
R_SPARC_TLS_GD_CALL
define
R_SPARC_TLS_GD_CALL
endif
R_SPARC_TLS_GD_CALL
ifndef
R_SPARC_TLS_LDM_HI22
define
R_SPARC_TLS_LDM_HI22
endif
R_SPARC_TLS_LDM_HI22
ifndef
R_SPARC_TLS_LDM_LO10
define
R_SPARC_TLS_LDM_LO10
endif
R_SPARC_TLS_LDM_LO10
ifndef
R_SPARC_TLS_LDM_ADD
define
R_SPARC_TLS_LDM_ADD
endif
R_SPARC_TLS_LDM_ADD
ifndef
R_SPARC_TLS_LDM_CALL
define
R_SPARC_TLS_LDM_CALL
endif
R_SPARC_TLS_LDM_CALL
ifndef
R_SPARC_TLS_LDO_HIX22
define
R_SPARC_TLS_LDO_HIX22
endif
R_SPARC_TLS_LDO_HIX22
ifndef
R_SPARC_TLS_LDO_LOX10
define
R_SPARC_TLS_LDO_LOX10
endif
R_SPARC_TLS_LDO_LOX10
ifndef
R_SPARC_TLS_LDO_ADD
define
R_SPARC_TLS_LDO_ADD
endif
R_SPARC_TLS_LDO_ADD
ifndef
R_SPARC_TLS_IE_HI22
define
R_SPARC_TLS_IE_HI22
endif
R_SPARC_TLS_IE_HI22
ifndef
R_SPARC_TLS_IE_LO10
define
R_SPARC_TLS_IE_LO10
endif
R_SPARC_TLS_IE_LO10
ifndef
R_SPARC_TLS_IE_LD
define
R_SPARC_TLS_IE_LD
endif
R_SPARC_TLS_IE_LD
ifndef
R_SPARC_TLS_IE_LDX
define
R_SPARC_TLS_IE_LDX
endif
R_SPARC_TLS_IE_LDX
ifndef
R_SPARC_TLS_IE_ADD
define
R_SPARC_TLS_IE_ADD
endif
R_SPARC_TLS_IE_ADD
ifndef
R_SPARC_TLS_LE_HIX22
define
R_SPARC_TLS_LE_HIX22
endif
R_SPARC_TLS_LE_HIX22
ifndef
R_SPARC_TLS_LE_LOX10
define
R_SPARC_TLS_LE_LOX10
endif
R_SPARC_TLS_LE_LOX10
ifndef
R_SPARC_TLS_DTPMOD32
define
R_SPARC_TLS_DTPMOD32
endif
R_SPARC_TLS_DTPMOD32
ifndef
R_SPARC_TLS_DTPMOD64
define
R_SPARC_TLS_DTPMOD64
endif
R_SPARC_TLS_DTPMOD64
ifndef
R_SPARC_TLS_DTPOFF32
define
R_SPARC_TLS_DTPOFF32
endif
R_SPARC_TLS_DTPOFF32
ifndef
R_SPARC_TLS_DTPOFF64
define
R_SPARC_TLS_DTPOFF64
endif
R_SPARC_TLS_DTPOFF64
ifndef
R_SPARC_TLS_TPOFF32
define
R_SPARC_TLS_TPOFF32
endif
R_SPARC_TLS_TPOFF32
ifndef
R_SPARC_TLS_TPOFF64
define
R_SPARC_TLS_TPOFF64
endif
R_SPARC_TLS_TPOFF64
ifndef
R_SPARC_GOTDATA_HIX22
define
R_SPARC_GOTDATA_HIX22
endif
R_SPARC_GOTDATA_HIX22
ifndef
R_SPARC_GOTDATA_LOX10
define
R_SPARC_GOTDATA_LOX10
endif
R_SPARC_GOTDATA_LOX10
ifndef
R_SPARC_GOTDATA_OP_HIX22
define
R_SPARC_GOTDATA_OP_HIX22
endif
R_SPARC_GOTDATA_OP_HIX22
ifndef
R_SPARC_GOTDATA_OP_LOX10
define
R_SPARC_GOTDATA_OP_LOX10
endif
R_SPARC_GOTDATA_OP_LOX10
ifndef
R_SPARC_GOTDATA_OP
define
R_SPARC_GOTDATA_OP
endif
R_SPARC_GOTDATA_OP
ifndef
R_SPARC_H34
define
R_SPARC_H34
endif
R_SPARC_H34
ifndef
R_SPARC_SIZE32
define
R_SPARC_SIZE32
endif
R_SPARC_SIZE32
ifndef
R_SPARC_SIZE64
define
R_SPARC_SIZE64
endif
R_SPARC_SIZE64
ifndef
R_SPARC_WDISP10
define
R_SPARC_WDISP10
endif
R_SPARC_WDISP10
ifndef
R_SPARC_JMP_IREL
define
R_SPARC_JMP_IREL
endif
R_SPARC_JMP_IREL
ifndef
R_SPARC_IRELATIVE
define
R_SPARC_IRELATIVE
endif
R_SPARC_IRELATIVE
ifndef
R_SPARC_GNU_VTINHERIT
define
R_SPARC_GNU_VTINHERIT
endif
R_SPARC_GNU_VTINHERIT
ifndef
R_SPARC_GNU_VTENTRY
define
R_SPARC_GNU_VTENTRY
endif
R_SPARC_GNU_VTENTRY
ifndef
R_SPARC_REV32
define
R_SPARC_REV32
endif
R_SPARC_REV32
Created
by
build_access
py
returns
string
of
length
if
invalid
arg
const
char
dwarf_get_elf_relocname_x86_64
unsigned
long
ifndef
R_X86_64_NONE
define
R_X86_64_NONE
endif
R_X86_64_NONE
ifndef
R_X86_64_64
define
R_X86_64_64
endif
R_X86_64_64
ifndef
R_X86_64_PC32
define
R_X86_64_PC32
endif
R_X86_64_PC32
ifndef
R_X86_64_GOT32
define
R_X86_64_GOT32
endif
R_X86_64_GOT32
ifndef
R_X86_64_PLT32
define
R_X86_64_PLT32
endif
R_X86_64_PLT32
ifndef
R_X86_64_COPY
define
R_X86_64_COPY
endif
R_X86_64_COPY
ifndef
R_X86_64_GLOB_DAT
define
R_X86_64_GLOB_DAT
endif
R_X86_64_GLOB_DAT
ifndef
R_X86_64_JUMP_SLOT
define
R_X86_64_JUMP_SLOT
endif
R_X86_64_JUMP_SLOT
ifndef
R_X86_64_RELATIVE
define
R_X86_64_RELATIVE
endif
R_X86_64_RELATIVE
ifndef
R_X86_64_GOTPCREL
define
R_X86_64_GOTPCREL
endif
R_X86_64_GOTPCREL
ifndef
R_X86_64_32
define
R_X86_64_32
endif
R_X86_64_32
ifndef
R_X86_64_32S
define
R_X86_64_32S
endif
R_X86_64_32S
ifndef
R_X86_64_16
define
R_X86_64_16
endif
R_X86_64_16
ifndef
R_X86_64_PC16
define
R_X86_64_PC16
endif
R_X86_64_PC16
ifndef
R_X86_64_8
define
R_X86_64_8
endif
R_X86_64_8
ifndef
R_X86_64_PC8
define
R_X86_64_PC8
endif
R_X86_64_PC8
ifndef
R_X86_64_DTPMOD64
define
R_X86_64_DTPMOD64
endif
R_X86_64_DTPMOD64
ifndef
R_X86_64_DTPOFF64
define
R_X86_64_DTPOFF64
endif
R_X86_64_DTPOFF64
ifndef
R_X86_64_TPOFF64
define
R_X86_64_TPOFF64
endif
R_X86_64_TPOFF64
ifndef
R_X86_64_TLSGD
define
R_X86_64_TLSGD
endif
R_X86_64_TLSGD
ifndef
R_X86_64_TLSLD
define
R_X86_64_TLSLD
endif
R_X86_64_TLSLD
ifndef
R_X86_64_DTPOFF32
define
R_X86_64_DTPOFF32
endif
R_X86_64_DTPOFF32
ifndef
R_X86_64_GOTTPOFF
define
R_X86_64_GOTTPOFF
endif
R_X86_64_GOTTPOFF
ifndef
R_X86_64_TPOFF32
define
R_X86_64_TPOFF32
endif
R_X86_64_TPOFF32
ifndef
R_X86_64_PC64
define
R_X86_64_PC64
endif
R_X86_64_PC64
ifndef
R_X86_64_GOTOFF64
define
R_X86_64_GOTOFF64
endif
R_X86_64_GOTOFF64
ifndef
R_X86_64_GOTPC32
define
R_X86_64_GOTPC32
endif
R_X86_64_GOTPC32
ifndef
R_X86_64_GOT64
define
R_X86_64_GOT64
endif
R_X86_64_GOT64
ifndef
R_X86_64_GOTPCREL64
define
R_X86_64_GOTPCREL64
endif
R_X86_64_GOTPCREL64
ifndef
R_X86_64_GOTPC64
define
R_X86_64_GOTPC64
endif
R_X86_64_GOTPC64
ifndef
R_X86_64_GOTPLT64
define
R_X86_64_GOTPLT64
endif
R_X86_64_GOTPLT64
ifndef
R_X86_64_PLTOFF64
define
R_X86_64_PLTOFF64
endif
R_X86_64_PLTOFF64
ifndef
R_X86_64_SIZE32
define
R_X86_64_SIZE32
endif
R_X86_64_SIZE32
ifndef
R_X86_64_SIZE64
define
R_X86_64_SIZE64
endif
R_X86_64_SIZE64
ifndef
R_X86_64_GOTPC32_TLSDESC
define
R_X86_64_GOTPC32_TLSDESC
endif
R_X86_64_GOTPC32_TLSDESC
ifndef
R_X86_64_TLSDESC_CALL
define
R_X86_64_TLSDESC_CALL
endif
R_X86_64_TLSDESC_CALL
ifndef
R_X86_64_TLSDESC
define
R_X86_64_TLSDESC
endif
R_X86_64_TLSDESC
ifndef
R_X86_64_IRELATIVE
define
R_X86_64_IRELATIVE
endif
R_X86_64_IRELATIVE
ifndef
R_X86_64_RELATIVE64
define
R_X86_64_RELATIVE64
endif
R_X86_64_RELATIVE64
ifndef
R_X86_64_GOTPCRELX
define
R_X86_64_GOTPCRELX
endif
R_X86_64_GOTPCRELX
ifndef
R_X86_64_REX_GOTPCRELX
define
R_X86_64_REX_GOTPCRELX
endif
R_X86_64_REX_GOTPCRELX
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
READELFOBJ_H
define
READELFOBJ_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Use
this
for
rel
too
struct
generic_rela
Dwarf_Unsigned
gr_offset
Dwarf_Unsigned
gr_info
Dwarf_Unsigned
gr_sym
From
info
Dwarf_Unsigned
gr_type
From
info
Dwarf_Signed
gr_addend
unsigned
char
gr_type2
MIPS64
unsigned
char
gr_type3
MIPS64
The
following
TRUE
if
rela
and
FALSE
if
rel
if
FALSE
gr_addend
will
be
zero
int
gr_is_rela
The
following
are
generic
to
simplify
handling
Elf32
and
Elf64
Some
fields
added
where
the
two
sizes
have
different
extraction
code
struct
generic_ehdr
unsigned
char
ge_ident
EI_NIDENT
Dwarf_Unsigned
ge_type
Dwarf_Unsigned
ge_machine
Dwarf_Unsigned
ge_version
Dwarf_Unsigned
ge_entry
Dwarf_Unsigned
ge_phoff
Dwarf_Unsigned
ge_shoff
Dwarf_Unsigned
ge_flags
Dwarf_Unsigned
ge_ehsize
Dwarf_Unsigned
ge_phentsize
Dwarf_Unsigned
ge_phnum
Dwarf_Unsigned
ge_shentsize
Dwarf_Unsigned
ge_shnum
Dwarf_Unsigned
ge_shstrndx
struct
generic_phdr
Dwarf_Unsigned
gp_type
Dwarf_Unsigned
gp_flags
Dwarf_Unsigned
gp_offset
Dwarf_Unsigned
gp_vaddr
Dwarf_Unsigned
gp_paddr
Dwarf_Unsigned
gp_filesz
Dwarf_Unsigned
gp_memsz
Dwarf_Unsigned
gp_align
struct
generic_shdr
Dwarf_Unsigned
gh_secnum
Dwarf_Unsigned
gh_name
const
char
gh_namestring
Dwarf_Unsigned
gh_type
Dwarf_Unsigned
gh_flags
Dwarf_Unsigned
gh_addr
Dwarf_Unsigned
gh_offset
Dwarf_Unsigned
gh_size
Dwarf_Unsigned
gh_link
Section
index
in
an
SHT_REL
or
SHT_RELA
section
of
the
target
section
from
gh_link
Otherwise
Dwarf_Unsigned
gh_reloc_target_secnum
Dwarf_Unsigned
gh_info
Dwarf_Unsigned
gh_addralign
Dwarf_Unsigned
gh_entsize
Zero
unless
content
read
in
Malloc
space
of
size
gh_size
in
bytes
For
dwarf
and
strings
mainly
free
this
if
not
null
char
gh_content
If
a
rel
or
rela
section
this
will
point
to
generic
relocation
records
if
such
have
been
loaded
free
this
if
not
null
Dwarf_Unsigned
gh_relcount
struct
generic_rela
gh_rels
For
SHT_GROUP
based
grouping
which
group
is
this
section
in
unknown
DW_GROUP_NUMBER_BASE
base
DWARF
DW_GROUPNUMBER_DWO
dwo
sections
are
in
an
SHT_GROUP
GNU
uses
this
set
with
group
number
from
SHT_GROUP
and
the
flags
should
have
SHF_GROUP
set
if
in
SHT_GROUP
Must
only
be
in
one
group?
Dwarf_Unsigned
gh_section_group_number
Content
of
an
SHT_GROUP
section
as
an
array
of
integers
is
the
version
which
can
only
be
one
Dwarf_Unsigned
gh_sht_group_array
Number
of
elements
in
the
gh_sht_group_array
Dwarf_Unsigned
gh_sht_group_array_count
TRUE
if
debug_info
eh_frame
etc
char
gh_is_dwarf
struct
generic_dynentry
Dwarf_Unsigned
gd_tag
gd_val
stands
in
for
d_ptr
and
d_val
union
the
union
adds
nothing
in
practice
since
we
expect
ptrsize
ulongest
Dwarf_Unsigned
gd_val
Dwarf_Unsigned
gd_dyn_file_offset
struct
generic_symentry
Dwarf_Unsigned
gs_name
Dwarf_Unsigned
gs_value
Dwarf_Unsigned
gs_size
Dwarf_Unsigned
gs_info
Dwarf_Unsigned
gs_other
Dwarf_Unsigned
gs_shndx
derived
Dwarf_Unsigned
gs_bind
Dwarf_Unsigned
gs_type
struct
location
const
char
g_name
Dwarf_Unsigned
g_offset
Dwarf_Unsigned
g_count
Dwarf_Unsigned
g_entrysize
Dwarf_Unsigned
g_totalsize
typedef
struct
elf_filedata_s
f_ident
E
means
it
is
elf
and
elf_filedata_s
is
the
struct
involved
Other
means
error
corruption
of
some
kind
f_ident
is
a
version
number
Only
version
is
defined
char
f_ident
char
f_path
non
null
if
known
Must
be
freed
int
f_fd
int
f_machine
EM_
int
f_destruct_close_fd
int
f_is_64bit
unsigned
f_endian
Dwarf_Unsigned
f_filesize
Elf
size
not
DWARF
or
Dwarf_Small
f_offsetsize
Dwarf_Small
f_pointersize
int
f_ftype
Dwarf_Unsigned
f_max_secdata_offset
Dwarf_Unsigned
f_max_progdata_offset
void
f_copy_word
void
const
void
unsigned
long
struct
location
f_loc_ehdr
struct
generic_ehdr
f_ehdr
struct
location
f_loc_shdr
struct
generic_shdr
f_shdr
struct
location
f_loc_phdr
struct
generic_phdr
f_phdr
char
f_elf_shstrings_data
section
name
strings
length
of
currentsection
Might
be
zero
Dwarf_Unsigned
f_elf_shstrings_length
size
of
malloc
d
space
Dwarf_Unsigned
f_elf_shstrings_max
This
is
the
dynamic
section
struct
location
f_loc_dynamic
struct
generic_dynentry
f_dynamic
Dwarf_Unsigned
f_dynamic_sect_index
dynsym
dynstr
struct
location
f_loc_dynsym
struct
generic_symentry
f_dynsym
char
f_dynsym_sect_strings
Dwarf_Unsigned
f_dynsym_sect_strings_max
Dwarf_Unsigned
f_dynsym_sect_strings_sect_index
Dwarf_Unsigned
f_dynsym_sect_index
symtab
strtab
struct
location
f_loc_symtab
struct
generic_symentry
f_symtab
char
f_symtab_sect_strings
Dwarf_Unsigned
f_symtab_sect_strings_max
Dwarf_Unsigned
f_symtab_sect_strings_sect_index
Dwarf_Unsigned
f_symtab_sect_index
Starts
at
used
specially
Dwarf_Unsigned
f_sg_next_group_number
Both
the
following
will
be
zero
unless
there
are
explicit
Elf
groups
Dwarf_Unsigned
f_sht_group_type_section_count
Dwarf_Unsigned
f_shf_group_flag_section_count
Dwarf_Unsigned
f_dwo_group_section_count
dwarf_elf_object_access_internals_t
int
dwarf_construct_elf_access
int
fd
const
char
path
dwarf_elf_object_access_internals_t
ep
int
errcode
int
dwarf_destruct_elf_access
dwarf_elf_object_access_internals_t
ep
int
errcode
int
_dwarf_load_elf_header
dwarf_elf_object_access_internals_t
ep
int
errcode
int
_dwarf_load_elf_sectheaders
dwarf_elf_object_access_internals_t
ep
int
errcode
int
_dwarf_load_elf_symtab_symbols
dwarf_elf_object_access_internals_t
ep
int
errcode
int
_dwarf_load_elf_symstr
dwarf_elf_object_access_internals_t
ep
int
errcode
These
two
enums
used
for
type
safety
in
passing
values
enum
RelocRela
RelocIsRela
RelocIsRel
enum
RelocOffsetSize
RelocOffset32
RelocOffset64
int
_dwarf_load_elf_relx
dwarf_elf_object_access_internals_t
ep
Dwarf_Unsigned
secnum
enum
RelocRela
int
errcode
ifndef
EI_NIDENT
define
EI_NIDENT
endif
EI_NIDENT
ifdef
__cplusplus
endif
__cplusplus
endif
READELFOBJ_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
Typed
in
from
the
SystemV
Application
Binary
Interface
but
using
char
arrays
instead
of
variables
as
for
reading
we
don
t
need
the
struct
members
to
be
variables
This
simplifies
configure
https
www
uclibc
org
docs
elf
gen
pdf
used
as
source
of
Elf64
fields
It
is
expected
code
including
this
will
have
included
an
official
elf
h
for
various
definitions
needed
before
including
this
But
that
is
not
strictly
necessary
given
other
headers
The
structs
were
all
officially
defined
so
files
could
be
mapped
in
Fields
are
arranged
so
there
will
not
be
gaps
and
we
need
not
deal
with
alignment
gaps
ifndef
DW_ELFSTRUCTS_H
define
DW_ELFSTRUCTS_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
ifndef
EI_NIDENT
define
EI_NIDENT
endif
ifndef
TYP
define
TYP
n
l
char
n
l
endif
typedef
struct
unsigned
char
e_ident
EI_NIDENT
TYP
e_type
TYP
e_machine
TYP
e_version
TYP
e_entry
TYP
e_phoff
TYP
e_shoff
TYP
e_flags
TYP
e_ehsize
TYP
e_phentsize
TYP
e_phnum
TYP
e_shentsize
TYP
e_shnum
TYP
e_shstrndx
dw_elf32_ehdr
typedef
struct
unsigned
char
e_ident
EI_NIDENT
TYP
e_type
TYP
e_machine
TYP
e_version
TYP
e_entry
TYP
e_phoff
TYP
e_shoff
TYP
e_flags
TYP
e_ehsize
TYP
e_phentsize
TYP
e_phnum
TYP
e_shentsize
TYP
e_shnum
TYP
e_shstrndx
dw_elf64_ehdr
typedef
struct
TYP
p_type
TYP
p_offset
TYP
p_vaddr
TYP
p_paddr
TYP
p_filesz
TYP
p_memsz
TYP
p_flags
TYP
p_align
dw_elf32_phdr
typedef
struct
TYP
p_type
TYP
p_flags
TYP
p_offset
TYP
p_vaddr
TYP
p_paddr
TYP
p_filesz
TYP
p_memsz
TYP
p_align
dw_elf64_phdr
typedef
struct
TYP
sh_name
TYP
sh_type
TYP
sh_flags
TYP
sh_addr
TYP
sh_offset
TYP
sh_size
TYP
sh_link
TYP
sh_info
TYP
sh_addralign
TYP
sh_entsize
dw_elf32_shdr
typedef
struct
TYP
sh_name
TYP
sh_type
TYP
sh_flags
TYP
sh_addr
TYP
sh_offset
TYP
sh_size
TYP
sh_link
TYP
sh_info
TYP
sh_addralign
TYP
sh_entsize
dw_elf64_shdr
typedef
struct
TYP
r_offset
TYP
r_info
dw_elf32_rel
typedef
struct
TYP
r_offset
TYP
r_info
dw_elf64_rel
typedef
struct
TYP
r_offset
TYP
r_info
TYP
r_addend
signed
dw_elf32_rela
typedef
struct
TYP
r_offset
TYP
r_info
TYP
r_addend
signed
dw_elf64_rela
typedef
struct
TYP
st_name
TYP
st_value
TYP
st_size
unsigned
char
st_info
unsigned
char
st_other
TYP
st_shndx
dw_elf32_sym
typedef
struct
TYP
st_name
unsigned
char
st_info
unsigned
char
st_other
TYP
st_shndx
TYP
st_value
TYP
st_size
dw_elf64_sym
typedef
struct
TYP
d_tag
signed
TYP
d_val
Union
in
original
dw_elf32_dyn
typedef
struct
TYP
d_tag
signed
TYP
d_val
Union
in
original
dw_elf64_dyn
ifdef
__cplusplus
endif
__cplusplus
endif
DW_ELFSTRUCTS_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_ERRMSG_LIST_H
define
DWARF_ERRMSG_LIST_H
Array
to
hold
string
representation
of
errors
Any
time
a
define
is
added
to
the
list
in
libdwarf
h
a
string
should
be
added
to
this
Array
Errors
in
the
list
missing
a
comma
for
example
happen
too
often
Making
this
a
separate
little
file
simplifies
testing
for
missing
commas
extra
strings
String
count
should
match
DW_DLE_LAST
const
char
_dwarf_errmsgs
No
error
n
DW_DLE_VMM
dwarf
format
library
version
mismatch
DW_DLE_MAP
memory
map
failure
DW_DLE_LEE
libelf
error
DW_DLE_NDS
no
debug
section
DW_DLE_NLS
no
line
section
DW_DLE_ID
invalid
descriptor
for
query
DW_DLE_IOF
I
O
failure
DW_DLE_MAF
memory
allocation
failure
DW_DLE_IA
invalid
argument
DW_DLE_MDE
mangled
debugging
entry
libelf
detected
error
DW_DLE_MLE
mangled
line
number
entry
DW_DLE_FNO
file
not
open
DW_DLE_FNR
file
not
a
regular
file
DW_DLE_FWA
file
open
with
wrong
access
DW_DLE_NOB
not
an
object
file
DW_DLE_MOF
mangled
object
file
header
DW_DLE_EOLL
end
of
location
list
entries
DW_DLE_NOLL
no
location
list
section
DW_DLE_BADOFF
Invalid
offset
DW_DLE_EOS
end
of
section
DW_DLE_ATRUNC
abbreviations
section
appears
truncated
DW_DLE_BADBITC
Address
size
passed
to
dwarf
bad
DW_DLE_DBG_ALLOC
Unable
to
malloc
a
Dwarf_Debug
structure
DW_DLE_FSTAT_ERROR
The
file
fd
passed
to
dwarf_init
cannot
be
fstat
ed
DW_DLE_FSTAT_MODE_ERROR
The
file
mode
bits
do
not
indicate
that
the
file
being
opened
via
dwarf_init
is
a
normal
file
DW_DLE_INIT_ACCESS_WRONG
A
call
to
dwarf_init
had
an
access
of
other
than
DW_DLC_READ
DW_DLE_ELF_BEGIN_ERROR
a
call
to
elf_begin
ELF_C_READ_MMAP
failed
DW_DLE_ELF_GETEHDR_ERROR
a
call
to
elf32_getehdr
or
elf64_getehdr
failed
DW_DLE_ELF_GETSHDR_ERROR
a
call
to
elf32_getshdr
or
elf64_getshdr
failed
DW_DLE_ELF_STRPTR_ERROR
a
call
to
elf_strptr
failed
trying
to
get
a
section
name
DW_DLE_DEBUG_INFO_DUPLICATE
Only
one
debug_info
section
is
allowed
DW_DLE_DEBUG_INFO_NULL
debug_info
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_ABBREV_DUPLICATE
Only
one
debug_abbrev
section
is
allowed
DW_DLE_DEBUG_ABBREV_NULL
debug_abbrev
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_ARANGES_DUPLICATE
Only
one
debug_aranges
section
is
allowed
DW_DLE_DEBUG_ARANGES_NULL
debug_aranges
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_LINE_DUPLICATE
Only
one
debug_line
section
is
allowed
DW_DLE_DEBUG_LINE_NULL
debug_line
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_LOC_DUPLICATE
Only
one
debug_loc
section
is
allowed
DW_DLE_DEBUG_LOC_NULL
debug_loc
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_MACINFO_DUPLICATE
Only
one
debug_macinfo
section
is
allowed
DW_DLE_DEBUG_MACINFO_NULL
debug_macinfo
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_PUBNAMES_DUPLICATE
Only
one
debug_pubnames
section
is
allowed
DW_DLE_DEBUG_PUBNAMES_NULL
debug_pubnames
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_STR_DUPLICATE
Only
one
debug_str
section
is
allowed
DW_DLE_DEBUG_STR_NULL
debug_str
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_CU_LENGTH_ERROR
Corrupted
DWARF
or
corrupted
object
DW_DLE_VERSION_STAMP_ERROR
Corrupted
DWARF
or
corrupted
object
DW_DLE_ABBREV_OFFSET_ERROR
Corrupted
DWARF
or
corrupted
object
DW_DLE_ADDRESS_SIZE_ERROR
size
too
large
DW_DLE_DEBUG_INFO_PTR_NULL
DW_DLE_DIE_NULL
DW_DLE_STRING_OFFSET_BAD
Corrupted
DWARF
or
corrupted
object
DW_DLE_DEBUG_LINE_LENGTH_BAD
DW_DLE_LINE_PROLOG_LENGTH_BAD
DW_DLE_LINE_NUM_OPERANDS_BAD
DW_DLE_LINE_SET_ADDR_ERROR
DW_DLE_LINE_EXT_OPCODE_BAD
DW_DLE_DWARF_LINE_NULL
DW_DLE_INCL_DIR_NUM_BAD
DW_DLE_LINE_FILE_NUM_BAD
DW_DLE_ALLOC_FAIL
Out
of
memory
or
corrupted
object
DW_DLE_NO_CALLBACK_FUNC
DW_DLE_SECT_ALLOC
DW_DLE_FILE_ENTRY_ALLOC
DW_DLE_LINE_ALLOC
DW_DLE_FPGM_ALLOC
DW_DLE_INCDIR_ALLOC
DW_DLE_STRING_ALLOC
DW_DLE_CHUNK_ALLOC
DW_DLE_BYTEOFF_ERR
DW_DLE_CIE_ALLOC
DW_DLE_FDE_ALLOC
DW_DLE_REGNO_OVFL
DW_DLE_CIE_OFFS_ALLOC
DW_DLE_WRONG_ADDRESS
DW_DLE_EXTRA_NEIGHBORS
DW_DLE_WRONG_TAG
DW_DLE_DIE_ALLOC
DW_DLE_PARENT_EXISTS
DW_DLE_DBG_NULL
DW_DLE_DEBUGLINE_ERROR
DW_DLE_DEBUGFRAME_ERROR
DW_DLE_DEBUGINFO_ERROR
DW_DLE_ATTR_ALLOC
DW_DLE_ABBREV_ALLOC
DW_DLE_OFFSET_UFLW
DW_DLE_ELF_SECT_ERR
DW_DLE_DEBUG_FRAME_LENGTH_BAD
DW_DLE_FRAME_VERSION_BAD
DW_DLE_CIE_RET_ADDR_REG_ERROR
DW_DLE_FDE_NULL
DW_DLE_FDE_DBG_NULL
DW_DLE_CIE_NULL
DW_DLE_CIE_DBG_NULL
DW_DLE_FRAME_TABLE_COL_BAD
DW_DLE_PC_NOT_IN_FDE_RANGE
DW_DLE_CIE_INSTR_EXEC_ERROR
DW_DLE_FRAME_INSTR_EXEC_ERROR
DW_DLE_FDE_PTR_NULL
DW_DLE_RET_OP_LIST_NULL
DW_DLE_LINE_CONTEXT_NULL
DW_DLE_DBG_NO_CU_CONTEXT
DW_DLE_DIE_NO_CU_CONTEXT
DW_DLE_FIRST_DIE_NOT_CU
DW_DLE_NEXT_DIE_PTR_NULL
DW_DLE_DEBUG_FRAME_DUPLICATE
Only
one
debug_frame
section
is
allowed
DW_DLE_DEBUG_FRAME_NULL
debug_frame
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_ABBREV_DECODE_ERROR
DW_DLE_DWARF_ABBREV_NULL
DW_DLE_ATTR_NULL
DW_DLE_DIE_BAD
DW_DLE_DIE_ABBREV_BAD
DW_DLE_ATTR_FORM_BAD
DW_DLE_ATTR_NO_CU_CONTEXT
DW_DLE_ATTR_FORM_SIZE_BAD
DW_DLE_ATTR_DBG_NULL
DW_DLE_BAD_REF_FORM
DW_DLE_ATTR_FORM_OFFSET_BAD
DW_DLE_LINE_OFFSET_BAD
DW_DLE_DEBUG_STR_OFFSET_BAD
DW_DLE_STRING_PTR_NULL
DW_DLE_PUBNAMES_VERSION_ERROR
DW_DLE_PUBNAMES_LENGTH_BAD
DW_DLE_GLOBAL_NULL
DW_DLE_GLOBAL_CONTEXT_NULL
DW_DLE_DIR_INDEX_BAD
DW_DLE_LOC_EXPR_BAD
DW_DLE_DIE_LOC_EXPR_BAD
DW_DLE_ADDR_ALLOC
DW_DLE_OFFSET_BAD
DW_DLE_MAKE_CU_CONTEXT_FAIL
DW_DLE_REL_ALLOC
DW_DLE_ARANGE_OFFSET_BAD
DW_DLE_SEGMENT_SIZE_BAD
Size
of
a
segment
selector
should
usually
be
less
than
bytes
DW_DLE_ARANGE_LENGTH_BAD
DW_DLE_ARANGE_DECODE_ERROR
DW_DLE_ARANGES_NULL
DW_DLE_ARANGE_NULL
DW_DLE_NO_FILE_NAME
DW_DLE_NO_COMP_DIR
DW_DLE_CU_ADDRESS_SIZE_BAD
DW_DLE_INPUT_ATTR_BAD
DW_DLE_EXPR_NULL
DW_DLE_BAD_EXPR_OPCODE
DW_DLE_EXPR_LENGTH_BAD
DW_DLE_MULTIPLE_RELOC_IN_EXPR
DW_DLE_ELF_GETIDENT_ERROR
DW_DLE_NO_AT_MIPS_FDE
DW_DLE_NO_CIE_FOR_FDE
DW_DLE_DIE_ABBREV_LIST_NULL
No
abbrev
exists
for
the
requested
abbrev
code
DW_DLE_DEBUG_FUNCNAMES_DUPLICATE
DW_DLE_DEBUG_FUNCNAMES_NULL
debug_funcnames
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_FUNCNAMES_VERSION_ERROR
DW_DLE_DEBUG_FUNCNAMES_LENGTH_BAD
DW_DLE_FUNC_NULL
DW_DLE_FUNC_CONTEXT_NULL
DW_DLE_DEBUG_TYPENAMES_DUPLICATE
DW_DLE_DEBUG_TYPENAMES_NULL
debug_typenames
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_TYPENAMES_VERSION_ERROR
DW_DLE_DEBUG_TYPENAMES_LENGTH_BAD
DW_DLE_TYPE_NULL
DW_DLE_TYPE_CONTEXT_NULL
DW_DLE_DEBUG_VARNAMES_DUPLICATE
DW_DLE_DEBUG_VARNAMES_NULL
debug_varnames
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_VARNAMES_VERSION_ERROR
DW_DLE_DEBUG_VARNAMES_LENGTH_BAD
DW_DLE_VAR_NULL
DW_DLE_VAR_CONTEXT_NULL
DW_DLE_DEBUG_WEAKNAMES_DUPLICATE
DW_DLE_DEBUG_WEAKNAMES_NULL
debug_weaknames
section
present
but
elf_getdata
failed
or
section
is
zero
length
DW_DLE_DEBUG_WEAKNAMES_VERSION_ERROR
DW_DLE_DEBUG_WEAKNAMES_LENGTH_BAD
DW_DLE_WEAK_NULL
DW_DLE_WEAK_CONTEXT_NULL
DW_DLE_LOCDESC_COUNT_WRONG
DW_DLE_MACINFO_STRING_NULL
DW_DLE_MACINFO_STRING_EMPTY
DW_DLE_MACINFO_INTERNAL_ERROR_SPACE
DW_DLE_MACINFO_MALLOC_FAIL
DW_DLE_DEBUGMACINFO_ERROR
DW_DLE_DEBUG_MACRO_LENGTH_BAD
in
debug_macinfo
DW_DLE_DEBUG_MACRO_MAX_BAD
in
debug_macinfo
DW_DLE_DEBUG_MACRO_INTERNAL_ERR
in
debug_macinfo
DW_DLE_DEBUG_MACRO_MALLOC_SPACE
in
debug_macinfo
DW_DLE_DEBUG_MACRO_INCONSISTENT
in
debug_macinfo
DW_DLE_DF_NO_CIE_AUGMENTATION
DW_DLE_DF_REG_NUM_TOO_HIGH
DW_DLE_DF_MAKE_INSTR_NO_INIT
DW_DLE_DF_NEW_LOC_LESS_OLD_LOC
DW_DLE_DF_POP_EMPTY_STACK
DW_DLE_DF_ALLOC_FAIL
DW_DLE_DF_FRAME_DECODING_ERROR
DW_DLE_DEBUG_LOC_SECTION_SHORT
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
DW_DLE_PUBTYPE_CONTEXT
DW_DLE_DEBUG_PUBTYPES_LENGTH_BAD
DW_DLE_DEBUG_PUBTYPES_VERSION_ERROR
DW_DLE_DEBUG_PUBTYPES_DUPLICATE
DW_DLE_FRAME_CIE_DECODE_ERROR
DW_DLE_FRAME_REGISTER_UNREPRESENTABLE
DW_DLE_FRAME_REGISTER_COUNT_MISMATCH
DW_DLE_LINK_LOOP
DW_DLE_STRP_OFFSET_BAD
DW_DLE_DEBUG_RANGES_DUPLICATE
DW_DLE_DEBUG_RANGES_OFFSET_BAD
DW_DLE_DEBUG_RANGES_MISSING_END
DW_DLE_DEBUG_RANGES_OUT_OF_MEM
DW_DLE_DEBUG_SYMTAB_ERR
DW_DLE_DEBUG_STRTAB_ERR
DW_DLE_RELOC_MISMATCH_INDEX
DW_DLE_RELOC_MISMATCH_RELOC_INDEX
DW_DLE_RELOC_MISMATCH_STRTAB_INDEX
DW_DLE_RELOC_SECTION_MISMATCH
DW_DLE_RELOC_SECTION_MISSING_INDEX
DW_DLE_RELOC_SECTION_LENGTH_ODD
DW_DLE_RELOC_SECTION_PTR_NULL
DW_DLE_RELOC_SECTION_MALLOC_FAIL
DW_DLE_NO_ELF64_SUPPORT
DW_DLE_MISSING_ELF64_SUPPORT
DW_DLE_ORPHAN_FDE
DW_DLE_DUPLICATE_INST_BLOCK
DW_DLE_BAD_REF_SIG8_FORM
DW_DLE_ATTR_EXPRLOC_FORM_BAD
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD
DW_DLE_NOT_REF_FORM
DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE
DW_DLE_REF_SIG8_NOT_HANDLED
DW_DLE_DEBUG_FRAME_POSSIBLE_ADDRESS_BOTCH
DW_DLE_LOC_BAD_TERMINATION
the
last
location
operator
in
an
expression
is
missing
some
associated
data
an
operator
ended
too
soon
DW_DLE_SYMTAB_SECTION_LENGTH_ODD
so
doing
relocations
seems
unsafe
DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD
so
doing
a
relocation
seems
unsafe
DW_DLE_RELOC_SECTION_RELOC_TARGET_SIZE_UNKNOWN
so
doing
a
relocation
is
unsafe
DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO
DW_DLE_LINE_NUMBER_HEADER_ERROR
a
line
number
program
header
seems
incomplete
perhaps
the
header_length
is
wrong?
DW_DLE_DEBUG_TYPES_NULL
DW_DLE_DEBUG_TYPES_DUPLICATE
DW_DLE_DEBUG_TYPES_ONLY_DWARF4
DW4
and
DW5
have
types
CUs
DW_DLE_DEBUG_TYPEOFFSET_BAD
DW_DLE_GNU_OPCODE_ERROR
DW_DLE_DEBUGPUBTYPES_ERROR
could
not
create
pubtypes
section
DW_DLE_AT_FIXUP_NULL
DW_DLE_AT_FIXUP_DUP
DW_DLE_BAD_ABINAME
DW_DLE_TOO_MANY_DEBUG
too
many
debug_
sections
present
somehow
DW_DLE_DEBUG_STR_OFFSETS_DUPLICATE
DW_DLE_SECTION_DUPLICATION
DW_DLE_SECTION_ERROR
DW_DLE_DEBUG_ADDR_DUPLICATE
DW_DLE_DEBUG_CU_UNAVAILABLE_FOR_FORM
DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE
DW_DLE_NEXT_DIE_PAST_END
DW_DLE_NEXT_DIE_WRONG_FORM
DW_DLE_NEXT_DIE_NO_ABBREV_LIST
DW_DLE_NESTED_FORM_INDIRECT_ERROR
DW_DLE_CU_DIE_NO_ABBREV_LIST
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
DW_DLE_ATTR_FORM_NOT_ADDR_INDEX
DW_DLE_ATTR_FORM_NOT_STR_INDEX
DW_DLE_DUPLICATE_GDB_INDEX
DW_DLE_ERRONEOUS_GDB_INDEX_SECTION
The
section
is
too
small
DW_DLE_GDB_INDEX_COUNT_ERROR
DW_DLE_GDB_INDEX_COUNT_ADDR_ERROR
DW_DLE_GDB_INDEX_CUVEC_ERROR
DW_DLE_GDB_INDEX_INDEX_ERROR
DW_DLE_DUPLICATE_CU_INDEX
DW_DLE_DUPLICATE_TU_INDEX
DW_DLE_XU_TYPE_ARG_ERROR
XU
means
dwarf_cu_
or
tu_
index
section
DW_DLE_XU_IMPOSSIBLE_ERROR
XU
means
dwarf_cu_
or
tu_
index
section
DW_DLE_XU_NAME_COL_ERROR
XU
means
dwarf_cu_
or
tu_
index
section
DW_DLE_XU_HASH_ROW_ERROR
XU
means
dwarf_cu_
or
tu_
index
section
DW_DLE_XU_HASH_INDEX_ERROR
XU
means
dwarf_cu_
or
tu_
index
section
DW_DLE_FAILSAFE_ERRVAL
DW_DLE_ARANGE_ERROR
producer
problem
in
object
generation
DW_DLE_PUBNAMES_ERROR
producer
problem
in
object
generation
DW_DLE_FUNCNAMES_ERROR
producer
problem
in
object
generation
DW_DLE_TYPENAMES_ERROR
producer
problem
in
object
generation
DW_DLE_VARNAMES_ERROR
producer
problem
in
object
generation
DW_DLE_WEAKNAMES_ERROR
producer
problem
in
object
generation
DW_DLE_RELOCS_ERROR
producer
problem
in
object
generation
DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION
DW_DLE_FISSION_INDEX_WRONG
DW_DLE_FISSION_VERSION_ERROR
DW_DLE_NEXT_DIE_LOW_ERROR
corrupted
DIE
tree
DW_DLE_CU_UT_TYPE_ERROR
bad
DW_UT_
value
corrupt
DWARF5
DW_DLE_NO_SUCH_SIGNATURE_FOUND
CU
signature
not
in
the
index
DW_DLE_SIGNATURE_SECTION_NUMBER_WRONG
libdwarf
software
error
DW_DLE_ATTR_FORM_NOT_DATA8
wanted
an
byte
signature
DW_DLE_SIG_TYPE_WRONG_STRING
expected
tu
or
cu
DW_DLE_MISSING_REQUIRED_TU_OFFSET_HASH
is
a
broken
dwp
package
file
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
is
a
broken
dwp
package
file
DW_DLE_DWP_MISSING_DWO_ID
DW_DLE_DWP_SIBLING_ERROR
DW_DLE_DEBUG_FISSION_INCOMPLETE
DW_DLE_FISSION_SECNUM_ERR
internal
libdwarf
error
DW_DLE_DEBUG_MACRO_DUPLICATE
DW_DLE_DEBUG_NAMES_DUPLICATE
DW_DLE_DEBUG_LINE_STR_DUPLICATE
DW_DLE_DEBUG_SUP_DUPLICATE
DW_DLE_NO_SIGNATURE_TO_LOOKUP
DW_DLE_NO_TIED_ADDR_AVAILABLE
DW_DLE_NO_TIED_SIG_AVAILABLE
DW_DLE_STRING_NOT_TERMINATED
section
data
may
be
corrupted
DW_DLE_BAD_LINE_TABLE_OPERATION
two
level
line
table
botch
DW_DLE_LINE_CONTEXT_BOTCH
call
is
wrong
or
memory
corruption
DW_DLE_LINE_CONTEXT_INDEX_WRONG
DW_DLE_NO_TIED_STRING_AVAILABLE
tied
file
does
not
have
the
string
DW_DLE_NO_TIED_FILE_AVAILABLE
see
dwarf_set_tied_dbg
DW_DLE_CU_TYPE_MISSING
libdwarf
bug
or
data
corruption
DW_DLE_LLE_CODE_UNKNOWN
libdwarf
bug
or
data
corruption
DW_DLE_LOCLIST_INTERFACE_ERROR
interface
cannot
do
location
or
DW_OP
DW_DLE_LOCLIST_INDEX_ERROR
DW_DLE_INTERFACE_NOT_SUPPORTED
DW_DLE_ZDEBUG_REQUIRES_ZLIB
Unable
to
decompress
zdebug
as
zlib
missing
DW_DLE_ZDEBUG_INPUT_FORMAT_ODD
DW_DLE_ZLIB_BUF_ERROR
Z_BUF_ERROR
buffer
size
small
DW_DLE_ZLIB_DATA_ERROR
Z_DATA_ERROR
compressed
data
corrupted
DW_DLE_MACRO_OFFSET_BAD
DW_DLE_MACRO_OPCODE_BAD
DW_DLE_MACRO_OPCODE_FORM_BAD
DW_DLE_UNKNOWN_FORM
Possibly
corrupt
DWARF
data
DW_DLE_BAD_MACRO_HEADER_POINTER
DW_DLE_BAD_MACRO_INDEX
DW_DLE_MACRO_OP_UNHANDLED
Possibly
an
implementation
extension
DW_DLE_MACRO_PAST_END
DW_DLE_LINE_STRP_OFFSET_BAD
DW_DLE_STRING_FORM_IMPROPER
An
internal
libdwarf
logic
error
DW_DLE_ELF_FLAGS_NOT_AVAILABLE
elf
non
elf
object
confusion?
DW_DLE_LEB_IMPROPER
Runs
off
end
of
section
or
CU
DW_DLE_DEBUG_LINE_RANGE_ZERO
Corrupted
line
section
DW_DLE_READ_LITTLEENDIAN_ERROR
Corrupted
dwarfdata
littleendian
host
DW_DLE_READ_BIGENDIAN_ERROR
Corrupted
dwarf
data
bigendian
host
DW_DLE_RELOC_INVALID
relocation
corruption
DW_DLE_INFO_HEADER_ERROR
Corrupt
dwarf
DW_DLE_ARANGES_HEADER_ERROR
Corrupt
dwarf
DW_DLE_LINE_OFFSET_WRONG_FORM
Corrupt
dwarf
DW_DLE_FORM_BLOCK_LENGTH_ERROR
Corrupt
dwarf
DW_DLE_ZLIB_SECTION_SHORT
Corrupt
dwarf
DW_DLE_CIE_INSTR_PTR_ERROR
DW_DLE_FDE_INSTR_PTR_ERROR
DW_DLE_FISSION_ADDITION_ERROR
Corrupt
dwarf
DW_DLE_HEADER_LEN_BIGGER_THAN_SECSIZE
Corrupt
dwarf
DW_DLE_LOCEXPR_OFF_SECTION_END
Corrupt
dwarf
DW_DLE_POINTER_SECTION_UNKNOWN
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
XU
means
cu_
or
tu_
index
DW_DLE_DIRECTORY_FORMAT_COUNT_VS_DIRECTORIES_MISMATCH
Inconsistent
line
table
corrupted
DW_DLE_COMPRESSED_EMPTY_SECTION
corrupt
section
data
DW_DLE_SIZE_WRAPAROUND
Impossible
string
length
DW_DLE_ILLOGICAL_TSEARCH
Impossible
situation
Corrupted
data?
DW_DLE_BAD_STRING_FORM
Not
a
currently
allowed
form
DW_DLE_DEBUGSTR_ERROR
problem
generating
debug_str
section
DW_DLE_DEBUGSTR_UNEXPECTED_REL
string
relocation
will
be
wrong
DW_DLE_DISCR_ARRAY_ERROR
Internal
error
in
dwarf_discr_list
DW_DLE_LEB_OUT_ERROR
Insufficient
buffer
to
turn
integer
to
leb
DW_DLE_SIBLING_LIST_IMPROPER
Runs
off
end
of
section
Corrupt
dwarf
DW_DLE_LOCLIST_OFFSET_BAD
Corrupt
dwarf
DW_DLE_LINE_TABLE_BAD
Corrupt
line
table
DW_DLE_DEBUG_LOClISTS_DUPLICATE
DW_DLE_DEBUG_RNGLISTS_DUPLICATE
DW_DLE_ABBREV_OFF_END
DW_DLE_FORM_STRING_BAD_STRING
string
runs
off
end
of
data
DW_DLE_AUGMENTATION_STRING_OFF_END
augmentation
runs
off
of
its
section
DW_DLE_STRING_OFF_END_PUBNAMES_LIKE
one
of
the
global
sections
string
bad
DW_DLE_LINE_STRING_BAD
runs
off
end
of
line
data
DW_DLE_DEFINE_FILE_STRING_BAD
runs
off
end
of
section
DW_DLE_MACRO_STRING_BAD
DWARF5
macro
def
undef
string
runs
off
section
data
DW_DLE_MACINFO_STRING_BAD
DWARF2
macro
def
undef
string
runs
off
section
data
DW_DLE_ZLIB_UNCOMPRESS_ERROR
Surely
an
invalid
uncompress
length
DW_DLE_IMPROPER_DWO_ID
DW_DLE_GROUPNUMBER_ERROR
An
error
determining
default
target
group
number
DW_DLE_ADDRESS_SIZE_ZERO
DW_DLE_DEBUG_NAMES_HEADER_ERROR
DW_DLE_DEBUG_NAMES_AUG_STRING_ERROR
corrupt
dwarf
DW_DLE_DEBUG_NAMES_PAD_NON_ZERO
corrupt
dwarf
DW_DLE_DEBUG_NAMES_OFF_END
corrupt
dwarf
DW_DLE_DEBUG_NAMES_ABBREV_OVERFLOW
Surprising
overrun
of
fixed
size
array
DW_DLE_DEBUG_NAMES_ABBREV_CORRUPTION
DW_DLE_DEBUG_NAMES_NULL_POINTER
null
argument
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
index
outside
valid
range
DW_DLE_DEBUG_NAMES_ENTRYPOOL_OFFSET
offset
outside
entrypool
DW_DLE_DEBUG_NAMES_UNHANDLED_FORM
Might
be
corrupt
dwarf
or
incomplete
DWARF
support
DW_DLE_LNCT_CODE_UNKNOWN
DW_DLE_LNCT_FORM_CODE_NOT_HANDLED
Might
be
bad
form
or
just
not
implemented
DW_DLE_LINE_HEADER_LENGTH_BOTCH
Internal
libdwarf
error
DW_DLE_STRING_HASHTAB_IDENTITY_ERROR
Internal
libdwarf
error
DW_DLE_UNIT_TYPE_NOT_HANDLED
Possibly
incomplete
dwarf5
support
DW_DLE_GROUP_MAP_ALLOC
Out
of
malloc
space
DW_DLE_GROUP_MAP_DUPLICATE
Each
section
should
appear
once
DW_DLE_GROUP_COUNT_ERROR
An
inconsistency
in
map
entry
count
DW_DLE_GROUP_INTERNAL_ERROR
libdwarf
data
corruption
DW_DLE_GROUP_LOAD_ERROR
corrupt
data?
DW_DLE_GROUP_LOAD_READ_ERROR
DW_DLE_AUG_DATA_LENGTH_BAD
Data
does
not
fit
in
section
DW_DLE_ABBREV_MISSING
Unable
to
find
abbrev
for
DIE
DW_DLE_NO_TAG_FOR_DIE
DW_DLE_LOWPC_WRONG_CLASS
found
in
dwarf_lowpc
DW_DLE_HIGHPC_WRONG_FORM
found
in
dwarf_highpc
DW_DLE_STR_OFFSETS_BASE_WRONG_FORM
DW_DLE_DATA16_OUTSIDE_SECTION
DW_DLE_LNCT_MD5_WRONG_FORM
DW_DLE_LINE_HEADER_CORRUPT
possible
data
corruption
DW_DLE_STR_OFFSETS_NULLARGUMENT
improper
call
DW_DLE_STR_OFFSETS_NULL_DBG
improper
call
DW_DLE_STR_OFFSETS_NO_MAGIC
improper
call
DLE_STR_OFFSETS_ARRAY_SIZE
Not
a
multiple
of
entry
size
DW_DLE_STR_OFFSETS_VERSION_WRONG
Must
be
DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG
Requested
outside
bound
DW_DLE_STR_OFFSETS_EXTRA_BYTES
debug_str_offsets
section
problem
DW_DLE_DUP_ATTR_ON_DIE
Compiler
error
object
improper
DWARF
DW_DLE_SECTION_NAME_BIG
Caller
provided
insufficient
room
for
section
name
DW_DLE_FILE_UNAVAILABLE
Unable
find
read
object
file
DW_DLE_FILE_WRONG_TYPE
Not
an
object
type
we
recognize
DW_DLE_SIBLING_OFFSET_WRONG
Corrupt
dwarf
DW_DLE_OPEN_FAIL
Unable
to
open
possibly
a
bad
filename
DW_DLE_OFFSET_SIZE
Offset
size
is
neither
nor
DW_DLE_MACH_O_SEGOFFSET_BAD
corrupt
object
DW_DLE_FILE_OFFSET_BAD
corrupt
object
DW_DLE_SEEK_ERROR
Seek
failed
corrupt
object
DW_DLE_READ_ERROR
Read
failed
corrupt
object
DW_DLE_ELF_CLASS_BAD
Corrupt
object
DW_DLE_ELF_ENDIAN_BAD
Corrupt
object
DW_DLE_ELF_VERSION_BAD
Corrupt
object
DW_DLE_FILE_TOO_SMALL
File
is
too
small
to
be
an
object
file
DW_DLE_PATH_SIZE_TOO_SMALL
buffer
passed
to
dwarf_object_detector_path
is
too
small
DW_DLE_BAD_TYPE_SIZE
At
compile
time
the
build
configured
itself
improperly
DW_DLE_PE_SIZE_SMALL
File
too
small
to
be
valid
PE
object
DW_DLE_PE_OFFSET_BAD
Calculated
offset
too
large
Corrupt
object
DW_DLE_PE_STRING_TOO_LONG
Increase
size
for
call
DW_DLE_IMAGE_FILE_UNKNOWN_TYPE
a
PE
object
has
an
unknown
machine
type
not
or
DLE_LINE_TABLE_LINENO_ERROR
Negative
line
number
impossible
Corrupted
line
table
DW_DLE_PRODUCER_CODE_NOT_AVAILABLE
Without
elf
h
the
producer
code
is
not
available
DW_DLE_NO_ELF_SUPPORT
libdwarf
was
compiled
without
Elf
object
support
DW_DLE_NO_STREAM_RELOC_SUPPORT
no
elf
h
so
cannot
generate
STREAM
relocations
DW_DLE_RETURN_EMPTY_PUBNAMES_ERROR
Flag
value
passed
in
not
allowed
DW_DLE_SECTION_SIZE_ERROR
Corrupt
Elf
Section
size
greater
than
file
size
or
not
a
multiple
of
section
entry
size
DW_DLE_INTERNAL_NULL_POINTER
Internal
libdwarf
call
null
pointer
DW_DLE_SECTION_STRING_OFFSET_BAD
Corrupt
Elf
an
offset
to
section
name
is
invalid
DW_DLE_SECTION_INDEX_BAD
Corrupt
Elf
a
section
index
is
incorrect
DW_DLE_INTEGER_TOO_SMALL
Build
does
not
allow
reading
Elf64
DW_DLE_ELF_SECTION_LINK_ERROR
Corrupt
Elf
section
links
in
error
DW_DLE_ELF_SECTION_GROUP_ERROR
Corrupt
Elf
section
group
information
problem
DW_DLE_ELF_SECTION_COUNT_MISMATCH
Corrupt
Elf
or
libdwarf
bug
DW_DLE_ELF_STRING_SECTION_MISSING
Corrupt
Elf
string
section
wrong
type
DW_DLE_SEEK_OFF_END
Corrupt
Elf
Seek
past
the
end
not
allowed
DW_DLE_READ_OFF_END
Corrupt
Elf
A
read
would
read
past
end
of
object
DW_DLE_ELF_SECTION_ERROR
Section
offset
or
size
is
too
large
Corrupt
elf
object
DW_DLE_ELF_STRING_SECTION_ERROR
String
section
missing
Corrupt
Elf
DW_DLE_MIXING_SPLIT_DWARF_VERSIONS
DWARF5
header
signature
and
DWARF4
DW_AT_
GNU
_dwo_id
present
in
one
CU
header
die
Corrupt
Dwarf
DW_DLE_TAG_CORRUPT
DW_TAG
outside
allowed
range
Corrupt
DWARF
DW_DLE_FORM_CORRUPT
DW_FORM
unknown
too
large
a
value
Corrupt
DWARF?
DW_DLE_ATTR_CORRUPT
DW_AT
outside
allowed
range
Corrupt
DWARF
DW_DLE_ABBREV_ATTR_DUPLICATION
Abbreviation
list
corruption
DW_DLE_DWP_SIGNATURE_MISMATCH
Impossible
signature
mismatch
Corrupted
Dwarf?
DW_DLE_CU_UT_TYPE_VALUE
Internal
libdwarf
data
corruption
DW_DLE_DUPLICATE_GNU_DEBUGLINK
Duplicated
section
gnu_debuglink
DW_DLE_CORRUPT_GNU_DEBUGLINK
Section
length
wrong
DW_DLE_CORRUPT_NOTE_GNU_DEBUGID
Data
corruption
in
note
gnu
debugid
section
DW_DLE_CORRUPT_GNU_DEBUGID_SIZE
Section
note
gnu
debugid
size
incorrect
DW_DLE_CORRUPT_GNU_DEBUGID_STRING
Section
note
gnu
debugid
owner
string
not
terminated
properly
DW_DLE_HEX_STRING_ERROR
dwarf_producer_init
extras
string
has
a
bad
hex
string
DW_DLE_DECIMAL_STRING_ERROR
dwarf_producer_init
extras
string
has
a
bad
decimal
string
DW_DLE_PRO_INIT_EXTRAS_UNKNOWN
dwarf_producer_init
extras
string
has
an
unknown
string
DW_DLE_PRO_INIT_EXTRAS_ERR
dwarf_producer_init
extras
string
has
an
unexpected
space
character
DW_DLE_NULL_ARGS_DWARF_ADD_PATH
either
Dwarf_Debug
or
file_path
argument
to
dwarf_add_file_path
is
NULL
DW_DLE_DWARF_INIT_DBG_NULL
a
dwarf_init
call
the
return
dbg
argument
is
null
DW_DLE_ELF_RELOC_SECTION_ERROR
A
relocation
section
header
link
field
is
incorrect
DW_DLE_USER_DECLARED_ERROR
library
user
created
this
DW_DLE_RNGLISTS_ERROR
Corrupt
dwarf
Bad
debug_rnglists
data
DW_DLE_LOCLISTS_ERROR
Corrupt
dwarf
Bad
debug_loclists
data
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
corrupt
section
header
DW_DLE_GDBINDEX_STRING_ERROR
gdb_index
section
string
error
DW_DLE_GNU_PUBNAMES_ERROR
A
problem
with
debug_gnu_pubnames
DW_DLE_GNU_PUBTYPES_ERROR
A
problem
with
debug_gnu_pubtypes
DW_DLE_DUPLICATE_GNU_DEBUG_PUBNAMES
Duplicated
section
debug_gnu_pubnames
DW_DLE_DUPLICATE_GNU_DEBUG_PUBTYPES
Duplicated
section
debug_gnu_pubtypes
DW_DLE_DEBUG_SUP_STRING_ERROR
The
string
in
debug_sup
head
runs
off
the
end
of
the
section
Corrupt
data
DW_DLE_DEBUG_SUP_ERROR
debug_sup
data
corruption
DW_DLE_LOCATION_ERROR
A
location
processing
libdwarf
error
DW_DLE_DEBUGLINK_PATH_SHORT
Buffer
provided
for
GNU
debuglink
is
too
small
DW_DLE_SIGNATURE_MISMATCH
DWARF4
extension
dwo_id
and
dwarf5signature
present
but
they
do
not
match
DW_DLE_MACRO_VERSION_ERROR
Unknown
DWARF5
macro
version
Corrupt
data
DW_DLE_NEGATIVE_SIZE
A
size
from
DW_FORM_implicit_const
is
not
appropriate
DW_DLE_UDATA_VALUE_NEGATIVE
Reading
a
negative
value
from
from
dwarf_formudata
is
not
allowed
endif
DWARF_ERRMSG_LIST_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_ERROR_H
define
DWARF_ERROR_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
void
_dwarf_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
errval
void
_dwarf_error_string
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Signed
errval
char
msg
define
DWARF_DBG_ERROR
dbg
errval
retval
_dwarf_error
dbg
error
errval
return
retval
define
DE_STANDARD
Normal
alloc
attached
to
dbg
define
DE_STATIC
Using
global
static
var
define
DE_MALLOC
Using
malloc
space
struct
Dwarf_Error_s
Dwarf_Signed
er_errval
void
er_msg
If
non
zero
the
Dwarf_Error_s
struct
is
not
malloc
d
To
aid
when
malloc
returns
NULL
If
zero
a
normal
dwarf_dealloc
will
work
er_static_alloc
only
accessed
by
dwarf_alloc
c
If
er_static_alloc
is
in
a
Dwarf_Error_s
struct
set
by
libdwarf
and
client
code
accidentally
turns
that
to
zero
through
a
wild
pointer
reference
the
field
is
hidden
from
clients
then
chaos
will
eventually
follow
int
er_static_alloc
extern
struct
Dwarf_Error_s
_dwarf_failsafe_error
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_ERROR_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
dwarf
standard
dictates
that
only
the
following
fields
can
be
read
when
an
unexpected
augmentation
string
in
the
cie
is
encountered
CIE
length
CIE_id
version
and
augmentation
FDE
length
CIE
pointer
initial
location
and
address
range
Unfortunately
with
the
above
restrictions
it
is
impossible
to
read
the
instruction
table
from
a
CIE
or
a
FDE
when
a
new
augmentation
string
is
encountered
To
fix
this
problem
the
following
layout
is
used
if
the
augmentation
string
starts
with
the
string
z
CIE
FDE
length
length
CIE_id
CIE_pointer
version
initial_location
augmentation
address_range
length_of_augmented_fields
NEW
code_alignment_factor
Any
new
fields
as
necessary
data_alignment_factor
instruction_table
return_address
length_of_augmented
fields
Any
new
fields
as
necessary
initial_instructions
The
type
of
all
the
old
data
items
are
the
same
as
what
is
described
in
dwarf
standard
The
length_of_augmented_fields
is
an
LEB128
data
item
that
denotes
the
size
in
bytes
of
the
augmented
fields
not
including
the
size
of
length_of_augmented_fields
itself
Handling
of
cie
augmentation
strings
is
necessarly
a
heuristic
See
dwarf_frame
c
for
the
currently
known
augmentation
strings
START
SGI
ONLY
COMMENT
SGI
IRIX
versions
of
cie
or
fde
were
intended
to
use
z1
z2
as
the
augmenter
strings
if
required
for
new
augmentation
However
that
never
happened
as
of
March
The
fde
s
augmented
by
the
string
z
have
a
new
field
signed
constant
byte
field
called
offset_into_exception_tables
following
the
length_of_augmented
field
This
field
contains
an
offset
into
the
_MIPS_eh_region
which
describes
the
IRIX
CC
exception
handling
tables
END
SGI
ONLY
COMMENT
GNU
eh_frame
has
an
augmentation
string
of
z
RLP
gcc
The
similarity
to
IRIX
z
and
proposed
but
never
implemented
IRIX
z1
z2
etc
was
confusing
things
If
the
section
is
eh_frame
then
z
means
GNU
exception
information
Augmentation
Data
not
IRIX
z
See
The
Linux
Standard
Base
Core
Specification
version
define
DW_DEBUG_FRAME_VERSION
DWARF2
define
DW_DEBUG_FRAME_VERSION3
DWARF3
define
DW_DEBUG_FRAME_VERSION4
DWARF4
The
following
is
SGI
IRIX
specific
and
probably
no
longer
in
use
anywhere
define
DW_DEBUG_FRAME_AUGMENTER_STRING
mti
v1
The
value
of
the
offset
field
for
Cie
s
define
DW_CIE_OFFSET
The
augmentation
string
may
be
NULL
define
DW_EMPTY_STRING
define
DW_FRAME_INSTR_OPCODE_SHIFT
define
DW_FRAME_INSTR_OFFSET_MASK
This
struct
denotes
the
rule
for
a
register
in
a
row
of
the
frame
table
In
other
words
it
is
one
element
of
the
table
struct
Dwarf_Reg_Rule_s
Is
a
flag
indicating
whether
the
rule
includes
the
offset
field
ie
whether
the
ru_offset
field
is
valid
or
not
Applies
only
if
DW_EXPR_OFFSET
or
DW_EXPR_VAL_OFFSET
It
is
important
since
reg
offset
offset
of
is
different
from
just
register
since
the
former
means
read
memory
at
address
given
by
the
sum
of
register
contents
plus
offset
to
get
the
value
whereas
the
latter
means
the
value
is
in
the
register
The
register
numbers
are
either
real
registers
ie
table
columns
defined
as
real
registers
or
defined
entries
that
are
not
really
hardware
registers
such
as
DW_FRAME_SAME_VAL
or
DW_FRAME_CFA_COL
Dwarf_Sbyte
ru_is_off
DW_EXPR_OFFSET
DWARF2
DW_EXPR_VAL_OFFSET
dwarf2
DW_EXPR_EXPRESSION
dwarf2
DW_EXPR_VAL_EXPRESSION
dwarf2
See
dwarf_frame
h
Dwarf_Sbyte
ru_value_type
Register
involved
in
this
rule
Dwarf_Half
ru_register
Offset
to
add
to
register
if
indicated
by
ru_is_offset
and
if
DW_EXPR_OFFSET
or
DW_EXPR_VAL_OFFSET
If
DW_EXPR_EXPRESSION
or
DW_EXPR_VAL_EXPRESSION
this
is
DW_FORM_block
block
length
not
offset
Dwarf_Unsigned
ru_offset_or_block_len
For
DW_EXPR_EXPRESSION
DW_EXPR_VAL_EXPRESSION
these
is
set
else
Dwarf_Small
ru_block
typedef
struct
Dwarf_Frame_s
Dwarf_Frame
This
structure
represents
a
row
of
the
frame
table
Fr_loc
is
the
pc
value
for
this
row
and
Fr_reg
contains
the
rule
for
each
column
Entry
DW_FRAME_CFA_COL
of
fr_reg
was
the
traditional
MIPS
way
of
setting
CFA
cfa_rule
is
the
new
one
struct
Dwarf_Frame_s
Pc
value
corresponding
to
this
row
of
the
frame
table
Dwarf_Addr
fr_loc
Rules
for
all
the
registers
in
this
row
struct
Dwarf_Reg_Rule_s
fr_cfa_rule
fr_reg_count
is
the
the
number
of
entries
of
the
fr_reg
array
unsigned
long
fr_reg_count
struct
Dwarf_Reg_Rule_s
fr_reg
Dwarf_Frame
fr_next
typedef
struct
Dwarf_Frame_Op_List_s
Dwarf_Frame_Op_List
This
is
used
to
chain
together
Dwarf_Frame_Op
structures
struct
Dwarf_Frame_Op_List_s
Dwarf_Frame_Op
fl_frame_instr
Dwarf_Frame_Op_List
fl_next
See
dwarf_frame
c
for
the
heuristics
used
to
set
the
Dwarf_Cie
ci_augmentation_type
This
succinctly
helps
interpret
the
size
and
meaning
of
debug_frame
and
for
gcc
eh_frame
In
the
case
of
gcc
eh_frame
gcc
z
may
be
followed
by
one
or
more
of
L
R
P
enum
Dwarf_augmentation_type
aug_empty_string
Default
empty
augmentation
string
aug_irix_exception_table
IRIX
plain
z
for
exception
handling
IRIX
CC
compiler
Proposed
z1
z2
never
implemented
aug_gcc_eh_z
gcc
z
augmentation
including
L
R
P
variations
gcc
exception
handling
in
eh_frame
aug_irix_mti_v1
IRIX
mti
v1
augmentation
string
Probably
never
in
any
released
SGI
IRIX
compiler
aug_eh
For
gcc
eh_frame
eh
is
the
string
gcc
egcs
Older
values
aug_armcc
armcc
meaning
the
cfa
calculation
is
corrected
to
be
standard
output
by
Arm
C
RVCT
SP1
and
later
See
http
sourceware
org
ml
gdb
patches
msg00249
html
for
details
aug_unknown
Unknown
augmentation
we
cannot
do
much
HC
From
http
sourceforge
net
p
elftoolchain
tickets
aug_metaware
aug_past_last
This
structure
contains
all
the
pertinent
info
for
a
Cie
Most
of
the
fields
are
taken
straight
from
the
definition
of
a
Cie
Ci_cie_start
points
to
the
address
in
debug_frame
where
this
Cie
begins
Ci_cie_instr_start
points
to
the
first
byte
of
the
frame
instructions
for
this
Cie
Ci_dbg
points
to
the
associated
Dwarf_Debug
structure
Ci_initial_table
is
a
pointer
to
the
table
row
generated
by
the
instructions
for
this
Cie
struct
Dwarf_Cie_s
Dwarf_Unsigned
ci_length
char
ci_augmentation
Dwarf_Small
ci_code_alignment_factor
Dwarf_Sbyte
ci_data_alignment_factor
Dwarf_Small
ci_return_address_register
Dwarf_Small
ci_cie_start
Dwarf_Small
ci_cie_instr_start
Dwarf_Small
ci_cie_end
Dwarf_Debug
ci_dbg
Dwarf_Frame
ci_initial_table
Dwarf_Cie
ci_next
Dwarf_Small
ci_length_size
Dwarf_Small
ci_extension_size
Dwarf_Half
ci_cie_version_number
enum
Dwarf_augmentation_type
ci_augmentation_type
The
following
for
GNU
eh_frame
exception
handling
Augmentation
Data
Set
if
ci_augmentation_type
is
aug_gcc_eh_z
Zero
if
unused
Dwarf_Unsigned
ci_gnu_eh_augmentation_len
Dwarf_Ptr
ci_gnu_eh_augmentation_bytes
These
are
extracted
from
the
gnu
eh_frame
augmentation
if
the
augmentation
begins
with
z
See
Linux
LSB
documents
Otherwize
these
are
zero
unsigned
char
ci_gnu_personality_handler_encoding
unsigned
char
ci_gnu_lsda_encoding
unsigned
char
ci_gnu_fde_begin_encoding
If
P
augmentation
present
is
handler
addr
Else
is
zero
Dwarf_Addr
ci_gnu_personality_handler_addr
In
creating
list
of
cie
s
which
will
become
an
array
record
the
position
so
fde
can
get
it
on
fde
creation
Dwarf_Unsigned
ci_index
Dwarf_Small
ci_section_ptr
Dwarf_Unsigned
ci_section_length
Dwarf_Small
ci_section_end
DWARF4
adds
address
size
and
segment
size
to
the
CIE
the
debug_info
section
may
not
always
be
present
to
allow
libdwarf
to
find
address_size
from
the
compilation
unit
Dwarf_Half
ci_address_size
Dwarf_Half
ci_segment_size
This
structure
contains
all
the
pertinent
info
for
a
Fde
Most
of
the
fields
are
taken
straight
from
the
definition
fd_cie_index
is
the
index
of
the
Cie
associated
with
this
Fde
in
the
list
of
Cie
s
for
this
debug_frame
Fd_cie
points
to
the
corresponding
Dwarf_Cie
structure
Fd_fde_start
points
to
the
start
address
of
the
Fde
Fd_fde_instr_start
points
to
the
start
of
the
instructions
for
this
Fde
Fd_dbg
points
to
the
associated
Dwarf_Debug
structure
struct
Dwarf_Fde_s
Dwarf_Unsigned
fd_length
Dwarf_Addr
fd_cie_offset
Dwarf_Unsigned
fd_cie_index
Dwarf_Cie
fd_cie
Dwarf_Addr
fd_initial_location
Dwarf_Small
fd_initial_loc_pos
Dwarf_Addr
fd_address_range
Dwarf_Small
fd_fde_start
Dwarf_Small
fd_fde_instr_start
Dwarf_Small
fd_fde_end
Dwarf_Debug
fd_dbg
fd_offset_into_exception_tables
is
SGI
IRIX
exception
table
offset
Unused
and
zero
if
not
IRIX
debug_frame
Dwarf_Signed
fd_offset_into_exception_tables
Dwarf_Fde
fd_next
Dwarf_Small
fd_length_size
Dwarf_Small
fd_extension_size
So
we
know
from
an
fde
which
count
of
fde
s
in
Dwarf_Debug
applies
eh
or
standard
Dwarf_Small
fd_is_eh
The
following
for
GNU
eh_frame
exception
handling
Augmentation
Data
Set
if
CIE
ci_augmentation_type
is
aug_gcc_eh_z
Zero
if
unused
Dwarf_Unsigned
fd_gnu_eh_augmentation_len
Dwarf_Bool
fd_gnu_eh_aug_present
Dwarf_Ptr
fd_gnu_eh_augmentation_bytes
Dwarf_Addr
fd_gnu_eh_lsda
If
L
augmentation
letter
present
is
address
of
the
Language
Specific
Data
Area
LSDA
If
not
L
is
zero
The
following
are
about
the
Elf
section
the
FDEs
come
from
Dwarf_Small
fd_section_ptr
Dwarf_Unsigned
fd_section_length
Dwarf_Unsigned
fd_section_index
Dwarf_Small
fd_section_end
If
fd_eh_table_value_set
is
true
then
fd_eh_table_value
is
meaningful
Never
meaningful
for
debug_frame
is
part
of
eh_frame
Dwarf_Unsigned
fd_eh_table_value
Dwarf_Bool
fd_eh_table_value_set
The
following
are
memoization
to
save
recalculation
struct
Dwarf_Frame_s
fd_fde_table
Dwarf_Addr
fd_fde_pc_requested
Dwarf_Bool
fd_have_fde_tab
int
_dwarf_frame_address_offsets
Dwarf_Debug
dbg
Dwarf_Addr
addrlist
Dwarf_Off
offsetlist
Dwarf_Signed
returncount
Dwarf_Error
err
int
_dwarf_get_fde_list_internal
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Small
section_ptr
Dwarf_Unsigned
section_index
Dwarf_Unsigned
section_length
Dwarf_Unsigned
cie_id_value
int
use_gnu_cie_calc
If
non
zero
this
is
gcc
eh_frame
Dwarf_Error
error
enum
Dwarf_augmentation_type
_dwarf_get_augmentation_type
Dwarf_Debug
dbg
Dwarf_Small
augmentation_string
int
is_gcc_eh_frame
int
_dwarf_fde_section_offset
Dwarf_Debug
dbg
Dwarf_Fde
in_fde
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Dwarf_Error
err
int
_dwarf_cie_section_offset
Dwarf_Debug
dbg
Dwarf_Cie
in_cie
Dwarf_Off
cie_off
Dwarf_Error
err
int
_dwarf_get_return_address_reg
Dwarf_Small
frame_ptr
int
version
Dwarf_Debug
dbg
Dwarf_Byte_Ptr
section_end
unsigned
long
size
Dwarf_Unsigned
return_address_register
Dwarf_Error
error
Temporary
recording
of
crucial
cie
fde
prefix
data
Vastly
simplifies
some
argument
lists
struct
cie_fde_prefix_s
cf_start_addr
is
a
pointer
to
the
first
byte
of
this
fde
cie
meaning
the
length
field
itself
Dwarf_Small
cf_start_addr
cf_addr_after_prefix
is
a
pointer
to
the
first
byte
of
this
fde
cie
we
are
reading
now
immediately
following
the
length
field
read
by
READ_AREA_LENGTH
Dwarf_Small
cf_addr_after_prefix
cf_length
is
the
length
field
value
from
the
cie
fde
header
Dwarf_Unsigned
cf_length
int
cf_local_length_size
int
cf_local_extension_size
Dwarf_Unsigned
cf_cie_id
Dwarf_Small
cf_cie_id_addr
used
for
eh_frame
calculations
Simplifies
passing
around
these
values
to
create
fde
having
these
here
cf_section_ptr
is
a
pointer
to
the
first
byte
of
the
object
section
the
prefix
is
read
from
Dwarf_Small
cf_section_ptr
Dwarf_Unsigned
cf_section_index
Dwarf_Unsigned
cf_section_length
int
_dwarf_exec_frame_instr
Dwarf_Bool
make_instr
Dwarf_Frame_Op
ret_frame_instr
Dwarf_Bool
search_pc
Dwarf_Addr
search_pc_val
Dwarf_Addr
initial_loc
Dwarf_Small
start_instr_ptr
Dwarf_Small
final_instr_ptr
Dwarf_Frame
table
Dwarf_Cie
cie
Dwarf_Debug
dbg
Dwarf_Half
reg_num_of_cfa
Dwarf_Signed
returned_count
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
int
dwarf_read_cie_fde_prefix
Dwarf_Debug
dbg
Dwarf_Small
frame_ptr_in
Dwarf_Small
section_ptr_in
Dwarf_Unsigned
section_index_in
Dwarf_Unsigned
section_length_in
struct
cie_fde_prefix_s
prefix_out
Dwarf_Error
error
int
dwarf_create_fde_from_after_start
Dwarf_Debug
dbg
struct
cie_fde_prefix_s
prefix
Dwarf_Small
section_pointer
Dwarf_Small
frame_ptr
Dwarf_Small
section_ptr_end
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_in
Dwarf_Fde
fde_ptr_out
Dwarf_Error
error
int
dwarf_create_cie_from_after_start
Dwarf_Debug
dbg
struct
cie_fde_prefix_s
prefix
Dwarf_Small
section_pointer
Dwarf_Small
frame_ptr
Dwarf_Small
section_ptr_end
Dwarf_Unsigned
cie_count
int
use_gnu_cie_calc
Dwarf_Cie
cie_ptr_out
Dwarf_Error
error
int
_dwarf_frame_constructor
Dwarf_Debug
dbg
void
void
_dwarf_frame_destructor
void
void
_dwarf_fde_destructor
void
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
typedef
struct
Dwarf_Func_Context_s
Dwarf_Func_Context
struct
never
completed
see
dwarf_global
h
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
following
is
based
on
The
gdb
online
documentation
at
https
sourceware
org
gdb
onlinedocs
gdb
Appendix
J
gdb_index
section
format
These
are
the
two
types
gdb_index
uses
the
offset_type
bits
and
other
fields
defined
bits
We
use
our
own
Dwarf_Unsigned
for
all
the
interfaces
these
are
just
for
reading
the
section
data
The
section
data
is
defined
to
be
in
little
endian
regardless
of
the
target
machine
We
use
our
host
endianness
in
all
interfaces
We
simply
assume
unsigned
int
is
bits
FIXME
typedef
Dwarf_Unsigned
gdbindex_64
enum
gdbindex_type_e
git_unknown
git_std
git_address
git_cuvec
struct
Dwarf_Gdbindex_array_instance_s
Dwarf_Small
dg_base
Dwarf_Unsigned
dg_count
the
in_object
struct
size
Dwarf_Unsigned
dg_entry_length
The
size
of
a
single
field
in
the
in
object
struct
int
dg_fieldlen
The
address_area
type
is
a
bit
irregular
enum
gdbindex_type_e
dg_type
struct
Dwarf_Gdbindex_s
Dwarf_Debug
gi_dbg
Dwarf_Small
gi_section_data
Dwarf_Unsigned
gi_section_length
Dwarf_Unsigned
gi_version
Dwarf_Unsigned
gi_cu_list_offset
Dwarf_Unsigned
gi_types_cu_list_offset
Dwarf_Unsigned
gi_address_area_offset
Dwarf_Unsigned
gi_symbol_table_offset
Dwarf_Unsigned
gi_constant_pool_offset
struct
Dwarf_Gdbindex_array_instance_s
gi_culisthdr
struct
Dwarf_Gdbindex_array_instance_s
gi_typesculisthdr
struct
Dwarf_Gdbindex_array_instance_s
gi_addressareahdr
struct
Dwarf_Gdbindex_array_instance_s
gi_symboltablehdr
struct
Dwarf_Gdbindex_array_instance_s
gi_cuvectorhdr
Dwarf_Small
gi_string_pool
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
typedef
struct
Dwarf_Global_Context_s
Dwarf_Global_Context
This
struct
contains
header
information
for
a
set
of
pubnames
Essentially
they
contain
the
context
for
a
set
of
pubnames
belonging
to
a
compilation
unit
This
is
also
used
for
the
sgi
specific
weaknames
typenames
varnames
funcnames
data
the
structs
for
those
are
incomplete
and
instances
of
this
are
used
instead
Also
used
for
DWARF3
debug_pubtypes
These
never
refer
to
debug_types
only
to
debug_info
struct
Dwarf_Global_Context_s
For
this
context
size
of
a
length
or
unsigned
char
pu_length_size
Size
of
the
pubnames
data
for
the
CU
unsigned
char
pu_length
For
this
CU
size
of
the
extension
except
for
dwarf2
extension
in
which
case
is
unsigned
char
pu_extension_size
Dwarf_Half
pu_version
or
offset
in
pubnames
of
the
pu
header
Dwarf_Off
pu_pub_offset
Offset
into
debug_info
of
the
compilation
unit
header
not
DIE
for
this
set
of
pubnames
Dwarf_Off
pu_offset_of_cu_header
Size
of
compilation
unit
that
these
pubnames
are
in
Dwarf_Unsigned
pu_info_length
unsigned
pu_alloc_type
DW_DLA
something
Dwarf_Debug
pu_dbg
This
struct
contains
information
for
a
single
pubname
struct
Dwarf_Global_s
Offset
from
the
start
of
the
corresponding
compilation
unit
of
the
DIE
for
the
given
pubname
CU
Dwarf_Off
gl_named_die_offset_within_cu
Points
to
the
given
pubname
Dwarf_Small
gl_name
Context
for
this
pubname
Dwarf_Global_Context
gl_context
unsigned
gl_alloc_type
DW_DLA
something
int
_dwarf_internal_get_pubnames_like_data
Dwarf_Debug
dbg
const
char
secname
Dwarf_Small
section_data_ptr
Dwarf_Unsigned
section_length
Dwarf_Global
globals
Dwarf_Signed
return_count
Dwarf_Error
error
int
context_code
int
global_code
int
length_err_num
int
version_err_num
void
_dwarf_internal_globals_dealloc
Dwarf_Debug
dbg
Dwarf_Global
dwgl
Dwarf_Signed
count
ifdef
__sgi
__sgi
should
only
be
defined
for
IRIX
MIPS
void
_dwarf_fix_up_offset_irix
Dwarf_Debug
dbg
Dwarf_Unsigned
varp
char
caller_site_name
define
FIX_UP_OFFSET_IRIX_BUG
ldbg
var
name
_dwarf_fix_up_offset_irix
ldbg
name
else
__sgi
define
FIX_UP_OFFSET_IRIX_BUG
ldbg
var
name
endif
__sgi
Copyright
C
David
Anderson
All
Rights
Reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
is
for
accessing
debug_gnu_pubnames
and
debug_gnu_pubtypes
It
has
nothing
to
do
with
gdb_index
struct
DGI_Entry_s
char
ge_string
Dwarf_Unsigned
ge_debug_info_offset
char
ge_flag_byte
if
Following
is
DW_GNUIVIS
bit
of
flag
byte
shifted
right
char
ge_flag_global_static
Following
is
DW_GNUIKIND
bits
of
flag
byte
shifted
right
Bits
are
reserved
and
should
de
zero
char
ge_flag_type
endif
each
block
data
on
disk
looks
like
LENGTH
which
determines
offset
size
version
offset
into
debug_info
offsetsize
size
of
area
in
debug_info
offsetsize
For
each
entry
offset
in
debug_info
of
DIE
offsetsize
byte
flag
strlen
string
Trailing
LENGTH
bytes
zero
struct
Dwarf_Gnu_IBlock_s
Dwarf_Gnu_Index_Head
ib_head
Dwarf_Unsigned
ib_index
of
this
ib
Dwarf_Unsigned
ib_block_length_offset
Dwarf_Unsigned
ib_block_length
Dwarf_Half
ib_offset_size
or
Dwarf_Half
ib_extension_size
or
Dwarf_Half
ib_version
Dwarf_Bool
ib_counted_entries
see
ib_entry_count
Dwarf_Unsigned
ib_offset_in_debug_info
Dwarf_Unsigned
ib_size_in_debug_info
following
the
length
field
Dwarf_Unsigned
ib_b_data_offset
Dwarf_Unsigned
ib_b_offset
offset
of
entry
area
Dwarf_Small
ib_b_data
the
entry
area
entrylength
LENGTH
offsetsize
Dwarf_Unsigned
ib_b_entrylength
Dwarf_Unsigned
ib_entry_count
struct
DGI_Entry_s
ib_entryarray
struct
Dwarf_Gnu_Index_Head_s
Dwarf_Debug
gi_dbg
Dwarf_Small
gi_section_data
Dwarf_Unsigned
gi_section_length
struct
Dwarf_Gnu_IBlock_s
gi_blockarray
Dwarf_Unsigned
gi_blockcount
Dwarf_Bool
gi_is_pubnames
if
false
is
pubtypes
void
_dwarf_gnu_index_head_destructor
void
incoming
void
_dwarf_free_gnu_index_head_content
Dwarf_Gnu_Index_Head
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
void
dwarf_harmless_init
struct
Dwarf_Harmless_s
dhp
unsigned
size
void
dwarf_harmless_cleanout
struct
Dwarf_Harmless_s
dhp
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_INCL_H
define
DWARF_INCL_H
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
string
h
strcpy
strlen
include
stddef
h
include
libdwarf_private
h
include
dwarf
h
include
libdwarf
h
include
dwarf_base_types
h
include
dwarf_opaque
h
endif
DWARF_INCL_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
define
DW_EXTENDED_OPCODE
This
is
used
as
the
starting
value
for
an
algorithm
to
get
the
minimum
difference
between
values
UINT_MAX
is
used
as
our
approximation
to
infinity
define
MAX_LINE_DIFF
UINT_MAX
This
is
for
a
sanity
check
on
line
table
extended
opcodes
It
is
entirely
arbitrary
and
is
surely
too
small
if
someone
was
inserting
strings
in
the
opcode
define
DW_LNE_LEN_MAX
This
structure
is
used
to
build
a
list
of
all
the
files
that
are
used
in
the
current
compilation
unit
All
of
the
fields
execpt
fi_next
have
meanings
that
are
obvious
from
section
of
the
Libdwarf
Doc
Because
of
DW_LNE_define_file
we
make
this
a
list
not
an
array
struct
Dwarf_File_Entry_s
struct
Dwarf_File_Entry_s
fi_next
Points
to
string
naming
the
file
DW_LNCT_path
Dwarf_Small
fi_file_name
Points
to
string
naming
the
source
with
n
endings
and
null
terminated
UTF
Embedded
source
Dwarf_Small
fi_llvm_source
Index
into
the
list
of
directories
of
the
directory
in
which
this
file
exits
For
DWARF5
values
are
to
N
For
DWARF4
etc
values
are
to
N
so
the
test
for
overrun
differs
Dwarf_Unsigned
fi_dir_index
Time
of
last
modification
of
the
file
Dwarf_Unsigned
fi_time_last_mod
Length
in
bytes
of
the
file
Dwarf_Unsigned
fi_file_length
Dwarf_Small
fi_gnu_subprogram_name
Dwarf_Unsigned
fi_gnu_decl_file
Dwarf_Unsigned
fi_gnu_decl_line
Dwarf_Form_Data16
fi_md5_value
char
fi_dir_index_present
char
fi_time_last_mod_present
char
fi_file_length_present
char
fi_md5_present
char
fi_gnu_decl_file_present
char
fi_gnu_decl_line_present
Part
of
two
level
line
tables
support
struct
Dwarf_Subprog_Entry_s
Dwarf_Small
ds_subprog_name
Dwarf_Unsigned
ds_decl_file
Dwarf_Unsigned
ds_decl_line
typedef
struct
Dwarf_Subprog_Entry_s
Dwarf_Subprog_Entry
struct
Dwarf_Unsigned_Pair_s
Dwarf_Unsigned
up_first
Dwarf_Unsigned
up_second
This
structure
provides
the
context
in
which
the
fields
of
a
Dwarf_Line
structure
are
interpreted
They
come
from
the
statement
program
prologue
Updated
by
dwarf_srclines
in
dwarf_line
c
lc_magic
will
be
DW_CONTEXT_MAGIC
unless
there
is
a
serious
programming
error
somewhere
It
s
set
zero
when
a
Line_Context
is
deallocated
Any
other
value
indicates
there
is
bug
somewhere
define
DW_CONTEXT_MAGIC
struct
Dwarf_Line_Context_s
unsigned
lc_magic
lc_new_style_access
is
non
zero
if
this
was
allocated
via
a
dwarf_srclines_b
call
or
equivalent
Otherwise
this
is
unsigned
char
lc_new_style_access
Dwarf_Unsigned
lc_unit_length
all
versions
The
section
offset
in
debug_line
or
debug_line
dwo
of
the
line
table
Dwarf_Unsigned
lc_section_offset
for
DWARF2
for
DWARF3
for
DWARF4
for
DWARF5
for
experimental
two
level
line
tables
Dwarf_Half
lc_version_number
all
versions
Total
length
of
the
line
data
for
this
CU
Dwarf_Unsigned
lc_total_length
all
versions
Length
of
the
initial
length
field
itself
Dwarf_Half
lc_length_field_length
all
versions
address
size
and
segment
sizefields
new
in
DWARF5
header
Dwarf_Small
lc_address_size
DWARF5
Dwarf_Small
lc_segment_selector_size
DWARF5
Dwarf_Unsigned
lc_header_length
all
versions
Dwarf_Unsigned
lc_prologue_length
Dwarf_Unsigned
lc_actuals_table_offset
Dwarf_Unsigned
lc_logicals_table_offset
Dwarf_Small
lc_minimum_instruction_length
all
versions
Dwarf_Ubyte
lc_maximum_ops_per_instruction
DWARF5
Start
and
end
of
this
CU
line
area
pf_line_ptr_start
pf_total_length
pf_length_field_length
pf_line_ptr_end
Meaning
lc_line_ptr_start
is
before
the
length
info
Dwarf_Small
lc_line_ptr_start
Dwarf_Small
lc_line_ptr_end
Start
of
the
lines
themselves
Dwarf_Small
lc_line_ptr_lines
Used
to
check
that
decoding
of
the
line
prologue
is
done
right
Dwarf_Small
lc_line_prologue_start
Dwarf_Small
lc_default_is_stmt
all
versions
Dwarf_Sbyte
lc_line_base
all
versions
Dwarf_Small
lc_line_range
all
versions
Highest
std
opcode
Dwarf_Small
lc_opcode_base
all
versions
pf_opcode_base
entries
each
a
count
normally
the
value
of
each
entry
is
or
Dwarf_Small
lc_opcode_length_table
all
versions
The
number
to
treat
as
standard
ops
This
is
a
special
accomodation
of
gcc
using
the
new
standard
opcodes
but
not
updating
the
version
number
It
s
legal
dwarf2
but
much
better
for
the
user
to
understand
as
dwarf3
when
it
looks
ok
Dwarf_Small
lc_std_op_count
includes
Points
to
the
portion
of
debug_line
section
that
contains
a
list
of
strings
naming
the
included
directories
Do
not
free
No
free
even
DWARF5?
An
array
of
pointers
to
strings
DWARF
does
not
name
the
current
dir
of
the
compilation
DWARF5
Initial
entry
is
the
dir
of
the
compilation
Dwarf_Small
lc_include_directories
Count
of
the
number
of
included
directories
Dwarf_Unsigned
lc_include_directories_count
count
of
uleb
pairs
Dwarf_Unsigned
lc_directory_entry_format_count
DWARF5
Dwarf_Unsigned
lc_directory_entry_values_count
DWARF5
This
must
be
freed
malloc
space
an
array
of
the
values
of
each
entry
DWARF5
struct
Dwarf_Unsigned_Pair_s
lc_directory_format_values
end
includes
file
names
Dwarf_Unsigned
lc_file_name_format_count
DWARF5
Dwarf_Unsigned
lc_file_name_format
DWARF5
Dwarf_Unsigned
lc_file_entry_values_count
DWARF5
This
must
be
freed
malloc
space
an
array
of
the
values
of
each
entry
struct
Dwarf_Unsigned_Pair_s
lc_file_format_values
DWARF5
Points
to
a
singly
linked
list
of
entries
providing
info
about
source
files
for
the
current
set
of
Dwarf_Line
structures
The
initial
entry
on
the
list
is
file
per
DWARF2
rules
And
so
on
lc_last_entry
points
at
the
last
entry
in
the
list
so
we
can
easily
expand
the
list
It
s
a
list
not
a
table
since
we
may
encounter
DW_LNE_define_file
entries
For
Dwarf5
the
initial
entry
is
file
and
must
match
the
CU
DIE
DW_AT_name
string
Dwarf_File_Entry
lc_file_entries
Dwarf_File_Entry
lc_last_entry
Count
of
number
of
source
files
for
this
set
of
Dwarf_Line
structures
Dwarf_Unsigned
lc_file_entry_count
all
versions
Values
Easing
the
process
of
indexing
through
lc_file_entries
Dwarf_Unsigned
lc_file_entry_baseindex
Dwarf_Unsigned
lc_file_entry_endindex
end
file
names
Points
to
an
array
of
subprogram
entries
With
Two
level
line
tables
this
may
be
non
zero
An
array
of
Dwarf_Subprogram_Entry_s
structs
Dwarf_Subprog_Entry
lc_subprogs
Count
of
the
number
of
subprogram
entries
With
Two
level
line
tables
this
may
be
non
zero
Dwarf_Unsigned
lc_subprogs_count
Count
of
the
number
of
lines
for
this
cu
Dwarf_Unsigned
lc_line_count
Points
to
name
of
compilation
directory
That
string
is
in
a
debug
section
DWARF
so
do
not
free
this
For
DWARF5
must
be
the
same
as
lc_include_directories
Dwarf_Small
lc_compilation_directory
Dwarf_Debug
lc_dbg
zero
table
count
is
skeleton
or
just
missing
names
is
standard
table
means
two
level
table
experimental
Other
is
a
bug
somewhere
Dwarf_Small
lc_table_count
Dwarf_Bool
lc_is_single_table
For
standard
line
tables
the
logicals
are
the
only
tables
and
linecount_actuals
is
Dwarf_Line
lc_linebuf_logicals
Dwarf_Unsigned
lc_linecount_logicals
Non
zero
only
if
two
level
table
with
actuals
Dwarf_Line
lc_linebuf_actuals
Dwarf_Unsigned
lc_linecount_actuals
The
line
table
set
of
registers
The
state
machine
state
variables
Using
names
from
the
DWARF
documentation
but
preceded
by
lr_
struct
Dwarf_Line_Registers_s
Dwarf_Addr
lr_address
DWARF2
Dwarf_Unsigned
lr_file
DWARF2
Dwarf_Unsigned
lr_line
DWARF2
Dwarf_Unsigned
lr_column
DWARF2
Dwarf_Bool
lr_is_stmt
DWARF2
Dwarf_Bool
lr_basic_block
DWARF2
Dwarf_Bool
lr_end_sequence
DWARF2
Dwarf_Bool
lr_prologue_end
DWARF3
Dwarf_Bool
lr_epilogue_begin
DWARF3
Dwarf_Small
lr_isa
DWARF3
Dwarf_Unsigned
lr_op_index
DWARF4
operation
within
VLIW
instruction
Dwarf_Unsigned
lr_discriminator
DWARF4
Dwarf_Unsigned
lr_call_context
EXPERIMENTAL
Dwarf_Unsigned
lr_subprogram
EXPERIMENTAL
typedef
struct
Dwarf_Line_Registers_s
Dwarf_Line_Registers
void
_dwarf_set_line_table_regs_default_values
Dwarf_Line_Registers
regs
unsigned
lineversion
Dwarf_Bool
is_stmt
This
structure
defines
a
row
of
the
line
table
All
of
the
fields
except
li_offset
have
the
exact
same
meaning
that
is
defined
in
Section
of
the
Libdwarf
Document
li_offset
is
used
by
_dwarf_addr_finder
which
is
called
by
rqs
an
sgi
utility
for
moving
shared
libraries
as
if
the
static
linker
ld
had
linked
the
shared
library
at
the
newly
specified
address
Most
libdwarf
using
apps
will
ignore
li_offset
and
_dwarf_addr_finder
struct
Dwarf_Line_s
Dwarf_Addr
li_address
pc
value
of
machine
instr
union
addr_or_line_s
struct
li_inner_s
New
as
of
DWARF4
Dwarf_Unsigned
li_discriminator
int
identifying
src
file
li_file
is
a
number
N
indexing
into
a
conceptual
source
file
table
as
described
in
dwarf2
spec
line
table
doc
see
Dwarf_File_Entry
lc_file_entries
and
Dwarf_Unsigned
lc_file_entry_count
Dwarf_Unsigned
li_file
In
single
level
table
is
line
number
in
source
file
N
In
logicals
table
is
not
used
In
actuals
table
is
index
into
logicals
table
N
Dwarf_Unsigned
li_line
Dwarf_Half
li_column
source
file
column
number
N
Dwarf_Small
li_isa
New
as
of
DWARF4
Two
level
line
tables
Is
index
from
logicals
table
into
logicals
table
N
Dwarf_Unsigned
li_call_context
Two
level
line
tables
is
index
into
subprograms
table
N
Dwarf_Unsigned
li_subprogram
To
save
space
use
bit
flags
indicate
start
of
stmt
unsigned
li_is_stmt
indicate
start
basic
block
unsigned
li_basic_block
first
post
sequence
instr
unsigned
li_end_sequence
unsigned
li_prologue_end
unsigned
li_epilogue_begin
Mark
a
line
record
as
being
DW_LNS_set_address
unsigned
li_is_addr_set
li_l_data
ifdef
__sgi
SGI
IRIX
ONLY
Dwarf_Off
li_offset
for
SGI
IRIX
rqs
only
endif
__sgi
li_addr_line
Dwarf_Line_Context
li_context
assoc
Dwarf_Line_Context_s
Set
only
on
the
actuals
table
of
a
two
level
line
table
Assists
in
the
dealloc
code
Dwarf_Bool
li_is_actuals_table
int
_dwarf_line_address_offsets
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Addr
addrs
Dwarf_Off
offs
Dwarf_Unsigned
returncount
Dwarf_Error
err
int
_dwarf_internal_srclines
Dwarf_Die
die
Dwarf_Bool
old_interface
Dwarf_Unsigned
version
Dwarf_Small
table_count
Dwarf_Line_Context
line_context
Dwarf_Line
linebuf
Dwarf_Signed
count
Dwarf_Line
linebuf_actuals
Dwarf_Signed
count_actuals
Dwarf_Bool
doaddrs
Dwarf_Bool
dolines
Dwarf_Error
error
The
LOP
WHAT_IS_OPCODE
stuff
is
here
so
it
can
be
reused
in
places
Seemed
hard
to
keep
the
places
the
same
without
an
inline
func
or
a
macro
Handling
the
line
section
where
the
header
and
the
file
being
processed
do
not
match
unusual
but
planned
for
in
the
design
of
debug_line
is
too
tricky
to
recode
this
several
times
and
keep
it
right
define
LOP_EXTENDED
define
LOP_DISCARD
define
LOP_STANDARD
define
LOP_SPECIAL
define
WHAT_IS_OPCODE
type
opcode
base
opcode_length
line_ptr
highest_std
if
opcode
base
we
know
we
must
treat
as
a
standard
op
or
a
special
case
if
opcode
DW_EXTENDED_OPCODE
type
LOP_EXTENDED
else
if
highest_std
base
Standard
case
compile
of
dwarf_line
c
and
object
have
same
standard
op
codes
set
Special
case
compile
of
dwarf_line
c
has
things
in
standard
op
codes
list
in
dwarf
h
header
not
in
the
object
handle
this
as
a
standard
op
code
in
switch
below
The
header
special
ops
overlap
the
object
standard
ops
The
new
standard
op
codes
will
not
appear
in
the
object
type
LOP_STANDARD
else
These
are
standard
opcodes
in
the
object
that
were
not
defined
in
the
header
at
the
time
dwarf_line
c
was
compiled
Provides
the
ability
of
out
of
date
dwarf
reader
to
read
newer
line
table
data
transparently
type
LOP_DISCARD
else
Is
a
special
op
code
type
LOP_SPECIAL
The
following
is
from
the
dwarf
definition
of
ubyte
and
is
specifically
mentioned
in
section
page
of
the
Rev
dwarf
specification
define
MAX_LINE_OP_CODE
Operand
counts
per
standard
operand
The
initial
zero
is
for
DW_LNS_copy
This
is
an
economical
way
to
verify
we
understand
the
table
of
standard
opcode
lengths
in
the
line
table
prologue
define
STANDARD_OPERAND_COUNT_DWARF2
define
STANDARD_OPERAND_COUNT_DWARF3
For
two
level
line
tables
we
have
three
additional
standard
opcodes
define
STANDARD_OPERAND_COUNT_TWO_LEVEL
void
_dwarf_print_header_issue
Dwarf_Debug
dbg
const
char
specific_msg
Dwarf_Small
data_start
Dwarf_Signed
value
unsigned
index
unsigned
tabv
unsigned
linetabv
int
err_count_out
int
_dwarf_decode_line_string_form
Dwarf_Debug
dbg
Dwarf_Unsigned
attrnum
Dwarf_Unsigned
form
Dwarf_Unsigned
offset_size
Dwarf_Small
line_ptr
Dwarf_Small
line_ptr_end
char
return_str
Dwarf_Error
error
int
_dwarf_decode_line_udata_form
Dwarf_Debug
dbg
Dwarf_Unsigned
attrnum
Dwarf_Unsigned
form
Dwarf_Small
line_ptr
Dwarf_Unsigned
return_val
Dwarf_Small
line_end_ptr
Dwarf_Error
error
void
_dwarf_report_bad_lnct
Dwarf_Debug
dbg
Dwarf_Unsigned
ltype
int
dlecode
const
char
dlename
Dwarf_Error
err
void
_dwarf_update_chain_list
Dwarf_Chain
chain_line
Dwarf_Chain
head_chain
Dwarf_Chain
curr_chain
void
_dwarf_free_chain_entries
Dwarf_Debug
dbg
Dwarf_Chain
head
int
count
int
_dwarf_line_context_constructor
Dwarf_Debug
dbg
void
m
void
_dwarf_line_context_destructor
void
m
void
_dwarf_print_line_context_record
Dwarf_Debug
dbg
Dwarf_Line_Context
line_context
void
_dwarf_context_src_files_destroy
Dwarf_Line_Context
context
int
_dwarf_add_to_files_list
Dwarf_Line_Context
context
Dwarf_File_Entry
fe
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
Google
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
is
included
twice
Once
for
libdwarf
callers
and
one
for
dwarfdump
which
prints
the
internals
This
way
we
have
just
one
blob
of
code
that
reads
the
table
operations
static
unsigned
char
dwarf_standard_opcode_operand_count
STANDARD_OPERAND_COUNT_TWO_LEVEL
DWARF2
Following
are
new
for
DWARF3
Experimental
opcodes
We
have
a
normal
standard
opcode
base
but
an
arm
compiler
emitted
a
non
standard
table
This
could
lead
to
problems
ARM
C
C
Compiler
RVCT4
Build
seems
to
get
the
table
wrong
static
unsigned
char
dwarf_arm_standard_opcode_operand_count
STANDARD_OPERAND_COUNT_DWARF3
DWARF2
this
is
wrong
Following
are
new
for
DWARF3
Rather
like
memcmp
but
identifies
which
value
pair
mismatches
the
return
value
is
non
zero
if
mismatch
zero
if
match
mismatch_entry
returns
the
table
index
that
mismatches
tabval
returns
the
table
byte
value
lineval
returns
the
value
from
the
line
table
header
static
int
operandmismatch
unsigned
char
table
unsigned
table_length
unsigned
char
linetable
unsigned
check_count
unsigned
mismatch_entry
unsigned
tabval
unsigned
lineval
unsigned
i
check_count
better
be
table_length
for
i
i
check_count
i
if
i
table_length
mismatch_entry
i
lineval
linetable
i
tabval
No
entry
present
A
kind
of
mismatch
return
TRUE
if
table
i
linetable
i
continue
mismatch_entry
i
tabval
table
i
lineval
linetable
i
return
TRUE
Matches
return
FALSE
Encapsulates
DECODE_LEB128_UWORD_CK
so
the
caller
can
free
resources
in
case
of
problems
static
int
read_uword_de
Dwarf_Small
lp
Dwarf_Unsigned
out_p
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Small
lpend
Dwarf_Small
inptr
lp
Dwarf_Unsigned
out
DECODE_LEB128_UWORD_CK
inptr
out
dbg
err
lpend
lp
inptr
out_p
out
return
DW_DLV_OK
static
int
read_sword_de
Dwarf_Small
lp
Dwarf_Signed
out_p
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Small
lpend
Dwarf_Small
inptr
lp
Dwarf_Signed
out
DECODE_LEB128_SWORD_CK
inptr
out
dbg
err
lpend
lp
inptr
out_p
out
return
DW_DLV_OK
Common
line
table
header
reading
code
Returns
DW_DLV_OK
DW_DLV_ERROR
DW_DLV_NO_ENTRY
cannot
be
returned
but
callers
should
assume
it
is
possible
The
line_context
area
must
be
initialized
properly
before
calling
this
Has
the
side
effect
of
allocating
arrays
which
must
be
freed
see
the
Line_Table_Context
which
holds
the
pointers
to
space
we
allocate
here
bogus_bytes_ptr
and
bogus_bytes
are
output
values
which
let
a
print
program
notify
the
user
of
some
surprising
bytes
after
a
line
table
header
and
before
the
line
table
instructions
These
can
be
ignored
unless
one
is
printing
And
are
ignored
if
NULL
passed
as
the
pointer
err_count_out
may
be
NULL
in
which
case
we
make
no
attempt
to
count
checking
type
errors
Checking
type
errors
do
not
stop
us
we
just
report
them
See
dw
linetableheader
txt
for
the
ordering
of
text
fields
across
the
various
dwarf
versions
The
code
follows
this
ordering
closely
Some
of
the
arguments
remaining
are
in
line_context
so
can
be
deleted
from
the
argument
list
after
a
close
look
for
correctness
static
int
_dwarf_read_line_table_header
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Small
section_start
Dwarf_Small
data_start
Dwarf_Unsigned
section_length
Dwarf_Small
updated_data_start_out
Dwarf_Line_Context
line_context
Dwarf_Small
bogus_bytes_ptr
Dwarf_Unsigned
bogus_bytes
Dwarf_Error
err
int
err_count_out
Dwarf_Small
line_ptr
data_start
Dwarf_Small
starting_line_ptr
data_start
Dwarf_Unsigned
total_length
int
local_length_size
int
local_extension_size
Dwarf_Unsigned
prologue_length
Dwarf_Half
version
Both
of
the
next
two
should
point
one
past
the
end
of
actual
data
of
interest
Dwarf_Small
section_end
section_start
section_length
Dwarf_Small
line_ptr_end
Dwarf_Small
lp_begin
int
res
Dwarf_Unsigned
htmp
if
bogus_bytes_ptr
bogus_bytes_ptr
if
bogus_bytes
bogus_bytes
line_context
lc_line_ptr_start
starting_line_ptr
READ_AREA_LENGTH
updates
line_ptr
for
consumed
bytes
READ_AREA_LENGTH_CK
dbg
total_length
Dwarf_Unsigned
line_ptr
local_length_size
local_extension_size
err
section_length
section_end
line_ptr_end
line_ptr
total_length
line_context
lc_line_ptr_end
line_ptr_end
line_context
lc_length_field_length
local_length_size
local_extension_size
line_context
lc_section_offset
starting_line_ptr
dbg
de_debug_line
dss_data
ASSERT
line_context
lc_length_field_length
line_ptr
line_context
lc_line_ptr_start
if
line_ptr_end
section_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_total_length
total_length
READ_UNALIGNED_CK
dbg
version
Dwarf_Half
line_ptr
DWARF_HALF_SIZE
err
line_ptr_end
res
_dwarf_read_unaligned_ck_wrapper
dbg
line_ptr
DWARF_HALF_SIZE
line_ptr_end
err
if
res
DW_DLV_ERROR
return
res
version
htmp
line_context
lc_version_number
version
line_ptr
DWARF_HALF_SIZE
if
version
DW_LINE_VERSION2
version
DW_LINE_VERSION3
version
DW_LINE_VERSION4
version
DW_LINE_VERSION5
version
EXPERIMENTAL_LINE_TABLES_VERSION
_dwarf_error
dbg
err
DW_DLE_VERSION_STAMP_ERROR
return
DW_DLV_ERROR
if
version
DW_LINE_VERSION5
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_address_size
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_segment_selector_size
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
else
line_context
lc_address_size
cu_context
cc_address_size
line_context
lc_segment_selector_size
cu_context
cc_segment_selector_size
READ_UNALIGNED_CK
dbg
prologue_length
Dwarf_Unsigned
line_ptr
local_length_size
err
line_ptr_end
line_context
lc_prologue_length
prologue_length
line_ptr
local_length_size
line_context
lc_line_prologue_start
line_ptr
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_minimum_instruction_length
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
if
version
DW_LINE_VERSION4
version
DW_LINE_VERSION5
version
EXPERIMENTAL_LINE_TABLES_VERSION
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_maximum_ops_per_instruction
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_default_is_stmt
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_LENGTH_BAD
return
DW_DLV_ERROR
line_context
lc_line_base
signed
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Sbyte
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
line_context
lc_line_range
unsigned
char
line_ptr
if
line_context
lc_line_range
_dwarf_error
dbg
err
DW_DLE_DEBUG_LINE_RANGE_ZERO
return
DW_DLV_ERROR
line_ptr
line_ptr
sizeof
Dwarf_Small
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
line_context
lc_opcode_base
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
Set
up
the
array
of
standard
opcode
lengths
We
think
this
works
ok
even
for
cross
endian
processing
of
objects
It
might
be
wrong
we
might
need
to
specially
process
the
array
of
ubyte
into
host
order
line_context
lc_opcode_length_table
line_ptr
lc_opcode_base
is
one
greater
than
the
size
of
the
array
line_ptr
line_context
lc_opcode_base
line_context
lc_std_op_count
line_context
lc_opcode_base
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
Determine
as
best
we
can
whether
the
lc_opcode_length_table
holds
or
standard
conforming
entries
gcc4
upped
to
DWARF3
s
without
updating
the
version
number
EXPERIMENTAL_LINE_TABLES_VERSION
upped
to
unsigned
check_count
line_context
lc_std_op_count
unsigned
tab_count
sizeof
dwarf_standard_opcode_operand_count
int
operand_ck_fail
true
if
line_context
lc_std_op_count
tab_count
_dwarf_print_header_issue
dbg
Too
many
standard
operands
in
linetable
header
data_start
line_context
lc_std_op_count
err_count_out
check_count
tab_count
unsigned
entrynum
unsigned
tabv
unsigned
linetabv
int
mismatch
operandmismatch
dwarf_standard_opcode_operand_count
tab_count
line_context
lc_opcode_length_table
check_count
if
mismatch
if
err_count_out
_dwarf_print_header_issue
dbg
standard
operands
did
not
match
checked
data_start
check_count
entrynum
tabv
linetabv
err_count_out
if
check_count
sizeof
dwarf_arm_standard_opcode_operand_count
check_count
sizeof
dwarf_arm_standard_opcode_operand_count
mismatch
operandmismatch
dwarf_arm_standard_opcode_operand_count
sizeof
dwarf_arm_standard_opcode_operand_count
line_context
lc_opcode_length_table
check_count
if
mismatch
err_count_out
_dwarf_print_header_issue
dbg
arm
incorrect
operands
in
use
data_start
check_count
entrynum
tabv
linetabv
err_count_out
if
mismatch
if
version
if
line_context
lc_std_op_count
STANDARD_OPERAND_COUNT_DWARF3
_dwarf_print_header_issue
dbg
standard
DWARF3
operands
matched
but
is
DWARF2
linetable
count
data_start
check_count
err_count_out
operand_ck_fail
false
if
operand_ck_fail
Here
we
are
not
sure
what
the
lc_std_op_count
is
_dwarf_error
dbg
err
DW_DLE_LINE_NUM_OPERANDS_BAD
return
DW_DLV_ERROR
At
this
point
we
no
longer
need
to
check
operand
counts
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
version
DW_LINE_VERSION5
Dwarf_Unsigned
directories_count
Dwarf_Unsigned
directories_malloc
line_context
lc_include_directories
malloc
sizeof
Dwarf_Small
directories_malloc
if
line_context
lc_include_directories
NULL
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
line_context
lc_include_directories
sizeof
Dwarf_Small
directories_malloc
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
while
char
line_ptr
if
directories_count
directories_malloc
Dwarf_Unsigned
expand
directories_malloc
Dwarf_Unsigned
bytesalloc
sizeof
Dwarf_Small
expand
Dwarf_Small
newdirs
realloc
line_context
lc_include_directories
bytesalloc
if
newdirs
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Doubled
size
zero
out
second
half
memset
newdirs
directories_malloc
sizeof
Dwarf_Small
directories_malloc
directories_malloc
expand
line_context
lc_include_directories
newdirs
line_context
lc_include_directories
directories_count
line_ptr
res
_dwarf_check_string_valid
dbg
data_start
line_ptr
line_ptr_end
DW_DLE_LINE_STRING_BAD
err
if
res
DW_DLV_OK
return
res
line_ptr
line_ptr
strlen
char
line_ptr
directories_count
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
line_ptr
line_context
lc_include_directories_count
directories_count
else
if
version
EXPERIMENTAL_LINE_TABLES_VERSION
Empty
old
style
dir
entry
list
line_ptr
else
if
version
DW_LINE_VERSION5
handled
below
else
No
old
style
directory
entries
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
version
DW_LINE_VERSION5
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
while
char
line_ptr
Dwarf_Unsigned
utmp
Dwarf_Unsigned
dir_index
Dwarf_Unsigned
lastmod
Dwarf_Unsigned
file_length
int
resl
Dwarf_File_Entry
currfile
currfile
Dwarf_File_Entry
malloc
sizeof
struct
Dwarf_File_Entry_s
if
currfile
NULL
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
currfile
sizeof
struct
Dwarf_File_Entry_s
Insert
early
so
in
case
of
error
we
can
find
and
free
the
record
_dwarf_add_to_files_list
line_context
currfile
currfile
fi_file_name
line_ptr
resl
_dwarf_check_string_valid
dbg
data_start
line_ptr
line_ptr_end
DW_DLE_LINE_STRING_BAD
err
if
resl
DW_DLV_OK
return
resl
line_ptr
line_ptr
strlen
char
line_ptr
DECODE_LEB128_UWORD_CK
line_ptr
utmp
dbg
err
line_ptr_end
res
read_uword_de
dbg
err
line_ptr_end
if
res
DW_DLV_ERROR
return
DW_DLV_ERROR
dir_index
Dwarf_Unsigned
utmp
if
dir_index
line_context
lc_include_directories_count
_dwarf_error
dbg
err
DW_DLE_DIR_INDEX_BAD
return
DW_DLV_ERROR
currfile
fi_dir_index
dir_index
currfile
fi_dir_index_present
TRUE
DECODE_LEB128_UWORD_CK
line_ptr
lastmod
dbg
err
line_ptr_end
res
read_uword_de
dbg
err
line_ptr_end
if
res
DW_DLV_ERROR
return
DW_DLV_ERROR
currfile
fi_time_last_mod
lastmod
currfile
fi_time_last_mod_present
TRUE
DECODE_LEB128_UWORD_CK
line_ptr
file_length
dbg
err
line_ptr_end
currfile
fi_file_length
file_length
currfile
fi_file_length_present
TRUE
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
Skip
trailing
nul
byte
line_ptr
else
if
version
EXPERIMENTAL_LINE_TABLES_VERSION
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
if
line_ptr
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
line_ptr
else
if
version
handled
below
else
No
old
style
filenames
entries
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
version
EXPERIMENTAL_LINE_TABLES_VERSION
static
unsigned
char
expbytes
Dwarf_Unsigned
logicals_table_offset
Dwarf_Unsigned
actuals_table_offset
unsigned
i
for
i
i
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
if
line_ptr
expbytes
i
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
line_ptr
READ_UNALIGNED_CK
dbg
logicals_table_offset
Dwarf_Unsigned
line_ptr
local_length_size
err
line_ptr_end
line_context
lc_logicals_table_offset
logicals_table_offset
line_ptr
local_length_size
READ_UNALIGNED_CK
dbg
actuals_table_offset
Dwarf_Unsigned
line_ptr
local_length_size
err
line_ptr_end
line_context
lc_actuals_table_offset
actuals_table_offset
line_ptr
local_length_size
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
version
DW_LINE_VERSION5
version
EXPERIMENTAL_LINE_TABLES_VERSION
DWARF
directory
names
Dwarf_Unsigned
directory_format_count
struct
Dwarf_Unsigned_Pair_s
format_values
Dwarf_Unsigned
directories_count
Dwarf_Unsigned
i
Dwarf_Unsigned
j
int
dres
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
directory_format_count
unsigned
char
line_ptr
line_context
lc_directory_entry_format_count
directory_format_count
line_ptr
line_ptr
sizeof
Dwarf_Small
if
directory_format_count
format_values
malloc
sizeof
struct
Dwarf_Unsigned_Pair_s
directory_format_count
if
format_values
NULL
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
for
i
i
directory_format_count
i
dres
read_uword_de
i
up_first
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
format_values
format_values
return
dres
dres
read_uword_de
i
up_second
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
format_values
format_values
return
dres
dres
read_uword_de
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
format_values
format_values
return
dres
line_context
lc_include_directories
malloc
sizeof
Dwarf_Small
directories_count
if
line_context
lc_include_directories
NULL
free
format_values
format_values
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
if
directory_format_count
directories_count
free
format_values
format_values
_dwarf_error_string
dbg
err
DW_DLE_DIRECTORY_FORMAT_COUNT_VS_DIRECTORIES_MISMATCH
DW_DLE_DIRECTORY_FORMAT_COUNT_
VS_DIRECTORIES_MISMATCH
format
count
is
zero
yet
directories
count
return
DW_DLV_ERROR
memset
line_context
lc_include_directories
sizeof
Dwarf_Small
directories_count
for
i
i
directories_count
i
for
j
j
directory_format_count
j
Dwarf_Unsigned
lntype
format_values
j
up_first
Dwarf_Unsigned
lnform
format_values
j
up_second
switch
lntype
case
DW_LNCT_path
char
inc_dir_ptr
res
_dwarf_decode_line_string_form
dbg
lntype
lnform
local_length_size
line_ptr_end
err
if
res
DW_DLV_OK
free
format_values
format_values
return
res
line_context
lc_include_directories
i
unsigned
char
inc_dir_ptr
break
default
free
format_values
format_values
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
if
line_ptr
line_ptr_end
free
format_values
format_values
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
line_context
lc_directory_format_values
format_values
format_values
line_context
lc_include_directories_count
directories_count
if
version
DW_LINE_VERSION5
version
EXPERIMENTAL_LINE_TABLES_VERSION
DWARF
file
names
struct
Dwarf_Unsigned_Pair_s
filename_entry_pairs
Dwarf_Unsigned
filename_format_count
Dwarf_Unsigned
files_count
Dwarf_Unsigned
i
Dwarf_Unsigned
j
int
dres
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
filename_format_count
unsigned
char
line_ptr
line_context
lc_file_name_format_count
filename_format_count
line_ptr
line_ptr
sizeof
Dwarf_Small
filename_entry_pairs
malloc
sizeof
struct
Dwarf_Unsigned_Pair_s
filename_format_count
if
filename_entry_pairs
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
for
i
i
filename_format_count
i
dres
read_uword_de
i
up_first
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
filename_entry_pairs
return
dres
dres
read_uword_de
i
up_second
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
filename_entry_pairs
return
dres
DECODE_LEB128_UWORD_CK
line_ptr
files_count
dbg
err
line_ptr_end
dres
read_uword_de
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
filename_entry_pairs
return
dres
for
i
i
files_count
i
Dwarf_File_Entry
curline
curline
Dwarf_File_Entry
malloc
sizeof
struct
Dwarf_File_Entry_s
if
curline
NULL
free
filename_entry_pairs
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
curline
sizeof
curline
_dwarf_add_to_files_list
line_context
curline
for
j
j
filename_format_count
j
Dwarf_Unsigned
dirindex
Dwarf_Unsigned
lntype
filename_entry_pairs
j
up_first
Dwarf_Unsigned
lnform
filename_entry_pairs
j
up_second
switch
lntype
The
LLVM
LNCT
is
documented
in
https
releases
llvm
org
docs
AMDGPUUsage
html
Cannot
find
the
GNU
items
documented
case
DW_LNCT_GNU_decl_file
FORM
udata
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
line_ptr_end
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_gnu_decl_file
dirindex
curline
fi_gnu_decl_file_present
TRUE
break
case
DW_LNCT_GNU_decl_line
FORM
udata
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
line_ptr_end
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_gnu_decl_line
dirindex
curline
fi_gnu_decl_line_present
TRUE
break
case
DW_LNCT_path
res
_dwarf_decode_line_string_form
dbg
lntype
lnform
local_length_size
line_ptr_end
char
fi_file_name
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
break
case
DW_LNCT_GNU_subprogram_name
res
_dwarf_decode_line_string_form
dbg
lntype
lnform
local_length_size
line_ptr_end
char
fi_gnu_subprogram_name
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
break
case
DW_LNCT_LLVM_source
res
_dwarf_decode_line_string_form
dbg
lntype
lnform
local_length_size
line_ptr_end
char
fi_llvm_source
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
break
case
DW_LNCT_directory_index
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
line_ptr_end
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_dir_index
dirindex
curline
fi_dir_index_present
TRUE
break
case
DW_LNCT_timestamp
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
fi_time_last_mod
line_ptr_end
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_time_last_mod_present
TRUE
break
case
DW_LNCT_size
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
fi_file_length
line_ptr_end
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_file_length_present
TRUE
break
case
DW_LNCT_MD5
form
DW_FORM_data16
if
filename_entry_pairs
j
up_second
DW_FORM_data16
free
filename_entry_pairs
_dwarf_error
dbg
err
DW_DLE_LNCT_MD5_WRONG_FORM
return
DW_DLV_ERROR
res
_dwarf_extract_data16
dbg
line_ptr
line_ptr
line_ptr_end
fi_md5_value
err
if
res
DW_DLV_OK
free
filename_entry_pairs
return
res
curline
fi_md5_present
TRUE
line_ptr
line_ptr
sizeof
curline
fi_md5_value
break
default
free
filename_entry_pairs
_dwarf_report_bad_lnct
dbg
lntype
DW_DLE_LINE_NUMBER_HEADER_ERROR
DW_DLE_LINE_NUMBER_HEADER_ERROR
err
return
DW_DLV_ERROR
if
line_ptr
line_ptr_end
free
filename_entry_pairs
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
line_context
lc_file_format_values
filename_entry_pairs
filename_entry_pairs
For
two
level
line
tables
read
the
subprograms
table
if
version
EXPERIMENTAL_LINE_TABLES_VERSION
Dwarf_Unsigned
subprog_format_count
Dwarf_Unsigned
subprog_entry_types
Dwarf_Unsigned
subprog_entry_forms
Dwarf_Unsigned
subprogs_count
Dwarf_Unsigned
i
Dwarf_Unsigned
j
int
dres
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
return
DW_DLV_ERROR
subprog_format_count
unsigned
char
line_ptr
line_ptr
line_ptr
sizeof
Dwarf_Small
subprog_entry_types
malloc
sizeof
Dwarf_Unsigned
subprog_format_count
if
subprog_entry_types
NULL
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
subprog_entry_forms
malloc
sizeof
Dwarf_Unsigned
subprog_format_count
if
subprog_entry_forms
NULL
free
subprog_entry_types
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
for
i
i
subprog_format_count
i
dres
read_uword_de
subprog_entry_types
i
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
subprog_entry_types
free
subprog_entry_forms
return
dres
dres
read_uword_de
subprog_entry_forms
i
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
subprog_entry_types
free
subprog_entry_forms
return
dres
dres
read_uword_de
dbg
err
line_ptr_end
if
dres
DW_DLV_OK
free
subprog_entry_types
free
subprog_entry_forms
return
dres
line_context
lc_subprogs
malloc
sizeof
struct
Dwarf_Subprog_Entry_s
subprogs_count
if
line_context
lc_subprogs
NULL
free
subprog_entry_types
free
subprog_entry_forms
_dwarf_error
dbg
err
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
memset
line_context
lc_subprogs
sizeof
struct
Dwarf_Subprog_Entry_s
subprogs_count
for
i
i
subprogs_count
i
struct
Dwarf_Subprog_Entry_s
curline
line_context
lc_subprogs
i
for
j
j
subprog_format_count
j
Dwarf_Unsigned
lntype
subprog_entry_types
j
Dwarf_Unsigned
lnform
subprog_entry_forms
j
switch
lntype
case
DW_LNCT_GNU_subprogram_name
res
_dwarf_decode_line_string_form
dbg
lntype
lnform
local_length_size
line_ptr_end
char
ds_subprog_name
err
if
res
DW_DLV_OK
free
subprog_entry_types
free
subprog_entry_forms
return
res
break
case
DW_LNCT_GNU_decl_file
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
ds_decl_file
line_ptr_end
err
if
res
DW_DLV_OK
free
subprog_entry_forms
free
subprog_entry_types
return
res
break
case
DW_LNCT_GNU_decl_line
res
_dwarf_decode_line_udata_form
dbg
lntype
lnform
ds_decl_line
line_ptr_end
err
if
res
DW_DLV_OK
free
subprog_entry_forms
free
subprog_entry_types
return
res
break
default
free
subprog_entry_forms
free
subprog_entry_types
_dwarf_report_bad_lnct
dbg
lntype
DW_DLE_LINE_NUMBER_HEADER_ERROR
DW_DLE_LINE_NUMBER_HEADER_ERROR
err
return
DW_DLV_ERROR
if
line_ptr
line_ptr_end
free
subprog_entry_types
free
subprog_entry_forms
_dwarf_error_string
dbg
err
DW_DLE_LINE_NUMBER_HEADER_ERROR
DW_DLE_LINE_NUMBER_HEADER_ERROR
Reading
suprogram
entry
DW_LNCT
types
we
run
off
the
end
of
the
table
return
DW_DLV_ERROR
free
subprog_entry_types
free
subprog_entry_forms
line_context
lc_subprogs_count
subprogs_count
if
version
EXPERIMENTAL_LINE_TABLES_VERSION
lp_begin
line_context
lc_line_prologue_start
line_context
lc_logicals_table_offset
else
lp_begin
line_context
lc_line_prologue_start
line_context
lc_prologue_length
if
line_ptr
line_ptr_end
_dwarf_error
dbg
err
DW_DLE_LINE_OFFSET_BAD
return
DW_DLV_ERROR
if
line_ptr
lp_begin
if
line_ptr
lp_begin
_dwarf_error
dbg
err
DW_DLE_LINE_PROLOG_LENGTH_BAD
return
DW_DLV_ERROR
else
Bug
in
compiler
These
bytes
are
really
part
of
the
instruction
stream
The
line_context
lc_prologue_length
is
wrong
too
high
if
bogus_bytes_ptr
bogus_bytes_ptr
line_ptr
if
bogus_bytes
How
far
off
things
are
We
expect
the
value
Negative
value
seems
impossible
ptrdiff_t
is
generated
but
not
named
bogus_bytes
lp_begin
line_ptr
Ignore
the
lp_begin
calc
Assume
line_ptr
right
Making
up
for
compiler
bug
lp_begin
line_ptr
line_context
lc_line_ptr_start
lp_begin
if
line_context
lc_actuals_table_offset
This
means
two
tables
line_context
lc_table_count
else
if
line_context
lc_line_ptr_end
lp_begin
line_context
lc_table_count
else
line_context
lc_table_count
updated_data_start_out
lp_begin
return
DW_DLV_OK
Read
one
line
table
program
For
two
level
line
tables
this
function
is
called
once
for
each
table
static
int
read_line_table_program
Dwarf_Debug
dbg
Dwarf_Small
line_ptr
Dwarf_Small
line_ptr_end
UNUSEDARG
Dwarf_Small
orig_line_ptr
Dwarf_Small
section_start
Dwarf_Line_Context
line_context
Dwarf_Half
address_size
Dwarf_Bool
doaddrs
Only
true
if
SGI
IRIX
rqs
calling
Dwarf_Bool
dolines
Dwarf_Bool
is_single_table
Dwarf_Bool
is_actuals_table
Dwarf_Error
error
UNUSEDARG
int
err_count_out
Dwarf_Unsigned
i
Dwarf_File_Entry
cur_file_entry
Dwarf_Line
logicals
line_context
lc_linebuf_logicals
Dwarf_Unsigned
logicals_count
line_context
lc_linecount_logicals
struct
Dwarf_Line_Registers_s
regs
This
is
a
pointer
to
the
current
line
being
added
to
the
line
matrix
Dwarf_Line
curr_line
These
variables
are
used
to
decode
leb128
numbers
Leb128_num
holds
the
decoded
number
and
leb128_length
is
its
length
in
bytes
Dwarf_Unsigned
leb128_num
Dwarf_Signed
advance_line
This
is
the
operand
of
the
latest
fixed_advance_pc
extended
opcode
Dwarf_Half
fixed_advance_pc
Counts
the
number
of
lines
in
the
line
matrix
Dwarf_Unsigned
line_count
This
is
the
length
of
an
extended
opcode
instr
Dwarf_Unsigned
instr_length
Used
to
chain
together
pointers
to
line
table
entries
that
are
later
used
to
create
a
block
of
Dwarf_Line
entries
Dwarf_Chain
chain_line
NULL
Dwarf_Chain
head_chain
NULL
Dwarf_Chain
curr_chain
NULL
This
points
to
a
block
of
Dwarf_Lines
a
pointer
to
which
is
returned
in
linebuf
Dwarf_Line
block_line
Mark
a
line
record
as
being
DW_LNS_set_address
Dwarf_Bool
is_addr_set
false
Initialize
the
one
state
machine
variable
that
depends
on
the
prefix
_dwarf_set_line_table_regs_default_values
line_context
lc_version_number
line_context
lc_default_is_stmt
Start
of
statement
program
while
line_ptr
line_ptr_end
int
type
Dwarf_Small
opcode
ifdef
PRINTING_DETAILS
dwarfstring
m9a
dwarfstring_constructor
dwarfstring_append_printf_u
DW_PR_DSx
ptrdiff_t
generated
but
not
named
line_ptr
section_start
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
opcode
Dwarf_Small
line_ptr
line_ptr
type
is
the
output
WHAT_IS_OPCODE
type
opcode
line_context
lc_opcode_base
line_context
lc_opcode_length_table
line_ptr
line_context
lc_std_op_count
if
type
LOP_DISCARD
int
oc
int
opcnt
line_context
lc_opcode_length_table
opcode
ifdef
PRINTING_DETAILS
dwarfstring
m9b
dwarfstring_constructor
dwarfstring_append_printf_i
DWARF
CHECK
DISCARD
standard
opcode
d
opcode
dwarfstring_append_printf_i
with
d
operands
not
understood
opcnt
_dwarf_printf
dbg
dwarfstring_string
err_count_out
dwarfstring_destructor
endif
PRINTING_DETAILS
for
oc
oc
opcnt
oc
int
ocres
Read
and
discard
operands
we
don
t
understand
arbitrary
choice
of
unsigned
read
signed
read
would
work
as
well
UNUSEDARG
Dwarf_Unsigned
utmp2
ocres
read_uword_de
dbg
error
line_ptr_end
if
ocres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
curr_line
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
dwarfstring
m9e
dwarfstring_constructor
dwarfstring_append_printf_u
DW_PR_DUu
utmp2
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
utmp2
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
ifdef
PRINTING_DETAILS
_dwarf_printf
dbg
n
endif
PRINTING_DETAILS
else
if
type
LOP_SPECIAL
This
op
code
is
a
special
op
in
the
object
no
matter
that
it
might
fall
into
the
standard
op
range
in
this
compile
That
is
these
are
special
opcodes
between
opcode_base
and
MAX_LINE_OP_CODE
including
opcode_base
and
MAX_LINE_OP_CODE
ifdef
PRINTING_DETAILS
unsigned
origop
opcode
endif
PRINTING_DETAILS
Dwarf_Unsigned
operation_advance
opcode
opcode
line_context
lc_opcode_base
operation_advance
opcode
line_context
lc_line_range
if
line_context
lc_maximum_ops_per_instruction
regs
lr_address
regs
lr_address
operation_advance
line_context
lc_minimum_instruction_length
else
regs
lr_address
regs
lr_address
line_context
lc_minimum_instruction_length
regs
lr_op_index
operation_advance
line_context
lc_maximum_ops_per_instruction
regs
lr_op_index
regs
lr_op_index
operation_advance
line_context
lc_maximum_ops_per_instruction
regs
lr_line
regs
lr_line
line_context
lc_line_base
opcode
line_context
lc_line_range
if
Dwarf_Signed
regs
lr_line
Something
is
badly
wrong
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_i
nERROR
DW_DLE_LINE_TABLE_LINENO_ERROR
The
line
number
computes
as
d
and
negative
line
numbers
are
not
correct
Dwarf_Signed
regs
lr_line
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_LINENO_ERROR
dwarfstring_string
dwarfstring_destructor
regs
lr_line
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
curr_line
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
dwarfstring
ma
dwarfstring
mb
dwarfstring_constructor
dwarfstring_constructor
dwarfstring_append_printf_u
Specialop
origop
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
print_line_detail
dbg
dwarfstring_string
opcode
line_count
is_single_table
is_actuals_table
dwarfstring_destructor
dwarfstring_destructor
endif
PRINTING_DETAILS
if
dolines
curr_line
Dwarf_Line
_dwarf_get_alloc
dbg
DW_DLA_LINE
if
curr_line
NULL
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Mark
a
line
record
as
being
DW_LNS_set_address
curr_line
li_addr_line
li_l_data
li_is_addr_set
is_addr_set
is_addr_set
false
curr_line
li_address
regs
lr_address
curr_line
li_addr_line
li_l_data
li_file
Dwarf_Signed
regs
lr_file
curr_line
li_addr_line
li_l_data
li_line
Dwarf_Signed
regs
lr_line
curr_line
li_addr_line
li_l_data
li_column
Dwarf_Half
regs
lr_column
curr_line
li_addr_line
li_l_data
li_is_stmt
regs
lr_is_stmt
curr_line
li_addr_line
li_l_data
li_basic_block
regs
lr_basic_block
curr_line
li_addr_line
li_l_data
li_end_sequence
curr_line
li_addr_line
li_l_data
li_epilogue_begin
regs
lr_epilogue_begin
curr_line
li_addr_line
li_l_data
li_prologue_end
regs
lr_prologue_end
curr_line
li_addr_line
li_l_data
li_isa
regs
lr_isa
curr_line
li_addr_line
li_l_data
li_discriminator
regs
lr_discriminator
curr_line
li_addr_line
li_l_data
li_call_context
regs
lr_call_context
curr_line
li_addr_line
li_l_data
li_subprogram
regs
lr_subprogram
curr_line
li_context
line_context
curr_line
li_is_actuals_table
is_actuals_table
line_count
chain_line
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
chain_line
NULL
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
chain_line
ch_itemtype
DW_DLA_LINE
chain_line
ch_item
curr_line
_dwarf_update_chain_list
chain_line
curr_line
regs
lr_basic_block
false
regs
lr_prologue_end
false
regs
lr_epilogue_begin
false
regs
lr_discriminator
ifdef
PRINTING_DETAILS
endif
PRINTING_DETAILS
else
if
type
LOP_STANDARD
ifdef
PRINTING_DETAILS
dwarfstring
mb
endif
PRINTING_DETAILS
switch
opcode
case
DW_LNS_copy
ifdef
PRINTING_DETAILS
print_line_detail
dbg
DW_LNS_copy
opcode
line_count
is_single_table
is_actuals_table
endif
PRINTING_DETAILS
if
dolines
curr_line
Dwarf_Line
_dwarf_get_alloc
dbg
DW_DLA_LINE
if
curr_line
NULL
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Mark
a
line
record
as
DW_LNS_set_address
curr_line
li_addr_line
li_l_data
li_is_addr_set
is_addr_set
is_addr_set
false
curr_line
li_address
regs
lr_address
curr_line
li_addr_line
li_l_data
li_file
Dwarf_Signed
regs
lr_file
curr_line
li_addr_line
li_l_data
li_line
Dwarf_Signed
regs
lr_line
curr_line
li_addr_line
li_l_data
li_column
Dwarf_Half
regs
lr_column
curr_line
li_addr_line
li_l_data
li_is_stmt
regs
lr_is_stmt
curr_line
li_addr_line
li_l_data
li_basic_block
regs
lr_basic_block
curr_line
li_addr_line
li_l_data
li_end_sequence
regs
lr_end_sequence
curr_line
li_context
line_context
curr_line
li_is_actuals_table
is_actuals_table
curr_line
li_addr_line
li_l_data
li_epilogue_begin
regs
lr_epilogue_begin
curr_line
li_addr_line
li_l_data
li_prologue_end
regs
lr_prologue_end
curr_line
li_addr_line
li_l_data
li_isa
regs
lr_isa
curr_line
li_addr_line
li_l_data
li_discriminator
regs
lr_discriminator
curr_line
li_addr_line
li_l_data
li_call_context
regs
lr_call_context
curr_line
li_addr_line
li_l_data
li_subprogram
regs
lr_subprogram
line_count
chain_line
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
chain_line
NULL
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
chain_line
ch_itemtype
DW_DLA_LINE
chain_line
ch_item
curr_line
_dwarf_update_chain_list
chain_line
curr_line
regs
lr_basic_block
false
regs
lr_prologue_end
false
regs
lr_epilogue_begin
false
regs
lr_discriminator
break
case
DW_LNS_advance_pc
Dwarf_Unsigned
utmp2
int
advres
advres
read_uword_de
dbg
error
line_ptr_end
if
advres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_advance_pc
val
DW_PR_DSd
utmp2
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
n
utmp2
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
leb128_num
utmp2
regs
lr_address
regs
lr_address
line_context
lc_minimum_instruction_length
leb128_num
break
case
DW_LNS_advance_line
Dwarf_Signed
stmp
int
alres
alres
read_sword_de
dbg
error
line_ptr_end
if
alres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
advance_line
Dwarf_Signed
stmp
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_advance_line
val
DW_PR_DSd
advance_line
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
n
advance_line
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
regs
lr_line
regs
lr_line
advance_line
if
Dwarf_Signed
regs
lr_line
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_i
nERROR
DW_DLE_LINE_TABLE_LINENO_ERROR
The
line
number
is
d
and
negative
line
numbers
after
DW_LNS_ADVANCE_LINE
Dwarf_Signed
regs
lr_line
dwarfstring_append_printf_i
of
d
are
not
correct
stmp
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_LINENO_ERROR
dwarfstring_string
dwarfstring_destructor
regs
lr_line
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
break
case
DW_LNS_set_file
Dwarf_Unsigned
utmp2
int
sfres
sfres
read_uword_de
dbg
error
line_ptr_end
if
sfres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_file
utmp2
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_set_file
ld
n
regs
lr_file
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
case
DW_LNS_set_column
Dwarf_Unsigned
utmp2
int
scres
scres
read_uword_de
dbg
error
line_ptr_end
if
scres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_column
utmp2
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_set_column
val
DW_PR_DSd
regs
lr_column
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
n
regs
lr_column
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
case
DW_LNS_negate_stmt
regs
lr_is_stmt
regs
lr_is_stmt
ifdef
PRINTING_DETAILS
_dwarf_printf
dbg
DW_LNS_negate_stmt
n
endif
PRINTING_DETAILS
break
case
DW_LNS_set_basic_block
regs
lr_basic_block
true
ifdef
PRINTING_DETAILS
_dwarf_printf
dbg
DW_LNS_set_basic_block
n
endif
PRINTING_DETAILS
break
case
DW_LNS_const_add_pc
opcode
MAX_LINE_OP_CODE
line_context
lc_opcode_base
if
line_context
lc_maximum_ops_per_instruction
Dwarf_Unsigned
operation_advance
opcode
line_context
lc_line_range
regs
lr_address
regs
lr_address
line_context
lc_minimum_instruction_length
operation_advance
else
Dwarf_Unsigned
operation_advance
opcode
line_context
lc_line_range
regs
lr_address
regs
lr_address
line_context
lc_minimum_instruction_length
regs
lr_op_index
operation_advance
line_context
lc_maximum_ops_per_instruction
regs
lr_op_index
regs
lr_op_index
operation_advance
line_context
lc_maximum_ops_per_instruction
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNS_const_add_pc
new
address
DW_PR_XZEROS
DW_PR_DSx
n
regs
lr_address
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
case
DW_LNS_fixed_advance_pc
Dwarf_Unsigned
fpc
int
apres
READ_UNALIGNED_CK
dbg
fixed_advance_pc
Dwarf_Half
line_ptr
DWARF_HALF_SIZE
error
line_ptr_end
apres
_dwarf_read_unaligned_ck_wrapper
dbg
line_ptr
DWARF_HALF_SIZE
line_ptr_end
error
fixed_advance_pc
fpc
if
apres
DW_DLV_ERROR
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
apres
line_ptr
DWARF_HALF_SIZE
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
DW_LNS_fixed_advance_pc
we
are
off
this
line
table
at
section
offset
x
localoff
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
regs
lr_address
regs
lr_address
fixed_advance_pc
regs
lr_op_index
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_fixed_advance_pc
val
DW_PR_DSd
fixed_advance_pc
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
fixed_advance_pc
dwarfstring_append_printf_u
new
address
DW_PR_XZEROS
DW_PR_DSx
n
regs
lr_address
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
New
in
DWARF3
case
DW_LNS_set_prologue_end
regs
lr_prologue_end
true
break
New
in
DWARF3
case
DW_LNS_set_epilogue_begin
regs
lr_epilogue_begin
true
ifdef
PRINTING_DETAILS
_dwarf_printf
dbg
DW_LNS_set_prologue_end
set
true
n
endif
PRINTING_DETAILS
break
New
in
DWARF3
case
DW_LNS_set_isa
Dwarf_Unsigned
utmp2
int
sires
sires
read_uword_de
dbg
error
line_ptr_end
if
sires
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_isa
utmp2
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNS_set_isa
new
value
DW_PR_XZEROS
DW_PR_DUx
n
utmp2
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
if
regs
lr_isa
utmp2
The
value
of
the
isa
did
not
fit
in
our
local
so
we
record
it
wrong
declare
an
error
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_LINE_NUM_OPERANDS_BAD
return
DW_DLV_ERROR
break
Experimental
two
level
line
tables
DW_LNS_set_address_from_logical
and
DW_LNS_set_subprogram
share
the
same
opcode
Disambiguate
by
checking
is_actuals_table
case
DW_LNS_set_subprogram
if
is_actuals_table
DW_LNS_set_address_from_logical
Dwarf_Signed
stmp
int
atres
atres
read_sword_de
dbg
error
line_ptr_end
if
atres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
advance_line
Dwarf_Signed
stmp
regs
lr_line
regs
lr_line
advance_line
if
Dwarf_Signed
regs
lr_line
dwarfstring
m
dwarfstring_constructor
dwarfstring_append_printf_i
nERROR
DW_DLE_LINE_TABLE_LINENO_ERROR
The
line
number
is
d
and
negative
line
numbers
after
DW_LNS_set_subprogram
Dwarf_Signed
regs
lr_line
dwarfstring_append_printf_i
of
d
applied
are
not
correct
stmp
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_LINENO_ERROR
dwarfstring_string
dwarfstring_destructor
regs
lr_line
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
if
regs
lr_line
regs
lr_line
logicals_count
regs
lr_address
logicals
regs
lr_line
li_address
regs
lr_op_index
ifdef
PRINTING_DETAILS
block
print
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_set_address_from
_logical
DW_PR_DSd
stmp
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
stmp
dwarfstring_append_printf_u
newaddr
DW_PR_XZEROS
DW_PR_DUx
n
regs
lr_address
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
else
ifdef
PRINTING_DETAILS
block
print
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_set_address_from_logical
line
is
DW_PR_DSd
regs
lr_line
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
n
regs
lr_line
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
else
DW_LNS_set_subprogram
building
logicals
table
Dwarf_Unsigned
utmp2
int
spres
regs
lr_call_context
spres
read_uword_de
dbg
error
line_ptr_end
if
spres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_subprogram
utmp2
ifdef
PRINTING_DETAILS
block
print
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_set_subprogram
DW_PR_DSd
utmp2
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
n
utmp2
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
Experimental
two
level
line
tables
case
DW_LNS_inlined_call
Dwarf_Signed
stmp
Dwarf_Unsigned
ilcuw
int
icres
icres
read_sword_de
dbg
error
line_ptr_end
if
icres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_call_context
line_count
stmp
icres
read_uword_de
dbg
error
line_ptr_end
regs
lr_subprogram
ilcuw
if
icres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
dwarfstring_constructor
dwarfstring_append_printf_i
DW_LNS_inlined_call
DW_PR_DSd
stmp
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
stmp
dwarfstring_append_printf_i
DW_PR_DSd
regs
lr_subprogram
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
regs
lr_subprogram
dwarfstring_append_printf_i
callcontext
DW_PR_DSd
regs
lr_call_context
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DSx
n
regs
lr_call_context
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
Experimental
two
level
line
tables
case
DW_LNS_pop_context
Dwarf_Unsigned
logical_num
regs
lr_call_context
Dwarf_Chain
logical_chain
head_chain
Dwarf_Line
logical_line
if
logical_num
logical_num
line_count
for
i
i
logical_num
i
logical_chain
logical_chain
ch_next
logical_line
Dwarf_Line
logical_chain
ch_item
regs
lr_file
logical_line
li_addr_line
li_l_data
li_file
regs
lr_line
logical_line
li_addr_line
li_l_data
li_line
regs
lr_column
logical_line
li_addr_line
li_l_data
li_column
regs
lr_discriminator
logical_line
li_addr_line
li_l_data
li_discriminator
regs
lr_is_stmt
logical_line
li_addr_line
li_l_data
li_is_stmt
regs
lr_call_context
logical_line
li_addr_line
li_l_data
li_call_context
regs
lr_subprogram
logical_line
li_addr_line
li_l_data
li_subprogram
ifdef
PRINTING_DETAILS
dwarfstring
pcon
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNS_pop_context
set
from
logical
DW_PR_DUu
logical_num
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
n
logical_num
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
else
dwarfstring
pcon
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNS_pop_context
does
nothing
logical
DW_PR_DUu
logical_num
dwarfstring_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
n
logical_num
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
End
switch
opcode
else
if
type
LOP_EXTENDED
Dwarf_Unsigned
utmp3
Dwarf_Small
ext_opcode
int
leres
leres
read_uword_de
dbg
error
line_ptr_end
if
leres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
instr_length
utmp3
Dwarf_Small
is
a
ubyte
and
the
extended
opcode
is
a
ubyte
though
not
stated
as
clearly
in
the
spec
as
one
might
hope
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
localoffset
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
extended
op
we
are
off
this
line
table
at
section
offset
x
localoffset
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
ext_opcode
Dwarf_Small
line_ptr
line_ptr
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
extended
op
opcode
we
are
off
this
line
table
at
section
offset
x
localoff
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
switch
ext_opcode
case
DW_LNE_end_sequence
regs
lr_end_sequence
true
if
dolines
curr_line
Dwarf_Line
_dwarf_get_alloc
dbg
DW_DLA_LINE
if
curr_line
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
print_line_detail
dbg
DW_LNE_end_sequence
extended
ext_opcode
line_count
is_single_table
is_actuals_table
endif
PRINTING_DETAILS
curr_line
li_address
regs
lr_address
curr_line
li_addr_line
li_l_data
li_file
Dwarf_Signed
regs
lr_file
curr_line
li_addr_line
li_l_data
li_line
Dwarf_Signed
regs
lr_line
curr_line
li_addr_line
li_l_data
li_column
Dwarf_Half
regs
lr_column
curr_line
li_addr_line
li_l_data
li_is_stmt
regs
lr_is_stmt
curr_line
li_addr_line
li_l_data
li_basic_block
regs
lr_basic_block
curr_line
li_addr_line
li_l_data
li_end_sequence
regs
lr_end_sequence
curr_line
li_context
line_context
curr_line
li_is_actuals_table
is_actuals_table
curr_line
li_addr_line
li_l_data
li_epilogue_begin
regs
lr_epilogue_begin
curr_line
li_addr_line
li_l_data
li_prologue_end
regs
lr_prologue_end
curr_line
li_addr_line
li_l_data
li_isa
regs
lr_isa
curr_line
li_addr_line
li_l_data
li_discriminator
regs
lr_discriminator
curr_line
li_addr_line
li_l_data
li_call_context
regs
lr_call_context
curr_line
li_addr_line
li_l_data
li_subprogram
regs
lr_subprogram
line_count
chain_line
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
chain_line
NULL
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
chain_line
ch_itemtype
DW_DLA_LINE
chain_line
ch_item
curr_line
_dwarf_update_chain_list
chain_line
curr_line
_dwarf_set_line_table_regs_default_values
line_context
lc_version_number
line_context
lc_default_is_stmt
break
case
DW_LNE_set_address
int
sares
READ_UNALIGNED_CK
dbg
regs
lr_address
Dwarf_Addr
line_ptr
address_size
error
line_ptr_end
sares
_dwarf_read_unaligned_ck_wrapper
dbg
lr_address
line_ptr
address_size
line_ptr_end
error
if
sares
DW_DLV_ERROR
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
sares
Mark
a
line
record
as
being
DW_LNS_set_address
is_addr_set
true
ifdef
PRINTING_DETAILS
dwarfstring
sadd
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNE_set_address
address
DW_PR_XZEROS
DW_PR_DUx
n
regs
lr_address
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
if
doaddrs
SGI
IRIX
rqs
processing
only
curr_line
Dwarf_Line
_dwarf_get_alloc
dbg
DW_DLA_LINE
if
curr_line
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
Mark
a
line
record
as
being
DW_LNS_set_address
curr_line
li_addr_line
li_l_data
li_is_addr_set
is_addr_set
is_addr_set
false
curr_line
li_address
regs
lr_address
ifdef
__sgi
SGI
IRIX
ONLY
ptrdiff_t
is
generated
but
not
named
curr_line
li_addr_line
li_offset
line_ptr
dbg
de_debug_line
dss_data
endif
__sgi
line_count
chain_line
Dwarf_Chain
_dwarf_get_alloc
dbg
DW_DLA_CHAIN
if
chain_line
NULL
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
chain_line
ch_itemtype
DW_DLA_LINE
chain_line
ch_item
curr_line
_dwarf_update_chain_list
chain_line
curr_line
regs
lr_op_index
line_ptr
address_size
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
DW_LNE_set_address
we
are
off
this
line
table
at
section
offset
x
localoff
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
break
case
DW_LNE_define_file
if
dolines
int
dlres
Dwarf_Unsigned
value
cur_file_entry
Dwarf_File_Entry
malloc
sizeof
struct
Dwarf_File_Entry_s
if
cur_file_entry
NULL
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
memset
cur_file_entry
sizeof
struct
Dwarf_File_Entry_s
_dwarf_add_to_files_list
line_context
cur_file_entry
cur_file_entry
fi_file_name
Dwarf_Small
line_ptr
dlres
_dwarf_check_string_valid
dbg
line_ptr
line_ptr
line_ptr_end
DW_DLE_DEFINE_FILE_STRING_BAD
error
if
dlres
DW_DLV_OK
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
dlres
line_ptr
line_ptr
strlen
char
line_ptr
dlres
read_uword_de
dbg
error
line_ptr_end
if
dlres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
cur_file_entry
fi_dir_index
Dwarf_Signed
value
cur_file_entry
fi_dir_index_present
TRUE
dlres
read_uword_de
dbg
error
line_ptr_end
if
dlres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
cur_file_entry
fi_time_last_mod
value
dlres
read_uword_de
dbg
error
line_ptr_end
if
dlres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
cur_file_entry
fi_file_length
value
cur_file_entry
fi_dir_index_present
TRUE
cur_file_entry
fi_time_last_mod_present
TRUE
cur_file_entry
fi_file_length_present
TRUE
ifdef
PRINTING_DETAILS
dwarfstring
m9c
dwarfstring_constructor
dwarfstring_append_printf_s
DW_LNE_define_file
s
n
char
cur_file_entry
fi_file_name
dwarfstring_append_printf_i
dir
index
d
n
int
cur_file_entry
fi_dir_index
time_t
tt3
time_t
cur_file_entry
fi_time_last_mod
ctime
supplies
newline
dwarfstring_append_printf_u
last
time
x
Dwarf_Unsigned
tt3
dwarfstring_append_printf_s
s
ctime
dwarfstring_append_printf_i
file
length
ld
cur_file_entry
fi_file_length
dwarfstring_append_printf_u
lx
n
cur_file_entry
fi_file_length
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
case
DW_LNE_set_discriminator
New
in
DWARF4
int
sdres
Dwarf_Unsigned
utmp2
sdres
read_uword_de
dbg
error
line_ptr_end
if
sdres
DW_DLV_ERROR
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
return
DW_DLV_ERROR
regs
lr_discriminator
utmp2
ifdef
PRINTING_DETAILS
dwarfstring
mk
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNE_set_discriminator
DW_PR_XZEROS
DW_PR_DUx
n
utmp2
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
break
default
This
is
an
extended
op
code
we
do
not
know
about
other
than
we
know
now
many
bytes
it
is
and
the
op
code
and
the
bytes
of
operand
Dwarf_Unsigned
remaining_bytes
instr_length
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
space_left
line_ptr
line_ptr_end
line_ptr_end
line_ptr
By
catching
this
here
instead
of
PRINTING_DETAILS
we
avoid
reading
off
of
our
data
of
interest
if
instr_length
space_left
remaining_bytes
remaining_bytes
DW_LNE_LEN_MAX
dwarfstring
g
ptrdiff_t
is
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
unknown
DW_LNE_extended
op
opcode
x
ext_opcode
dwarfstring_append_printf_u
we
are
off
this
line
table
at
section
offset
x
and
localoff
dwarfstring_append_printf_u
instruction
length
u
instr_length
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
ifdef
PRINTING_DETAILS
dwarfstring
m9d
dwarfstring_constructor
dwarfstring_append_printf_u
DW_LNE
extended
op
x
ext_opcode
dwarfstring_append_printf_u
Bytecount
DW_PR_DUu
Dwarf_Unsigned
instr_length
if
remaining_bytes
If
remaining
bytes
distance
to
end
we
will
have
an
error
dwarfstring_append
linedata
while
remaining_bytes
dwarfstring_append_printf_u
unsigned
char
line_ptr
line_ptr
if
A
test
above
see
space_left
above
proves
we
will
not
run
off
the
end
here
The
following
test
is
too
late
anyway
we
might
have
read
off
the
end
just
before
line_ptr
incremented
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
DW_LNE
extended
op
remaining
bytes
we
are
off
this
line
table
at
section
offset
x
localoff
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
endif
remaining_bytes
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
else
PRINTING_DETAILS
line_ptr
remaining_bytes
if
line_ptr
line_ptr_end
dwarfstring
g
ptrdiff_t
generated
but
not
named
Dwarf_Unsigned
localoff
line_ptr
section_start
line_ptr
section_start
dwarfstring_constructor
dwarfstring_append_printf_u
DW_DLE_LINE_TABLE_BAD
reading
DW_LNE
extended
op
remaining
bytes
we
are
off
this
line
table
at
section
offset
x
localoff
_dwarf_error_string
dbg
error
DW_DLE_LINE_TABLE_BAD
dwarfstring_string
dwarfstring_destructor
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
_dwarf_free_chain_entries
dbg
head_chain
line_count
return
DW_DLV_ERROR
endif
PRINTING_DETAILS
_dwarf_printf
dbg
n
break
End
switch
block_line
Dwarf_Line
_dwarf_get_alloc
dbg
DW_DLA_LIST
line_count
if
block_line
NULL
curr_chain
head_chain
_dwarf_free_chain_entries
dbg
head_chain
line_count
if
curr_line
dwarf_dealloc
dbg
curr_line
DW_DLA_LINE
curr_line
_dwarf_error
dbg
error
DW_DLE_ALLOC_FAIL
return
DW_DLV_ERROR
curr_chain
head_chain
for
i
i
line_count
i
Dwarf_Chain
t
block_line
i
curr_chain
ch_item
curr_chain
ch_item
curr_chain
ch_itemtype
t
curr_chain
curr_chain
curr_chain
ch_next
dwarf_dealloc
dbg
t
DW_DLA_CHAIN
if
is_single_table
is_actuals_table
line_context
lc_linebuf_logicals
block_line
line_context
lc_linecount_logicals
line_count
else
line_context
lc_linebuf_actuals
block_line
line_context
lc_linecount_actuals
line_count
ifdef
PRINTING_DETAILS
dwarfstring
mc
dwarfstring_constructor
if
is_single_table
if
line_count
dwarfstring_append_printf_u
Line
table
is
present
offset
DW_PR_XZEROS
DW_PR_DUx
but
no
lines
present
n
line_context
lc_section_offset
else
if
is_actuals_table
if
line_count
dwarfstring_append_printf_u
Line
table
present
offset
DW_PR_XZEROS
DW_PR_DUx
but
no
actuals
lines
present
n
line_context
lc_section_offset
else
if
line_count
dwarfstring_append_printf_u
Line
table
present
offset
DW_PR_XZEROS
DW_PR_DUx
but
no
logicals
lines
present
n
line_context
lc_section_offset
if
dwarfstring_strlen
_dwarf_printf
dbg
dwarfstring_string
dwarfstring_destructor
endif
PRINTING_DETAILS
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_LOC_H
define
DWARF_LOC_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
typedef
struct
Dwarf_Loc_Chain_s
Dwarf_Loc_Chain
struct
Dwarf_Loc_Chain_s
Dwarf_Small
lc_atom
Dwarf_Unsigned
lc_raw1
Dwarf_Unsigned
lc_raw2
Dwarf_Unsigned
lc_raw3
Dwarf_Unsigned
lc_number
Dwarf_Unsigned
lc_number2
Dwarf_Unsigned
lc_number3
Dwarf_Unsigned
lc_offset
Dwarf_Unsigned
lc_opnumber
Dwarf_Loc_Chain
lc_next
Dwarf_Loclists_Context_s
contains
the
data
from
the
debug_loclists
section
headers
if
that
section
exists
Dwarf
debug_loc
has
no
such
data
The
array
one
of
these
per
header
in
debug_loclists
is
recorded
in
Dwarf_Debug
These
are
filled
in
at
startup
at
the
same
time
debug_info
is
opened
Nothing
of
this
struct
is
exposed
to
libdwarf
callers
typedef
struct
Dwarf_Loclists_Context_s
Dwarf_Loclists_Context
struct
Dwarf_Loclists_Context_s
Dwarf_Debug
lc_dbg
Dwarf_Unsigned
lc_index
An
index
assigned
by
libdwarf
to
each
loclists
context
Starting
with
zero
at
the
zero
offset
in
debug_loclists
Offset
of
the
debug_loclists
header
involved
Dwarf_Unsigned
lc_header_offset
Dwarf_Unsigned
lc_length
Many
places
in
in
libdwarf
this
is
called
length_size
Dwarf_Small
lc_offset_size
rc_extension_size
is
zero
unless
this
is
standard
DWARF3
and
later
dwarf
using
the
extension
mechanism
DWARF3
and
later
rc_extension_size
is
DWARF2
MIPS
IRIX
rc_extension_size
is
zero
DWARF
rc_extension_size
is
zero
Dwarf_Small
lc_extension_size
unsigned
lc_version
Dwarf_Small
lc_address_size
Dwarf_Small
lc_segment_selector_size
Dwarf_Unsigned
lc_offset_entry_count
offset
in
the
section
of
the
offset
entries
Dwarf_Unsigned
lc_offsets_off_in_sect
Do
not
free
Points
into
section
memory
Dwarf_Small
lc_offsets_array
Offset
in
the
debug_loclists
section
of
the
first
loclist
in
the
set
of
loclists
for
the
CU
Dwarf_Unsigned
lc_first_loclist_offset
Dwarf_Unsigned
lc_past_last_loclist_offset
pointer
to
byte
of
loclist
header
Dwarf_Small
lc_loclists_header
pointer
to
first
byte
of
the
loclist
data
for
loclist
involved
Do
not
free
Dwarf_Small
lc_startaddr
pointer
one
past
end
of
the
loclist
data
Dwarf_Small
lc_endaddr
Contains
info
on
an
uninterpreted
block
of
data
the
data
is
DWARF
location
expression
operators
struct
Dwarf_Block_c_s
length
of
block
bl_data
points
at
Dwarf_Unsigned
bl_len
Uninterpreted
data
location
expressions
DW_OP_reg31
etc
Dwarf_Ptr
bl_data
DW_LKIND
see
libdwarf
h
in
Dwarf_Small
bl_kind
Section
not
CU
offset
which
data
comes
from
Dwarf_Unsigned
bl_section_offset
Section
offset
where
the
location
description
itself
starts
So
a
few
bytes
lower
than
bl_section_offset
Dwarf_Unsigned
bl_locdesc_offset
typedef
struct
Dwarf_Block_c_s
Dwarf_Block_c
Location
record
Records
up
to
operand
values
For
DWARF5
ops
with
a
byte
size
and
then
a
block
of
data
of
that
size
we
the
size
in
an
operand
and
follow
that
with
the
next
operand
as
a
pointer
to
the
block
The
pointer
is
inserted
via
cast
so
an
ugly
hack
This
struct
is
opaque
Not
visible
to
callers
typedef
struct
Dwarf_Loc_Expr_Op_s
Dwarf_Loc_Expr_Op
struct
Dwarf_Loc_Expr_Op_s
Dwarf_Small
lr_atom
Location
operation
Operands
exactly
as
in
DWARF
Dwarf_Unsigned
lr_raw1
Dwarf_Unsigned
lr_raw2
Dwarf_Unsigned
lr_raw3
Dwarf_Unsigned
lr_number
First
operand
Second
operand
For
OP_bregx
OP_bit_piece
OP_
GNU_
const_type
OP_
GNU_
deref_type
OP_
GNU_
entry_value
OP_implicit_value
OP_
GNU_
implicit_pointer
OP_
GNU_
regval_type
OP_xderef_type
Dwarf_Unsigned
lr_number2
Third
Operand
For
OP_
GNU_
const
type
pointer
to
block
of
length
lr_number2
FIXME
retrieve
the
value
at
the
pointer
store
the
value
here
instead
Dwarf_Unsigned
lr_number3
The
number
assigned
to
the
number
of
ops
in
the
expression
we
are
expanding
Dwarf_Unsigned
lr_opnumber
Dwarf_Unsigned
lr_offset
offset
for
OP_BRA
etc
Dwarf_Loc_Expr_Op
lr_next
When
a
list
is
useful
Used
at
construction
to
enable
verifying
we
set
sensibly
before
returning
to
callers
define
DW_LLE_VALUE_BOGUS
Location
description
DWARF
Adds
the
DW_LLE
value
new
in
DWARF5
This
struct
is
opaque
Not
visible
to
callers
struct
Dwarf_Locdesc_c_s
Dwarf_Small
ld_kind
DW_LKIND
A
DW_LLEX
or
DW_LLE
value
real
or
synthesized
Dwarf_Small
ld_lle_value
Failed
means
debug_addr
section
needed
but
missing
possibly
tied
file
needed
Dwarf_Bool
ld_index_failed
Beginning
of
active
range
This
is
actually
an
offset
of
an
applicable
base
address
not
a
pc
value
Dwarf_Addr
ld_rawlow
Translated
to
address
Dwarf_Addr
ld_lopc
End
of
active
range
This
is
actually
an
offset
of
an
applicable
base
address
or
a
length
never
a
pc
value
Dwarf_Addr
ld_rawhigh
Translated
to
address
Dwarf_Addr
ld_highpc
Byte
length
of
the
entire
record
for
this
entry
including
any
DW_OP
entries
Dwarf_Unsigned
ld_entrylen
For
debug_loclists
eases
building
record
Dwarf_Block_c
ld_opsblock
count
of
struct
Dwarf_Loc_Expr_Op_s
expression
operators
in
array
Dwarf_Half
ld_cents
pointer
to
array
of
expression
operator
structs
Dwarf_Loc_Expr_Op
ld_s
Section
not
CU
offset
where
loc
expr
begins
Dwarf_Unsigned
ld_section_offset
Section
not
CU
offset
where
location
descr
begins
Dwarf_Unsigned
ld_locdesc_offset
Pointer
to
our
header
in
which
we
are
located
Dwarf_Loc_Head_c
ld_loclist_head
Dwarf_Locdesc_c
ld_next
helps
building
the
locdescs
int
_dwarf_locdesc_c_constructor
Dwarf_Debug
dbg
void
locd
A
header
to
the
loclist
and
the
location
description
s
attached
to
an
attribute
This
struct
is
opaque
The
contents
not
visible
to
callers
struct
Dwarf_Loc_Head_c_s
The
array
or
more
entries
of
struct
Loc_Desc_c_s
If
it
may
really
be
a
locexpr
Dwarf_Locdesc_c
ll_locdesc
Entry
count
of
the
ll_locdesc
array
Dwarf_Unsigned
ll_locdesc_count
unsigned
ll_attrnum
unsigned
ll_attrform
unsigned
ll_cuversion
unsigned
ll_address_size
unsigned
ll_offset_size
The
CU
Context
of
this
loclist
or
locexpr
Dwarf_CU_Context
ll_context
DW_LKIND
Dwarf_Small
ll_kind
Dwarf_Debug
ll_dbg
If
ll_kind
DW_LKIND_loclists
the
following
pointer
is
non
null
and
index
is
the
index
of
the
localcontext
Dwarf_Unsigned
ll_index
Dwarf_Loclists_Context
ll_localcontext
rh_last
and
rh_first
used
during
build
up
Zero
when
array
rh_loclists
built
Dwarf_Locdesc_c
ll_first
Dwarf_Locdesc_c
ll_last
Dwarf_Unsigned
ll_bytes_total
unsigned
ll_segment_selector_size
DW_AT_loclists_base
Dwarf_Bool
ll_at_loclists_base_present
Dwarf_Unsigned
ll_at_loclists_base
DW_AT_low_pc
of
CU
or
zero
if
none
Dwarf_Bool
ll_cu_base_address_present
Dwarf_Unsigned
ll_cu_base_address
DW_AT_addr_base
so
we
can
use
debug_addr
if
such
is
needed
Dwarf_Bool
ll_cu_addr_base_present
Dwarf_Unsigned
ll_cu_addr_base
Dwarf_Small
ll_llepointer
Dwarf_Unsigned
ll_llearea_offset
Dwarf_Small
ll_end_data_area
int
_dwarf_fill_in_locdesc_op_c
Dwarf_Debug
dbg
Dwarf_Unsigned
locdesc_index
Dwarf_Loc_Head_c
loc_head
Dwarf_Block_c
loc_block
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Small
version_stamp
Dwarf_Addr
lowpc
Dwarf_Addr
highpc
Dwarf_Half
lle_op
Dwarf_Error
error
int
_dwarf_loc_block_sanity_check
Dwarf_Debug
dbg
Dwarf_Block_c
loc_block
Dwarf_Error
error
int
_dwarf_internal_read_loclists_header
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
sectionlength
Dwarf_Small
data
Dwarf_Small
end_data
Dwarf_Unsigned
offset
Dwarf_Loclists_Context
buildhere
Dwarf_Unsigned
next_offset
Dwarf_Error
error
void
_dwarf_loclists_head_destructor
void
l
int
_dwarf_loclists_fill_in_lle_head
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
int
_dwarf_loclists_expression_build
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
llhead
Dwarf_Error
error
int
_dwarf_read_loc_expr_op
Dwarf_Debug
dbg
Dwarf_Block_c
loc_block
Caller
Start
numbering
at
Dwarf_Signed
opnumber
for
DWARF
etc
Dwarf_Half
version_stamp
Dwarf_Half
offset_size
or
Dwarf_Half
address_size
Dwarf_Signed
startoffset_in
offset
in
block
not
section
offset
Dwarf_Small
section_end
nextoffset_out
so
caller
knows
next
entry
startoffset
Dwarf_Unsigned
nextoffset_out
The
values
picked
up
Dwarf_Loc_Expr_Op
curr_loc
Dwarf_Error
error
void
_dwarf_free_loclists_head_content
Dwarf_Loc_Head_c
head
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_LOC_H
This
is
a
cut
down
version
of
loader
h
from
cctools
shrunk
to
eliminate
aspects
unwanted
in
libdwarf
and
to
avoid
include
entirely
All
tab
characters
replaced
with
spaces
so
various
things
no
line
up
as
they
used
to
Comment
reformatting
for
line
length
may
have
left
some
original
comments
hard
to
follow
cctools
in
its
original
form
is
available
from
https
opensource
apple
com
see
Developer
Tools
version
cctools
include
loader
h
Copyright
c
Apple
Inc
All
Rights
Reserved
This
file
contains
Original
Code
and
or
Modifications
of
Original
Code
as
defined
in
and
that
are
subject
to
the
Apple
Public
Source
License
Version
the
License
You
may
not
use
this
file
except
in
compliance
with
the
License
Please
obtain
a
copy
of
the
License
at
http
www
opensource
apple
com
apsl
and
read
it
before
using
this
file
The
Original
Code
and
all
software
distributed
under
the
License
are
distributed
on
an
AS
IS
basis
WITHOUT
WARRANTY
OF
ANY
KIND
EITHER
EXPRESS
OR
IMPLIED
AND
APPLE
HEREBY
DISCLAIMS
ALL
SUCH
WARRANTIES
INCLUDING
WITHOUT
LIMITATION
ANY
WARRANTIES
OF
MERCHANTABILITY
FITNESS
FOR
A
PARTICULAR
PURPOSE
QUIET
ENJOYMENT
OR
NON
INFRINGEMENT
Please
see
the
License
for
the
specific
language
governing
rights
and
limitations
under
the
License
ifndef
MACHO_LOADER_H
define
MACHO_LOADER_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
if
Not
used
here
DavidA
September
This
file
describes
the
format
of
mach
object
files
include
stdint
h
mach
machine
h
is
needed
here
for
the
cpu_type_t
and
cpu_subtype_t
types
and
contains
the
constants
for
the
possible
values
of
these
types
include
mach
machine
h
mach
vm_prot
h
is
needed
here
for
the
vm_prot_t
type
and
contains
the
constants
that
are
or
ed
together
for
the
possible
values
of
this
type
include
mach
vm_prot
h
machine
thread_status
h
is
expected
to
define
the
flavors
of
the
thread
states
and
the
structures
of
those
flavors
for
each
machine
include
mach
machine
thread_status
h
include
architecture
byte_order
h
endif
ifndef
TYP
define
TYP
n
l
char
n
l
endif
TYP
The
bit
mach
header
appears
at
the
very
beginning
of
the
object
file
for
bit
architectures
struct
mach_header
TYP
magic
mach
magic
number
identifier
TYP
cputype
cpu
specifier
TYP
cpusubtype
machine
specifier
TYP
filetype
type
of
file
TYP
ncmds
number
of
load
commands
TYP
sizeofcmds
the
size
of
all
the
load
commands
TYP
flags
flags
Constant
for
the
magic
field
of
the
mach_header
bit
architectures
MH_MAGIC
MH_MAGIC_64
appear
in
big
endian
objects
MH_CIGAM
MH_CIGAM_64
appear
in
little
endian
objects
define
MH_MAGIC
the
mach
magic
number
define
MH_CIGAM
NXSwapInt
MH_MAGIC
The
bit
mach
header
appears
at
the
very
beginning
of
object
files
for
bit
architectures
struct
mach_header_64
TYP
magic
mach
magic
number
identifier
TYP
cputype
cpu
specifier
TYP
cpusubtype
machine
specifier
TYP
filetype
type
of
file
TYP
ncmds
number
of
load
commands
TYP
sizeofcmds
the
size
of
all
the
load
commands
TYP
flags
flags
TYP
reserved
reserved
Constant
for
the
magic
field
of
the
mach_header_64
bit
architectures
define
MH_MAGIC_64
the
bit
mach
magic
number
define
MH_CIGAM_64
NXSwapInt
MH_MAGIC_64
The
layout
of
the
file
depends
on
the
filetype
For
all
but
the
MH_OBJECT
file
type
the
segments
are
padded
out
and
aligned
on
a
segment
alignment
boundary
for
efficient
demand
paging
The
MH_EXECUTE
MH_FVMLIB
MH_DYLIB
MH_DYLINKER
and
MH_BUNDLE
file
types
also
have
the
headers
included
as
part
of
their
first
segment
The
file
type
MH_OBJECT
is
a
compact
format
intended
as
output
of
the
assembler
and
input
and
possibly
output
of
the
link
editor
the
o
format
All
sections
are
in
one
unnamed
segment
with
no
segment
padding
This
format
is
used
as
an
executable
format
when
the
file
is
so
small
the
segment
padding
greatly
increases
its
size
The
file
type
MH_PRELOAD
is
an
executable
format
intended
for
things
that
are
not
executed
under
the
kernel
proms
stand
alones
kernels
etc
The
format
can
be
executed
under
the
kernel
but
may
demand
paged
it
and
not
preload
it
before
execution
A
core
file
is
in
MH_CORE
format
and
can
be
in
any
legal
Mach
O
file
Constants
for
the
filetype
field
of
the
mach_header
define
MH_OBJECT
relocatable
object
file
define
MH_EXECUTE
demand
paged
executable
file
define
MH_FVMLIB
fixed
VM
shared
library
file
define
MH_CORE
core
file
define
MH_PRELOAD
preloaded
executable
file
define
MH_DYLIB
dynamically
bound
shared
library
define
MH_DYLINKER
dynamic
link
editor
define
MH_BUNDLE
dynamically
bound
bundle
file
define
MH_DYLIB_STUB
shared
library
stub
for
static
linking
only
no
section
contents
define
MH_DSYM
companion
file
with
only
debug
sections
define
MH_KEXT_BUNDLE
x86_64
kexts
Constants
for
the
flags
field
of
the
mach_header
define
MH_NOUNDEFS
the
object
file
has
no
undefined
references
define
MH_INCRLINK
the
object
file
is
the
output
of
an
incremental
link
against
a
base
file
and
can
t
be
link
edited
again
define
MH_DYLDLINK
the
object
file
is
input
for
the
dynamic
linker
and
can
t
be
staticly
link
edited
again
define
MH_BINDATLOAD
the
object
file
s
undefined
references
are
bound
by
the
dynamic
linker
when
loaded
define
MH_PREBOUND
the
file
has
its
dynamic
undefined
references
prebound
define
MH_SPLIT_SEGS
the
file
has
its
read
only
and
read
write
segments
split
define
MH_LAZY_INIT
the
shared
library
init
routine
is
to
be
run
lazily
via
catching
memory
faults
to
its
writeable
segments
obsolete
define
MH_TWOLEVEL
the
image
is
using
two
level
name
space
bindings
define
MH_FORCE_FLAT
the
executable
is
forcing
all
images
to
use
flat
name
space
bindings
define
MH_NOMULTIDEFS
this
umbrella
guarantees
no
multiple
definitions
of
symbols
in
its
sub
images
so
the
two
level
namespace
hints
can
always
be
used
define
MH_NOFIXPREBINDING
do
not
have
dyld
notify
the
prebinding
agent
about
this
executable
define
MH_PREBINDABLE
the
binary
is
not
prebound
but
can
have
its
prebinding
redone
only
used
when
MH_PREBOUND
is
not
set
define
MH_ALLMODSBOUND
indicates
that
this
binary
binds
to
all
two
level
namespace
modules
of
its
dependent
libraries
only
used
when
MH_PREBINDABLE
and
MH_TWOLEVEL
are
both
set
define
MH_SUBSECTIONS_VIA_SYMBOLS
safe
to
divide
up
the
sections
into
sub
sections
via
symbols
for
dead
code
stripping
define
MH_CANONICAL
the
binary
has
been
canonicalized
via
the
unprebind
operation
define
MH_WEAK_DEFINES
the
final
linked
image
contains
external
weak
symbols
define
MH_BINDS_TO_WEAK
the
final
linked
image
uses
weak
symbols
define
MH_ALLOW_STACK_EXECUTION
When
this
bit
is
set
all
stacks
in
the
task
will
be
given
stack
execution
privilege
Only
used
in
MH_EXECUTE
filetypes
define
MH_ROOT_SAFE
When
this
bit
is
set
the
binary
declares
it
is
safe
for
use
in
processes
with
uid
zero
define
MH_SETUID_SAFE
When
this
bit
is
set
the
binary
declares
it
is
safe
for
use
in
processes
when
issetugid
is
true
define
MH_NO_REEXPORTED_DYLIBS
When
this
bit
is
set
on
a
dylib
the
static
linker
does
not
need
to
examine
dependent
dylibs
to
see
if
any
are
re
exported
define
MH_PIE
When
this
bit
is
set
the
OS
will
load
the
main
executable
at
a
random
address
Only
used
in
MH_EXECUTE
filetypes
define
MH_DEAD_STRIPPABLE_DYLIB
Only
for
use
on
dylibs
When
linking
against
a
dylib
that
has
this
bit
set
the
static
linker
will
automatically
not
create
a
LC_LOAD_DYLIB
load
command
to
the
dylib
if
no
symbols
are
being
referenced
from
the
dylib
define
MH_HAS_TLV_DESCRIPTORS
Contains
a
section
of
type
S_THREAD_LOCAL_VARIABLES
define
MH_NO_HEAP_EXECUTION
When
this
bit
is
set
the
OS
will
run
the
main
executable
with
a
non
executable
heap
even
on
platforms
e
g
i386
that
don
t
require
it
Only
used
in
MH_EXECUTE
filetypes
define
MH_APP_EXTENSION_SAFE
The
code
was
linked
for
use
in
an
application
extension
The
load
commands
directly
follow
the
mach_header
The
total
size
of
all
of
the
commands
is
given
by
the
sizeofcmds
field
in
the
mach_header
All
load
commands
must
have
as
their
first
two
fields
cmd
and
cmdsize
The
cmd
field
is
filled
in
with
a
constant
for
that
command
type
Each
command
type
has
a
structure
specifically
for
it
The
cmdsize
field
is
the
size
in
bytes
of
the
particular
load
command
structure
plus
anything
that
follows
it
that
is
a
part
of
the
load
command
i
e
section
structures
strings
etc
To
advance
to
the
next
load
command
the
cmdsize
can
be
added
to
the
offset
or
pointer
of
the
current
load
command
The
cmdsize
for
bit
architectures
MUST
be
a
multiple
of
bytes
and
for
bit
architectures
MUST
be
a
multiple
of
bytes
these
are
forever
the
maximum
alignment
of
any
load
commands
The
padded
bytes
must
be
zero
All
tables
in
the
object
file
must
also
follow
these
rules
so
the
file
can
be
memory
mapped
Otherwise
the
pointers
to
these
tables
will
not
work
well
or
at
all
on
some
machines
With
all
padding
zeroed
like
objects
will
compare
byte
for
byte
struct
load_command
TYP
cmd
type
of
load
command
TYP
cmdsize
total
size
of
command
in
bytes
After
MacOS
X
when
a
new
load
command
is
added
that
is
required
to
be
understood
by
the
dynamic
linker
for
the
image
to
execute
properly
the
LC_REQ_DYLD
bit
will
be
or
ed
into
the
load
command
constant
If
the
dynamic
linker
sees
such
a
load
command
it
it
does
not
understand
will
issue
a
unknown
load
command
required
for
execution
error
and
refuse
to
use
the
image
Other
load
commands
without
this
bit
that
are
not
understood
will
simply
be
ignored
define
LC_REQ_DYLD
Constants
for
the
cmd
field
of
all
load
commands
the
type
define
LC_SEGMENT
segment
of
this
file
to
be
mapped
define
LC_SYMTAB
link
edit
stab
symbol
table
info
define
LC_SYMSEG
link
edit
gdb
symbol
table
info
obsolete
define
LC_THREAD
thread
define
LC_UNIXTHREAD
unix
thread
includes
a
stack
define
LC_LOADFVMLIB
load
a
specified
fixed
VM
shared
library
define
LC_IDFVMLIB
fixed
VM
shared
library
identification
define
LC_IDENT
object
identification
info
obsolete
define
LC_FVMFILE
fixed
VM
file
inclusion
internal
use
define
LC_PREPAGE
prepage
command
internal
use
define
LC_DYSYMTAB
dynamic
link
edit
symbol
table
info
define
LC_LOAD_DYLIB
load
a
dynamically
linked
shared
library
define
LC_ID_DYLIB
dynamically
linked
shared
lib
ident
define
LC_LOAD_DYLINKER
load
a
dynamic
linker
define
LC_ID_DYLINKER
dynamic
linker
identification
define
LC_PREBOUND_DYLIB
modules
prebound
for
a
dynamically
linked
shared
library
define
LC_ROUTINES
image
routines
define
LC_SUB_FRAMEWORK
sub
framework
define
LC_SUB_UMBRELLA
sub
umbrella
define
LC_SUB_CLIENT
sub
client
define
LC_SUB_LIBRARY
sub
library
define
LC_TWOLEVEL_HINTS
two
level
namespace
lookup
hints
define
LC_PREBIND_CKSUM
prebind
checksum
load
a
dynamically
linked
shared
library
that
is
allowed
to
be
missing
all
symbols
are
weak
imported
define
LC_LOAD_WEAK_DYLIB
LC_REQ_DYLD
define
LC_SEGMENT_64
bit
segment
of
this
file
to
be
mapped
define
LC_ROUTINES_64
bit
image
routines
define
LC_UUID
the
uuid
define
LC_RPATH
LC_REQ_DYLD
runpath
additions
define
LC_CODE_SIGNATURE
local
of
code
signature
define
LC_SEGMENT_SPLIT_INFO
local
of
info
to
split
segments
define
LC_REEXPORT_DYLIB
LC_REQ_DYLD
load
and
re
export
dylib
define
LC_LAZY_LOAD_DYLIB
delay
load
of
dylib
until
first
use
define
LC_ENCRYPTION_INFO
encrypted
segment
information
define
LC_DYLD_INFO
compressed
dyld
information
define
LC_DYLD_INFO_ONLY
compressed
dyld
information
only
define
LC_LOAD_UPWARD_DYLIB
LC_REQ_DYLD
load
upward
dylib
define
LC_VERSION_MIN_MACOSX
build
for
MacOSX
min
OS
version
define
LC_VERSION_MIN_IPHONEOS
build
for
iPhoneOS
min
OS
version
define
LC_FUNCTION_STARTS
compressed
table
of
function
start
addresses
define
LC_DYLD_ENVIRONMENT
string
for
dyld
to
treat
like
environment
variable
define
LC_MAIN
replacement
for
LC_UNIXTHREAD
define
LC_DATA_IN_CODE
table
of
non
instructions
in
__text
define
LC_SOURCE_VERSION
source
version
used
to
build
binary
define
LC_DYLIB_CODE_SIGN_DRS
Code
signing
DRs
copied
from
linked
dylibs
define
LC_ENCRYPTION_INFO_64
bit
encrypted
segment
information
define
LC_LINKER_OPTION
linker
options
in
MH_OBJECT
files
define
LC_LINKER_OPTIMIZATION_HINT
optimization
hints
in
MH_OBJECT
files
define
LC_VERSION_MIN_TVOS
build
for
AppleTV
min
OS
version
define
LC_VERSION_MIN_WATCHOS
build
for
Watch
min
OS
version
A
variable
length
string
in
a
load
command
is
represented
by
an
lc_str
union
The
strings
are
stored
just
after
the
load
command
structure
and
the
offset
is
from
the
start
of
the
load
command
structure
The
size
of
the
string
is
reflected
in
the
cmdsize
field
of
the
load
command
Once
again
any
padded
bytes
to
bring
the
cmdsize
field
to
a
multiple
of
bytes
must
be
zero
union
lc_str
TYP
offset
offset
to
the
string
ifndef
__LP64__
char
ptr
pointer
to
the
string
endif
The
segment
load
command
indicates
that
a
part
of
this
file
is
to
be
mapped
into
the
task
s
address
space
The
size
of
this
segment
in
memory
vmsize
maybe
equal
to
or
larger
than
the
amount
to
map
from
this
file
filesize
The
file
is
mapped
starting
at
fileoff
to
the
beginning
of
the
segment
in
memory
vmaddr
The
rest
of
the
memory
of
the
segment
if
any
is
allocated
zero
fill
on
demand
The
segment
s
maximum
virtual
memory
protection
and
initial
virtual
memory
protection
are
specified
by
the
maxprot
and
initprot
fields
If
the
segment
has
sections
then
the
section
structures
directly
follow
the
segment
command
and
their
size
is
reflected
in
cmdsize
struct
segment_command
for
bit
architectures
TYP
cmd
LC_SEGMENT
TYP
cmdsize
includes
sizeof
section
structs
char
segname
segment
name
TYP
vmaddr
memory
address
of
this
segment
TYP
vmsize
memory
size
of
this
segment
TYP
fileoff
file
offset
of
this
segment
TYP
filesize
amount
to
map
from
the
file
TYP
maxprot
maximum
VM
protection
TYP
initprot
initial
VM
protection
TYP
nsects
number
of
sections
in
segment
TYP
flags
flags
The
bit
segment
load
command
indicates
that
a
part
of
this
file
is
to
be
mapped
into
a
bit
task
s
address
space
If
the
bit
segment
has
sections
then
section_64
structures
directly
follow
the
bit
segment
command
and
their
size
is
reflected
in
cmdsize
struct
segment_command_64
for
bit
architectures
TYP
cmd
LC_SEGMENT_64
TYP
cmdsize
includes
sizeof
section_64
structs
char
segname
segment
name
TYP
vmaddr
memory
address
of
this
segment
TYP
vmsize
memory
size
of
this
segment
TYP
fileoff
file
offset
of
this
segment
TYP
filesize
amount
to
map
from
the
file
TYP
maxprot
maximum
VM
protection
TYP
initprot
initial
VM
protection
TYP
nsects
number
of
sections
in
segment
TYP
flags
flags
Constants
for
the
flags
field
of
the
segment_command
define
SG_HIGHVM
the
file
contents
for
this
segment
is
for
the
high
part
of
the
VM
space
the
low
part
is
zero
filled
for
stacks
in
core
files
define
SG_FVMLIB
this
segment
is
the
VM
that
is
allocated
by
a
fixed
VM
library
for
overlap
checking
in
the
link
editor
define
SG_NORELOC
this
segment
has
nothing
that
was
relocated
in
it
and
nothing
relocated
to
it
that
is
it
maybe
safely
replaced
without
relocation
define
SG_PROTECTED_VERSION_1
This
segment
is
protected
If
the
segment
starts
at
file
offset
the
first
page
of
the
segment
is
not
protected
All
other
pages
of
the
segment
are
protected
A
segment
is
made
up
of
zero
or
more
sections
Non
MH_OBJECT
files
have
all
of
their
segments
with
the
proper
sections
in
each
and
padded
to
the
specified
segment
alignment
when
produced
by
the
link
editor
The
first
segment
of
a
MH_EXECUTE
and
MH_FVMLIB
format
file
contains
the
mach_header
and
load
commands
of
the
object
file
before
its
first
section
The
zero
fill
sections
are
always
last
in
their
segment
in
all
formats
This
allows
the
zeroed
segment
padding
to
be
mapped
into
memory
where
zero
fill
sections
might
be
The
gigabyte
zero
fill
sections
those
with
the
section
type
S_GB_ZEROFILL
can
only
be
in
a
segment
with
sections
of
this
type
These
segments
are
then
placed
after
all
other
segments
The
MH_OBJECT
format
has
all
of
its
sections
in
one
segment
for
compactness
There
is
no
padding
to
a
specified
segment
boundary
and
the
mach_header
and
load
commands
are
not
part
of
the
segment
Sections
with
the
same
section
name
sectname
going
into
the
same
segment
segname
are
combined
by
the
link
editor
The
resulting
section
is
aligned
to
the
maximum
alignment
of
the
combined
sections
and
is
the
new
section
s
alignment
The
combined
sections
are
aligned
to
their
original
alignment
in
the
combined
section
Any
padded
bytes
to
get
the
specified
alignment
are
zeroed
The
format
of
the
relocation
entries
referenced
by
the
reloff
and
nreloc
fields
of
the
section
structure
for
mach
object
files
is
described
in
the
header
file
reloc
h
struct
section
for
bit
architectures
char
sectname
name
of
this
section
char
segname
segment
this
section
goes
in
TYP
addr
memory
address
of
this
section
TYP
size
size
in
bytes
of
this
section
TYP
offset
file
offset
of
this
section
TYP
align
section
alignment
power
of
TYP
reloff
file
offset
of
relocation
entries
TYP
nreloc
number
of
relocation
entries
TYP
flags
flags
section
type
and
attributes
TYP
reserved1
reserved
for
offset
or
index
TYP
reserved2
reserved
for
count
or
sizeof
struct
section_64
for
bit
architectures
char
sectname
name
of
this
section
char
segname
segment
this
section
goes
in
TYP
addr
memory
address
of
this
section
TYP
size
size
in
bytes
of
this
section
TYP
offset
file
offset
of
this
section
TYP
align
section
alignment
power
of
TYP
reloff
file
offset
of
relocation
entries
TYP
nreloc
number
of
relocation
entries
TYP
flags
flags
section
type
and
attributes
TYP
reserved1
reserved
for
offset
or
index
TYP
reserved2
reserved
for
count
or
sizeof
TYP
reserved3
reserved
The
flags
field
of
a
section
structure
is
separated
into
two
parts
a
section
type
and
section
attributes
The
section
types
are
mutually
exclusive
it
can
only
have
one
type
but
the
section
attributes
are
not
it
may
have
more
than
one
attribute
define
SECTION_TYPE
section
types
define
SECTION_ATTRIBUTES
section
attributes
Constants
for
the
type
of
a
section
define
S_REGULAR
regular
section
define
S_ZEROFILL
zero
fill
on
demand
section
define
S_CSTRING_LITERALS
section
with
only
literal
C
strings
define
S_4BYTE_LITERALS
section
with
only
byte
literals
define
S_8BYTE_LITERALS
section
with
only
byte
literals
define
S_LITERAL_POINTERS
section
with
only
pointers
to
literals
For
the
two
types
of
symbol
pointers
sections
and
the
symbol
stubs
section
they
have
indirect
symbol
table
entries
For
each
of
the
entries
in
the
section
the
indirect
symbol
table
entries
in
corresponding
order
in
the
indirect
symbol
table
start
at
the
index
stored
in
the
reserved1
field
of
the
section
structure
Since
the
indirect
symbol
table
entries
correspond
to
the
entries
in
the
section
the
number
of
indirect
symbol
table
entries
is
inferred
from
the
size
of
the
section
divided
by
the
size
of
the
entries
in
the
section
For
symbol
pointers
sections
the
size
of
the
entries
in
the
section
is
bytes
and
for
symbol
stubs
sections
the
byte
size
of
the
stubs
is
stored
in
the
reserved2
field
of
the
section
structure
define
S_NON_LAZY_SYMBOL_POINTERS
section
with
only
non
lazy
symbol
pointers
define
S_LAZY_SYMBOL_POINTERS
section
with
only
lazy
symbol
pointers
define
S_SYMBOL_STUBS
section
with
only
symbol
stubs
byte
size
of
stub
in
the
reserved2
field
define
S_MOD_INIT_FUNC_POINTERS
section
with
only
function
pointers
for
initialization
define
S_MOD_TERM_FUNC_POINTERS
section
with
only
function
pointers
for
termination
define
S_COALESCED
section
contains
symbols
that
are
to
be
coalesced
define
S_GB_ZEROFILL
zero
fill
on
demand
section
that
can
be
larger
than
gigabytes
define
S_INTERPOSING
section
with
only
pairs
of
function
pointers
for
interposing
define
S_16BYTE_LITERALS
section
with
only
byte
literals
define
S_DTRACE_DOF
section
contains
DTrace
Object
Format
define
S_LAZY_DYLIB_SYMBOL_POINTERS
section
with
only
lazy
symbol
pointers
to
lazy
loaded
dylibs
Section
types
to
support
thread
local
variables
define
S_THREAD_LOCAL_REGULAR
template
of
initial
values
for
TLVs
define
S_THREAD_LOCAL_ZEROFILL
template
of
initial
values
for
TLVs
define
S_THREAD_LOCAL_VARIABLES
TLV
descriptors
define
S_THREAD_LOCAL_VARIABLE_POINTERS
pointers
to
TLV
descriptors
define
S_THREAD_LOCAL_INIT_FUNCTION_POINTERS
functions
to
call
to
initialize
TLV
values
Constants
for
the
section
attributes
part
of
the
flags
field
of
a
section
structure
define
SECTION_ATTRIBUTES_USR
User
setable
attributes
define
S_ATTR_PURE_INSTRUCTIONS
section
contains
only
true
machine
instructions
define
S_ATTR_NO_TOC
section
contains
coalesced
symbols
that
are
not
to
be
in
a
ranlib
table
of
contents
define
S_ATTR_STRIP_STATIC_SYMS
ok
to
strip
static
symbols
in
this
section
in
files
with
the
MH_DYLDLINK
flag
define
S_ATTR_NO_DEAD_STRIP
no
dead
stripping
define
S_ATTR_LIVE_SUPPORT
blocks
are
live
if
they
reference
live
blocks
define
S_ATTR_SELF_MODIFYING_CODE
Used
with
i386
code
stubs
written
on
by
dyld
If
a
segment
contains
any
sections
marked
with
S_ATTR_DEBUG
then
all
sections
in
that
segment
must
have
this
attribute
No
section
other
than
a
section
marked
with
this
attribute
may
reference
the
contents
of
this
section
A
section
with
this
attribute
may
contain
no
symbols
and
must
have
a
section
type
S_REGULAR
The
static
linker
will
not
copy
section
contents
from
sections
with
this
attribute
into
its
output
file
These
sections
generally
contain
DWARF
debugging
info
define
S_ATTR_DEBUG
a
debug
section
define
SECTION_ATTRIBUTES_SYS
system
setable
attributes
define
S_ATTR_SOME_INSTRUCTIONS
section
contains
some
machine
instructions
define
S_ATTR_EXT_RELOC
section
has
external
relocation
entries
define
S_ATTR_LOC_RELOC
section
has
local
relocation
entries
The
names
of
segments
and
sections
in
them
are
mostly
meaningless
to
the
link
editor
But
there
are
few
things
to
support
traditional
UNIX
executables
that
require
the
link
editor
and
assembler
to
use
some
names
agreed
upon
by
convention
The
initial
protection
of
the
__TEXT
segment
has
write
protection
turned
off
not
writeable
The
link
editor
will
allocate
common
symbols
at
the
end
of
the
__common
section
in
the
__DATA
segment
It
will
create
the
section
and
segment
if
needed
The
currently
known
segment
names
and
the
section
names
in
those
segments
define
SEG_PAGEZERO
__PAGEZERO
the
pagezero
segment
which
has
no
protections
and
catches
NULL
references
for
MH_EXECUTE
files
define
SEG_TEXT
__TEXT
the
tradition
UNIX
text
segment
define
SECT_TEXT
__text
the
real
text
part
of
the
text
section
no
headers
and
no
padding
define
SECT_FVMLIB_INIT0
__fvmlib_init0
the
fvmlib
initialization
section
define
SECT_FVMLIB_INIT1
__fvmlib_init1
the
section
following
the
fvmlib
initialization
section
define
SEG_DATA
__DATA
the
tradition
UNIX
data
segment
define
SECT_DATA
__data
the
real
initialized
data
section
no
padding
no
bss
overlap
define
SECT_BSS
__bss
the
real
uninitialized
data
section
no
padding
define
SECT_COMMON
__common
the
section
common
symbols
are
allocated
in
by
the
link
editor
define
SEG_OBJC
__OBJC
objective
C
runtime
segment
define
SECT_OBJC_SYMBOLS
__symbol_table
symbol
table
define
SECT_OBJC_MODULES
__module_info
module
information
define
SECT_OBJC_STRINGS
__selector_strs
string
table
define
SECT_OBJC_REFS
__selector_refs
string
table
define
SEG_ICON
__ICON
the
icon
segment
define
SECT_ICON_HEADER
__header
the
icon
headers
define
SECT_ICON_TIFF
__tiff
the
icons
in
tiff
format
define
SEG_LINKEDIT
__LINKEDIT
the
segment
containing
all
structs
created
and
maintained
by
the
link
editor
Created
with
seglinkedit
option
to
ld
for
MH_EXECUTE
and
FVMLIB
file
types
only
define
SEG_UNIXSTACK
__UNIXSTACK
the
unix
stack
segment
define
SEG_IMPORT
__IMPORT
the
segment
for
the
self
dyld
modifing
code
stubs
that
has
read
write
and
execute
permissions
Fixed
virtual
memory
shared
libraries
are
identified
by
two
things
The
target
pathname
the
name
of
the
library
as
found
for
execution
and
the
minor
version
number
The
address
of
where
the
headers
are
loaded
is
in
header_addr
THIS
IS
OBSOLETE
and
no
longer
supported
struct
fvmlib
union
lc_str
name
library
s
target
pathname
TYP
minor_version
library
s
minor
version
number
TYP
header_addr
library
s
header
address
A
fixed
virtual
shared
library
filetype
MH_FVMLIB
in
the
mach
header
contains
a
fvmlib_command
cmd
LC_IDFVMLIB
to
identify
the
library
An
object
that
uses
a
fixed
virtual
shared
library
also
contains
a
fvmlib_command
cmd
LC_LOADFVMLIB
for
each
library
it
uses
THIS
IS
OBSOLETE
and
no
longer
supported
struct
fvmlib_command
TYP
cmd
LC_IDFVMLIB
or
LC_LOADFVMLIB
TYP
cmdsize
includes
pathname
string
struct
fvmlib
fvmlib
the
library
identification
Dynamicly
linked
shared
libraries
are
identified
by
two
things
The
pathname
the
name
of
the
library
as
found
for
execution
and
the
compatibility
version
number
The
pathname
must
match
and
the
compatibility
number
in
the
user
of
the
library
must
be
greater
than
or
equal
to
the
library
being
used
The
time
stamp
is
used
to
record
the
time
a
library
was
built
and
copied
into
user
so
it
can
be
use
to
determined
if
the
library
used
at
runtime
is
exactly
the
same
as
used
to
built
the
program
struct
dylib
union
lc_str
name
library
s
path
name
TYP
timestamp
library
s
build
time
stamp
TYP
current_version
library
s
current
version
number
TYP
compatibility_version
library
s
compatibility
vers
number
A
dynamically
linked
shared
library
filetype
MH_DYLIB
in
the
mach
header
contains
a
dylib_command
cmd
LC_ID_DYLIB
to
identify
the
library
An
object
that
uses
a
dynamically
linked
shared
library
also
contains
a
dylib_command
cmd
LC_LOAD_DYLIB
LC_LOAD_WEAK_DYLIB
or
LC_REEXPORT_DYLIB
for
each
library
it
uses
struct
dylib_command
TYP
cmd
LC_ID_DYLIB
LC_LOAD_
WEAK_
DYLIB
LC_REEXPORT_DYLIB
TYP
cmdsize
includes
pathname
string
struct
dylib
dylib
the
library
identification
A
dynamically
linked
shared
library
may
be
a
subframework
of
an
umbrella
framework
If
so
it
will
be
linked
with
umbrella
umbrella_name
where
Where
umbrella_name
is
the
name
of
the
umbrella
framework
A
subframework
can
only
be
linked
against
by
its
umbrella
framework
or
other
subframeworks
that
are
part
of
the
same
umbrella
framework
Otherwise
the
static
link
editor
produces
an
error
and
states
to
link
against
the
umbrella
framework
The
name
of
the
umbrella
framework
for
subframeworks
is
recorded
in
the
following
structure
struct
sub_framework_command
TYP
cmd
LC_SUB_FRAMEWORK
TYP
cmdsize
includes
umbrella
string
union
lc_str
umbrella
the
umbrella
framework
name
For
dynamically
linked
shared
libraries
that
are
subframework
of
an
umbrella
framework
they
can
allow
clients
other
than
the
umbrella
framework
or
other
subframeworks
in
the
same
umbrella
framework
To
do
this
the
subframework
is
built
with
allowable_client
client_name
and
an
LC_SUB_CLIENT
load
command
is
created
for
each
allowable_client
flag
The
client_name
is
usually
a
framework
name
It
can
also
be
a
name
used
for
bundles
clients
where
the
bundle
is
built
with
client_name
client_name
struct
sub_client_command
TYP
cmd
LC_SUB_CLIENT
TYP
cmdsize
includes
client
string
union
lc_str
client
the
client
name
A
dynamically
linked
shared
library
may
be
a
sub_umbrella
of
an
umbrella
framework
If
so
it
will
be
linked
with
sub_umbrella
umbrella_name
where
Where
umbrella_name
is
the
name
of
the
sub_umbrella
framework
When
staticly
linking
when
twolevel_namespace
is
in
effect
a
twolevel
namespace
umbrella
framework
will
only
cause
its
subframeworks
and
those
frameworks
listed
as
sub_umbrella
frameworks
to
be
implicited
linked
in
Any
other
dependent
dynamic
libraries
will
not
be
linked
it
when
twolevel_namespace
is
in
effect
The
primary
library
recorded
by
the
static
linker
when
resolving
a
symbol
in
these
libraries
will
be
the
umbrella
framework
Zero
or
more
sub_umbrella
frameworks
may
be
use
by
an
umbrella
framework
The
name
of
a
sub_umbrella
framework
is
recorded
in
the
following
structure
struct
sub_umbrella_command
TYP
cmd
LC_SUB_UMBRELLA
TYP
cmdsize
includes
sub_umbrella
string
union
lc_str
sub_umbrella
the
sub_umbrella
framework
name
A
dynamically
linked
shared
library
may
be
a
sub_library
of
another
shared
library
If
so
it
will
be
linked
with
sub_library
library_name
where
Where
library_name
is
the
name
of
the
sub_library
shared
library
When
staticly
linking
when
twolevel_namespace
is
in
effect
a
twolevel
namespace
shared
library
will
only
cause
its
subframeworks
and
those
frameworks
listed
as
sub_umbrella
frameworks
and
libraries
listed
as
sub_libraries
to
be
implicited
linked
in
Any
other
dependent
dynamic
libraries
will
not
be
linked
it
when
twolevel_namespace
is
in
effect
The
primary
library
recorded
by
the
static
linker
when
resolving
a
symbol
in
these
libraries
will
be
the
umbrella
framework
or
dynamic
library
Zero
or
more
sub_library
shared
libraries
may
be
use
by
an
umbrella
framework
or
or
dynamic
library
The
name
of
a
sub_library
framework
is
recorded
in
the
following
structure
For
example
usr
lib
libobjc_profile
A
dylib
would
be
recorded
as
libobjc
struct
sub_library_command
TYP
cmd
LC_SUB_LIBRARY
TYP
cmdsize
includes
sub_library
string
union
lc_str
sub_library
the
sub_library
name
A
program
filetype
MH_EXECUTE
that
is
prebound
to
its
dynamic
libraries
has
one
of
these
for
each
library
that
the
static
linker
used
in
prebinding
It
contains
a
bit
vector
for
the
modules
in
the
library
The
bits
indicate
which
modules
are
bound
and
which
are
not
from
the
library
The
bit
for
module
is
the
low
bit
of
the
first
byte
So
the
bit
for
the
Nth
module
is
linked_modules
N
N
struct
prebound_dylib_command
TYP
cmd
LC_PREBOUND_DYLIB
TYP
cmdsize
includes
strings
union
lc_str
name
library
s
path
name
TYP
nmodules
number
of
modules
in
library
union
lc_str
linked_modules
bit
vector
of
linked
modules
A
program
that
uses
a
dynamic
linker
contains
a
dylinker_command
to
identify
the
name
of
the
dynamic
linker
LC_LOAD_DYLINKER
And
a
dynamic
linker
contains
a
dylinker_command
to
identify
the
dynamic
linker
LC_ID_DYLINKER
A
file
can
have
at
most
one
of
these
This
struct
is
also
used
for
the
LC_DYLD_ENVIRONMENT
load
command
and
contains
string
for
dyld
to
treat
like
environment
variable
struct
dylinker_command
TYP
cmd
LC_ID_DYLINKER
LC_LOAD_DYLINKER
or
LC_DYLD_ENVIRONMENT
TYP
cmdsize
includes
pathname
string
union
lc_str
name
dynamic
linker
s
path
name
Thread
commands
contain
machine
specific
data
structures
suitable
for
use
in
the
thread
state
primitives
The
machine
specific
data
structures
follow
the
struct
thread_command
as
follows
Each
flavor
of
machine
specific
data
structure
is
preceded
by
an
unsigned
long
constant
for
the
flavor
of
that
data
structure
an
uint32_t
that
is
the
count
of
longs
of
the
size
of
the
state
data
structure
and
then
the
state
data
structure
follows
This
triple
may
be
repeated
for
many
flavors
The
constants
for
the
flavors
counts
and
state
data
structure
definitions
are
expected
to
be
in
the
header
file
machine
thread_status
h
These
machine
specific
data
structures
sizes
must
be
multiples
of
bytes
The
cmdsize
reflects
the
total
size
of
the
thread_command
and
all
of
the
sizes
of
the
constants
for
the
flavors
counts
and
state
data
structures
For
executable
objects
that
are
unix
processes
there
will
be
one
thread_command
cmd
LC_UNIXTHREAD
created
for
it
by
the
link
editor
This
is
the
same
as
a
LC_THREAD
except
that
a
stack
is
automatically
created
based
on
the
shell
s
limit
for
the
stack
size
Command
arguments
and
environment
variables
are
copied
onto
that
stack
struct
thread_command
TYP
cmd
LC_THREAD
or
LC_UNIXTHREAD
TYP
cmdsize
total
size
of
this
command
uint32_t
flavor
flavor
of
thread
state
uint32_t
count
count
of
longs
in
thread
state
struct
XXX_thread_state
state
thread
state
for
this
flavor
The
routines
command
contains
the
address
of
the
dynamic
shared
library
initialization
routine
and
an
index
into
the
module
table
for
the
module
that
defines
the
routine
Before
any
modules
are
used
from
the
library
the
dynamic
linker
fully
binds
the
module
that
defines
the
initialization
routine
and
then
calls
it
This
gets
called
before
any
module
initialization
routines
used
for
C
static
constructors
in
the
library
struct
routines_command
for
bit
architectures
TYP
cmd
LC_ROUTINES
TYP
cmdsize
total
size
of
this
command
TYP
init_address
address
of
initialization
routine
TYP
init_module
index
into
the
module
table
that
the
init
routine
is
defined
in
TYP
reserved1
TYP
reserved2
TYP
reserved3
TYP
reserved4
TYP
reserved5
TYP
reserved6
The
bit
routines
command
Same
use
as
above
struct
routines_command_64
for
bit
architectures
TYP
cmd
LC_ROUTINES_64
TYP
cmdsize
total
size
of
this
command
TYP
init_address
address
of
initialization
routine
TYP
init_module
index
into
the
module
table
that
the
init
routine
is
defined
in
TYP
reserved1
TYP
reserved2
TYP
reserved3
TYP
reserved4
TYP
reserved5
TYP
reserved6
The
symtab_command
contains
the
offsets
and
sizes
of
the
link
edit
stab
style
symbol
table
information
as
described
in
the
header
files
nlist
h
and
stab
h
struct
symtab_command
TYP
cmd
LC_SYMTAB
TYP
cmdsize
sizeof
struct
symtab_command
TYP
symoff
symbol
table
offset
TYP
nsyms
number
of
symbol
table
entries
TYP
stroff
string
table
offset
TYP
strsize
string
table
size
in
bytes
This
is
the
second
set
of
the
symbolic
information
which
is
used
to
support
the
data
structures
for
the
dynamically
link
editor
The
original
set
of
symbolic
information
in
the
symtab_command
which
contains
the
symbol
and
string
tables
must
also
be
present
when
this
load
command
is
present
When
this
load
command
is
present
the
symbol
table
is
organized
into
three
groups
of
symbols
local
symbols
static
and
debugging
symbols
grouped
by
module
defined
external
symbols
grouped
by
module
sorted
by
name
if
not
lib
undefined
external
symbols
sorted
by
name
if
MH_BINDATLOAD
is
not
set
and
in
order
the
were
seen
by
the
static
linker
if
MH_BINDATLOAD
is
set
In
this
load
command
there
are
offsets
and
counts
to
each
of
the
three
groups
of
symbols
This
load
command
contains
a
the
offsets
and
sizes
of
the
following
new
symbolic
information
tables
table
of
contents
module
table
reference
symbol
table
indirect
symbol
table
The
first
three
tables
above
the
table
of
contents
module
table
and
reference
symbol
table
are
only
present
if
the
file
is
a
dynamically
linked
shared
library
For
executable
and
object
modules
which
are
files
containing
only
one
module
the
information
that
would
be
in
these
three
tables
is
determined
as
follows
table
of
contents
the
defined
external
symbols
are
sorted
by
name
module
table
the
file
contains
only
one
module
so
everything
in
the
file
is
part
of
the
module
reference
symbol
table
is
the
defined
and
undefined
external
symbols
For
dynamically
linked
shared
library
files
this
load
command
also
contains
offsets
and
sizes
to
the
pool
of
relocation
entries
for
all
sections
separated
into
two
groups
external
relocation
entries
local
relocation
entries
For
executable
and
object
modules
the
relocation
entries
continue
to
hang
off
the
section
structures
struct
dysymtab_command
TYP
cmd
LC_DYSYMTAB
TYP
cmdsize
sizeof
struct
dysymtab_command
The
symbols
indicated
by
symoff
and
nsyms
of
the
LC_SYMTAB
load
command
are
grouped
into
the
following
three
groups
local
symbols
further
grouped
by
the
module
they
are
from
defined
external
symbols
further
grouped
by
the
module
they
are
from
undefined
symbols
The
local
symbols
are
used
only
for
debugging
The
dynamic
binding
process
may
have
to
use
them
to
indicate
to
the
debugger
the
local
symbols
for
a
module
that
is
being
bound
The
last
two
groups
are
used
by
the
dynamic
binding
process
to
do
the
binding
indirectly
through
the
module
table
and
the
reference
symbol
table
when
this
is
a
dynamically
linked
shared
library
file
TYP
ilocalsym
index
to
local
symbols
TYP
nlocalsym
number
of
local
symbols
TYP
iextdefsym
index
to
externally
defined
symbols
TYP
nextdefsym
number
of
externally
defined
symbols
TYP
iundefsym
index
to
undefined
symbols
TYP
nundefsym
number
of
undefined
symbols
For
the
for
the
dynamic
binding
process
to
find
which
module
a
symbol
is
defined
in
the
table
of
contents
is
used
analogous
to
the
ranlib
structure
in
an
archive
which
maps
defined
external
symbols
to
modules
they
are
defined
in
This
exists
only
in
a
dynamically
linked
shared
library
file
For
executable
and
object
modules
the
defined
external
symbols
are
sorted
by
name
and
is
use
as
the
table
of
contents
TYP
tocoff
file
offset
to
table
of
contents
TYP
ntoc
number
of
entries
in
table
of
contents
To
support
dynamic
binding
of
modules
whole
object
files
the
symbol
table
must
reflect
the
modules
that
the
file
was
created
from
This
is
done
by
having
a
module
table
that
has
indexes
and
counts
into
the
merged
tables
for
each
module
The
module
structure
that
these
two
entries
refer
to
is
described
below
This
exists
only
in
a
dynamically
linked
shared
library
file
For
executable
and
object
modules
the
file
only
contains
one
module
so
everything
in
the
file
belongs
to
the
module
TYP
modtaboff
file
offset
to
module
table
TYP
nmodtab
number
of
module
table
entries
To
support
dynamic
module
binding
the
module
structure
for
each
module
indicates
the
external
references
defined
and
undefined
each
module
makes
For
each
module
there
is
an
offset
and
a
count
into
the
reference
symbol
table
for
the
symbols
that
the
module
references
This
exists
only
in
a
dynamically
linked
shared
library
file
For
executable
and
object
modules
the
defined
external
symbols
and
the
undefined
external
symbols
indicates
the
external
references
TYP
extrefsymoff
offset
to
referenced
symbol
table
TYP
nextrefsyms
number
of
referenced
symbol
table
entries
The
sections
that
contain
symbol
pointers
and
routine
stubs
have
indexes
and
implied
counts
based
on
the
size
of
the
section
and
fixed
size
of
the
entry
into
the
indirect
symbol
table
for
each
pointer
and
stub
For
every
section
of
these
two
types
the
index
into
the
indirect
symbol
table
is
stored
in
the
section
header
in
the
field
reserved1
An
indirect
symbol
table
entry
is
simply
a
index
into
the
symbol
table
to
the
symbol
that
the
pointer
or
stub
is
referring
to
The
indirect
symbol
table
is
ordered
to
match
the
entries
in
the
section
TYP
indirectsymoff
file
offset
to
the
indirect
symbol
table
TYP
nindirectsyms
number
of
indirect
symbol
table
entries
To
support
relocating
an
individual
module
in
a
library
file
quickly
the
external
relocation
entries
for
each
module
in
the
library
need
to
be
accessed
efficiently
Since
the
relocation
entries
can
t
be
accessed
through
the
section
headers
for
a
library
file
they
are
separated
into
groups
of
local
and
external
entries
further
grouped
by
module
In
this
case
the
presents
of
this
load
command
who
s
extreloff
nextrel
locreloff
and
nlocrel
fields
are
non
zero
indicates
that
the
relocation
entries
of
non
merged
sections
are
not
referenced
through
the
section
structures
and
the
reloff
and
nreloc
fields
in
the
section
headers
are
set
to
zero
Since
the
relocation
entries
are
not
accessed
through
the
section
headers
this
requires
the
r_address
field
to
be
something
other
than
a
section
offset
to
identify
the
item
to
be
relocated
In
this
case
r_address
is
set
to
the
offset
from
the
vmaddr
of
the
first
LC_SEGMENT
command
For
MH_SPLIT_SEGS
images
r_address
is
set
to
the
the
offset
from
the
vmaddr
of
the
first
read
write
LC_SEGMENT
command
The
relocation
entries
are
grouped
by
module
and
the
module
table
entries
have
indexes
and
counts
into
them
for
the
group
of
external
relocation
entries
for
that
the
module
For
sections
that
are
merged
across
modules
there
must
not
be
any
remaining
external
relocation
entries
for
them
for
merged
sections
remaining
relocation
entries
must
be
local
TYP
extreloff
offset
to
external
relocation
entries
TYP
nextrel
number
of
external
relocation
entries
All
the
local
relocation
entries
are
grouped
together
they
are
not
grouped
by
their
module
since
they
are
only
used
if
the
object
is
moved
from
it
staticly
link
edited
address
TYP
locreloff
offset
to
local
relocation
entries
TYP
nlocrel
number
of
local
relocation
entries
An
indirect
symbol
table
entry
is
simply
a
index
into
the
symbol
table
to
the
symbol
that
the
pointer
or
stub
is
referring
to
Unless
it
is
for
a
non
lazy
symbol
pointer
section
for
a
defined
symbol
which
strip
has
removed
In
which
case
it
has
the
value
INDIRECT_SYMBOL_LOCAL
If
the
symbol
was
also
absolute
INDIRECT_SYMBOL_ABS
is
or
ed
with
that
define
INDIRECT_SYMBOL_LOCAL
define
INDIRECT_SYMBOL_ABS
a
table
of
contents
entry
struct
dylib_table_of_contents
TYP
symbol_index
the
defined
external
symbol
index
into
the
symbol
table
TYP
module_index
index
into
the
module
table
this
symbol
is
defined
in
a
module
table
entry
struct
dylib_module
the
module
name
index
into
string
table
TYP
module_name
TYP
iextdefsym
index
into
externally
defined
symbols
TYP
nextdefsym
number
of
externally
defined
symbols
TYP
irefsym
index
into
reference
symbol
table
TYP
nrefsym
number
of
reference
symbol
table
entries
TYP
ilocalsym
index
into
symbols
for
local
symbols
TYP
nlocalsym
number
of
local
symbols
TYP
iextrel
index
into
external
relocation
entries
TYP
nextrel
number
of
external
relocation
entries
TYP
iinit_iterm
low
bits
are
the
index
into
the
init
section
high
bits
are
the
index
into
the
term
section
TYP
ninit_nterm
low
bits
are
the
number
of
init
section
entries
high
bits
are
the
number
of
term
section
entries
for
this
module
address
of
the
start
of
the
__OBJC
__module_info
section
TYP
objc_module_info_addr
for
this
module
size
of
the
__OBJC
__module_info
section
TYP
objc_module_info_size
a
bit
module
table
entry
struct
dylib_module_64
the
module
name
index
into
string
table
TYP
module_name
TYP
iextdefsym
index
into
externally
defined
symbols
TYP
nextdefsym
number
of
externally
defined
symbols
TYP
irefsym
index
into
reference
symbol
table
TYP
nrefsym
number
of
reference
symbol
table
entries
TYP
ilocalsym
index
into
symbols
for
local
symbols
TYP
nlocalsym
number
of
local
symbols
TYP
iextrel
index
into
external
relocation
entries
TYP
nextrel
number
of
external
relocation
entries
TYP
iinit_iterm
low
bits
are
the
index
into
the
init
section
high
bits
are
the
index
into
the
term
section
TYP
ninit_nterm
low
bits
are
the
number
of
init
section
entries
high
bits
are
the
number
of
term
section
entries
TYP
objc_module_info_size
for
this
module
size
of
the
__OBJC
__module_info
section
TYP
objc_module_info_addr
for
this
module
address
of
the
start
of
the
__OBJC
__module_info
section
The
entries
in
the
reference
symbol
table
are
used
when
loading
the
module
both
by
the
static
and
dynamic
link
editors
and
if
the
module
is
unloaded
or
replaced
Therefore
all
external
symbols
defined
and
undefined
are
listed
in
the
module
s
reference
table
The
flags
describe
the
type
of
reference
that
is
being
made
The
constants
for
the
flags
are
defined
in
mach
o
nlist
h
as
they
are
also
used
for
symbol
table
entries
if
dwarf
readers
not
using
this
struct
dylib_reference
UNUSED
uint32_t
isym
index
into
the
symbol
table
UNUSED
flags
flags
to
indicate
the
type
of
reference
endif
The
twolevel_hints_command
contains
the
offset
and
number
of
hints
in
the
two
level
namespace
lookup
hints
table
struct
twolevel_hints_command
TYP
cmd
LC_TWOLEVEL_HINTS
TYP
cmdsize
sizeof
struct
twolevel_hints_command
TYP
offset
offset
to
the
hint
table
TYP
nhints
number
of
hints
in
the
hint
table
The
entries
in
the
two
level
namespace
lookup
hints
table
are
twolevel_hint
structs
These
provide
hints
to
the
dynamic
link
editor
where
to
start
looking
for
an
undefined
symbol
in
a
two
level
namespace
image
The
isub_image
field
is
an
index
into
the
sub
images
sub
frameworks
and
sub
umbrellas
list
that
made
up
the
two
level
image
that
the
undefined
symbol
was
found
in
when
it
was
built
by
the
static
link
editor
If
isub
image
is
the
the
symbol
is
expected
to
be
defined
in
library
and
not
in
the
sub
images
If
isub
image
is
non
zero
it
is
an
index
into
the
array
of
sub
images
for
the
umbrella
with
the
first
index
in
the
sub
images
being
The
array
of
sub
images
is
the
ordered
list
of
sub
images
of
the
umbrella
that
would
be
searched
for
a
symbol
that
has
the
umbrella
recorded
as
its
primary
library
The
table
of
contents
index
is
an
index
into
the
library
s
table
of
contents
This
is
used
as
the
starting
point
of
the
binary
search
or
a
directed
linear
search
if
Not
used
by
dwarf
readers
struct
twolevel_hint
UNUSED
uint32_t
isub_image
index
into
the
sub
images
itoc
index
into
the
table
of
contents
endif
The
prebind_cksum_command
contains
the
value
of
the
original
check
sum
for
prebound
files
or
zero
When
a
prebound
file
is
first
created
or
modified
for
other
than
updating
its
prebinding
information
the
value
of
the
check
sum
is
set
to
zero
When
the
file
has
it
prebinding
re
done
and
if
the
value
of
the
check
sum
is
zero
the
original
check
sum
is
calculated
and
stored
in
cksum
field
of
this
load
command
in
the
output
file
If
when
the
prebinding
is
re
done
and
the
cksum
field
is
non
zero
it
is
left
unchanged
from
the
input
file
struct
prebind_cksum_command
TYP
cmd
LC_PREBIND_CKSUM
TYP
cmdsize
sizeof
struct
prebind_cksum_command
TYP
cksum
the
check
sum
or
zero
The
uuid
load
command
contains
a
single
bit
unique
random
number
that
identifies
an
object
produced
by
the
static
link
editor
struct
uuid_command
TYP
cmd
LC_UUID
TYP
cmdsize
sizeof
struct
uuid_command
unsigned
char
uuid
the
bit
uuid
The
rpath_command
contains
a
path
which
at
runtime
should
be
added
to
the
current
run
path
used
to
find
prefixed
dylibs
struct
rpath_command
TYP
cmd
LC_RPATH
TYP
cmdsize
includes
string
union
lc_str
path
path
to
add
to
run
path
The
linkedit_data_command
contains
the
offsets
and
sizes
of
a
blob
of
data
in
the
__LINKEDIT
segment
struct
linkedit_data_command
TYP
cmd
LC_CODE_SIGNATURE
LC_SEGMENT_SPLIT_INFO
LC_FUNCTION_STARTS
LC_DATA_IN_CODE
LC_DYLIB_CODE_SIGN_DRS
or
LC_LINKER_OPTIMIZATION_HINT
TYP
cmdsize
sizeof
struct
linkedit_data_command
TYP
dataoff
file
offset
of
data
in
__LINKEDIT
segment
TYP
datasize
file
size
of
data
in
__LINKEDIT
segment
The
encryption_info_command
contains
the
file
offset
and
size
of
an
of
an
encrypted
segment
struct
encryption_info_command
TYP
cmd
LC_ENCRYPTION_INFO
TYP
cmdsize
sizeof
struct
encryption_info_command
TYP
cryptoff
file
offset
of
encrypted
range
TYP
cryptsize
file
size
of
encrypted
range
TYP
cryptid
which
encryption
system
means
not
encrypted
yet
The
encryption_info_command_64
contains
the
file
offset
and
size
of
an
of
an
encrypted
segment
for
use
in
x86_64
targets
struct
encryption_info_command_64
TYP
cmd
LC_ENCRYPTION_INFO_64
TYP
cmdsize
sizeof
struct
encryption_info_command_64
TYP
cryptoff
file
offset
of
encrypted
range
TYP
cryptsize
file
size
of
encrypted
range
TYP
cryptid
which
encryption
system
means
not
encrypted
yet
TYP
pad
padding
to
make
this
struct
s
size
a
multiple
of
bytes
The
version_min_command
contains
the
min
OS
version
on
which
this
binary
was
built
to
run
struct
version_min_command
TYP
cmd
LC_VERSION_MIN_MACOSX
or
LC_VERSION_MIN_IPHONEOS
or
LC_VERSION_MIN_WATCHOS
or
LC_VERSION_MIN_TVOS
TYP
cmdsize
sizeof
struct
min_version_command
TYP
version
X
Y
Z
is
encoded
in
nibbles
xxxx
yy
zz
TYP
sdk
X
Y
Z
is
encoded
in
nibbles
xxxx
yy
zz
The
dyld_info_command
contains
the
file
offsets
and
sizes
of
the
new
compressed
form
of
the
information
dyld
needs
to
load
the
image
This
information
is
used
by
dyld
on
Mac
OS
X
and
later
All
information
pointed
to
by
this
command
is
encoded
using
byte
streams
so
no
endian
swapping
is
needed
to
interpret
it
struct
dyld_info_command
TYP
cmd
LC_DYLD_INFO
or
LC_DYLD_INFO_ONLY
TYP
cmdsize
sizeof
struct
dyld_info_command
Dyld
rebases
an
image
whenever
dyld
loads
it
at
an
address
different
from
its
preferred
address
The
rebase
information
is
a
stream
of
byte
sized
opcodes
whose
symbolic
names
start
with
REBASE_OPCODE_
Conceptually
the
rebase
information
is
a
table
of
tuples
seg
index
seg
offset
type
The
opcodes
are
a
compressed
way
to
encode
the
table
by
only
encoding
when
a
column
changes
In
addition
simple
patterns
like
every
n
th
offset
for
m
times
can
be
encoded
in
a
few
bytes
TYP
rebase_off
file
offset
to
rebase
info
TYP
rebase_size
size
of
rebase
info
Dyld
binds
an
image
during
the
loading
process
if
the
image
requires
any
pointers
to
be
initialized
to
symbols
in
other
images
The
bind
information
is
a
stream
of
byte
sized
opcodes
whose
symbolic
names
start
with
BIND_OPCODE_
Conceptually
the
bind
information
is
a
table
of
tuples
seg
index
seg
offset
type
symbol
library
ordinal
symbol
name
addend
The
opcodes
are
a
compressed
way
to
encode
the
table
by
only
encoding
when
a
column
changes
In
addition
simple
patterns
like
for
runs
of
pointers
initialzed
to
the
same
value
can
be
encoded
in
a
few
bytes
TYP
bind_off
file
offset
to
binding
info
TYP
bind_size
size
of
binding
info
Some
C
programs
require
dyld
to
unique
symbols
so
that
all
images
in
the
process
use
the
same
copy
of
some
code
data
This
step
is
done
after
binding
The
content
of
the
weak_bind
info
is
an
opcode
stream
like
the
bind_info
But
it
is
sorted
alphabetically
by
symbol
name
This
enable
dyld
to
walk
all
images
with
weak
binding
information
in
order
and
look
for
collisions
If
there
are
no
collisions
dyld
does
no
updating
That
means
that
some
fixups
are
also
encoded
in
the
bind_info
For
instance
all
calls
to
operator
new
are
first
bound
to
libstdc
dylib
using
the
information
in
bind_info
Then
if
some
image
overrides
operator
new
that
is
detected
when
the
weak_bind
information
is
processed
and
the
call
to
operator
new
is
then
rebound
TYP
weak_bind_off
file
offset
to
weak
binding
info
TYP
weak_bind_size
size
of
weak
binding
info
Some
uses
of
external
symbols
do
not
need
to
be
bound
immediately
Instead
they
can
be
lazily
bound
on
first
use
The
lazy_bind
are
contains
a
stream
of
BIND
opcodes
to
bind
all
lazy
symbols
Normal
use
is
that
dyld
ignores
the
lazy_bind
section
when
loading
an
image
Instead
the
static
linker
arranged
for
the
lazy
pointer
to
initially
point
to
a
helper
function
which
pushes
the
offset
into
the
lazy_bind
area
for
the
symbol
needing
to
be
bound
then
jumps
to
dyld
which
simply
adds
the
offset
to
lazy_bind_off
to
get
the
information
on
what
to
bind
TYP
lazy_bind_off
file
offset
to
lazy
binding
info
TYP
lazy_bind_size
size
of
lazy
binding
infs
The
symbols
exported
by
a
dylib
are
encoded
in
a
trie
This
is
a
compact
representation
that
factors
out
common
prefixes
It
also
reduces
LINKEDIT
pages
in
RAM
because
it
encodes
all
information
name
address
flags
in
one
small
contiguous
range
The
export
area
is
a
stream
of
nodes
The
first
node
sequentially
is
the
start
node
for
the
trie
Nodes
for
a
symbol
start
with
a
uleb128
that
is
the
length
of
the
exported
symbol
information
for
the
string
so
far
If
there
is
no
exported
symbol
the
node
starts
with
a
zero
byte
If
there
is
exported
info
it
follows
the
length
First
is
a
uleb128
containing
flags
Normally
it
is
followed
by
a
uleb128
encoded
offset
which
is
location
of
the
content
named
by
the
symbol
from
the
mach_header
for
the
image
If
the
flags
is
EXPORT_SYMBOL_FLAGS_REEXPORT
then
following
the
flags
is
a
uleb128
encoded
library
ordinal
then
a
zero
terminated
UTF8
string
If
the
string
is
zero
length
then
the
symbol
is
re
export
from
the
specified
dylib
with
the
same
name
If
the
flags
is
EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER
then
following
the
flags
is
two
uleb128s
the
stub
offset
and
the
resolver
offset
The
stub
is
used
by
non
lazy
pointers
The
resolver
is
used
by
lazy
pointers
and
must
be
called
to
get
the
actual
address
to
use
After
the
optional
exported
symbol
information
is
a
byte
of
how
many
edges
that
this
node
has
leaving
it
followed
by
each
edge
Each
edge
is
a
zero
terminated
UTF8
of
the
addition
chars
in
the
symbol
followed
by
a
uleb128
offset
for
the
node
that
edge
points
to
TYP
export_off
file
offset
to
lazy
binding
info
TYP
export_size
size
of
lazy
binding
infs
The
following
are
used
to
encode
rebasing
information
define
REBASE_TYPE_POINTER
define
REBASE_TYPE_TEXT_ABSOLUTE32
define
REBASE_TYPE_TEXT_PCREL32
define
REBASE_OPCODE_MASK
define
REBASE_IMMEDIATE_MASK
define
REBASE_OPCODE_DONE
define
REBASE_OPCODE_SET_TYPE_IMM
define
REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB
define
REBASE_OPCODE_ADD_ADDR_ULEB
define
REBASE_OPCODE_ADD_ADDR_IMM_SCALED
define
REBASE_OPCODE_DO_REBASE_IMM_TIMES
define
REBASE_OPCODE_DO_REBASE_ULEB_TIMES
define
REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB
define
REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB
The
following
are
used
to
encode
binding
information
define
BIND_TYPE_POINTER
define
BIND_TYPE_TEXT_ABSOLUTE32
define
BIND_TYPE_TEXT_PCREL32
define
BIND_SPECIAL_DYLIB_SELF
define
BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE
define
BIND_SPECIAL_DYLIB_FLAT_LOOKUP
define
BIND_SYMBOL_FLAGS_WEAK_IMPORT
define
BIND_SYMBOL_FLAGS_NON_WEAK_DEFINITION
define
BIND_OPCODE_MASK
define
BIND_IMMEDIATE_MASK
define
BIND_OPCODE_DONE
define
BIND_OPCODE_SET_DYLIB_ORDINAL_IMM
define
BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB
define
BIND_OPCODE_SET_DYLIB_SPECIAL_IMM
define
BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM
define
BIND_OPCODE_SET_TYPE_IMM
define
BIND_OPCODE_SET_ADDEND_SLEB
define
BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB
define
BIND_OPCODE_ADD_ADDR_ULEB
define
BIND_OPCODE_DO_BIND
define
BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB
define
BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED
define
BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB
The
following
are
used
on
the
flags
byte
of
a
terminal
node
in
the
export
information
define
EXPORT_SYMBOL_FLAGS_KIND_MASK
define
EXPORT_SYMBOL_FLAGS_KIND_REGULAR
define
EXPORT_SYMBOL_FLAGS_KIND_THREAD_LOCAL
define
EXPORT_SYMBOL_FLAGS_WEAK_DEFINITION
define
EXPORT_SYMBOL_FLAGS_REEXPORT
define
EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER
The
linker_option_command
contains
linker
options
embedded
in
object
files
struct
linker_option_command
TYP
cmd
LC_LINKER_OPTION
only
used
in
MH_OBJECT
filetypes
TYP
cmdsize
TYP
count
number
of
strings
concatenation
of
zero
terminated
UTF8
strings
Zero
filled
at
end
to
align
The
symseg_command
contains
the
offset
and
size
of
the
GNU
style
symbol
table
information
as
described
in
the
header
file
symseg
h
The
symbol
roots
of
the
symbol
segments
must
also
be
aligned
properly
in
the
file
So
the
requirement
of
keeping
the
offsets
aligned
to
a
multiple
of
a
bytes
translates
to
the
length
field
of
the
symbol
roots
also
being
a
multiple
of
a
long
Also
the
padding
must
again
be
zeroed
THIS
IS
OBSOLETE
and
no
longer
supported
struct
symseg_command
TYP
cmd
LC_SYMSEG
TYP
cmdsize
sizeof
struct
symseg_command
TYP
offset
symbol
segment
offset
TYP
size
symbol
segment
size
in
bytes
The
ident_command
contains
a
free
format
string
table
following
the
ident_command
structure
The
strings
are
null
terminated
and
the
size
of
the
command
is
padded
out
with
zero
bytes
to
a
multiple
of
bytes
THIS
IS
OBSOLETE
and
no
longer
supported
struct
ident_command
TYP
cmd
LC_IDENT
TYP
cmdsize
strings
that
follow
this
command
The
fvmfile_command
contains
a
reference
to
a
file
to
be
loaded
at
the
specified
virtual
address
Presently
this
command
is
reserved
for
internal
use
The
kernel
ignores
this
command
when
loading
a
program
into
memory
struct
fvmfile_command
TYP
cmd
LC_FVMFILE
TYP
cmdsize
includes
pathname
string
union
lc_str
name
files
pathname
TYP
header_addr
files
virtual
address
The
entry_point_command
is
a
replacement
for
thread_command
It
is
used
for
main
executables
to
specify
the
location
file
offset
of
main
If
stack_size
was
used
at
link
time
the
stacksize
field
will
contain
the
stack
size
need
for
the
main
thread
struct
entry_point_command
TYP
cmd
LC_MAIN
only
used
in
MH_EXECUTE
filetypes
TYP
cmdsize
TYP
entryoff
file
__TEXT
offset
of
main
TYP
stacksize
if
not
zero
initial
stack
size
The
source_version_command
is
an
optional
load
command
containing
the
version
of
the
sources
used
to
build
the
binary
struct
source_version_command
TYP
cmd
LC_SOURCE_VERSION
TYP
cmdsize
TYP
version
A
B
C
D
E
packed
as
a24
b10
c10
d10
e10
The
LC_DATA_IN_CODE
load
commands
uses
a
linkedit_data_command
to
point
to
an
array
of
data_in_code_entry
entries
Each
entry
describes
a
range
of
data
in
a
code
section
struct
data_in_code_entry
TYP
offset
from
mach_header
to
start
of
data
range
TYP
length
number
of
bytes
in
data
range
TYP
kind
a
DICE_KIND_
value
define
DICE_KIND_DATA
define
DICE_KIND_JUMP_TABLE8
define
DICE_KIND_JUMP_TABLE16
define
DICE_KIND_JUMP_TABLE32
define
DICE_KIND_ABS_JUMP_TABLE32
Sections
of
type
S_THREAD_LOCAL_VARIABLES
contain
an
array
of
tlv_descriptor
structures
struct
tlv_descriptor
void
thunk
struct
tlv_descriptor
unsigned
long
key
unsigned
long
offset
ifdef
__cplusplus
endif
__cplusplus
endif
MACHO_LOADER_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_MACHOREAD_H
define
DWARF_MACHOREAD_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
struct
generic_macho_header
Dwarf_Unsigned
magic
Dwarf_Unsigned
cputype
Dwarf_Unsigned
cpusubtype
Dwarf_Unsigned
filetype
Dwarf_Unsigned
ncmds
number
of
load
commands
the
size
of
all
the
load
commands
Dwarf_Unsigned
sizeofcmds
Dwarf_Unsigned
flags
Dwarf_Unsigned
reserved
struct
generic_macho_command
Dwarf_Unsigned
cmd
Dwarf_Unsigned
cmdsize
Dwarf_Unsigned
offset_this_command
struct
generic_macho_segment_command
Dwarf_Unsigned
cmd
Dwarf_Unsigned
cmdsize
char
segname
Dwarf_Unsigned
vmaddr
Dwarf_Unsigned
vmsize
Dwarf_Unsigned
fileoff
Dwarf_Unsigned
filesize
Dwarf_Unsigned
maxprot
Dwarf_Unsigned
initprot
Dwarf_Unsigned
nsects
Dwarf_Unsigned
flags
our
index
into
mo_commands
Dwarf_Unsigned
macho_command_index
Dwarf_Unsigned
sectionsoffset
struct
generic_macho_section
Larger
than
in
file
room
for
NUL
guaranteed
char
sectname
char
segname
const
char
dwarfsectname
Dwarf_Unsigned
addr
Dwarf_Unsigned
size
Dwarf_Unsigned
offset
Dwarf_Unsigned
align
Dwarf_Unsigned
reloff
Dwarf_Unsigned
nreloc
Dwarf_Unsigned
flags
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Unsigned
generic_segment_num
Dwarf_Unsigned
offset_of_sec_rec
Dwarf_Small
loaded_data
ident
M
means
this
is
a
macho
header
ident
will
be
indicating
version
Other
bytes
in
ident
not
defined
should
be
zero
typedef
struct
dwarf_macho_filedata_s
char
mo_ident
const
char
mo_path
libdwarf
must
free
int
mo_fd
int
mo_destruct_close_fd
aka
lib
owns
fd
int
mo_is_64bit
Dwarf_Unsigned
mo_filesize
Dwarf_Small
mo_offsetsize
or
section
data
Dwarf_Small
mo_pointersize
int
mo_ftype
Dwarf_Endianness
mo_endian
Dwarf_Small
mo_machine
void
mo_copy_word
void
const
void
unsigned
long
Used
to
hold
and
header
data
struct
generic_macho_header
mo_header
unsigned
mo_command_count
Dwarf_Unsigned
mo_command_start_offset
struct
generic_macho_command
mo_commands
Dwarf_Unsigned
mo_offset_after_commands
Dwarf_Unsigned
mo_segment_count
struct
generic_macho_segment_command
mo_segment_commands
Dwarf_Unsigned
mo_dwarf_sectioncount
struct
generic_macho_section
mo_dwarf_sections
dwarf_macho_object_access_internals_t
int
dwarf_load_macho_header
dwarf_macho_object_access_internals_t
mfp
int
errcode
int
dwarf_load_macho_commands
dwarf_macho_object_access_internals_t
mfp
int
errcode
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_MACHOREAD_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
dwarf_macro
h
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
dwarf_macro5
h
For
the
DWARF5
debug_macro
section
also
appears
as
an
extension
to
DWARF4
struct
Dwarf_Macro_Forms_s
Code
means
DW_MACRO_define
etc
Dwarf_Small
mf_code
How
many
entries
in
mf_formbytes
array
Dwarf_Small
mf_formcount
Never
free
these
these
are
in
the
object
file
memory
const
Dwarf_Small
mf_formbytes
struct
Dwarf_Macro_OperationsList_s
unsigned
mol_count
struct
Dwarf_Macro_Forms_s
mol_data
struct
Dwarf_Macro_Operator_s
mo_opcode
mo_form
mf_code
unless
it
is
the
final
byte
in
which
case
all
values
are
zero
Dwarf_Small
mo_opcode
struct
Dwarf_Macro_Forms_s
mo_form
Points
at
the
first
byte
of
the
data
meaning
it
points
one
past
the
macro
operation
code
byte
Dwarf_Small
mo_data
define
MACRO_OFFSET_SIZE_FLAG
define
MACRO_LINE_OFFSET_FLAG
define
MACRO_OP_TABLE_FLAG
define
DW_MACRO_VERSION4
GNU
Extension
for
DWARF
define
DW_MACRO_VERSION5
DWARF
Could
be
reordered
to
be
most
space
efficient
That
might
be
a
little
harder
to
read
Hmm
struct
Dwarf_Macro_Context_s
Dwarf_Unsigned
mc_sentinel
Dwarf_Half
mc_version_number
Section_offset
in
debug_macro
of
macro
header
Dwarf_Unsigned
mc_section_offset
Dwarf_Unsigned
mc_section_size
Total
length
of
the
macro
data
for
this
macro
unit
Calculated
not
part
of
header
Dwarf_Unsigned
mc_total_length
Dwarf_Half
mc_macro_header_length
Dwarf_Small
mc_flags
If
DW_MACRO_start_file
is
in
the
operators
of
this
table
then
the
mc_debug_line_offset
must
be
present
from
the
header
Dwarf_Unsigned
mc_debug_line_offset
the
following
three
set
from
the
bits
in
mc_flags
If
offsets
bits
Dwarf_Bool
mc_offset_size_flag
if
debug_line
offset
is
present
Dwarf_Bool
mc_debug_line_offset_flag
or
depending
on
mc_offset_size_flag
Dwarf_Small
mc_offset_size
If
one
the
operands
opcodes
mc_opcode_forms
table
is
present
in
the
header
If
not
we
use
a
default
table
Even
when
there
are
operands
in
the
header
the
standardops
may
or
may
not
be
defined
in
the
header
Dwarf_Bool
mc_operands_table_flag
Count
of
the
Dwarf_Macro_Forms_s
structs
pointed
to
by
mc_opcode_forms
These
from
the
header
Dwarf_Small
mc_opcode_count
struct
Dwarf_Macro_Forms_s
mc_opcode_forms
mc_ops
must
be
free
d
but
pointers
inside
mc_ops
are
to
static
or
section
data
so
must
not
be
freed
Dwarf_Unsigned
mc_macro_ops_count
Dwarf_Unsigned
mc_ops_data_length
struct
Dwarf_Macro_Operator_s
mc_ops
Dwarf_Small
mc_macro_header
Dwarf_Small
mc_macro_ops
These
are
malloc
space
not
_dwarf_get_alloc
so
the
DW_DLA_MACRO_CONTEXT
dealloc
will
free
them
char
mc_srcfiles
Dwarf_Signed
mc_srcfiles_count
These
are
from
CU
DIE
attribute
names
They
may
be
NULL
or
point
at
data
in
a
dwarf
section
Do
not
free
This
attempts
to
make
up
for
the
lack
of
a
base
file
name
in
DWARF2
line
tables
const
char
mc_at_comp_dir
const
char
mc_at_name
The
following
is
malloc
so
macro_context_s
destructor
needs
to
free
it
const
char
mc_file_path
Dwarf_Debug
mc_dbg
Dwarf_CU_Context
mc_cu_context
int
_dwarf_macro_constructor
Dwarf_Debug
dbg
void
m
void
_dwarf_macro_destructor
void
m
Generated
routines
do
not
edit
Generated
sourcedate
BEGIN
FILE
ifndef
DWARF_NAMES_H
define
DWARF_NAMES_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
extern
int
dwarf_get_TAG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_children_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FORM_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_AT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_OP_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DEFAULTED_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_IDX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LLEX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LLE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_RLE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIVIS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIKIND_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_UT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_SECT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_END_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATCF_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ACCESS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIRTUALITY_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LANG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ID_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_INL_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ORD_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DSC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNCT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ISA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACRO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACINFO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CFA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_EH_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FRAME_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CHILDREN_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ADDR_name
unsigned
int
val_in
const
char
s_out
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_NAMES_H
END
FILE
Automatically
generated
do
not
edit
Generated
sourcedate
BEGIN
FILE
ifndef
__DWARF_NAMES_ENUM_H__
define
__DWARF_NAMES_ENUM_H__
enum
Dwarf_TAG_e
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_imported_declaration
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_mutable_type
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
DW_TAG_immutable_type
DW_TAG_lo_user
DW_TAG_MIPS_loop
DW_TAG_HP_array_descriptor
DW_TAG_format_label
DW_TAG_function_template
DW_TAG_class_template
DW_TAG_GNU_BINCL
DW_TAG_GNU_EINCL
DW_TAG_GNU_template_template_parameter
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_formal_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_GNU_call_site_parameter
DW_TAG_SUN_function_template
DW_TAG_SUN_class_template
DW_TAG_SUN_struct_template
DW_TAG_SUN_union_template
DW_TAG_SUN_indirect_inheritance
DW_TAG_SUN_codeflags
DW_TAG_SUN_memop_info
DW_TAG_SUN_omp_child_func
DW_TAG_SUN_rtti_descriptor
DW_TAG_SUN_dtor_info
DW_TAG_SUN_dtor
DW_TAG_SUN_f90_interface
DW_TAG_SUN_fortran_vax_structure
DW_TAG_SUN_hi
DW_TAG_ALTIUM_circ_type
DW_TAG_ALTIUM_mwa_circ_type
DW_TAG_ALTIUM_rev_carry_type
DW_TAG_ALTIUM_rom
DW_TAG_ghs_namespace
DW_TAG_ghs_using_namespace
DW_TAG_ghs_using_declaration
DW_TAG_ghs_template_templ_param
DW_TAG_upc_shared_type
DW_TAG_upc_strict_type
DW_TAG_upc_relaxed_type
DW_TAG_PGI_kanji_type
DW_TAG_PGI_interface_block
DW_TAG_BORLAND_property
DW_TAG_BORLAND_Delphi_string
DW_TAG_BORLAND_Delphi_dynamic_array
DW_TAG_BORLAND_Delphi_set
DW_TAG_BORLAND_Delphi_variant
DW_TAG_hi_user
enum
Dwarf_children_e
DW_children_no
DW_children_yes
enum
Dwarf_FORM_e
DW_FORM_addr
DW_FORM_block2
DW_FORM_block4
DW_FORM_data2
DW_FORM_data4
DW_FORM_data8
DW_FORM_string
DW_FORM_block
DW_FORM_block1
DW_FORM_data1
DW_FORM_flag
DW_FORM_sdata
DW_FORM_strp
DW_FORM_udata
DW_FORM_ref_addr
DW_FORM_ref1
DW_FORM_ref2
DW_FORM_ref4
DW_FORM_ref8
DW_FORM_ref_udata
DW_FORM_indirect
DW_FORM_sec_offset
DW_FORM_exprloc
DW_FORM_flag_present
DW_FORM_strx
DW_FORM_addrx
DW_FORM_ref_sup4
DW_FORM_strp_sup
DW_FORM_data16
DW_FORM_line_strp
DW_FORM_ref_sig8
DW_FORM_implicit_const
DW_FORM_loclistx
DW_FORM_rnglistx
DW_FORM_ref_sup8
DW_FORM_strx1
DW_FORM_strx2
DW_FORM_strx3
DW_FORM_strx4
DW_FORM_addrx1
DW_FORM_addrx2
DW_FORM_addrx3
DW_FORM_addrx4
DW_FORM_GNU_addr_index
DW_FORM_GNU_str_index
DW_FORM_GNU_ref_alt
DW_FORM_GNU_strp_alt
enum
Dwarf_AT_e
DW_AT_sibling
DW_AT_location
DW_AT_name
DW_AT_ordering
DW_AT_subscr_data
DW_AT_byte_size
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_element_list
DW_AT_stmt_list
DW_AT_low_pc
DW_AT_high_pc
DW_AT_language
DW_AT_member
DW_AT_discr
DW_AT_discr_value
DW_AT_visibility
DW_AT_import
DW_AT_string_length
DW_AT_common_reference
DW_AT_comp_dir
DW_AT_const_value
DW_AT_containing_type
DW_AT_default_value
DW_AT_inline
DW_AT_is_optional
DW_AT_lower_bound
DW_AT_producer
DW_AT_prototyped
DW_AT_return_addr
DW_AT_start_scope
DW_AT_bit_stride
DW_AT_upper_bound
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_address_class
DW_AT_artificial
DW_AT_base_types
DW_AT_calling_convention
DW_AT_count
DW_AT_data_member_location
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_declaration
DW_AT_discr_list
DW_AT_encoding
DW_AT_external
DW_AT_frame_base
DW_AT_friend
DW_AT_identifier_case
DW_AT_macro_info
DW_AT_namelist_item
DW_AT_priority
DW_AT_segment
DW_AT_specification
DW_AT_static_link
DW_AT_type
DW_AT_use_location
DW_AT_variable_parameter
DW_AT_virtuality
DW_AT_vtable_elem_location
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_byte_stride
DW_AT_entry_pc
DW_AT_use_UTF8
DW_AT_extension
DW_AT_ranges
DW_AT_trampoline
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_description
DW_AT_binary_scale
DW_AT_decimal_scale
DW_AT_small
DW_AT_decimal_sign
DW_AT_digit_count
DW_AT_picture_string
DW_AT_mutable
DW_AT_threads_scaled
DW_AT_explicit
DW_AT_object_pointer
DW_AT_endianity
DW_AT_elemental
DW_AT_pure
DW_AT_recursive
DW_AT_signature
DW_AT_main_subprogram
DW_AT_data_bit_offset
DW_AT_const_expr
DW_AT_enum_class
DW_AT_linkage_name
DW_AT_string_length_bit_size
DW_AT_string_length_byte_size
DW_AT_rank
DW_AT_str_offsets_base
DW_AT_addr_base
DW_AT_rnglists_base
DW_AT_dwo_id
DW_AT_dwo_name
DW_AT_reference
DW_AT_rvalue_reference
DW_AT_macros
DW_AT_call_all_calls
DW_AT_call_all_source_calls
DW_AT_call_all_tail_calls
DW_AT_call_return_pc
DW_AT_call_value
DW_AT_call_origin
DW_AT_call_parameter
DW_AT_call_pc
DW_AT_call_tail_call
DW_AT_call_target
DW_AT_call_target_clobbered
DW_AT_call_data_location
DW_AT_call_data_value
DW_AT_noreturn
DW_AT_alignment
DW_AT_export_symbols
DW_AT_deleted
DW_AT_defaulted
DW_AT_loclists_base
DW_AT_ghs_namespace_alias
DW_AT_ghs_using_namespace
DW_AT_ghs_using_declaration
DW_AT_HP_block_index
DW_AT_MIPS_fde
DW_AT_MIPS_loop_begin
DW_AT_MIPS_tail_loop_begin
DW_AT_MIPS_epilog_begin
DW_AT_MIPS_loop_unroll_factor
DW_AT_MIPS_software_pipeline_depth
DW_AT_MIPS_linkage_name
DW_AT_MIPS_stride
DW_AT_MIPS_abstract_name
DW_AT_MIPS_clone_origin
DW_AT_MIPS_has_inlines
DW_AT_MIPS_stride_byte
DW_AT_MIPS_stride_elem
DW_AT_MIPS_ptr_dopetype
DW_AT_MIPS_allocatable_dopetype
DW_AT_MIPS_assumed_shape_dopetype
DW_AT_MIPS_assumed_size
DW_AT_HP_raw_data_ptr
DW_AT_HP_pass_by_reference
DW_AT_HP_opt_level
DW_AT_HP_prof_version_id
DW_AT_HP_opt_flags
DW_AT_HP_cold_region_low_pc
DW_AT_HP_cold_region_high_pc
DW_AT_HP_all_variables_modifiable
DW_AT_HP_linkage_name
DW_AT_HP_prof_flags
DW_AT_HP_unit_name
DW_AT_HP_unit_size
DW_AT_HP_widened_byte_size
DW_AT_HP_definition_points
DW_AT_HP_default_location
DW_AT_INTEL_other_endian
DW_AT_HP_is_result_param
DW_AT_ghs_rsm
DW_AT_ghs_frsm
DW_AT_ghs_frames
DW_AT_ghs_rso
DW_AT_ghs_subcpu
DW_AT_ghs_lbrace_line
DW_AT_sf_names
DW_AT_src_info
DW_AT_mac_info
DW_AT_src_coords
DW_AT_body_begin
DW_AT_body_end
DW_AT_GNU_vector
DW_AT_GNU_guarded_by
DW_AT_GNU_pt_guarded_by
DW_AT_GNU_guarded
DW_AT_GNU_pt_guarded
DW_AT_GNU_locks_excluded
DW_AT_GNU_exclusive_locks_required
DW_AT_GNU_shared_locks_required
DW_AT_GNU_odr_signature
DW_AT_GNU_template_name
DW_AT_GNU_call_site_value
DW_AT_GNU_call_site_data_value
DW_AT_GNU_call_site_target
DW_AT_GNU_call_site_target_clobbered
DW_AT_GNU_tail_call
DW_AT_GNU_all_tail_call_sites
DW_AT_GNU_all_call_sites
DW_AT_GNU_all_source_call_sites
DW_AT_GNU_macros
DW_AT_GNU_deleted
DW_AT_GNU_dwo_name
DW_AT_GNU_dwo_id
DW_AT_GNU_ranges_base
DW_AT_GNU_addr_base
DW_AT_GNU_pubnames
DW_AT_GNU_pubtypes
DW_AT_GNU_discriminator
DW_AT_GNU_locviews
DW_AT_GNU_entry_view
DW_AT_SUN_template
DW_AT_SUN_alignment
DW_AT_SUN_vtable
DW_AT_SUN_count_guarantee
DW_AT_SUN_command_line
DW_AT_SUN_vbase
DW_AT_SUN_compile_options
DW_AT_SUN_language
DW_AT_SUN_browser_file
DW_AT_SUN_vtable_abi
DW_AT_SUN_func_offsets
DW_AT_SUN_cf_kind
DW_AT_SUN_vtable_index
DW_AT_SUN_omp_tpriv_addr
DW_AT_SUN_omp_child_func
DW_AT_SUN_func_offset
DW_AT_SUN_memop_type_ref
DW_AT_SUN_profile_id
DW_AT_SUN_memop_signature
DW_AT_SUN_obj_dir
DW_AT_SUN_obj_file
DW_AT_SUN_original_name
DW_AT_SUN_hwcprof_signature
DW_AT_SUN_amd64_parmdump
DW_AT_SUN_part_link_name
DW_AT_SUN_link_name
DW_AT_SUN_pass_with_const
DW_AT_SUN_return_with_const
DW_AT_SUN_import_by_name
DW_AT_SUN_f90_pointer
DW_AT_SUN_pass_by_ref
DW_AT_SUN_f90_allocatable
DW_AT_SUN_f90_assumed_shape_array
DW_AT_SUN_c_vla
DW_AT_SUN_return_value_ptr
DW_AT_SUN_dtor_start
DW_AT_SUN_dtor_length
DW_AT_SUN_dtor_state_initial
DW_AT_SUN_dtor_state_final
DW_AT_SUN_dtor_state_deltas
DW_AT_SUN_import_by_lname
DW_AT_SUN_f90_use_only
DW_AT_SUN_namelist_spec
DW_AT_SUN_is_omp_child_func
DW_AT_SUN_fortran_main_alias
DW_AT_SUN_fortran_based
DW_AT_ALTIUM_loclist
DW_AT_use_GNAT_descriptive_type
DW_AT_GNAT_descriptive_type
DW_AT_GNU_numerator
DW_AT_GNU_denominator
DW_AT_GNU_bias
DW_AT_go_kind
DW_AT_go_key
DW_AT_go_elem
DW_AT_go_embedded_field
DW_AT_go_runtime_type
DW_AT_upc_threads_scaled
DW_AT_IBM_wsa_addr
DW_AT_IBM_home_location
DW_AT_IBM_alt_srcview
DW_AT_PGI_lbase
DW_AT_PGI_soffset
DW_AT_PGI_lstride
DW_AT_BORLAND_property_read
DW_AT_BORLAND_property_write
DW_AT_BORLAND_property_implements
DW_AT_BORLAND_property_index
DW_AT_BORLAND_property_default
DW_AT_BORLAND_Delphi_unit
DW_AT_BORLAND_Delphi_class
DW_AT_BORLAND_Delphi_record
DW_AT_BORLAND_Delphi_metaclass
DW_AT_BORLAND_Delphi_constructor
DW_AT_BORLAND_Delphi_destructor
DW_AT_BORLAND_Delphi_anonymous_method
DW_AT_BORLAND_Delphi_interface
DW_AT_BORLAND_Delphi_ABI
DW_AT_BORLAND_Delphi_frameptr
DW_AT_BORLAND_closure
DW_AT_LLVM_include_path
DW_AT_LLVM_config_macros
DW_AT_LLVM_sysroot
DW_AT_LLVM_tag_offset
DW_AT_APPLE_optimized
DW_AT_APPLE_flags
DW_AT_APPLE_isa
DW_AT_APPLE_block
DW_AT_APPLE_major_runtime_vers
DW_AT_APPLE_runtime_class
DW_AT_APPLE_omit_frame_ptr
DW_AT_APPLE_property_name
DW_AT_APPLE_property_getter
DW_AT_APPLE_property_setter
DW_AT_APPLE_property_attribute
DW_AT_APPLE_objc_complete_type
DW_AT_APPLE_property
DW_AT_APPLE_objc_direct
DW_AT_APPLE_sdk
DW_AT_hi_user
enum
Dwarf_OP_e
DW_OP_addr
DW_OP_deref
DW_OP_const1u
DW_OP_const1s
DW_OP_const2u
DW_OP_const2s
DW_OP_const4u
DW_OP_const4s
DW_OP_const8u
DW_OP_const8s
DW_OP_constu
DW_OP_consts
DW_OP_dup
DW_OP_drop
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_rot
DW_OP_xderef
DW_OP_abs
DW_OP_and
DW_OP_div
DW_OP_minus
DW_OP_mod
DW_OP_mul
DW_OP_neg
DW_OP_not
DW_OP_or
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_shr
DW_OP_shra
DW_OP_xor
DW_OP_bra
DW_OP_eq
DW_OP_ge
DW_OP_gt
DW_OP_le
DW_OP_lt
DW_OP_ne
DW_OP_skip
DW_OP_lit0
DW_OP_lit1
DW_OP_lit2
DW_OP_lit3
DW_OP_lit4
DW_OP_lit5
DW_OP_lit6
DW_OP_lit7
DW_OP_lit8
DW_OP_lit9
DW_OP_lit10
DW_OP_lit11
DW_OP_lit12
DW_OP_lit13
DW_OP_lit14
DW_OP_lit15
DW_OP_lit16
DW_OP_lit17
DW_OP_lit18
DW_OP_lit19
DW_OP_lit20
DW_OP_lit21
DW_OP_lit22
DW_OP_lit23
DW_OP_lit24
DW_OP_lit25
DW_OP_lit26
DW_OP_lit27
DW_OP_lit28
DW_OP_lit29
DW_OP_lit30
DW_OP_lit31
DW_OP_reg0
DW_OP_reg1
DW_OP_reg2
DW_OP_reg3
DW_OP_reg4
DW_OP_reg5
DW_OP_reg6
DW_OP_reg7
DW_OP_reg8
DW_OP_reg9
DW_OP_reg10
DW_OP_reg11
DW_OP_reg12
DW_OP_reg13
DW_OP_reg14
DW_OP_reg15
DW_OP_reg16
DW_OP_reg17
DW_OP_reg18
DW_OP_reg19
DW_OP_reg20
DW_OP_reg21
DW_OP_reg22
DW_OP_reg23
DW_OP_reg24
DW_OP_reg25
DW_OP_reg26
DW_OP_reg27
DW_OP_reg28
DW_OP_reg29
DW_OP_reg30
DW_OP_reg31
DW_OP_breg0
DW_OP_breg1
DW_OP_breg2
DW_OP_breg3
DW_OP_breg4
DW_OP_breg5
DW_OP_breg6
DW_OP_breg7
DW_OP_breg8
DW_OP_breg9
DW_OP_breg10
DW_OP_breg11
DW_OP_breg12
DW_OP_breg13
DW_OP_breg14
DW_OP_breg15
DW_OP_breg16
DW_OP_breg17
DW_OP_breg18
DW_OP_breg19
DW_OP_breg20
DW_OP_breg21
DW_OP_breg22
DW_OP_breg23
DW_OP_breg24
DW_OP_breg25
DW_OP_breg26
DW_OP_breg27
DW_OP_breg28
DW_OP_breg29
DW_OP_breg30
DW_OP_breg31
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_deref_size
DW_OP_xderef_size
DW_OP_nop
DW_OP_push_object_address
DW_OP_call2
DW_OP_call4
DW_OP_call_ref
DW_OP_form_tls_address
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_xderef_type
DW_OP_convert
DW_OP_reinterpret
DW_OP_GNU_push_tls_address
DW_OP_HP_is_value
DW_OP_HP_fltconst4
DW_OP_HP_fltconst8
DW_OP_HP_mod_range
DW_OP_HP_unmod_range
DW_OP_HP_tls
DW_OP_INTEL_bit_piece
DW_OP_WASM_location
DW_OP_WASM_location_int
DW_OP_GNU_uninit
DW_OP_GNU_encoded_addr
DW_OP_GNU_implicit_pointer
DW_OP_GNU_entry_value
DW_OP_GNU_const_type
DW_OP_GNU_regval_type
DW_OP_GNU_deref_type
DW_OP_GNU_convert
DW_OP_PGI_omp_thread_num
DW_OP_GNU_reinterpret
DW_OP_GNU_parameter_ref
DW_OP_GNU_addr_index
DW_OP_GNU_const_index
DW_OP_GNU_variable_value
DW_OP_hi_user
enum
Dwarf_ATE_e
DW_ATE_address
DW_ATE_boolean
DW_ATE_complex_float
DW_ATE_float
DW_ATE_signed
DW_ATE_signed_char
DW_ATE_unsigned
DW_ATE_unsigned_char
DW_ATE_imaginary_float
DW_ATE_packed_decimal
DW_ATE_numeric_string
DW_ATE_edited
DW_ATE_signed_fixed
DW_ATE_unsigned_fixed
DW_ATE_decimal_float
DW_ATE_UTF
DW_ATE_UCS
DW_ATE_ASCII
DW_ATE_ALTIUM_fract
DW_ATE_ALTIUM_accum
DW_ATE_HP_float128
DW_ATE_HP_complex_float128
DW_ATE_HP_floathpintel
DW_ATE_HP_imaginary_float80
DW_ATE_HP_imaginary_float128
DW_ATE_SUN_interval_float
DW_ATE_SUN_imaginary_float
DW_ATE_hi_user
enum
Dwarf_DEFAULTED_e
DW_DEFAULTED_no
DW_DEFAULTED_in_class
DW_DEFAULTED_out_of_class
enum
Dwarf_IDX_e
DW_IDX_compile_unit
DW_IDX_type_unit
DW_IDX_die_offset
DW_IDX_parent
DW_IDX_type_hash
DW_IDX_hi_user
DW_IDX_lo_user
enum
Dwarf_LLEX_e
DW_LLEX_end_of_list_entry
DW_LLEX_base_address_selection_entry
DW_LLEX_start_end_entry
DW_LLEX_start_length_entry
DW_LLEX_offset_pair_entry
enum
Dwarf_LLE_e
DW_LLE_end_of_list
DW_LLE_base_addressx
DW_LLE_startx_endx
DW_LLE_startx_length
DW_LLE_offset_pair
DW_LLE_default_location
DW_LLE_base_address
DW_LLE_start_end
DW_LLE_start_length
enum
Dwarf_RLE_e
DW_RLE_end_of_list
DW_RLE_base_addressx
DW_RLE_startx_endx
DW_RLE_startx_length
DW_RLE_offset_pair
DW_RLE_base_address
DW_RLE_start_end
DW_RLE_start_length
enum
Dwarf_GNUIVIS_e
DW_GNUIVIS_global
DW_GNUIVIS_static
enum
Dwarf_GNUIKIND_e
DW_GNUIKIND_none
DW_GNUIKIND_type
DW_GNUIKIND_variable
DW_GNUIKIND_function
DW_GNUIKIND_other
enum
Dwarf_UT_e
DW_UT_compile
DW_UT_type
DW_UT_partial
DW_UT_skeleton
DW_UT_split_compile
DW_UT_split_type
DW_UT_lo_user
DW_UT_hi_user
enum
Dwarf_SECT_e
DW_SECT_INFO
DW_SECT_TYPES
DW_SECT_ABBREV
DW_SECT_LINE
DW_SECT_LOCLISTS
DW_SECT_STR_OFFSETS
DW_SECT_MACRO
DW_SECT_RNGLISTS
enum
Dwarf_DS_e
DW_DS_unsigned
DW_DS_leading_overpunch
DW_DS_trailing_overpunch
DW_DS_leading_separate
DW_DS_trailing_separate
enum
Dwarf_END_e
DW_END_default
DW_END_big
DW_END_little
DW_END_lo_user
DW_END_hi_user
enum
Dwarf_ATCF_e
DW_ATCF_lo_user
DW_ATCF_SUN_mop_bitfield
DW_ATCF_SUN_mop_spill
DW_ATCF_SUN_mop_scopy
DW_ATCF_SUN_func_start
DW_ATCF_SUN_end_ctors
DW_ATCF_SUN_branch_target
DW_ATCF_SUN_mop_stack_probe
DW_ATCF_SUN_func_epilog
DW_ATCF_hi_user
enum
Dwarf_ACCESS_e
DW_ACCESS_public
DW_ACCESS_protected
DW_ACCESS_private
enum
Dwarf_VIS_e
DW_VIS_local
DW_VIS_exported
DW_VIS_qualified
enum
Dwarf_VIRTUALITY_e
DW_VIRTUALITY_none
DW_VIRTUALITY_virtual
DW_VIRTUALITY_pure_virtual
enum
Dwarf_LANG_e
DW_LANG_C89
DW_LANG_C
DW_LANG_Ada83
DW_LANG_C_plus_plus
DW_LANG_Cobol74
DW_LANG_Cobol85
DW_LANG_Fortran77
DW_LANG_Fortran90
DW_LANG_Pascal83
DW_LANG_Modula2
DW_LANG_Java
DW_LANG_C99
DW_LANG_Ada95
DW_LANG_Fortran95
DW_LANG_PLI
DW_LANG_ObjC
DW_LANG_ObjC_plus_plus
DW_LANG_UPC
DW_LANG_D
DW_LANG_Python
DW_LANG_OpenCL
DW_LANG_Go
DW_LANG_Modula3
DW_LANG_Haskel
DW_LANG_C_plus_plus_03
DW_LANG_C_plus_plus_11
DW_LANG_OCaml
DW_LANG_Rust
DW_LANG_C11
DW_LANG_Swift
DW_LANG_Julia
DW_LANG_Dylan
DW_LANG_C_plus_plus_14
DW_LANG_Fortran03
DW_LANG_Fortran08
DW_LANG_RenderScript
DW_LANG_BLISS
DW_LANG_lo_user
DW_LANG_Mips_Assembler
DW_LANG_Upc
DW_LANG_SUN_Assembler
DW_LANG_ALTIUM_Assembler
DW_LANG_hi_user
enum
Dwarf_ID_e
DW_ID_case_sensitive
DW_ID_up_case
DW_ID_down_case
DW_ID_case_insensitive
enum
Dwarf_CC_e
DW_CC_normal
DW_CC_program
DW_CC_nocall
DW_CC_pass_by_reference
DW_CC_pass_by_value
DW_CC_lo_user
DW_CC_GNU_borland_fastcall_i386
DW_CC_ALTIUM_interrupt
DW_CC_ALTIUM_near_system_stack
DW_CC_ALTIUM_near_user_stack
DW_CC_ALTIUM_huge_user_stack
DW_CC_GNU_BORLAND_safecall
DW_CC_GNU_BORLAND_stdcall
DW_CC_GNU_BORLAND_pascal
DW_CC_GNU_BORLAND_msfastcall
DW_CC_GNU_BORLAND_msreturn
DW_CC_GNU_BORLAND_thiscall
DW_CC_GNU_BORLAND_fastcall
DW_CC_LLVM_vectorcall
DW_CC_LLVM_Win64
DW_CC_LLVM_X86_64SysV
DW_CC_LLVM_AAPCS
DW_CC_LLVM_AAPCS_VFP
DW_CC_LLVM_IntelOclBicc
DW_CC_LLVM_SpirFunction
DW_CC_LLVM_OpenCLKernel
DW_CC_LLVM_Swift
DW_CC_LLVM_PreserveMost
DW_CC_LLVM_PreserveAll
DW_CC_LLVM_X86RegCall
DW_CC_GDB_IBM_OpenCL
enum
Dwarf_INL_e
DW_INL_not_inlined
DW_INL_inlined
DW_INL_declared_not_inlined
DW_INL_declared_inlined
enum
Dwarf_ORD_e
DW_ORD_row_major
DW_ORD_col_major
enum
Dwarf_DSC_e
DW_DSC_label
DW_DSC_range
enum
Dwarf_LNCT_e
DW_LNCT_path
DW_LNCT_directory_index
DW_LNCT_timestamp
DW_LNCT_size
DW_LNCT_MD5
DW_LNCT_GNU_subprogram_name
DW_LNCT_GNU_decl_file
DW_LNCT_GNU_decl_line
DW_LNCT_lo_user
DW_LNCT_LLVM_source
DW_LNCT_hi_user
enum
Dwarf_LNS_e
DW_LNS_copy
DW_LNS_advance_pc
DW_LNS_advance_line
DW_LNS_set_file
DW_LNS_set_column
DW_LNS_negate_stmt
DW_LNS_set_basic_block
DW_LNS_const_add_pc
DW_LNS_fixed_advance_pc
DW_LNS_set_prologue_end
DW_LNS_set_epilogue_begin
DW_LNS_set_isa
DW_LNS_set_address_from_logical
DW_LNS_inlined_call
DW_LNS_pop_context
enum
Dwarf_LNE_e
DW_LNE_end_sequence
DW_LNE_set_address
DW_LNE_define_file
DW_LNE_set_discriminator
DW_LNE_HP_negate_is_UV_update
DW_LNE_HP_push_context
DW_LNE_HP_pop_context
DW_LNE_HP_set_file_line_column
DW_LNE_HP_set_routine_name
DW_LNE_HP_set_sequence
DW_LNE_HP_negate_post_semantics
DW_LNE_HP_negate_function_exit
DW_LNE_HP_negate_front_end_logical
DW_LNE_HP_define_proc
DW_LNE_HP_source_file_correlation
DW_LNE_hi_user
enum
Dwarf_ISA_e
DW_ISA_UNKNOWN
DW_ISA_ARM_thumb
DW_ISA_ARM_arm
enum
Dwarf_MACRO_e
DW_MACRO_define
DW_MACRO_undef
DW_MACRO_start_file
DW_MACRO_end_file
DW_MACRO_define_strp
DW_MACRO_undef_strp
DW_MACRO_import
DW_MACRO_define_sup
DW_MACRO_undef_sup
DW_MACRO_import_sup
DW_MACRO_define_strx
DW_MACRO_undef_strx
DW_MACRO_lo_user
DW_MACRO_hi_user
enum
Dwarf_MACINFO_e
DW_MACINFO_define
DW_MACINFO_undef
DW_MACINFO_start_file
DW_MACINFO_end_file
DW_MACINFO_vendor_ext
enum
Dwarf_CFA_e
DW_CFA_extended
DW_CFA_set_loc
DW_CFA_advance_loc1
DW_CFA_advance_loc2
DW_CFA_advance_loc4
DW_CFA_offset_extended
DW_CFA_restore_extended
DW_CFA_undefined
DW_CFA_same_value
DW_CFA_register
DW_CFA_remember_state
DW_CFA_restore_state
DW_CFA_def_cfa
DW_CFA_def_cfa_register
DW_CFA_def_cfa_offset
DW_CFA_def_cfa_expression
DW_CFA_expression
DW_CFA_offset_extended_sf
DW_CFA_def_cfa_sf
DW_CFA_def_cfa_offset_sf
DW_CFA_val_offset
DW_CFA_val_offset_sf
DW_CFA_val_expression
DW_CFA_lo_user
DW_CFA_MIPS_advance_loc8
DW_CFA_GNU_window_save
DW_CFA_GNU_args_size
DW_CFA_GNU_negative_offset_extended
DW_CFA_METAWARE_info
DW_CFA_high_user
DW_CFA_advance_loc
DW_CFA_offset
DW_CFA_restore
enum
Dwarf_EH_e
DW_EH_PE_absptr
DW_EH_PE_uleb128
DW_EH_PE_udata2
DW_EH_PE_udata4
DW_EH_PE_udata8
DW_EH_PE_sleb128
DW_EH_PE_sdata2
DW_EH_PE_sdata4
DW_EH_PE_sdata8
DW_EH_PE_pcrel
DW_EH_PE_textrel
DW_EH_PE_datarel
DW_EH_PE_funcrel
DW_EH_PE_aligned
DW_EH_PE_omit
enum
Dwarf_FRAME_e
DW_FRAME_CFA_COL
DW_FRAME_REG1
DW_FRAME_REG2
DW_FRAME_REG3
DW_FRAME_REG4
DW_FRAME_REG5
DW_FRAME_REG6
DW_FRAME_REG7
DW_FRAME_REG8
DW_FRAME_REG9
DW_FRAME_REG10
DW_FRAME_REG11
DW_FRAME_REG12
DW_FRAME_REG13
DW_FRAME_REG14
DW_FRAME_REG15
DW_FRAME_REG16
DW_FRAME_REG17
DW_FRAME_REG18
DW_FRAME_REG19
DW_FRAME_REG20
DW_FRAME_REG21
DW_FRAME_REG22
DW_FRAME_REG23
DW_FRAME_REG24
DW_FRAME_REG25
DW_FRAME_REG26
DW_FRAME_REG27
DW_FRAME_REG28
DW_FRAME_REG29
DW_FRAME_REG30
DW_FRAME_REG31
DW_FRAME_FREG0
DW_FRAME_FREG1
DW_FRAME_FREG2
DW_FRAME_FREG3
DW_FRAME_FREG4
DW_FRAME_FREG5
DW_FRAME_FREG6
DW_FRAME_FREG7
DW_FRAME_FREG8
DW_FRAME_FREG9
DW_FRAME_FREG10
DW_FRAME_FREG11
DW_FRAME_FREG12
DW_FRAME_FREG13
DW_FRAME_FREG14
DW_FRAME_FREG15
DW_FRAME_FREG16
DW_FRAME_FREG17
DW_FRAME_FREG18
DW_FRAME_FREG19
DW_FRAME_FREG20
DW_FRAME_FREG21
DW_FRAME_FREG22
DW_FRAME_FREG23
DW_FRAME_FREG24
DW_FRAME_FREG25
DW_FRAME_FREG26
DW_FRAME_FREG27
DW_FRAME_FREG28
DW_FRAME_FREG29
DW_FRAME_FREG30
DW_FRAME_FREG31
DW_FRAME_FREG32
DW_FRAME_FREG33
DW_FRAME_FREG34
DW_FRAME_FREG35
DW_FRAME_FREG36
DW_FRAME_FREG37
DW_FRAME_FREG38
DW_FRAME_FREG39
DW_FRAME_FREG40
DW_FRAME_FREG41
DW_FRAME_FREG42
DW_FRAME_FREG43
DW_FRAME_FREG44
DW_FRAME_FREG45
DW_FRAME_FREG46
DW_FRAME_FREG47
DW_FRAME_FREG48
DW_FRAME_FREG49
DW_FRAME_FREG50
DW_FRAME_FREG51
DW_FRAME_FREG52
DW_FRAME_FREG53
DW_FRAME_FREG54
DW_FRAME_FREG55
DW_FRAME_FREG56
DW_FRAME_FREG57
DW_FRAME_FREG58
DW_FRAME_FREG59
DW_FRAME_FREG60
DW_FRAME_FREG61
DW_FRAME_FREG62
DW_FRAME_FREG63
DW_FRAME_FREG64
DW_FRAME_FREG65
DW_FRAME_FREG66
DW_FRAME_FREG67
DW_FRAME_FREG68
DW_FRAME_FREG69
DW_FRAME_FREG70
DW_FRAME_FREG71
DW_FRAME_FREG72
DW_FRAME_FREG73
DW_FRAME_FREG74
DW_FRAME_FREG75
DW_FRAME_FREG76
DW_FRAME_HIGHEST_NORMAL_REGISTER
enum
Dwarf_CHILDREN_e
DW_CHILDREN_no
DW_CHILDREN_yes
enum
Dwarf_ADDR_e
DW_ADDR_none
endif
__DWARF_NAMES_ENUM_H__
END
FILE
Automatically
generated
do
not
edit
Generated
sourcedate
BEGIN
FILE
define
DWARF_PRINT_PREFIX
before
this
point
if
you
wish
to
ifndef
DWARF_PRINT_PREFIX
define
DWARF_PRINT_PREFIX
dwarf_
endif
define
dw_glue
x
y
x
y
define
dw_glue2
x
y
dw_glue
x
y
define
DWPREFIX
x
dw_glue2
DWARF_PRINT_PREFIX
x
int
DWPREFIX
get_TAG_name
unsigned
int
const
char
int
DWPREFIX
get_children_name
unsigned
int
const
char
int
DWPREFIX
get_FORM_name
unsigned
int
const
char
int
DWPREFIX
get_AT_name
unsigned
int
const
char
int
DWPREFIX
get_OP_name
unsigned
int
const
char
int
DWPREFIX
get_ATE_name
unsigned
int
const
char
int
DWPREFIX
get_DEFAULTED_name
unsigned
int
const
char
int
DWPREFIX
get_IDX_name
unsigned
int
const
char
int
DWPREFIX
get_LLEX_name
unsigned
int
const
char
int
DWPREFIX
get_LLE_name
unsigned
int
const
char
int
DWPREFIX
get_RLE_name
unsigned
int
const
char
int
DWPREFIX
get_GNUIVIS_name
unsigned
int
const
char
int
DWPREFIX
get_GNUIKIND_name
unsigned
int
const
char
int
DWPREFIX
get_UT_name
unsigned
int
const
char
int
DWPREFIX
get_SECT_name
unsigned
int
const
char
int
DWPREFIX
get_DS_name
unsigned
int
const
char
int
DWPREFIX
get_END_name
unsigned
int
const
char
int
DWPREFIX
get_ATCF_name
unsigned
int
const
char
int
DWPREFIX
get_ACCESS_name
unsigned
int
const
char
int
DWPREFIX
get_VIS_name
unsigned
int
const
char
int
DWPREFIX
get_VIRTUALITY_name
unsigned
int
const
char
int
DWPREFIX
get_LANG_name
unsigned
int
const
char
int
DWPREFIX
get_ID_name
unsigned
int
const
char
int
DWPREFIX
get_CC_name
unsigned
int
const
char
int
DWPREFIX
get_INL_name
unsigned
int
const
char
int
DWPREFIX
get_ORD_name
unsigned
int
const
char
int
DWPREFIX
get_DSC_name
unsigned
int
const
char
int
DWPREFIX
get_LNCT_name
unsigned
int
const
char
int
DWPREFIX
get_LNS_name
unsigned
int
const
char
int
DWPREFIX
get_LNE_name
unsigned
int
const
char
int
DWPREFIX
get_ISA_name
unsigned
int
const
char
int
DWPREFIX
get_MACRO_name
unsigned
int
const
char
int
DWPREFIX
get_MACINFO_name
unsigned
int
const
char
int
DWPREFIX
get_CFA_name
unsigned
int
const
char
int
DWPREFIX
get_EH_name
unsigned
int
const
char
int
DWPREFIX
get_FRAME_name
unsigned
int
const
char
int
DWPREFIX
get_CHILDREN_name
unsigned
int
const
char
int
DWPREFIX
get_ADDR_name
unsigned
int
const
char
END
FILE
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_OBJECT_DETECTOR_H
define
DWARF_OBJECT_DETECTOR_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Declares
the
interface
function
outpath
is
a
place
you
provide
of
a
length
outpath_len
you
consider
reasonable
where
the
final
path
used
is
recorded
outpath_len
must
be
larger
than
strlen
path
This
matters
as
for
mach
o
if
the
path
is
a
directory
name
the
function
will
look
in
the
standard
macho
place
for
the
object
file
useful
for
dSYM
and
return
the
constructed
path
in
oupath
returns
DW_DLV_OK
DW_DLV_ERROR
or
DW_DLV_NO_ENTRY
ifndef
DW_FTYPE_UNKNOWN
define
DW_FTYPE_UNKNOWN
define
DW_FTYPE_ELF
define
DW_FTYPE_MACH_O
define
DW_FTYPE_PE
define
DW_FTYPE_ARCHIVE
unix
archive
endif
DW_FTYPE_UNKNOWN
ifndef
DW_ENDIAN_UNKNOWN
define
DW_ENDIAN_UNKNOWN
define
DW_ENDIAN_BIG
define
DW_ENDIAN_LITTLE
endif
DW_ENDIAN_UNKNOWN
offsetsize
refers
to
the
object
file
format
Elf
or
macho
or
PE
for
example
Not
to
DWARF
offset
sizes
Path
means
look
first
for
an
dynsym
object
of
the
same
name
per
MacOS
standards
making
the
outpath
space
needed
is
more
than
that
in
path
Copies
the
actual
path
into
outpath
an
error
if
the
length
in
outpath_len
is
less
than
needed
for
the
object
found
If
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
returned
the
argument
values
other
than
path
must
be
considered
to
be
in
an
unknown
state
The
errcode
is
a
small
integer
distinct
from
libdwarf
and
simply
printing
the
integer
returned
through
errcode
when
the
function
returns
DW_DLV_ERROR
will
hopefully
suffice
for
most
purposes
int
dwarf_object_detector_path
const
char
path
char
outpath
unsigned
long
outpath_len
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
errcode
int
dwarf_object_detector_fd
int
fd
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
errcode
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_OBJECT_DETECTOR_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_OBJECT_READ_COMMON_H
define
DWARF_OBJECT_READ_COMMON_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
int
_dwarf_object_read_random
int
fd
char
buf
off_t
loc
size_t
size
off_t
filesize
int
errc
void
_dwarf_safe_strcpy
char
out
long
outlen
const
char
in
long
inlen
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_OBJECT_READ_COMMON_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
Arxan
Technologies
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Following
the
nomenclature
of
the
DWARF
standard
Section
Version
Numbers
DWARF
means
not
applicable
means
not
defined
in
that
version
The
version
numbers
for
debug_info
is
the
same
as
debug_info
dwo
etc
for
the
other
dwo
sections
The
versions
applicable
by
section
are
DWARF2
DWARF3
DWARF4
DWARF5
debug_abbrev
debug_addr
debug_aranges
debug_frame
debug_info
debug_line
debug_line_str
debug_loc
debug_loclists
debug_macinfo
debug_macro
debug_names
debug_pubnames
debug_pubtypes
debug_ranges
debug_rnglists
debug_str
debug_str_offsets
debug_sup
debug_types
debug_abbrev
dwo
debug_info
dwo
debug_line
dwo
debug_loc
dwo
debug_loclists
dwo
debug_macro
dwo
debug_rnglists
dwo
debug_str
dwo
debug_str_offsets
dwo
debug_cu_index
debug_tu_index
struct
Dwarf_Rnglists_Context_s
typedef
struct
Dwarf_Rnglists_Context_s
Dwarf_Rnglists_Context
struct
Dwarf_Loclists_Context_s
typedef
struct
Dwarf_Loclists_Context_s
Dwarf_Loclists_Context
struct
Dwarf_Die_s
Dwarf_Byte_Ptr
di_debug_ptr
Dwarf_Abbrev_List
di_abbrev_list
Dwarf_CU_Context
di_cu_context
int
di_abbrev_code
TRUE
if
part
of
debug_info
FALSE
if
part
of
debug_types
Dwarf_Bool
di_is_info
struct
Dwarf_Attribute_s
Dwarf_Half
ar_attribute
Attribute
Value
Dwarf_Half
ar_attribute_form
Attribute
Form
Dwarf_Half
ar_attribute_form_direct
Identical
to
ar_attribute_form
except
that
if
the
original
form
uleb
was
DW_FORM_indirect
ar_attribute_form_direct
contains
DW_FORM_indirect
but
ar_attribute_form
contains
the
true
form
Dwarf_CU_Context
ar_cu_context
The
following
points
to
either
debug_info
or
debug_types
depending
on
if
context
is
cc_is_info
or
not
Dwarf_Small
ar_debug_ptr
If
DW_FORM_implicit
const
the
value
is
here
not
in
the
DIE
Dwarf_Signed
ar_implicit_const
Dwarf_Debug
ar_dbg
dbg
owning
the
attr
Dwarf_Die
ar_die
Access
to
the
DIE
owning
the
attribute
Dwarf_Attribute
ar_next
This
structure
provides
the
context
for
a
compilation
unit
Thus
it
contains
the
Dwarf_Debug
cc_dbg
that
this
cu
belongs
to
It
contains
the
information
in
the
compilation
unit
header
cc_length
cc_version_stamp
cc_abbrev_offset
and
cc_address_size
in
the
debug_info
section
for
that
cu
In
addition
it
contains
the
count
cc_count_cu
of
the
cu
number
of
that
cu
in
the
list
of
cu
s
in
the
debug_info
The
count
starts
at
ie
cc_count_cu
is
for
the
first
cu
for
the
second
and
so
on
This
struct
also
contains
a
pointer
to
a
list
of
pairs
of
abbrev
code
and
a
pointer
to
the
start
of
that
abbrev
in
the
debug_abbrev
section
Each
die
will
also
contain
a
pointer
to
such
a
struct
to
record
the
context
for
that
die
Notice
that
a
pointer
to
the
CU
DIE
itself
is
Dwarf_Off
off2
cu_context
cc_debug_info_offset
cu_die_info_ptr
dbg
de_debug_info
dss_data
off2
_dwarf_length_of_cu_header
dbg
off2
Or
similar
for
de_debug_types
Updated
by
dwarf_next_cu_header
in
dwarf_die_deliv
c
struct
Dwarf_CU_Context_s
Dwarf_Debug
cc_dbg
The
sum
of
cc_length
cc_length_size
and
cc_extension_size
is
the
total
length
of
the
CU
including
its
header
cc_length
is
the
length
of
the
compilation
unit
excluding
cc_length_size
and
cc_extension_size
Dwarf_Unsigned
cc_length
cc_length_size
is
the
size
in
bytes
of
an
offset
Should
probably
be
renamed
cc_offset_size
for
dwarf
for
dwarf
whether
MIPS
IRIX
dwarf
or
standard
dwarf
using
the
extension
mechanism
Dwarf_Small
cc_length_size
cc_extension_size
is
zero
unless
this
is
standard
DWARF3
and
later
dwarf
using
the
extension
mechanism
DWARF3
and
later
cc_extension_size
is
DWARF2
MIPS
IRIX
cc_extension_size
is
zero
DWARF
cc_extension_size
is
zero
Dwarf_Small
cc_extension_size
cc_version_stamp
is
the
DWARF
version
number
applicable
to
the
DWARF
in
this
compilation
unit
Dwarf_Half
cc_version_stamp
cc_abbrev_offset
is
the
section
global
offset
of
the
debug_abbrev
section
this
CU
uses
Data
from
CU
header
Includes
DWP
adjustment
made
as
soon
as
we
create
a
cu_context
Dwarf_Unsigned
cc_abbrev_offset
cc_address_size
is
the
size
of
an
address
in
this
compilation
unit
Dwarf_Small
cc_address_size
Dwarf_Small
cc_segment_selector_size
cc_debug_offset
is
the
global
offset
in
the
section
of
the
area
length
field
of
the
CU
The
CU
header
of
the
CU
is
at
offset
cc_debug_offset
cc_length_size
cc_extension_size
This
is
a
section
global
offset
May
be
debug_info
or
debug_types
Even
in
DWP
this
is
set
to
true
global
offset
right
away
when
cu_context
created
See
cc_is_info
flag
Dwarf_Unsigned
cc_debug_offset
START
DEBUG
FISSION
Split
Dwarf
data
cc_signature
is
in
the
TU
header
of
a
type
unit
of
a
TU
DIE
or
for
DW5
in
the
skeleton
or
split_compile
header
is
a
dwo_id
Ignore
this
field
if
cc_signature_present
is
zero
TU
CUs
signature
is
not
the
same
namespace
as
DW_AT_dwo_id
signatures
The
two
must
be
kept
separate
for
DWARF5
If
cc_unit_type
DW_UT_compile
or
DW_UT_partial
the
signature
is
a
CU
signature
dwo_id
Some
early
DW5
drafts
encouraged
DWARF4
output
of
some
compilers
to
include
dwo_id
but
in
a
messier
way
lacking
DW_UT_
If
cc_unit_type
DW_UT_split_type
the
signature
is
a
type
signature
Dwarf_Half
cc_cu_die_tag
Dwarf_Sig8
cc_signature
cc_type_signature_offset
contains
the
section
local
DIE
offset
of
the
type
the
signature
applies
to
if
the
cc_unit_type
is
DW_UT_type
or
DW_UT_split_type
Dwarf_Unsigned
cc_signature_offset
For
each
CU
and
each
TU
in
a
dwp
package
file
there
is
is
a
hash
and
a
set
of
offsets
indexed
by
DW_SECT_
id
Only
one
such
set
per
CU
or
TU
The
data
on
all
that
is
in
cc_dwp_offsets
If
it
is
a
TU
the
signature
in
cc_dwp_offsets
must
match
the
signature
in
cc_signature
struct
Dwarf_Debug_Fission_Per_CU_s
cc_dwp_offsets
Dwarf_Bool
cc_signature_present
Meaning
type
signature
in
TU
header
or
for
CU
header
signature
in
CU
DIE
Dwarf_Bool
cc_low_pc_present
Dwarf_Bool
cc_addr_base_present
Not
TRUE
in
dwo
Dwarf_Bool
cc_cu_die_has_children
Dwarf_Bool
cc_dwo_name_present
Dwarf_Bool
cc_at_strx_present
Non
zero
if
this
context
is
a
dwo
section
Either
dwo
or
dwp
file
Dwarf_Bool
cc_is_dwo
cc_cu_die_offset_present
is
non
zero
if
cc_cu_die_global_sec_offset
is
meaningful
Dwarf_Bool
cc_cu_die_offset_present
if
present
is
base
address
of
CU
Dwarf_Unsigned
cc_low_pc
from
DW_AT_addr_base
in
CU
DIE
offset
to
debug_addr
table
Dwarf_Unsigned
cc_addr_base
Zero
in
dwo
DW_SECT_LINE
Dwarf_Bool
cc_line_base_present
DW5
Dwarf_Unsigned
cc_line_base
DW5
Dwarf_Unsigned
cc_line_base_contr_size
DW5
From
DW_AT_loclists_base
or
DW_SECT_LOCLISTS
Dwarf_Unsigned
cc_loclists_base
Dwarf_Unsigned
cc_loclists_base_contr_size
Dwarf_Bool
cc_loclists_base_present
Dwarf_Bool
cc_loclists_header_length_present
debug_str_offsets
DW_SECT_STR_OFFSETS
DW4
DW5
vs
DW_AT_str_offsets_base
table
array
off
Dwarf_Bool
cc_str_offsets_base_present
Dwarf_Bool
cc_str_offsets_header_length_present
Dwarf_Unsigned
cc_str_offsets_header_offset
from
cu
tu
Dwarf_Unsigned
cc_str_offsets_contr_size
Dwarf_Unsigned
cc_str_offsets_base
to
get
from
the
start
of
a
str_offsets
table
to
the
offsets
array
entries
See
cc_str_offsets_header_length_present
though
not
normally
needed
If
header_length
is
zero
all
CUs
in
this
DWP
use
a
DWARF4
extension
simple
offset
array
not
a
DWARF5
set
of
tables
Dwarf_Unsigned
cc_str_offsets_header_length
Dwarf_Unsigned
cc_str_offsets_offset_size
DW_SECT_MACRO
Dwarf_Unsigned
cc_macro_base
DW5
Dwarf_Unsigned
cc_macro_base_contr_size
DW5
Dwarf_Bool
cc_macro_base_present
Dwarf_Bool
cc_macro_header_length_present
DW_SECT_RNGLISTS
Dwarf_Unsigned
cc_rnglists_base
DW5
Dwarf_Unsigned
cc_rnglists_base_contr_size
DW5
DW_AT_GNU_ranges_base
was
a
GNU
extension
that
appeared
but
was
unused
See
dwarf_die_deliv
c
for
details
Dwarf_Unsigned
cc_ranges_base
DW_AT_GNU_ranges_base
is
a
GNU
extension
DW4
Dwarf_Bool
cc_ranges_base_present
debug_rnglists
Dwarf_Bool
cc_rnglists_base_present
DW5
Dwarf_Bool
cc_rnglists_header_length_present
char
cc_dwo_name
END
DEBUG
FISSION
Split
Dwarf
data
Global
section
offset
to
the
bytes
of
the
CU
die
for
this
CU
Set
when
the
CU
die
is
accessed
by
dwarf_siblingof_b
Dwarf_Unsigned
cc_cu_die_global_sec_offset
Dwarf_Byte_Ptr
cc_last_abbrev_ptr
Dwarf_Byte_Ptr
cc_last_abbrev_endptr
Dwarf_Hash_Table
cc_abbrev_hash_table
Dwarf_Unsigned
cc_highest_known_code
Dwarf_CU_Context
cc_next
Dwarf_Bool
cc_is_info
TRUE
means
context
is
in
debug_info
FALSE
means
is
in
debug_types
FALSE
only
possible
for
DWARF4
debug_types
section
CUs
For
DWARF5
all
DIEs
are
in
debug_info
dwo
Dwarf_Half
cc_unit_type
DWARF5
Set
from
header
as
a
DW_UT_
value
For
DWARF
this
is
filled
in
initially
from
the
CU
header
and
refined
by
inspecting
the
CU
DIE
to
detect
the
correct
setting
Consolidates
section
specific
data
in
one
place
Section
is
an
Elf
specific
term
intended
as
a
general
term
for
non
Elf
objects
some
code
must
synthesize
the
values
somehow
struct
Dwarf_Section_s
Dwarf_Small
dss_data
Dwarf_Unsigned
dss_size
Some
Elf
sections
have
a
non
zero
dss_entrysize
which
is
the
size
in
bytes
of
a
table
entry
in
the
section
Relocations
and
symbols
are
both
in
tables
so
have
a
non
zero
entrysize
Object
formats
which
do
not
care
about
this
should
leave
this
field
zero
Dwarf_Unsigned
dss_entrysize
dss_index
is
the
section
index
as
things
are
numbered
in
an
object
file
being
read
An
Elf
section
number
Dwarf_Unsigned
dss_index
dss_addr
is
the
section
address
which
is
only
non
zero
for
a
GNU
eh
section
Purpose
to
handle
DW_EH_PE_pcrel
encoding
Leaving
it
zero
is
fine
for
non
elf
Dwarf_Addr
dss_addr
Dwarf_Small
dss_data_was_malloc
is_in_use
set
during
initial
object
reading
to
detect
duplicates
Ignored
after
setup
done
Dwarf_Small
dss_is_in_use
When
loading
COMDAT
they
refer
sometimes
to
base
sections
so
we
need
to
have
the
BASE
group
sections
filled
in
when
the
corresponding
is
not
in
the
COMDAT
group
list
debug_abbrev
is
an
example
Dwarf_Unsigned
dss_group_number
These
for
reporting
compression
Dwarf_Unsigned
dss_uncompressed_length
Dwarf_Unsigned
dss_compressed_length
If
this
is
zdebug
to
start
data
size
are
the
raw
section
bytes
Initially
for
all
sections
dss_data_was_malloc
set
FALSE
and
dss_requires_decompress
set
FALSE
For
zdebug
set
dss_zdebug_requires_decompress
set
TRUE
In
that
case
it
is
likely
ZLIB
compressed
but
we
do
not
know
that
just
scanning
section
headers
If
not
zdebug
but
it
is
SHF_COMPRESSED
then
decompress
is
required
On
translation
ie
zlib
use
and
malloc
Set
dss_data
dss_size
to
point
to
malloc
space
and
malloc
size
Set
dss_did_decompress
FALSE
Set
dss_was_malloc
TRUE
Dwarf_Small
dss_zdebug_requires_decompress
Dwarf_Small
dss_did_decompress
Dwarf_Small
dss_shf_compressed
section
flag
SHF_COMPRESS
Section
compression
starts
with
ZLIB
chars
Dwarf_Small
dss_ZLIB_compressed
For
non
elf
leaving
the
following
fields
zero
will
mean
they
are
ignored
dss_link
should
be
zero
unless
a
section
has
a
link
to
another
sh_link
Used
to
access
relocation
data
for
a
section
and
for
symtab
section
access
its
strtab
Dwarf_Unsigned
dss_link
The
following
is
used
when
reading
rela
sections
such
sections
appear
in
some
o
files
Dwarf_Half
dss_reloc_index
Zero
means
ignore
the
reloc
fields
Dwarf_Small
dss_reloc_data
Dwarf_Unsigned
dss_reloc_size
Dwarf_Unsigned
dss_reloc_entrysize
Dwarf_Addr
dss_reloc_addr
dss_reloc_symtab
is
the
sh_link
of
a
rela
to
its
symtab
leave
it
if
non
meaningful
Dwarf_Addr
dss_reloc_symtab
dss_reloc_link
should
be
zero
unless
a
reloc
section
has
a
link
to
another
sh_link
Used
to
access
the
symtab
for
relocating
a
section
Dwarf_Unsigned
dss_reloc_link
Pointer
to
the
elf
symtab
used
for
elf
rela
Leave
it
if
not
relevant
struct
Dwarf_Section_s
dss_symtab
dss_name
dss_standard_name
must
never
be
freed
they
are
static
strings
in
libdwarf
const
char
dss_name
const
char
dss_standard_name
Object
section
number
in
object
file
unsigned
dss_number
These
are
elf
flags
and
non
elf
object
should
just
leave
these
fields
zero
Which
is
essentially
automatic
as
they
are
not
in
Dwarf_Obj_Access_Section_s
Dwarf_Unsigned
dss_flags
Dwarf_Unsigned
dss_addralign
Set
when
loading
group
section
as
those
are
special
and
neither
compressed
nor
have
relocations
so
never
malloc
space
for
libdwarf
Dwarf_Small
dss_ignore_reloc_group_sec
char
dss_is_rela
Overview
if
next_to_use
first
no
error
slots
are
used
If
next_to_use
mod
maxcount
first
the
slots
are
all
used
struct
Dwarf_Harmless_s
unsigned
dh_maxcount
unsigned
dh_next_to_use
unsigned
dh_first
unsigned
dh_errs_count
char
dh_errors
Data
needed
separately
for
debug_info
and
debug_types
as
we
may
be
reading
both
interspersed
So
we
always
select
the
one
we
need
struct
Dwarf_Debug_InfoTypes_s
Context
for
the
compilation_unit
just
read
by
a
call
to
dwarf_next_cu_header
Updated
by
dwarf_next_cu_header
in
dwarf_die_deliv
c
Dwarf_CU_Context
de_cu_context
Points
to
linked
list
of
CU
Contexts
for
the
CU
s
already
read
These
are
only
CU
s
read
by
dwarf_next_cu_header
Dwarf_CU_Context
de_cu_context_list
Points
to
the
last
CU
Context
added
to
the
list
by
dwarf_next_cu_header
Dwarf_CU_Context
de_cu_context_list_end
Offset
of
last
byte
of
last
CU
read
Actually
one
past
that
last
byte
So
use
care
and
compare
as
offset
de_last_offset
to
know
if
offset
is
too
big
Dwarf_Unsigned
de_last_offset
de_last_di_info_ptr
and
de_last_die
are
used
with
dwarf_siblingof
dwarf_child
and
dwarf_validate_die_sibling
dwarf_validate_die_sibling
will
not
give
meaningful
results
if
called
inappropriately
Dwarf_Byte_Ptr
de_last_di_ptr
Dwarf_Die
de_last_die
typedef
struct
Dwarf_Debug_InfoTypes_s
Dwarf_Debug_InfoTypes
As
the
tasks
performed
on
a
debug
related
section
is
the
same
in
order
to
make
the
process
of
adding
a
new
section
very
unlikely
a
little
bit
easy
and
to
reduce
the
possibility
of
errors
a
simple
table
build
dynamically
will
contain
the
relevant
information
struct
Dwarf_dbg_sect_s
Debug
section
name
must
not
be
freed
is
quoted
string
This
is
the
name
from
the
object
file
itself
const
char
ds_name
The
section
number
in
object
section
numbering
unsigned
ds_number
Debug
section
information
points
to
de_debug_
member
or
the
like
of
the
dbg
struct
struct
Dwarf_Section_s
ds_secdata
unsigned
ds_groupnumber
int
ds_duperr
Error
code
for
duplicated
section
int
ds_emptyerr
Error
code
for
empty
section
int
ds_have_dwarf
Section
contains
DWARF
int
ds_have_zdebug
Section
compressed
zdebug
name
As
the
number
of
debug
sections
does
not
change
very
often
in
the
case
a
new
section
is
added
in
enter_section_in_array
the
MAX_DEBUG_SECTIONS
must
be
updated
accordingly
This
does
not
yet
allow
for
section
groups
in
object
files
for
which
many
debug_info
and
other
sections
may
exist
define
DWARF_MAX_DEBUG_SECTIONS
define
DWARFSTRING_ALLOC_SIZE
All
the
Dwarf_Debug
tied
file
info
in
one
place
struct
Dwarf_Tied_Data_s
Used
to
access
executable
from
dwo
or
dwp
object
Pointer
to
the
tied_to
Dwarf_Debug
Dwarf_Debug
td_tied_object
TRUE
if
this
tied
object
is
tied
to
It
s
extra
work
to
look
for
a
DW_AT_dwo_id
Set
when
tied
dbg
on
the
base
was
created
This
helps
us
do
it
only
when
it
may
be
productive
Dwarf_Bool
td_is_tied_object
Used
for
Type
Unit
signatures
Type
Units
are
in
debug_types
in
DW4
but
in
debug_info
in
DW5
Some
debug_info
point
to
them
symbolically
via
DW_AT_signature
attributes
If
non
zero
is
a
dwarf_tsearch
tree
Only
non
zero
if
td_is_tied_object
is
set
and
we
had
a
reason
to
build
the
search
tree
Type
Units
have
a
Dwarf_Sig8
signature
in
the
header
and
such
is
recorded
here
Type
Unit
signatures
can
conflict
with
signatures
in
split
dwarf
dwo
dwp
sections
The
Key
for
each
record
is
a
Dwarf_Sig8
bytes
The
data
for
each
is
a
pointer
to
a
Dwarf_CU_context
record
in
this
dbg
cu_context
in
one
of
tied
dbg
s
de_cu_context_list
void
td_tied_search
dg_groupnum
does
not
exist
dg_groupnum
is
base
dg_groupnum
is
dwo
dg_groupnum
and
higher
are
COMDAT
groups
if
any
struct
Dwarf_Group_Data_s
For
traditional
DWARF
the
value
is
one
just
one
group
unsigned
gd_number_of_groups
Raw
elf
elf
like
section
count
unsigned
gd_number_of_sections
unsigned
gd_map_entry_count
A
map
from
section
number
to
group
number
void
gd_map
struct
Dwarf_Debug_s
All
file
access
methods
and
support
data
are
hidden
in
this
structure
We
get
a
pointer
callers
control
the
lifetime
of
the
structure
and
contents
struct
Dwarf_Obj_Access_Interface_s
de_obj_file
Dwarf_Handler
de_errhand
Dwarf_Ptr
de_errarg
Enabling
us
to
close
an
fd
if
we
own
it
as
in
the
case
of
dwarf_init_path
de_fd
is
only
meaningful
if
de_owns_fd
is
set
Each
object
file
type
has
any
necessary
fd
recorded
under
de_obj_file
int
de_fd
char
de_owns_fd
DW_PATHSOURCE_BASIC
or
MACOS
or
DEBUGLINK
unsigned
char
de_path_source
unsigned
char
de_using_libelf
de_path
is
only
set
automatically
if
dwarf_init_path
was
used
to
initialize
things
Used
with
the
gnu_debuglink
section
const
char
de_path
const
char
de_gnu_global_paths
unsigned
de_gnu_global_path_count
struct
Dwarf_Debug_InfoTypes_s
de_info_reading
struct
Dwarf_Debug_InfoTypes_s
de_types_reading
DW_GROUPNUMBER_ANY
DW_GROUPNUMBER_BASE
DW_GROUPNUMBER_DWO
or
a
comdat
group
number
Selected
at
init
time
of
this
dbg
based
on
user
request
and
on
data
in
the
object
unsigned
de_groupnumber
Supporting
data
for
groupnumbers
struct
Dwarf_Group_Data_s
de_groupnumbers
Number
of
bytes
in
the
length
and
offset
field
in
various
debu
sections
It
s
not
very
meaningful
and
is
only
used
in
one
approximate
calculation
de_offset_size
would
be
a
more
apropos
name
Dwarf_Small
de_length_size
Size
of
the
object
file
in
bytes
If
Unknown
leave
this
zero
Dwarf_Unsigned
de_filesize
number
of
bytes
in
a
pointer
of
the
target
in
various
debug_
sections
in
in
MIPS
ia64
Dwarf_Small
de_pointer_size
set
at
creation
of
a
Dwarf_Debug
to
say
if
form_string
should
be
checked
for
valid
length
at
every
call
means
do
the
check
non
zero
means
do
not
do
the
check
Dwarf_Small
de_assume_string_in_bounds
Keep
track
of
allocations
so
a
dwarf_finish
call
can
clean
up
Null
till
a
tree
is
created
void
de_alloc_tree
These
fields
are
used
to
process
debug_frame
section
Updated
by
dwarf_get_fde_list
in
dwarf_frame
h
Points
to
contiguous
block
of
pointers
to
Dwarf_Cie_s
structs
Dwarf_Cie
de_cie_data
Count
of
number
of
Dwarf_Cie_s
structs
Dwarf_Signed
de_cie_count
Keep
eh
GNU
separate
Dwarf_Cie
de_cie_data_eh
Dwarf_Signed
de_cie_count_eh
Points
to
contiguous
block
of
pointers
to
Dwarf_Fde_s
structs
Dwarf_Fde
de_fde_data
Count
of
number
of
Dwarf_Fde_s
structs
Dwarf_Unsigned
de_fde_count
Keep
eh
GNU
separate
Dwarf_Fde
de_fde_data_eh
Dwarf_Unsigned
de_fde_count_eh
struct
Dwarf_Section_s
de_debug_info
struct
Dwarf_Section_s
de_debug_types
struct
Dwarf_Section_s
de_debug_abbrev
struct
Dwarf_Section_s
de_debug_line
struct
Dwarf_Section_s
de_debug_line_str
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_loc
struct
Dwarf_Section_s
de_debug_aranges
struct
Dwarf_Section_s
de_debug_macinfo
struct
Dwarf_Section_s
de_debug_macro
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_names
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_pubnames
struct
Dwarf_Section_s
de_debug_str
struct
Dwarf_Section_s
de_debug_sup
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_loclists
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_rnglists
New
in
DWARF5
struct
Dwarf_Section_s
de_debug_frame
struct
Dwarf_Section_s
de_gnu_debuglink
New
Sept
struct
Dwarf_Section_s
de_note_gnu_buildid
New
Sept
gnu
the
g
eh_frame
section
struct
Dwarf_Section_s
de_debug_frame_eh_gnu
DWARF3
debug_pubtypes
struct
Dwarf_Section_s
de_debug_pubtypes
Four
SGI
IRIX
extensions
essentially
identical
to
DWARF3
debug_pubtypes
Only
on
SGI
IRIX
struct
Dwarf_Section_s
de_debug_funcnames
struct
Dwarf_Section_s
de_debug_typenames
struct
Dwarf_Section_s
de_debug_varnames
struct
Dwarf_Section_s
de_debug_weaknames
struct
Dwarf_Section_s
de_debug_ranges
Following
two
part
of
DebugFission
and
DWARF5
struct
Dwarf_Section_s
de_debug_str_offsets
struct
Dwarf_Section_s
de_debug_addr
For
the
debug_rnglists
dwo
section
Dwarf_Unsigned
de_rnglists_context_count
pointer
to
array
of
pointers
to
rnglists
context
instances
Dwarf_Rnglists_Context
de_rnglists_context
For
the
debug_loclists
dwo
section
Dwarf_Unsigned
de_loclists_context_count
pointer
to
array
of
pointers
to
loclists
context
instances
Dwarf_Loclists_Context
de_loclists_context
Following
for
the
gdb_index
section
struct
Dwarf_Section_s
de_debug_gdbindex
Types
in
DWARF5
are
in
debug_info
and
in
DWARF4
are
in
debug_types
These
indexes
first
standardized
in
DWARF5
DWARF4
can
have
them
as
an
extension
The
next
to
refer
to
the
DWP
index
sections
and
the
tu
and
cu
indexes
sections
are
distinct
in
DWARF4
struct
Dwarf_Section_s
de_debug_cu_index
struct
Dwarf_Section_s
de_debug_tu_index
struct
Dwarf_Section_s
de_debug_gnu_pubnames
struct
Dwarf_Section_s
de_debug_gnu_pubtypes
For
non
elf
simply
leave
the
following
two
structs
zeroed
and
they
will
be
ignored
struct
Dwarf_Section_s
de_elf_symtab
struct
Dwarf_Section_s
de_elf_strtab
For
a
dwp
object
file
For
DWARF4
type
units
are
in
debug_types
DWP
is
a
GNU
extension
in
DW4
For
DWARF5
type
units
are
in
debug_info
Dwarf_Xu_Index_Header
de_cu_hashindex_data
Dwarf_Xu_Index_Header
de_tu_hashindex_data
void
de_copy_word
void
const
void
unsigned
long
unsigned
char
de_same_endian
unsigned
char
de_elf_must_close
If
non
zero
then
it
was
dwarf_init
not
dwarf_elf_init
so
must
elf_end
Default
is
DW_FRAME_INITIAL_VALUE
from
header
Dwarf_Half
de_frame_rule_initial_value
Default
is
DW_FRAME_LAST_REG_NUM
Dwarf_Half
de_frame_reg_rules_entry_count
Dwarf_Half
de_frame_cfa_col_number
Dwarf_Half
de_frame_same_value_number
Dwarf_Half
de_frame_undefined_value_number
unsigned
char
de_big_endian_object
Non
zero
if
object
being
read
is
big
endian
Non
zero
if
dwarf_get_globals
dwarf_get_funcs
dwarf_get_types
dwarf_get_pubtypes
dwarf_get_vars
dwarf_get_weaks
should
create
and
return
a
special
zero
die
offset
for
the
corresponding
pubnames
style
section
CU
header
with
zero
pubnames
style
named
DIEs
In
that
case
the
list
returned
will
have
an
entry
with
a
zero
for
the
die
offset
which
is
an
impossible
debug_info
die_offset
New
March
See
dwarf_return_empty_pubnames
unsigned
char
de_return_empty_pubnames
struct
Dwarf_dbg_sect_s
de_debug_sections
DWARF_MAX_DEBUG_SECTIONS
Number
actually
used
unsigned
de_debug_sections_total_entries
struct
Dwarf_Harmless_s
de_harmless_errors
struct
Dwarf_Printf_Callback_Info_s
de_printf_callback
void
de_printf_callback_null_device_handle
Used
in
a
tied
dbg
to
hold
global
info
on
the
tied
object
DW_AT_dwo_id
And
for
Type
Unit
signatures
whether
tied
or
not
It
is
not
defined
whether
the
main
object
is
executable
and
the
tied
file
is
a
dwo
dwp
or
the
reverse
The
focus
of
reporting
is
on
the
main
file
but
the
tied
file
is
sometimes
needed
and
referenced
struct
Dwarf_Tied_Data_s
de_tied_data
New
style
takes
advantage
of
dwarfstrings
capability
This
not
a
public
function
int
_dwarf_printf
Dwarf_Debug
dbg
const
char
data
typedef
struct
Dwarf_Chain_s
Dwarf_Chain
struct
Dwarf_Chain_s
void
ch_item
int
ch_itemtype
Needed
to
dealloc
chain
contents
Dwarf_Chain
ch_next
typedef
struct
Dwarf_Chain_o
Dwarf_Chain_2
struct
Dwarf_Chain_o
Dwarf_Off
ch_item
Dwarf_Chain_2
ch_next
Size
of
cu
header
version
stamp
field
define
CU_VERSION_STAMP_SIZE
DWARF_HALF_SIZE
Size
of
cu
header
address
size
field
define
CU_ADDRESS_SIZE_SIZE
sizeof
Dwarf_Small
define
ORIGINAL_DWARF_OFFSET_SIZE
The
DISTINGUISHED
VALUE
is
byte
value
defined
by
DWARF
since
DWARF3
define
DISTINGUISHED_VALUE
define
DISTINGUISHED_VALUE_OFFSET_SIZE
define
DISTINGUISHED_VALUE_ARRAY
x
char
x
int
_dwarf_ignorethissection
const
char
scn_name
We
don
t
load
the
sections
until
they
are
needed
This
function
is
used
to
load
the
section
int
_dwarf_load_section
Dwarf_Debug
struct
Dwarf_Section_s
Dwarf_Error
void
_dwarf_dealloc_rnglists_context
Dwarf_Debug
dbg
void
_dwarf_dealloc_loclists_context
Dwarf_Debug
dbg
int
_dwarf_get_string_base_attr_value
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
sbase_out
Dwarf_Error
error
int
_dwarf_read_str_offsets_header
Dwarf_Debug
dbg
Dwarf_Small
table_start_ptr
Dwarf_Unsigned
secsize
Dwarf_Small
secendptr
Dwarf_CU_Context
cucontext
Followed
by
return
values
error
Dwarf_Unsigned
length
Dwarf_Half
offset_size_out
Dwarf_Half
extension_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Unsigned
header_length_out
Dwarf_Error
error
int
_dwarf_extract_string_offset_via_str_offsets
Dwarf_Debug
dbg
Dwarf_Small
data_ptr
Dwarf_Small
end_data_ptr
Dwarf_Half
attrnum
Dwarf_Half
attrform
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
str_sect_offset_out
Dwarf_Error
error
int
_dwarf_look_in_local_and_tied_by_index
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
index
Dwarf_Addr
return_addr
Dwarf_Error
error
if
Never
implemented
int
_dwarf_get_base_and_size_given_signature
Dwarf_CU_Context
context
Dwarf_Sig8
signature_in
xu_sect_index
means
DW_SECT_info
etc
Dwarf_Unsigned
xu_sect_index
Dwarf_Unsigned
base_out
Dwarf_Unsigned
size_out
Dwarf_Error
err
endif
Dwarf_Bool
_dwarf_file_has_debug_fission_cu_index
Dwarf_Debug
dbg
Dwarf_Bool
_dwarf_file_has_debug_fission_tu_index
Dwarf_Debug
dbg
Dwarf_Bool
_dwarf_file_has_debug_fission_index
Dwarf_Debug
dbg
This
should
only
be
called
on
a
CU
Never
a
TU
int
_dwarf_get_debugfission_for_offset
Dwarf_Debug
dbg
Dwarf_Off
offset_wanted
const
char
keytype
cu
or
tu
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
error
whichone
must
be
a
valid
DW_SECT
macro
value
Dwarf_Unsigned
_dwarf_get_dwp_extra_offset
struct
Dwarf_Debug_Fission_Per_CU_s
dwp
unsigned
whichone
Dwarf_Unsigned
size
This
will
look
into
the
tied
Dwarf_Debug
to
which
should
have
a
skeleton
CU
DIE
and
an
addr_base
and
also
have
the
debug_addr
section
int
_dwarf_get_addr_from_tied
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
addrindex
Dwarf_Addr
addr_out
Dwarf_Error
error
int
_dwarf_get_fission_addition_die
Dwarf_Die
die
int
dw_sect_index
Dwarf_Unsigned
offset
Dwarf_Unsigned
size
Dwarf_Error
error
int
_dwarf_get_addr_index_itself
int
theform
Dwarf_Small
info_ptr
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
val_out
Dwarf_Error
error
Dwarf_Bool
_dwarf_addr_form_is_indexed
int
form
int
_dwarf_load_die_containing_section
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
error
int
_dwarf_create_a_new_cu_context_record_on_list
Dwarf_Debug
dbg
Dwarf_Debug_InfoTypes
dis
Dwarf_Bool
is_info
Dwarf_Unsigned
section_size
Dwarf_Unsigned
new_cu_offset
Dwarf_CU_Context
context_out
Dwarf_Error
error
Dwarf_Unsigned
_dwarf_calculate_next_cu_context_offset
Dwarf_CU_Context
cu_context
int
_dwarf_search_for_signature
Dwarf_Debug
dbg
Dwarf_Sig8
sig
Dwarf_CU_Context
context_out
Dwarf_Error
error
int
_dwarf_merge_all_base_attrs_of_cu_die
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Debug
tieddbg
Dwarf_CU_Context
tiedcontext_out
Dwarf_Error
error
void
_dwarf_tied_destroy_free_node
void
node
void
_dwarf_destroy_group_map
Dwarf_Debug
dbg
int
_dwarf_section_get_target_group
Dwarf_Debug
dbg
unsigned
obj_section_index
unsigned
groupnumber
Dwarf_Error
error
int
_dwarf_dwo_groupnumber_given_name
const
char
name
unsigned
grpnum_out
int
_dwarf_section_get_target_group_from_map
Dwarf_Debug
dbg
unsigned
obj_section_index
unsigned
groupnumber_out
UNUSEDARG
Dwarf_Error
error
int
_dwarf_insert_in_group_map
Dwarf_Debug
dbg
unsigned
groupnum
unsigned
section_index
const
char
name
Dwarf_Error
error
returns
TRUE
FALSE
meaning
this
section
name
is
in
map
for
this
groupnum
or
not
int
_dwarf_section_in_group_by_name
Dwarf_Debug
dbg
const
char
scn_name
unsigned
groupnum
int
_dwarf_next_cu_header_internal
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Bool
has_signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_offset
Dwarf_Half
header_cu_type
Dwarf_Error
error
Relates
to
debug_addr
int
_dwarf_look_in_local_and_tied
Dwarf_Half
attr_form
Dwarf_CU_Context
context
Dwarf_Small
info_ptr
Dwarf_Addr
return_addr
Dwarf_Error
error
int
_dwarf_get_ranges_base_attr_from_tied
Dwarf_Debug
dbg
Dwarf_CU_Context
context
Dwarf_Unsigned
ranges_base_out
Dwarf_Unsigned
addr_base_out
Dwarf_Error
error
int
_dwarf_get_string_from_tied
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
char
return_str
Dwarf_Error
error
int
_dwarf_valid_form_we_know
Dwarf_Unsigned
at_form
Dwarf_Unsigned
at_name
int
_dwarf_extract_local_debug_str_string_given_offset
Dwarf_Debug
dbg
unsigned
attrform
Dwarf_Unsigned
offset
char
return_str
Dwarf_Error
error
int
_dwarf_file_name_is_full_path
Dwarf_Small
fname
This
is
an
elf
only
extension
to
get
SHF_COMPRESSED
flag
from
sh_flags
if
pointer
not
set
which
is
normal
for
non
elf
objects
it
is
fine
typedef
int
_dwarf_get_elf_flags_func_ptr_type
void
obj_in
Dwarf_Half
section_index
Dwarf_Unsigned
flags_out
Dwarf_Unsigned
addralign_out
int
error
extern
_dwarf_get_elf_flags_func_ptr_type
_dwarf_get_elf_flags_func_ptr
This
is
libelf
access
to
Elf
object
extern
int
_dwarf_elf_setup
int
fd
char
true_path_out_buffer
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
This
is
non
libelf
Elf
access
extern
int
_dwarf_elf_nlsetup
int
fd
char
true_path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
void
_dwarf_destruct_elf_nlaccess
struct
Dwarf_Obj_Access_Interface_s
aip
extern
int
_dwarf_macho_setup
int
fd
char
true_path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
void
_dwarf_destruct_macho_access
struct
Dwarf_Obj_Access_Interface_s
aip
extern
int
_dwarf_pe_setup
int
fd
char
path
unsigned
ftype
unsigned
endian
unsigned
offsetsize
size_t
filesize
unsigned
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
void
_dwarf_destruct_pe_access
struct
Dwarf_Obj_Access_Interface_s
aip
void
_dwarf_create_address_size_dwarf_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
addrsize
int
errcode
const
char
errname
extern
Dwarf_Bool
_dwarf_allow_formudata
unsigned
form
extern
int
_dwarf_formudata_internal
Dwarf_Debug
dbg
Dwarf_Attribute
attr
unsigned
form
Dwarf_Byte_Ptr
data
Dwarf_Byte_Ptr
section_end
Dwarf_Unsigned
return_uval
Dwarf_Unsigned
bytes_read
Dwarf_Error
error
Dwarf_Byte_Ptr
_dwarf_calculate_info_section_start_ptr
Dwarf_CU_Context
context
Dwarf_Unsigned
section_len_out
Dwarf_Byte_Ptr
_dwarf_calculate_info_section_end_ptr
Dwarf_CU_Context
context
Dwarf_Byte_Ptr
_dwarf_calculate_abbrev_section_end_ptr
Dwarf_CU_Context
context
int
_dwarf_formblock_internal
Dwarf_Debug
dbg
Dwarf_Attribute
attr
Dwarf_CU_Context
cu_context
Dwarf_Block
return_block
Dwarf_Error
error
int
_dwarf_extract_data16
Dwarf_Debug
dbg
Dwarf_Small
data
Dwarf_Small
section_start
Dwarf_Small
section_end
Dwarf_Form_Data16
returned_val
Dwarf_Error
error
unsigned
int
_dwarf_crc32
unsigned
int
init
const
unsigned
char
buf
size_t
len
void
_dwarf_dumpsig
const
char
msg
Dwarf_Sig8
sig
int
lineno
ifndef
DWARF_PE_DESCR_H
define
DWARF_PE_DESCR_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifdef
__cplusplus
extern
C
endif
__cplusplus
define
IMAGE_DOS_SIGNATURE_dw
le
on
disk
M
Z
define
IMAGE_DOS_REVSIGNATURE_dw
be
on
disk
define
IMAGE_NT_SIGNATURE_dw
ifndef
TYP
define
TYP
n
l
char
n
l
endif
TYPE
Data
types
see
https
msdn
microsoft
com
en
us
library
windows
desktop
aa383751
v
vs
aspx
define
FIELD_OFFSET
type
field
LONG
LONG_PTR
type
field
define
IMAGE_SIZEOF_SYMBOL
struct
dos_header_dw
TYP
dh_mz
TYP
dh_dos_data
TYP
dh_image_offset
IMAGE_FILE_HEADER_dw
see
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680313
v
vs
aspx
typedef
struct
TYP
Machine
TYP
NumberOfSections
TYP
TimeDateStamp
TYP
PointerToSymbolTable
TYP
NumberOfSymbols
TYP
SizeOfOptionalHeader
TYP
Characteristics
IMAGE_FILE_HEADER_dw
IMAGE_DATA_DIRECTORY_dw
see
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680305
v
vs
aspx
typedef
struct
TYP
VirtualAddress
TYP
Size
IMAGE_DATA_DIRECTORY_dw
IMAGE_OPTIONAL_HEADER
see
https
msdn
microsoft
com
en
us
library
windows
desktop
ms680339
v
vs
aspx
define
IMAGE_NUMBEROF_DIRECTORY_ENTRIES
typedef
struct
TYP
Magic
unsigned
char
MajorLinkerVersion
unsigned
char
MinorLinkerVersion
TYP
SizeOfCode
TYP
SizeOfInitializedData
TYP
SizeOfUninitializedData
TYP
AddressOfEntryPoint
TYP
BaseOfCode
TYP
BaseOfData
TYP
ImageBase
TYP
SectionAlignment
TYP
FileAlignment
TYP
MajorOperatingSystemVersion
TYP
MinorOperatingSystemVersion
TYP
MajorImageVersion
TYP
MinorImageVersion
TYP
MajorSubsystemVersion
TYP
MinorSubsystemVersion
TYP
Win32VersionValue
TYP
SizeOfImage
TYP
SizeOfHeaders
TYP
CheckSum
TYP
Subsystem
TYP
DllCharacteristics
TYP
SizeOfStackReserve
TYP
SizeOfStackCommit
TYP
SizeOfHeapReserve
TYP
SizeOfHeapCommit
TYP
LoaderFlags
TYP
NumberOfRvaAndSizes
IMAGE_DATA_DIRECTORY_dw
DataDirectory
IMAGE_NUMBEROF_DIRECTORY_ENTRIES
IMAGE_OPTIONAL_HEADER32_dw
typedef
struct
TYP
Magic
unsigned
char
MajorLinkerVersion
unsigned
char
MinorLinkerVersion
TYP
SizeOfCode
TYP
SizeOfInitializedData
TYP
SizeOfUninitializedData
TYP
AddressOfEntryPoint
TYP
BaseOfCode
TYP
ImageBase
TYP
SectionAlignment
TYP
FileAlignment
TYP
MajorOperatingSystemVersion
TYP
MinorOperatingSystemVersion
TYP
MajorImageVersion
TYP
MinorImageVersion
TYP
MajorSubsystemVersion
TYP
MinorSubsystemVersion
TYP
Win32VersionValue
TYP
SizeOfImage
TYP
SizeOfHeaders
TYP
CheckSum
TYP
Subsystem
TYP
DllCharacteristics
TYP
SizeOfStackReserve
TYP
SizeOfStackCommit
TYP
SizeOfHeapReserve
TYP
SizeOfHeapCommit
TYP
LoaderFlags
TYP
NumberOfRvaAndSizes
IMAGE_DATA_DIRECTORY_dw
DataDirectory
IMAGE_NUMBEROF_DIRECTORY_ENTRIES
IMAGE_OPTIONAL_HEADER64_dw
IMAGE_NT_HEADERS
see
https
msdn
microsoft
com
fr
fr
library
windows
desktop
ms680336
v
vs
aspx
define
IMAGE_NT_OPTIONAL_HDR32_MAGIC
define
IMAGE_NT_OPTIONAL_HDR64_MAGIC
define
IMAGE_ROM_OPTIONAL_HDR_MAGIC
typedef
struct
TYP
Signature
IMAGE_FILE_HEADER_dw
FileHeader
IMAGE_OPTIONAL_HEADER64_dw
OptionalHeader
IMAGE_NT_HEADERS64_dw
PIMAGE_NT_HEADERS64_dw
typedef
struct
TYP
Signature
IMAGE_FILE_HEADER_dw
FileHeader
IMAGE_OPTIONAL_HEADER32_dw
OptionalHeader
IMAGE_NT_HEADERS32_dw
PIMAGE_NT_HEADERS32_dw
IMAGE_SECTION_HEADER_dw
see
https
msdn
microsoft
com
en
us
library
windows
desktop
ms680341
v
vs
aspx
and
for
details
on
VirtualSize
and
SizeOfRawData
https
docs
microsoft
com
en
us
windows
desktop
api
winnt
ns
winnt
_image_section_header
define
IMAGE_SIZEOF_SHORT_NAME
typedef
struct
char
Name
IMAGE_SIZEOF_SHORT_NAME
union
TYP
PhysicalAddress
TYP
VirtualSize
Misc
TYP
VirtualAddress
TYP
SizeOfRawData
TYP
PointerToRawData
TYP
PointerToRelocations
TYP
PointerToLinenumbers
TYP
NumberOfRelocations
TYP
NumberOfLinenumbers
TYP
Characteristics
IMAGE_SECTION_HEADER_dw
PIMAGE_SECTION_HEADER_dw
define
IMAGE_SCN_SCALE_INDEX
define
IMAGE_SCN_TYPE_NO_PAD
define
IMAGE_SCN_CNT_CODE
define
IMAGE_SCN_CNT_INITIALIZED_DATA
define
IMAGE_SCN_CNT_UNINITIALIZED_DATA
define
IMAGE_SCN_LNK_OTHER
define
IMAGE_SCN_LNK_INFO
define
IMAGE_SCN_LNK_REMOVE
define
IMAGE_SCN_LNK_COMDAT
define
IMAGE_SCN_NO_DEFER_SPEC_EXC
define
IMAGE_SCN_MEM_FARDATA
define
IMAGE_SCN_MEM_PURGEABLE
define
IMAGE_SCN_MEM_LOCKED
define
IMAGE_SCN_MEM_PRELOAD
define
IMAGE_SCN_ALIGN_1BYTES
define
IMAGE_SCN_ALIGN_2BYTES
define
IMAGE_SCN_ALIGN_4BYTES
define
IMAGE_SCN_ALIGN_8BYTES
define
IMAGE_SCN_ALIGN_16BYTES
define
IMAGE_SCN_ALIGN_32BYTES
define
IMAGE_SCN_ALIGN_64BYTES
define
IMAGE_SCN_ALIGN_128BYTES
define
IMAGE_SCN_ALIGN_256BYTES
define
IMAGE_SCN_ALIGN_512BYTES
define
IMAGE_SCN_ALIGN_1024BYTES
define
IMAGE_SCN_ALIGN_2048BYTES
define
IMAGE_SCN_ALIGN_4096BYTES
define
IMAGE_SCN_ALIGN_8192BYTES
define
IMAGE_SCN_ALIGN_MASK
define
IMAGE_SCN_LNK_NRELOC_OVFL
define
IMAGE_SCN_MEM_DISCARDABLE
define
IMAGE_SCN_MEM_NOT_CACHED
define
IMAGE_SCN_MEM_NOT_PAGED
define
IMAGE_SCN_MEM_SHARED
define
IMAGE_SCN_MEM_EXECUTE
define
IMAGE_SCN_MEM_READ
define
IMAGE_SCN_MEM_WRITE
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_PE_DESCR_H
ifndef
PE_GENERIC_H
define
PE_GENERIC_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifdef
__cplusplus
extern
C
endif
__cplusplus
struct
dwarf_pe_generic_file_header
Dwarf_Unsigned
Machine
Dwarf_Unsigned
NumberOfSections
Dwarf_Unsigned
TimeDateStamp
Dwarf_Unsigned
PointerToSymbolTable
Dwarf_Unsigned
NumberOfSymbols
Dwarf_Unsigned
SizeOfOptionalHeader
in
object
file
Dwarf_Unsigned
Characteristics
struct
dwarf_pe_generic_data_directory
Dwarf_Unsigned
VirtualAddress
Dwarf_Unsigned
Size
define
DWARF_PE_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
struct
dwarf_pe_generic_optional_header
Dwarf_Unsigned
Magic
unsigned
char
MajorLinkerVersion
unsigned
char
MinorLinkerVersion
Dwarf_Unsigned
SizeOfCode
Dwarf_Unsigned
SizeOfInitializedData
Dwarf_Unsigned
SizeOfUninitializedData
Dwarf_Unsigned
AddressOfEntryPoint
Dwarf_Unsigned
BaseOfCode
Dwarf_Unsigned
BaseOfData
Dwarf_Unsigned
ImageBase
Dwarf_Unsigned
SectionAlignment
Dwarf_Unsigned
FileAlignment
Dwarf_Unsigned
MajorOperatingSystemVersion
Dwarf_Unsigned
MinorOperatingSystemVersion
Dwarf_Unsigned
MajorImageVersion
Dwarf_Unsigned
MinorImageVersion
Dwarf_Unsigned
MajorSubsystemVersion
Dwarf_Unsigned
MinorSubsystemVersion
Dwarf_Unsigned
Win32VersionValue
Dwarf_Unsigned
SizeOfImage
size
in
object
file
Dwarf_Unsigned
SizeOfHeaders
size
in
object
file
Dwarf_Unsigned
CheckSum
Dwarf_Unsigned
Subsystem
Dwarf_Unsigned
DllCharacteristics
Dwarf_Unsigned
SizeOfStackReserve
Dwarf_Unsigned
SizeOfStackCommit
Dwarf_Unsigned
SizeOfHeapReserve
Dwarf_Unsigned
SizeOfHeapCommit
Dwarf_Unsigned
LoaderFlags
Dwarf_Unsigned
NumberOfRvaAndSizes
Dwarf_Unsigned
SizeOfDataDirEntry
size
in
object
file
struct
dwarf_pe_generic_data_directory
DataDirectory
DWARF_PE_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES
struct
dwarf_pe_generic_image_section_header
char
name
Name
must
be
freed
char
dwarfsectname
Name
must
be
freed
Dwarf_Unsigned
SecHeaderOffset
offset
in
object
file
union
Dwarf_Unsigned
PhysicalAddress
Dwarf_Unsigned
VirtualSize
Misc
Dwarf_Unsigned
VirtualAddress
Dwarf_Unsigned
SizeOfRawData
size
we
need
Dwarf_Unsigned
PointerToRawData
Dwarf_Unsigned
PointerToRelocations
Dwarf_Unsigned
PointerToLinenumbers
Dwarf_Unsigned
NumberOfRelocations
Dwarf_Unsigned
NumberOfLinenumbers
Dwarf_Unsigned
Characteristics
Dwarf_Small
loaded_data
must
be
freed
define
DWARF_PE_IMAGE_NT_OPTIONAL_HDR32_MAGIC
define
DWARF_PE_IMAGE_NT_OPTIONAL_HDR64_MAGIC
define
DWARF_PE_IMAGE_ROM_OPTIONAL_HDR_MAGIC
ident
P
means
this
is
a
PE
header
ident
will
be
indicating
version
Other
bytes
in
ident
not
defined
should
be
zero
typedef
struct
pe_filedata_s
char
pe_ident
const
char
pe_path
must
free
int
pe_fd
int
pe_destruct_close_fd
aka
lib
owns
fd
int
pe_is_64bit
Dwarf_Unsigned
pe_filesize
Dwarf_Small
pe_offsetsize
or
section
data
Dwarf_Small
pe_pointersize
int
pe_ftype
unsigned
pe_endian
Dwarf_Small
pe_machine
void
pe_copy_word
void
const
void
unsigned
long
Dwarf_Unsigned
pe_nt_header_offset
Dwarf_Unsigned
pe_optional_header_offset
Dwarf_Unsigned
pe_optional_header_size
Dwarf_Unsigned
pe_symbol_table_offset
Dwarf_Unsigned
pe_string_table_offset
Dwarf_Unsigned
pe_section_table_offset
Dwarf_Unsigned
pe_signature
struct
dwarf_pe_generic_file_header
pe_FileHeader
struct
dwarf_pe_generic_optional_header
pe_OptionalHeader
Dwarf_Unsigned
pe_section_count
struct
dwarf_pe_generic_image_section_header
pe_sectionptr
Dwarf_Unsigned
pe_string_table_size
char
pe_string_table
dwarf_pe_object_access_internals_t
ifdef
__cplusplus
endif
__cplusplus
endif
PE_GENERIC_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_READING_H
define
DWARF_READING_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
ifndef
DW_DLV_OK
DW_DLV_OK
must
match
libdwarf
h
DW_DLV_NO_ENTRY
must
match
libdwarf
h
define
DW_DLV_OK
define
DW_DLV_NO_ENTRY
define
DW_DLV_ERROR
endif
DW_DLV_OK
define
ALIGN4
define
ALIGN8
define
PREFIX
t
define
LUFMT
lu
define
UFMT
u
define
DFMT
d
define
XFMT
x
even
if
already
seen
values
must
match
so
no
ifdef
needed
define
DW_DLV_NO_ENTRY
define
DW_DLV_OK
define
DW_DLV_ERROR
define
P
printf
define
F
fflush
stdout
define
RRMOA
f
buf
loc
siz
fsiz
errc
_dwarf_object_read_random
f
char
buf
loc
siz
fsiz
errc
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_READING_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_386_H
define
DWARF_RELOC_386_H
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
Relocation
types
for
i386
architecture
define
R_386_NONE
define
R_386_32
define
R_386_PC32
define
R_386_GOT32
define
R_386_PLT32
define
R_386_COPY
define
R_386_GLOB_DAT
define
R_386_JMP_SLOT
define
R_386_RELATIVE
define
R_386_GOTOFF
define
R_386_GOTPC
define
R_386_32PLT
define
R_386_TLS_TPOFF
define
R_386_TLS_IE
define
R_386_TLS_GOTIE
define
R_386_TLS_LE
define
R_386_TLS_LDM
define
R_386_16
define
R_386_PC16
define
R_386_8
define
R_386_PC8
define
R_386_TLS_GD_32
define
R_386_TLS_GD_PUSH
define
R_386_TLS_GD_CALL
define
R_386_TLS_GD_POP
define
R_386_TLS_LDM_32
define
R_386_TLS_LDM_PUSH
define
R_386_TLS_LDM_CALL
define
R_386_TLS_LDM_POP
define
R_386_TLS_LDO_32
define
R_386_TLS_IE_32
define
R_386_TLS_LE_32
define
R_386_TLS_DTPMOD32
define
R_386_TLS_DTPOFF32
define
R_386_TLS_TPOFF32
define
R_386_SIZE32
define
R_386_TLS_GOTDESC
define
R_386_TLS_DESC_CALL
define
R_386_TLS_DESC
define
R_386_IRELATIVE
define
R_386_NUM
Keep
this
the
last
entry
define
R_X86_64_NUM
endif
_WIN32
Relocation
types
for
X86_64
static
const
char
reloc_type_names_386
R_386_NONE
R_386_32
R_386_PC32
R_386_GOT32
R_386_PLT32
R_386_COPY
R_386_GLOB_DAT
R_386_JMP_SLOT
R_386_RELATIVE
R_386_GOTOFF
R_386_GOTPC
R_386_32PLT
R_386_TLS_TPOFF
R_386_TLS_IE
R_386_TLS_GOTIE
R_386_TLS_LE
R_386_TLS_LDM
R_386_16
R_386_PC16
R_386_8
R_386_PC8
R_386_TLS_GD_32
R_386_TLS_GD_PUSH
R_386_TLS_GD_CALL
R_386_TLS_GD_POP
R_386_TLS_LDM_32
R_386_TLS_LDM_PUSH
R_386_TLS_LDM_CALL
R_386_TLS_LDM_POP
R_386_TLS_LDO_32
R_386_TLS_IE_32
R_386_TLS_LE_32
R_386_TLS_DTPMOD32
R_386_TLS_DTPOFF32
R_386_TLS_TPOFF32
R_386_SIZE32
R_386_TLS_GOTDESC
R_386_TLS_DESC_CALL
R_386_TLS_DESC
R_386_IRELATIVE
endif
DWARF_RELOC_386_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_ARM_H
define
DWARF_RELOC_ARM_H
Definitions
for
ARM
define
DWARF_RELOC_ARM
ifndef
EM_AARCH64
define
EM_AARCH64
Arm
endif
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
Relocation
types
for
ARM
define
R_ARM_NONE
define
R_ARM_PC24
define
R_ARM_ABS32
define
R_ARM_REL32
define
R_ARM_LDR_PC_G0
define
R_ARM_ABS16
define
R_ARM_ABS12
define
R_ARM_THM_ABS5
define
R_ARM_ABS8
define
R_ARM_SBREL32
define
R_ARM_THM_CALL
define
R_ARM_THM_PC8
define
R_ARM_BREL_ADJ
define
R_ARM_TLS_DESC
define
R_ARM_THM_SWI8
define
R_ARM_XPC25
define
R_ARM_THM_XPC22
define
R_ARM_TLS_DTPMOD32
define
R_ARM_TLS_DTPOFF32
define
R_ARM_TLS_TPOFF32
define
R_ARM_COPY
define
R_ARM_GLOB_DAT
define
R_ARM_JUMP_SLOT
define
R_ARM_RELATIVE
define
R_ARM_GOTOFF32
define
R_ARM_BASE_PREL
define
R_ARM_GOT_BREL
define
R_ARM_PLT32
define
R_ARM_CALL
define
R_ARM_JUMP24
define
R_ARM_THM_JUMP24
define
R_ARM_BASE_ABS
define
R_ARM_ALU_PCREL_7_0
define
R_ARM_ALU_PCREL_15_8
define
R_ARM_ALU_PCREL_23_15
define
R_ARM_LDR_SBREL_11_0_NC
define
R_ARM_ALU_SBREL_19_12_NC
define
R_ARM_ALU_SBREL_27_20_CK
define
R_ARM_TARGET1
define
R_ARM_SBREL31
define
R_ARM_V4BX
define
R_ARM_TARGET2
define
R_ARM_PREL31
define
R_ARM_MOVW_ABS_NC
define
R_ARM_MOVT_ABS
define
R_ARM_MOVW_PREL_NC
define
R_ARM_MOVT_PREL
define
R_ARM_THM_MOVW_ABS_NC
define
R_ARM_THM_MOVT_ABS
define
R_ARM_THM_MOVW_PREL_NC
define
R_ARM_THM_MOVT_PREL
define
R_ARM_THM_JUMP19
define
R_ARM_THM_JUMP6
define
R_ARM_THM_ALU_PREL_11_0
define
R_ARM_THM_PC12
define
R_ARM_ABS32_NOI
define
R_ARM_REL32_NOI
define
R_ARM_ALU_PC_G0_NC
define
R_ARM_ALU_PC_G0
define
R_ARM_ALU_PC_G1_NC
define
R_ARM_ALU_PC_G1
define
R_ARM_ALU_PC_G2
define
R_ARM_LDR_PC_G1
define
R_ARM_LDR_PC_G2
define
R_ARM_LDRS_PC_G0
define
R_ARM_LDRS_PC_G1
define
R_ARM_LDRS_PC_G2
define
R_ARM_LDC_PC_G0
define
R_ARM_LDC_PC_G1
define
R_ARM_LDC_PC_G2
define
R_ARM_ALU_SB_G0_NC
define
R_ARM_ALU_SB_G0
define
R_ARM_ALU_SB_G1_NC
define
R_ARM_ALU_SB_G1
define
R_ARM_ALU_SB_G2
define
R_ARM_LDR_SB_G0
define
R_ARM_LDR_SB_G1
define
R_ARM_LDR_SB_G2
define
R_ARM_LDRS_SB_G0
define
R_ARM_LDRS_SB_G1
define
R_ARM_LDRS_SB_G2
define
R_ARM_LDC_SB_G0
define
R_ARM_LDC_SB_G1
define
R_ARM_LDC_SB_G2
define
R_ARM_MOVW_BREL_NC
define
R_ARM_MOVT_BREL
define
R_ARM_MOVW_BREL
define
R_ARM_THM_MOVW_BREL_NC
define
R_ARM_THM_MOVT_BREL
define
R_ARM_THM_MOVW_BREL
define
R_ARM_TLS_GOTDESC
define
R_ARM_TLS_CALL
define
R_ARM_TLS_DESCSEQ
define
R_ARM_THM_TLS_CALL
define
R_ARM_PLT32_ABS
define
R_ARM_GOT_ABS
define
R_ARM_GOT_PREL
define
R_ARM_GOT_BREL12
define
R_ARM_GOTOFF12
define
R_ARM_GOTRELAX
define
R_ARM_GNU_VTENTRY
define
R_ARM_GNU_VTINHERIT
define
R_ARM_THM_JUMP11
define
R_ARM_THM_JUMP8
define
R_ARM_TLS_GD32
define
R_ARM_TLS_LDM32
define
R_ARM_TLS_LDO32
define
R_ARM_TLS_IE32
define
R_ARM_TLS_LE32
define
R_ARM_TLS_LDO12
define
R_ARM_TLS_LE12
define
R_ARM_TLS_IE12GP
define
R_ARM_ME_TOO
define
R_ARM_THM_TLS_DESCSEQ16
define
R_ARM_THM_TLS_DESCSEQ32
define
R_ARM_RXPC25
define
R_ARM_RSBREL32
define
R_ARM_THM_RPC22
define
R_ARM_RREL32
define
R_ARM_RABS32
define
R_ARM_RPC24
define
R_ARM_RBASE
Keep
this
the
last
entry
define
R_ARM_NUM
endif
_WIN32
ARM
relocations
defined
by
the
ABIs
static
const
char
reloc_type_names_ARM
R_ARM_NONE
R_ARM_PC24
R_ARM_ABS32
R_ARM_REL32
R_ARM_LDR_PC_G0
R_ARM_ABS16
R_ARM_ABS12
R_ARM_THM_ABS5
R_ARM_ABS8
R_ARM_SBREL32
R_ARM_THM_CALL
R_ARM_THM_PC8
R_ARM_BREL_ADJ
R_ARM_TLS_DESC
R_ARM_THM_SWI8
R_ARM_XPC25
R_ARM_THM_XPC22
R_ARM_TLS_DTPMOD32
R_ARM_TLS_DTPOFF32
R_ARM_TLS_TPOFF32
R_ARM_COPY
R_ARM_GLOB_DAT
R_ARM_JUMP_SLOT
R_ARM_RELATIVE
R_ARM_GOTOFF32
R_ARM_BASE_PREL
R_ARM_GOT_BREL
R_ARM_PLT32
R_ARM_CALL
R_ARM_JUMP24
R_ARM_THM_JUMP24
R_ARM_BASE_ABS
R_ARM_ALU_PCREL_7_0
R_ARM_ALU_PCREL_15_8
R_ARM_ALU_PCREL_23_15
R_ARM_LDR_SBREL_11_0_NC
R_ARM_ALU_SBREL_19_12_NC
R_ARM_ALU_SBREL_27_20_CK
R_ARM_TARGET1
R_ARM_SBREL31
R_ARM_V4BX
R_ARM_TARGET2
R_ARM_PREL31
R_ARM_MOVW_ABS_NC
R_ARM_MOVT_ABS
R_ARM_MOVW_PREL_NC
R_ARM_MOVT_PREL
R_ARM_THM_MOVW_ABS_NC
R_ARM_THM_MOVT_ABS
R_ARM_THM_MOVW_PREL_NC
R_ARM_THM_MOVT_PREL
R_ARM_THM_JUMP19
R_ARM_THM_JUMP6
R_ARM_THM_ALU_PREL_11_0
R_ARM_THM_PC12
R_ARM_ABS32_NOI
R_ARM_REL32_NOI
R_ARM_ALU_PC_G0_NC
R_ARM_ALU_PC_G0
R_ARM_ALU_PC_G1_NC
R_ARM_ALU_PC_G1
R_ARM_ALU_PC_G2
R_ARM_LDR_PC_G1
R_ARM_LDR_PC_G2
R_ARM_LDRS_PC_G0
R_ARM_LDRS_PC_G1
R_ARM_LDRS_PC_G2
R_ARM_LDC_PC_G0
R_ARM_LDC_PC_G1
R_ARM_LDC_PC_G2
R_ARM_ALU_SB_G0_NC
R_ARM_ALU_SB_G0
R_ARM_ALU_SB_G1_NC
R_ARM_ALU_SB_G1
R_ARM_ALU_SB_G2
R_ARM_LDR_SB_G0
R_ARM_LDR_SB_G1
R_ARM_LDR_SB_G2
R_ARM_LDRS_SB_G0
R_ARM_LDRS_SB_G1
R_ARM_LDRS_SB_G2
R_ARM_LDC_SB_G0
R_ARM_LDC_SB_G1
R_ARM_LDC_SB_G2
R_ARM_MOVW_BREL_NC
R_ARM_MOVT_BREL
R_ARM_MOVW_BREL
R_ARM_THM_MOVW_BREL_NC
R_ARM_THM_MOVT_BREL
R_ARM_THM_MOVW_BREL
R_ARM_TLS_GOTDESC
R_ARM_TLS_CALL
R_ARM_TLS_DESCSEQ
R_ARM_THM_TLS_CALL
R_ARM_PLT32_ABS
R_ARM_GOT_ABS
R_ARM_GOT_PREL
R_ARM_GOT_BREL12
R_ARM_GOTOFF12
R_ARM_GOTRELAX
R_ARM_GNU_VTENTRY
R_ARM_GNU_VTINHERIT
R_ARM_THM_JUMP11
R_ARM_THM_JUMP8
R_ARM_TLS_GD32
R_ARM_TLS_LDM32
R_ARM_TLS_LDO32
R_ARM_TLS_IE32
R_ARM_TLS_LE32
R_ARM_TLS_LDO12
R_ARM_TLS_LE12
R_ARM_TLS_IE12GP
R_ARM_TLS_MOVT_TPOFF32
R_ARM_PRIVATE_0
R_ARM_TLS_MOVW_TPOFF32
R_ARM_PRIVATE_1
R_ARM_THM_TLS_MOVT_TPOFF32
R_ARM_PRIVATE_2
R_ARM_THM_TLS_MOVT_TPOFF32
R_ARM_PRIVATE_3
R_ARM_PRIVATE_4
R_ARM_PRIVATE_5
R_ARM_PRIVATE_6
R_ARM_PRIVATE_7
R_ARM_PRIVATE_8
R_ARM_PRIVATE_9
R_ARM_PRIVATE_10
R_ARM_PRIVATE_11
R_ARM_PRIVATE_12
R_ARM_PRIVATE_13
R_ARM_PRIVATE_14
R_ARM_PRIVATE_15
R_ARM_ME_TOO
R_ARM_THM_TLS_DESCSEQ16
R_ARM_THM_TLS_DESCSEQ32
ifndef
R_AARCH64_ABS64
define
R_AARCH64_ABS64
endif
ifndef
R_AARCH64_ABS32
define
R_AARCH64_ABS32
endif
endif
DWARF_RELOC_ARM_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_MIPS_H
define
DWARF_RELOC_MIPS_H
Definitions
for
MIPS
define
DWARF_RELOC_MIPS
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
Relocation
types
for
MIPS
define
R_MIPS_NONE
define
R_MIPS_16
define
R_MIPS_32
define
R_MIPS_ADD
R_MIPS_32
define
R_MIPS_REL
define
R_MIPS_REL32
R_MIPS_REL
define
R_MIPS_26
define
R_MIPS_HI16
define
R_MIPS_LO16
define
R_MIPS_GPREL
define
R_MIPS_GPREL16
R_MIPS_GPREL
define
R_MIPS_LITERAL
define
R_MIPS_GOT
define
R_MIPS_GOT16
R_MIPS_GOT
define
R_MIPS_PC16
define
R_MIPS_CALL
define
R_MIPS_CALL16
R_MIPS_CALL
define
R_MIPS_GPREL32
define
R_MIPS_UNUSED1
define
R_MIPS_UNUSED2
define
R_MIPS_UNUSED3
define
R_MIPS_SHIFT5
define
R_MIPS_SHIFT6
define
R_MIPS_64
define
R_MIPS_GOT_DISP
define
R_MIPS_GOT_PAGE
define
R_MIPS_GOT_OFST
define
R_MIPS_GOT_HI16
define
R_MIPS_GOT_LO16
define
R_MIPS_SUB
define
R_MIPS_INSERT_A
define
R_MIPS_INSERT_B
define
R_MIPS_DELETE
define
R_MIPS_HIGHER
define
R_MIPS_HIGHEST
define
R_MIPS_CALL_HI16
define
R_MIPS_CALL_LO16
define
R_MIPS_SCN_DISP
define
R_MIPS_REL16
define
R_MIPS_ADD_IMMEDIATE
Keep
this
the
last
entry
define
R_MIPS_NUM
endif
_WIN32
Relocation
types
for
MIPS
static
const
char
reloc_type_names_MIPS
R_MIPS_NONE
R_MIPS_16
R_MIPS_32
R_MIPS_REL32
R_MIPS_26
R_MIPS_HI16
R_MIPS_LO16
R_MIPS_GPREL16
R_MIPS_LITERAL
R_MIPS_GOT16
R_MIPS_PC16
R_MIPS_CALL16
R_MIPS_GPREL32
R_MIPS_UNUSED1
R_MIPS_UNUSED2
R_MIPS_UNUSED3
R_MIPS_SHIFT5
R_MIPS_SHIFT6
R_MIPS_64
R_MIPS_GOT_DISP
R_MIPS_GOT_PAGE
R_MIPS_GOT_OFST
R_MIPS_GOT_HI16
R_MIPS_GOT_LO16
R_MIPS_SUB
R_MIPS_INSERT_A
R_MIPS_INSERT_B
R_MIPS_DELETE
R_MIPS_HIGHER
R_MIPS_HIGHEST
R_MIPS_CALL_HI16
R_MIPS_CALL_LO16
R_MIPS_SCN_DISP
R_MIPS_REL16
R_MIPS_ADD_IMMEDIATE
endif
DWARF_RELOC_MIPS_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_PPC_H
define
DWARF_RELOC_PPC_H
Definitions
for
PPC
define
DWARF_RELOC_PPC
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
PowerPC
relocations
defined
by
the
ABIs
define
R_PPC_NONE
define
R_PPC_ADDR32
absolute
address
define
R_PPC_ADDR24
address
bits
ignored
define
R_PPC_ADDR16
absolute
address
define
R_PPC_ADDR16_LO
lower
of
absolute
address
define
R_PPC_ADDR16_HI
high
of
absolute
address
define
R_PPC_ADDR16_HA
adjusted
high
define
R_PPC_ADDR14
address
bits
ignored
define
R_PPC_ADDR14_BRTAKEN
define
R_PPC_ADDR14_BRNTAKEN
define
R_PPC_REL24
PC
relative
bit
define
R_PPC_REL14
PC
relative
bit
define
R_PPC_REL14_BRTAKEN
define
R_PPC_REL14_BRNTAKEN
define
R_PPC_GOT16
define
R_PPC_GOT16_LO
define
R_PPC_GOT16_HI
define
R_PPC_GOT16_HA
define
R_PPC_PLTREL24
define
R_PPC_COPY
define
R_PPC_GLOB_DAT
define
R_PPC_JMP_SLOT
define
R_PPC_RELATIVE
define
R_PPC_LOCAL24PC
define
R_PPC_UADDR32
define
R_PPC_UADDR16
define
R_PPC_REL32
define
R_PPC_PLT32
define
R_PPC_PLTREL32
define
R_PPC_PLT16_LO
define
R_PPC_PLT16_HI
define
R_PPC_PLT16_HA
define
R_PPC_SDAREL16
define
R_PPC_SECTOFF
define
R_PPC_SECTOFF_LO
define
R_PPC_SECTOFF_HI
define
R_PPC_SECTOFF_HA
Unused
types
define
R_PPC_37
define
R_PPC_38
define
R_PPC_39
define
R_PPC_40
define
R_PPC_41
define
R_PPC_42
define
R_PPC_43
define
R_PPC_44
define
R_PPC_45
define
R_PPC_46
define
R_PPC_47
define
R_PPC_48
define
R_PPC_49
define
R_PPC_50
define
R_PPC_51
define
R_PPC_52
define
R_PPC_53
define
R_PPC_54
define
R_PPC_55
Unused
types
define
R_PPC_56
define
R_PPC_57
define
R_PPC_58
define
R_PPC_59
define
R_PPC_60
define
R_PPC_61
define
R_PPC_62
define
R_PPC_63
define
R_PPC_64
define
R_PPC_65
define
R_PPC_66
PowerPC
relocations
defined
for
the
TLS
access
ABI
define
R_PPC_TLS
none
sym
add
define
R_PPC_DTPMOD32
word32
sym
add
define
R_PPC_TPREL16
half16
sym
add
define
R_PPC_TPREL16_LO
half16
sym
add
define
R_PPC_TPREL16_HI
half16
sym
add
define
R_PPC_TPREL16_HA
half16
sym
add
define
R_PPC_TPREL32
word32
sym
add
define
R_PPC_DTPREL16
half16
sym
add
define
R_PPC_DTPREL16_LO
half16
sym
add
define
R_PPC_DTPREL16_HI
half16
sym
add
define
R_PPC_DTPREL16_HA
half16
sym
add
define
R_PPC_DTPREL32
word32
sym
add
define
R_PPC_GOT_TLSGD16
half16
sym
add
define
R_PPC_GOT_TLSGD16_LO
half16
sym
add
define
R_PPC_GOT_TLSGD16_HI
half16
sym
add
define
R_PPC_GOT_TLSGD16_HA
half16
sym
add
define
R_PPC_GOT_TLSLD16
half16
sym
add
define
R_PPC_GOT_TLSLD16_LO
half16
sym
add
define
R_PPC_GOT_TLSLD16_HI
half16
sym
add
define
R_PPC_GOT_TLSLD16_HA
half16
sym
add
define
R_PPC_GOT_TPREL16
half16
sym
add
define
R_PPC_GOT_TPREL16_LO
half16
sym
add
define
R_PPC_GOT_TPREL16_HI
half16
sym
add
define
R_PPC_GOT_TPREL16_HA
half16
sym
add
define
R_PPC_GOT_DTPREL16
half16
sym
add
define
R_PPC_GOT_DTPREL16_LO
half16
sym
add
define
R_PPC_GOT_DTPREL16_HI
half16
sym
add
define
R_PPC_GOT_DTPREL16_HA
half16
sym
add
Keep
this
the
last
entry
define
R_PPC_NUM
endif
_WIN32
PowerPC
relocations
defined
by
the
ABIs
static
const
char
reloc_type_names_PPC
R_PPC_NONE
R_PPC_ADDR32
R_PPC_ADDR24
R_PPC_ADDR16
R_PPC_ADDR16_LO
R_PPC_ADDR16_HI
R_PPC_ADDR16_HA
R_PPC_ADDR14
R_PPC_ADDR14_BRTAKEN
R_PPC_ADDR14_BRNTAKEN
R_PPC_REL24
R_PPC_REL14
R_PPC_REL14_BRTAKEN
R_PPC_REL14_BRNTAKEN
R_PPC_GOT16
R_PPC_GOT16_LO
R_PPC_GOT16_HI
R_PPC_GOT16_HA
R_PPC_PLTREL24
R_PPC_COPY
R_PPC_GLOB_DAT
R_PPC_JMP_SLOT
R_PPC_RELATIVE
R_PPC_LOCAL24PC
R_PPC_UADDR32
R_PPC_UADDR16
R_PPC_REL32
R_PPC_PLT32
R_PPC_PLTREL32
R_PPC_PLT16_LO
R_PPC_PLT16_HI
R_PPC_PLT16_HA
R_PPC_SDAREL16
R_PPC_SECTOFF
R_PPC_SECTOFF_LO
R_PPC_SECTOFF_HI
R_PPC_SECTOFF_HA
R_PPC_37
R_PPC_38
R_PPC_39
R_PPC_40
R_PPC_41
R_PPC_42
R_PPC_43
R_PPC_44
R_PPC_45
R_PPC_46
R_PPC_47
R_PPC_48
R_PPC_49
R_PPC_50
R_PPC_51
R_PPC_52
R_PPC_53
R_PPC_54
R_PPC_55
R_PPC_56
R_PPC_57
R_PPC_58
R_PPC_59
R_PPC_60
R_PPC_61
R_PPC_62
R_PPC_63
R_PPC_64
R_PPC_65
R_PPC_66
R_PPC_TLS
R_PPC_DTPMOD32
R_PPC_TPREL16
R_PPC_TPREL16_LO
R_PPC_TPREL16_HI
R_PPC_TPREL16_HA
R_PPC_TPREL32
R_PPC_DTPREL16
R_PPC_DTPREL16_LO
R_PPC_DTPREL16_HI
R_PPC_DTPREL16_HA
R_PPC_DTPREL64
R_PPC_GOT_TLSGD16
R_PPC_GOT_TLSGD16_LO
R_PPC_GOT_TLSGD16_HI
R_PPC_GOT_TLSGD16_HA
R_PPC_GOT_TLSLD16
R_PPC_GOT_TLSLD16_LO
R_PPC_GOT_TLSLD16_HI
R_PPC_GOT_TLSLD16_HA
R_PPC_GOT_TPREL16_DS
R_PPC_GOT_TPREL16_LO
R_PPC_GOT_TPREL16_HI
R_PPC_GOT_TPREL16_HA
R_PPC_GOT_DTPREL16
R_PPC_GOT_DTPREL16_LO
R_PPC_GOT_DTPREL16_HI
R_PPC_GOT_DTPREL16_HA
endif
DWARF_RELOC_PPC_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_PPC64_H
define
DWARF_RELOC_PPC64_H
Definitions
for
PPC64
define
DWARF_RELOC_PPC64
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
include
dwarf_reloc_ppc
h
PowerPC64
relocations
defined
by
the
ABIs
define
R_PPC64_NONE
R_PPC_NONE
define
R_PPC64_ADDR32
R_PPC_ADDR32
absolute
address
define
R_PPC64_ADDR24
R_PPC_ADDR24
address
word
aligned
define
R_PPC64_ADDR16
R_PPC_ADDR16
absolute
address
lower
of
abs
address
define
R_PPC64_ADDR16_LO
R_PPC_ADDR16_LO
high
of
abs
address
define
R_PPC64_ADDR16_HI
R_PPC_ADDR16_HI
define
R_PPC64_ADDR16_HA
R_PPC_ADDR16_HA
adjusted
high
define
R_PPC64_ADDR14
R_PPC_ADDR14
address
word
aligned
define
R_PPC64_ADDR14_BRTAKEN
R_PPC_ADDR14_BRTAKEN
define
R_PPC64_ADDR14_BRNTAKEN
R_PPC_ADDR14_BRNTAKEN
define
R_PPC64_REL24
R_PPC_REL24
PC
relative
bit
word
aligned
define
R_PPC64_REL14
R_PPC_REL14
PC
relative
bit
define
R_PPC64_REL14_BRTAKEN
R_PPC_REL14_BRTAKEN
define
R_PPC64_REL14_BRNTAKEN
R_PPC_REL14_BRNTAKEN
define
R_PPC64_GOT16
R_PPC_GOT16
define
R_PPC64_GOT16_LO
R_PPC_GOT16_LO
define
R_PPC64_GOT16_HI
R_PPC_GOT16_HI
define
R_PPC64_GOT16_HA
R_PPC_GOT16_HA
define
R_PPC64_COPY
R_PPC_COPY
define
R_PPC64_GLOB_DAT
R_PPC_GLOB_DAT
define
R_PPC64_JMP_SLOT
R_PPC_JMP_SLOT
define
R_PPC64_RELATIVE
R_PPC_RELATIVE
define
R_PPC64_UADDR32
R_PPC_UADDR32
define
R_PPC64_UADDR16
R_PPC_UADDR16
define
R_PPC64_REL32
R_PPC_REL32
define
R_PPC64_PLT32
R_PPC_PLT32
define
R_PPC64_PLTREL32
R_PPC_PLTREL32
define
R_PPC64_PLT16_LO
R_PPC_PLT16_LO
define
R_PPC64_PLT16_HI
R_PPC_PLT16_HI
define
R_PPC64_PLT16_HA
R_PPC_PLT16_HA
define
R_PPC64_SECTOFF
R_PPC_SECTOFF
define
R_PPC64_SECTOFF_LO
R_PPC_SECTOFF_LO
define
R_PPC64_SECTOFF_HI
R_PPC_SECTOFF_HI
define
R_PPC64_SECTOFF_HA
R_PPC_SECTOFF_HA
define
R_PPC64_ADDR30
word30
S
A
P
define
R_PPC64_ADDR64
doubleword64
S
A
define
R_PPC64_ADDR16_HIGHER
half16
higher
S
A
define
R_PPC64_ADDR16_HIGHERA
half16
highera
S
A
define
R_PPC64_ADDR16_HIGHEST
half16
highest
S
A
define
R_PPC64_ADDR16_HIGHESTA
half16
highesta
S
A
define
R_PPC64_UADDR64
doubleword64
S
A
define
R_PPC64_REL64
doubleword64
S
A
P
define
R_PPC64_PLT64
doubleword64
L
A
define
R_PPC64_PLTREL64
doubleword64
L
A
P
define
R_PPC64_TOC16
half16
S
A
TOC
define
R_PPC64_TOC16_LO
half16
lo
S
A
TOC
define
R_PPC64_TOC16_HI
half16
hi
S
A
TOC
define
R_PPC64_TOC16_HA
half16
ha
S
A
TOC
define
R_PPC64_TOC
doubleword64
TOC
define
R_PPC64_PLTGOT16
half16
M
A
define
R_PPC64_PLTGOT16_LO
half16
lo
M
A
define
R_PPC64_PLTGOT16_HI
half16
hi
M
A
define
R_PPC64_PLTGOT16_HA
half16
ha
M
A
define
R_PPC64_ADDR16_DS
half16ds
S
A
define
R_PPC64_ADDR16_LO_DS
half16ds
lo
S
A
define
R_PPC64_GOT16_DS
half16ds
G
A
define
R_PPC64_GOT16_LO_DS
half16ds
lo
G
A
define
R_PPC64_PLT16_LO_DS
half16ds
lo
L
A
define
R_PPC64_SECTOFF_DS
half16ds
R
A
define
R_PPC64_SECTOFF_LO_DS
half16ds
lo
R
A
define
R_PPC64_TOC16_DS
half16ds
S
A
TOC
define
R_PPC64_TOC16_LO_DS
half16ds
lo
S
A
TOC
define
R_PPC64_PLTGOT16_DS
half16ds
M
A
define
R_PPC64_PLTGOT16_LO_DS
half16ds
lo
M
A
PowerPC64
relocations
defined
for
the
TLS
access
ABI
define
R_PPC64_TLS
none
sym
add
define
R_PPC64_DTPMOD64
doubleword64
sym
add
define
R_PPC64_TPREL16
half16
sym
add
define
R_PPC64_TPREL16_LO
half16
sym
add
define
R_PPC64_TPREL16_HI
half16
sym
add
define
R_PPC64_TPREL16_HA
half16
sym
add
define
R_PPC64_TPREL64
doubleword64
sym
add
define
R_PPC64_DTPREL16
half16
sym
add
define
R_PPC64_DTPREL16_LO
half16
sym
add
define
R_PPC64_DTPREL16_HI
half16
sym
add
define
R_PPC64_DTPREL16_HA
half16
sym
add
define
R_PPC64_DTPREL64
doubleword64
sym
add
define
R_PPC64_GOT_TLSGD16
half16
sym
add
define
R_PPC64_GOT_TLSGD16_LO
half16
sym
add
define
R_PPC64_GOT_TLSGD16_HI
half16
sym
add
define
R_PPC64_GOT_TLSGD16_HA
half16
sym
add
define
R_PPC64_GOT_TLSLD16
half16
sym
add
define
R_PPC64_GOT_TLSLD16_LO
half16
sym
add
define
R_PPC64_GOT_TLSLD16_HI
half16
sym
add
define
R_PPC64_GOT_TLSLD16_HA
half16
sym
add
define
R_PPC64_GOT_TPREL16_DS
half16ds
sym
add
half16ds
sym
add
define
R_PPC64_GOT_TPREL16_LO_DS
define
R_PPC64_GOT_TPREL16_HI
half16
sym
add
define
R_PPC64_GOT_TPREL16_HA
half16
sym
add
define
R_PPC64_GOT_DTPREL16_DS
half16ds
sym
add
half16ds
sym
add
define
R_PPC64_GOT_DTPREL16_LO_DS
define
R_PPC64_GOT_DTPREL16_HI
half16
sym
add
define
R_PPC64_GOT_DTPREL16_HA
half16
sym
add
define
R_PPC64_TPREL16_DS
half16ds
sym
add
define
R_PPC64_TPREL16_LO_DS
half16ds
sym
add
define
R_PPC64_TPREL16_HIGHER
half16
sym
add
define
R_PPC64_TPREL16_HIGHERA
half16
sym
add
define
R_PPC64_TPREL16_HIGHEST
half16
sym
add
half16
sym
add
define
R_PPC64_TPREL16_HIGHESTA
define
R_PPC64_DTPREL16_DS
half16ds
sym
add
define
R_PPC64_DTPREL16_LO_DS
half16ds
sym
add
half16
sym
add
define
R_PPC64_DTPREL16_HIGHER
half16
sym
add
define
R_PPC64_DTPREL16_HIGHERA
half16
sym
add
define
R_PPC64_DTPREL16_HIGHEST
half16
sym
add
define
R_PPC64_DTPREL16_HIGHESTA
Additional
relocation
types
define
R_PPC64_TOC32
define
R_PPC64_DTPMOD32
define
R_PPC64_TPREL32
define
R_PPC64_DTPREL32
Keep
this
the
last
entry
define
R_PPC64_NUM
endif
_WIN32
PowerPC64
relocations
defined
by
the
ABIs
static
const
char
reloc_type_names_PPC64
R_PPC64_NONE
R_PPC64_ADDR32
R_PPC64_ADDR24
R_PPC64_ADDR16
R_PPC64_ADDR16_LO
R_PPC64_ADDR16_HI
R_PPC64_ADDR16_HA
R_PPC64_ADDR14
R_PPC64_ADDR14_BRTAKEN
R_PPC64_ADDR14_BRNTAKEN
R_PPC64_REL24
R_PPC64_REL14
R_PPC64_REL14_BRTAKEN
R_PPC64_REL14_BRNTAKEN
R_PPC64_GOT16
R_PPC64_GOT16_LO
R_PPC64_GOT16_HI
R_PPC64_GOT16_HA
R_PPC64_PLTREL24
R_PPC64_COPY
R_PPC64_GLOB_DAT
R_PPC64_JMP_SLOT
R_PPC64_RELATIVE
R_PPC64_LOCAL24PC
R_PPC64_UADDR32
R_PPC64_UADDR16
R_PPC64_REL32
R_PPC64_PLT32
R_PPC64_PLTREL32
R_PPC64_PLT16_LO
R_PPC64_PLT16_HI
R_PPC64_PLT16_HA
R_PPC64_SDAREL16
R_PPC64_SECTOFF
R_PPC64_SECTOFF_LO
R_PPC64_SECTOFF_HI
R_PPC64_SECTOFF_HA
R_PPC64_REL30
R_PPC64_ADDR64
R_PPC64_ADDR16_HIGHER
R_PPC64_ADDR16_HIGHERA
R_PPC64_ADDR16_HIGHEST
R_PPC64_ADDR16_HIGHESTA
R_PPC64_UADDR64
R_PPC64_REL64
R_PPC64_PLT64
R_PPC64_PLTREL64
R_PPC64_TOC16
R_PPC64_TOC16_LO
R_PPC64_TOC16_HI
R_PPC64_TOC16_HA
R_PPC64_TOC
R_PPC64_PLTGOT16
R_PPC64_PLTGOT16_LO
R_PPC64_PLTGOT16_HI
R_PPC64_PLTGOT16_HA
R_PPC64_ADDR16_DS
R_PPC64_ADDR16_LO_DS
R_PPC64_GOT16_DS
R_PPC64_GOT16_LO_DS
R_PPC64_PLT16_LO_DS
R_PPC64_SECTOFF_DS
R_PPC64_SECTOFF_LO_DS
R_PPC64_TOC16_DS
R_PPC64_TOC16_LO_DS
R_PPC64_PLTGOT16_DS
R_PPC64_PLTGOT16_LO_DS
R_PPC64_TLS
R_PPC64_DTPMOD32
R_PPC64_TPREL16
R_PPC64_TPREL16_LO
R_PPC64_TPREL16_HI
R_PPC64_TPREL16_HA
R_PPC64_TPREL32
R_PPC64_DTPREL16
R_PPC64_DTPREL16_LO
R_PPC64_DTPREL16_HI
R_PPC64_DTPREL16_HA
R_PPC64_DTPREL64
R_PPC64_GOT_TLSGD16
R_PPC64_GOT_TLSGD16_LO
R_PPC64_GOT_TLSGD16_HI
R_PPC64_GOT_TLSGD16_HA
R_PPC64_GOT_TLSLD16
R_PPC64_GOT_TLSLD16_LO
R_PPC64_GOT_TLSLD16_HI
R_PPC64_GOT_TLSLD16_HA
R_PPC64_GOT_TPREL16_DS
R_PPC64_GOT_TPREL16_LO
R_PPC64_GOT_TPREL16_HI
R_PPC64_GOT_TPREL16_HA
R_PPC64_GOT_DTPREL16
R_PPC64_GOT_DTPREL16_LO
R_PPC64_GOT_DTPREL16_HI
R_PPC64_GOT_DTPREL16_HA
R_PPC64_TPREL16_DS
R_PPC64_TPREL16_LO_DS
R_PPC64_TPREL16_HIGHER
R_PPC64_TPREL16_HIGHERA
R_PPC64_TPREL16_HIGHEST
R_PPC64_TPREL16_HIGHESTA
R_PPC64_DTPREL16_DS
R_PPC64_DTPREL16_LO_DS
R_PPC64_DTPREL16_HIGHER
R_PPC64_DTPREL16_HIGHERA
R_PPC64_DTPREL16_HIGHEST
R_PPC64_DTPREL16_HIGHESTA
R_PPC64_TOC32
R_PPC64_DTPMOD32
R_PPC64_TPREL32
R_PPC64_DTPREL32
endif
DWARF_RELOC_PPC64_H
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
ifndef
DWARF_RELOC_X86_64_H
define
DWARF_RELOC_X86_64_H
Definitions
for
X86_64
define
DWARF_RELOC_X86_64
Include
the
definitions
only
in
the
case
of
Windows
ifdef
_WIN32
Relocation
types
for
AMD
x86
architecture
define
R_X86_64_NONE
No
reloc
define
R_X86_64_64
Direct
bit
define
R_X86_64_PC32
PC
relative
bit
signed
define
R_X86_64_GOT32
bit
GOT
entry
define
R_X86_64_PLT32
bit
PLT
address
define
R_X86_64_COPY
Copy
symbol
at
runtime
define
R_X86_64_GLOB_DAT
Create
GOT
entry
define
R_X86_64_JUMP_SLOT
Create
PLT
entry
define
R_X86_64_RELATIVE
Adjust
by
program
base
define
R_X86_64_GOTPCREL
bit
signed
pc
relative
to
GOT
define
R_X86_64_32
Direct
bit
zero
extended
define
R_X86_64_32S
Direct
bit
sign
extended
define
R_X86_64_16
Direct
bit
zero
extended
define
R_X86_64_PC16
bit
sign
extended
pc
relative
define
R_X86_64_8
Direct
bit
sign
extended
define
R_X86_64_PC8
bit
sign
extended
pc
relative
define
R_X86_64_DTPMOD64
ID
of
module
containing
symbol
define
R_X86_64_DTPOFF64
Offset
in
module
s
TLS
block
define
R_X86_64_TPOFF64
Offset
in
initial
TLS
block
define
R_X86_64_TLSGD
bit
signed
PC
relative
offset
to
two
GOT
entries
for
GD
symbol
define
R_X86_64_TLSLD
bit
signed
PC
relative
offset
to
two
GOT
entries
for
LD
symbol
define
R_X86_64_DTPOFF32
Offset
in
TLS
block
define
R_X86_64_GOTTPOFF
bit
signed
PC
relative
offset
to
GOT
entry
for
IE
symbol
define
R_X86_64_TPOFF32
Offset
in
initial
TLS
block
define
R_X86_64_PC64
PC
relative
bit
define
R_X86_64_GOTOFF64
bit
offset
to
GOT
define
R_X86_64_GOTPC32
bit
signed
pc
relative
to
GOT
define
R_X86_64_GOT64
bit
GOT
entry
offset
define
R_X86_64_GOTPCREL64
bit
PC
relative
GOT
entry
define
R_X86_64_GOTPC64
bit
PC
relative
offset
to
GOT
define
R_X86_64_GOTPLT64
like
GOT64
says
PLT
entry
needed
bit
GOT
relative
offset
to
PLT
entry
define
R_X86_64_PLTOFF64
define
R_X86_64_SIZE32
Size
of
symbol
plus
bit
addend
define
R_X86_64_SIZE64
Size
of
symbol
plus
bit
addend
GOT
offset
for
TLS
descriptor
define
R_X86_64_GOTPC32_TLSDESC
define
R_X86_64_TLSDESC_CALL
For
for
call
thru
TLS
descriptor
define
R_X86_64_TLSDESC
TLS
descriptor
define
R_X86_64_IRELATIVE
Adjust
indirectly
by
program
base
define
R_X86_64_RELATIVE64
adjust
by
program
base
Keep
this
the
last
entry
define
R_X86_64_NUM
endif
_WIN32
Relocation
types
for
X86_64
static
const
char
reloc_type_names_X86_64
R_X86_64_NONE
R_X86_64_64
R_X86_64_PC32
R_X86_64_GOT32
R_X86_64_PLT32
R_X86_64_COPY
R_X86_64_GLOB_DAT
R_X86_64_JUMP_SLOT
R_X86_64_RELATIVE
R_X86_64_GOTPCREL
R_X86_64_32
R_X86_64_32S
R_X86_64_16
R_X86_64_PC16
R_X86_64_8
R_X86_64_PC8
R_X86_64_DTPMOD64
R_X86_64_DTPOFF64
R_X86_64_TPOFF64
R_X86_64_TLSGD
R_X86_64_TLSLD
R_X86_64_DTPOFF32
R_X86_64_GOTTPOFF
R_X86_64_TPOFF32
R_X86_64_PC64
R_X86_64_GOTOFF64
R_X86_64_GOTPC32
R_X86_64_GOT64
R_X86_64_GOTPCREL64
R_X86_64_GOTPC64
R_X86_64_GOTPLT64
R_X86_64_PLTOFF64
R_X86_64_SIZE32
R_X86_64_SIZE64
R_X86_64_GOTPC32_TLSDESC
R_X86_64_TLSDESC_CALL
R_X86_64_TLSDESC
R_X86_64_IRELATIVE
R_X86_64_RELATIVE64
endif
DWARF_RELOC_X86_64_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
DWARF_RNGLISTS_H
define
DWARF_RNGLISTS_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Rangelists
header
for
a
CU
The
type
is
never
visible
to
libdwarf
callers
struct
Dwarf_Rnglists_Context_s
Dwarf_Debug
rc_dbg
Dwarf_Unsigned
rc_index
An
index
assigned
by
libdwarf
to
each
rnglists
context
Starting
with
zero
at
the
zero
offset
in
debug_rnglists
Offset
of
the
debug_rnglists
header
involved
Dwarf_Unsigned
rc_header_offset
Dwarf_Unsigned
rc_length
Many
places
in
in
libdwarf
this
is
called
length_size
Dwarf_Small
rc_offset_size
rc_extension_size
is
zero
unless
this
is
standard
DWARF3
and
later
dwarf
using
the
extension
mechanism
DWARF3
and
later
rc_extension_size
is
DWARF2
MIPS
IRIX
rc_extension_size
is
zero
DWARF
rc_extension_size
is
zero
Dwarf_Small
rc_extension_size
unsigned
rc_version
Dwarf_Small
rc_address_size
Dwarf_Small
rc_segment_selector_size
Dwarf_Unsigned
rc_offset_entry_count
offset
in
the
section
of
the
offset
entries
Dwarf_Unsigned
rc_offsets_off_in_sect
Do
not
free
Points
into
section
memory
Dwarf_Small
rc_offsets_array
Offset
in
the
debug_rnglists
section
of
the
first
rangelist
in
the
set
of
rangelists
for
the
CU
Dwarf_Unsigned
rc_first_rnglist_offset
Dwarf_Unsigned
rc_past_last_rnglist_offset
pointer
to
byte
of
rangelist
header
Dwarf_Small
rc_rnglists_header
pointer
to
first
byte
of
the
rnglist
data
for
rnglist
involved
Do
not
free
Dwarf_Small
rc_startaddr
pointer
one
past
end
of
the
rnglist
data
Dwarf_Small
rc_endaddr
typedef
struct
Dwarf_Rnglists_Entry_s
Dwarf_Rnglists_Entry
struct
Dwarf_Rnglists_Entry_s
unsigned
rle_entrylen
unsigned
rle_code
Failed
means
debug_addr
section
needed
but
missing
possibly
tied
file
needed
Dwarf_Bool
rle_index_failed
Dwarf_Unsigned
rle_raw1
Dwarf_Unsigned
rle_raw2
Cooked
means
the
raw
values
from
the
debug_rnglists
section
translated
to
DIE
specific
addresses
Dwarf_Unsigned
rle_cooked1
Dwarf_Unsigned
rle_cooked2
Dwarf_Rnglists_Entry
rle_next
struct
Dwarf_Rnglists_Head_s
Dwarf_Rnglists_Entry
rh_rnglists
rh_last
and
rh_first
used
during
build
up
Zero
when
array
rh_rnglists
built
Dwarf_Rnglists_Entry
rh_first
Dwarf_Rnglists_Entry
rh_last
Dwarf_Unsigned
rh_count
Dwarf_Unsigned
rh_bytes_total
A
global
Rnglists
Context
Dwarf_CU_Context
rh_context
Dwarf_Debug
rh_dbg
Dwarf_Rnglists_Context
rh_localcontext
Dwarf_Unsigned
rh_version
Dwarf_Unsigned
rh_index
Dwarf_Unsigned
rh_offset_size
Dwarf_Unsigned
rh_address_size
unsigned
rh_segment_selector_size
DW_AT_rnglists_base
Dwarf_Bool
rh_at_rnglists_base_present
Dwarf_Unsigned
rh_at_rnglists_base
DW_AT_low_pc
of
CU
or
zero
if
none
Dwarf_Bool
rh_cu_base_address_present
Dwarf_Unsigned
rh_cu_base_address
DW_AT_addr_base
so
we
can
use
debug_addr
if
such
is
needed
Dwarf_Bool
rh_cu_addr_base_present
Dwarf_Unsigned
rh_cu_addr_base
Dwarf_Small
rh_rlepointer
Dwarf_Unsigned
rh_rlearea_offset
Dwarf_Small
rh_end_data_area
int
_dwarf_internal_read_rnglists_header
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
sectionlength
Dwarf_Small
data
Dwarf_Small
end_data
Dwarf_Unsigned
offset
Dwarf_Rnglists_Context
buildhere
Dwarf_Unsigned
next_offset
Dwarf_Error
error
void
_dwarf_rnglists_head_destructor
void
m
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_RNGLISTS_H
ifndef
DWARF_STR_OFFSETS_H
define
DWARF_STR_OFFSETS_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
struct
Dwarf_Str_Offsets_Table_s
pointers
are
to
dwarf
memory
valid
till
Dwarf_Debug
is
closed
None
are
to
be
deallocated
Dwarf_Unsigned
so_magic_value
Dwarf_Debug
so_dbg
Section
data
Dwarf_Small
so_section_start_ptr
Dwarf_Small
so_section_end_ptr
Dwarf_Unsigned
so_section_size
Overall
data
about
wasted
space
in
the
section
Dwarf_Unsigned
so_wasted_section_bytes
The
number
of
tables
processed
in
the
section
Dwarf_Unsigned
so_table_count
Used
to
iterate
through
the
section
getting
to
each
table
Dwarf_Unsigned
so_next_table_offset
Per
table
ie
a
table
is
a
header
and
array
of
offsets
inside
the
section
Dwarf_Small
so_header_ptr
Dwarf_Small
so_end_cu_ptr
Dwarf_Small
so_array_ptr
Dwarf_Unsigned
so_table_start_offset
Dwarf_Unsigned
so_array_start_offset
Dwarf_Unsigned
so_array_entry_count
Dwarf_Half
so_array_entry_size
int
_dwarf_trial_read_dwarf_five_hdr
Dwarf_Debug
dbg
Dwarf_Small
table_start_ptr
Dwarf_Unsigned
secsize
Dwarf_Small
secendptr
Dwarf_Unsigned
length_out
Dwarf_Half
local_offset_size_out
Dwarf_Half
local_extension_size_out
Dwarf_Half
version_out
Dwarf_Half
padding_out
Dwarf_Error
error
int
_dwarf_find_all_offsets_via_fission
Dwarf_Debug
dbg
Dwarf_CU_Context
cu_context
Dwarf_Error
error
endif
DWARF_STR_OFFSETS_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
define
HASHSEARCH
ifdef
HASHSEARCH
Only
needed
for
hash
based
search
in
a
tsearch
style
define
INITTREE
x
y
x
dwarf_initialize_search_hash
x
y
else
define
INITTREE
x
y
endif
HASHSEARCH
Contexts
are
in
a
list
in
a
dbg
and
do
not
move
once
established
So
saving
one
is
ok
as
long
as
the
dbg
exists
struct
Dwarf_Tied_Entry_s
Dwarf_Sig8
dt_key
Dwarf_CU_Context
dt_context
int
_dwarf_tied_compare_function
const
void
l
const
void
r
void
_dwarf_tied_make_entry
Dwarf_Sig8
key
Dwarf_CU_Context
val
DW_TSHASHTYPE
_dwarf_tied_data_hashfunc
const
void
keyp
ifndef
DWARF_TSEARCH_H
define
DWARF_TSEARCH_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
The
following
interfaces
follow
tsearch
See
the
Single
Unix
Specification
but
the
implementation
is
written
without
reference
to
the
source
code
of
any
version
of
tsearch
Only
uses
of
tsearch
were
examined
not
tsearch
source
code
See
https
www
prevanders
net
tsearch
html
and
https
www
prevanders
net
dwarf
html
tsearch
for
information
about
tsearch
We
are
matching
the
standard
functional
interface
here
but
to
avoid
interfering
with
libc
implementations
or
code
using
libc
implementations
we
change
all
the
names
configure
cmake
ensure
uintptr_t
defined
but
if
not
possibly
Duintptr_t
unsigned
long
might
help
ifndef
DW_TSHASHTYPE
define
DW_TSHASHTYPE
uintptr_t
endif
The
DW_VISIT
values
passed
back
to
you
through
the
callback
function
in
dwarf_twalk
typedef
enum
dwarf_preorder
dwarf_postorder
dwarf_endorder
dwarf_leaf
DW_VISIT
void
return
values
are
actually
void
key
so
you
must
dereference
these
once
to
get
a
key
you
passed
in
We
rename
these
so
there
is
no
conflict
with
another
version
of
the
tsearch
sources
such
as
is
used
in
dwarfdump
define
dwarf_tsearch
_dwarf_tsearch
define
dwarf_tfind
_dwarf_tfind
define
dwarf_tdelete
_dwarf_tdelete
define
dwarf_twalk
_dwarf_twalk
define
dwarf_tdestroy
_dwarf_tdestroy
define
dwarf_tdump
_dwarf_tdump
define
dwarf_initialize_search_hash
_dwarf_initialize_search_hash
void
dwarf_tsearch
const
void
key
void
rootp
int
compar
const
void
const
void
void
dwarf_tfind
const
void
key
void
const
rootp
int
compar
const
void
const
void
dwarf_tdelete
returns
NULL
if
it
cannot
delete
anything
or
if
the
tree
is
now
empty
if
empty
rootp
is
set
NULL
by
dwarf_tdelete
If
the
delete
succeeds
and
the
tree
is
non
empty
returns
a
pointer
to
the
parent
node
of
the
deleted
item
unless
the
deleted
item
was
at
the
root
in
which
case
the
returned
pointer
relates
to
the
new
root
void
dwarf_tdelete
const
void
key
void
rootp
int
compar
const
void
const
void
void
dwarf_twalk
const
void
root
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
dwarf_tdestroy
cannot
set
the
root
pointer
NULL
you
must
do
so
on
return
from
dwarf_tdestroy
void
dwarf_tdestroy
void
root
void
free_node
void
nodep
Prints
a
simple
tree
representation
to
stdout
For
debugging
void
dwarf_tdump
const
void
root
char
keyprint
const
void
const
char
msg
Returns
NULL
and
does
nothing
unless
the
implemenation
used
uses
a
hash
tree
void
dwarf_initialize_search_hash
void
treeptr
DW_TSHASHTYPE
hashfunc
const
void
key
unsigned
long
size_estimate
endif
DWARF_TSEARCH_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
typedef
struct
Dwarf_Type_Context_s
Dwarf_Type_Context
type
never
completed
see
dwarf_global
h
ifndef
DWARF_UTIL_H
define
DWARF_UTIL_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
dwarf_base_types
h
void
_dwarf_create_area_len_error
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Unsigned
targ
Dwarf_Unsigned
sectionlen
define
DECODE_LEB128_UWORD_CK
ptr
value
dbg
errptr
endptr
do
Dwarf_Unsigned
lu_leblen
Dwarf_Unsigned
lu_local
int
lu_res
lu_res
dwarf_decode_leb128
char
ptr
char
endptr
if
lu_res
DW_DLV_ERROR
_dwarf_error
dbg
errptr
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
value
lu_local
ptr
lu_leblen
while
define
DECODE_LEB128_UWORD_LEN_CK
ptr
value
leblen
dbg
errptr
endptr
do
Dwarf_Unsigned
lu_leblen
Dwarf_Unsigned
lu_local
int
lu_res
lu_res
dwarf_decode_leb128
char
ptr
char
endptr
if
lu_res
DW_DLV_ERROR
_dwarf_error
dbg
errptr
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
value
lu_local
ptr
lu_leblen
leblen
lu_leblen
while
Decodes
signed
leb128
encoded
numbers
Make
sure
ptr
is
a
pointer
to
a
byte
type
In
and
earlier
this
was
a
hand
inlined
version
of
dwarf_decode_leb128
which
did
not
work
correctly
if
Dwarf_Unsigned
was
bits
define
DECODE_LEB128_SWORD_CK
ptr
value
dbg
errptr
endptr
do
Dwarf_Unsigned
uleblen
Dwarf_Signed
local
int
lu_res
lu_res
dwarf_decode_signed_leb128
char
ptr
char
endptr
if
lu_res
DW_DLV_ERROR
_dwarf_error
dbg
errptr
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
value
local
ptr
uleblen
while
define
DECODE_LEB128_SWORD_LEN_CK
ptr
value
leblen
dbg
errptr
endptr
do
Dwarf_Unsigned
lu_leblen
Dwarf_Signed
lu_local
int
lu_res
lu_res
dwarf_decode_signed_leb128
char
ptr
char
endptr
if
lu_res
DW_DLV_ERROR
_dwarf_error
dbg
errptr
DW_DLE_LEB_IMPROPER
return
DW_DLV_ERROR
leblen
lu_leblen
value
lu_local
ptr
lu_leblen
while
Any
error
found
here
represents
a
bug
that
cannot
be
dealloc
d
as
the
caller
will
not
know
there
was
no
dbg
define
CHECK_DIE
die
error_ret_value
do
if
die
NULL
_dwarf_error
NULL
error
DW_DLE_DIE_NULL
return
error_ret_value
if
die
di_cu_context
NULL
_dwarf_error
NULL
error
DW_DLE_DIE_NO_CU_CONTEXT
return
error_ret_value
if
die
di_cu_context
cc_dbg
NULL
_dwarf_error
NULL
error
DW_DLE_DBG_NULL
return
error_ret_value
while
Reads
source
for
length
bytes
from
unaligned
addr
Avoids
any
constant
in
conditional
warnings
and
avoids
a
test
in
the
generated
code
for
non
const
cases
which
are
in
the
majority
Uses
a
temp
to
avoid
the
test
The
decl
here
should
avoid
any
problem
of
size
in
the
temp
This
code
is
ENDIAN
DEPENDENT
The
memcpy
args
are
the
endian
issue
Does
not
update
the
source
field
for
READ_UNALIGNED_CK
the
error
code
refers
to
host
endianness
typedef
Dwarf_Unsigned
BIGGEST_UINT
ifdef
WORDS_BIGENDIAN
define
READ_UNALIGNED_CK
dbg
dest
desttype
source
length
error
endptr
do
BIGGEST_UINT
_ltmp
Dwarf_Byte_Ptr
readend
source
length
if
readend
source
_dwarf_error_string
dbg
error
DW_DLE_READ_BIGENDIAN_ERROR
DW_DLE_READ_BIGENDIAN_ERROR
Read
would
start
past
the
end
of
section
return
DW_DLV_ERROR
if
readend
endptr
_dwarf_error_string
dbg
error
DW_DLE_READ_BIGENDIAN_ERROR
DW_DLE_READ_BIGENDIAN_ERROR
Read
would
end
past
the
end
of
section
return
DW_DLV_ERROR
dbg
de_copy_word
char
sizeof
_ltmp
length
source
length
dest
desttype
_ltmp
while
This
macro
sign
extends
a
variable
depending
on
the
length
It
fills
the
bytes
between
the
size
of
the
destination
and
the
length
with
appropriate
padding
This
code
is
ENDIAN
DEPENDENT
but
dependent
only
on
host
endianness
not
object
file
endianness
The
memcpy
args
are
the
issue
define
SIGN_EXTEND
dest
length
do
if
Dwarf_Sbyte
char
sizeof
dest
length
memcpy
char
xff
xff
xff
xff
xff
xff
xff
xff
sizeof
dest
length
while
else
LITTLE
ENDIAN
define
READ_UNALIGNED_CK
dbg
dest
desttype
source
length
error
endptr
do
BIGGEST_UINT
_ltmp
Dwarf_Byte_Ptr
readend
source
length
if
readend
source
_dwarf_error_string
dbg
error
DW_DLE_READ_LITTLEENDIAN_ERROR
DW_DLE_READ_LITTLEENDIAN_ERROR
Read
starts
past
the
end
of
section
return
DW_DLV_ERROR
if
readend
endptr
_dwarf_error_string
dbg
error
DW_DLE_READ_LITTLEENDIAN_ERROR
DW_DLE_READ_LITTLEENDIAN_ERROR
Read
would
end
past
the
end
of
section
return
DW_DLV_ERROR
dbg
de_copy_word
char
source
length
dest
desttype
_ltmp
while
This
macro
sign
extends
a
variable
depending
on
the
length
It
fills
the
bytes
between
the
size
of
the
destination
and
the
length
with
appropriate
padding
This
code
is
ENDIAN
DEPENDENT
but
dependent
only
on
host
endianness
not
object
file
endianness
The
memcpy
args
are
the
issue
define
SIGN_EXTEND
dest
length
do
if
Dwarf_Sbyte
char
length
memcpy
char
length
xff
xff
xff
xff
xff
xff
xff
xff
sizeof
dest
length
while
endif
LITTLE_ENDIAN
READ_AREA
LENGTH
reads
the
length
the
older
way
of
pure
or
bit
or
the
dwarf
v3
extension
way
It
reads
the
bits
from
where
rw_src_data_p
points
to
and
updates
the
rw_src_data_p
to
point
past
what
was
just
read
It
updates
w_length_size
to
the
size
of
an
offset
either
or
and
w_exten_size
set
unless
this
frame
has
the
DWARF3
and
later
extension
in
which
case
w_exten_size
is
set
to
r_dbg
is
just
the
current
dbg
pointer
w_target
is
the
output
length
field
r_targtype
is
the
output
type
Always
Dwarf_Unsigned
so
far
This
one
handles
the
v3
extension
and
and
SGI
MIPS
fixed
bit
via
the
dwarf_init
set
r_dbg
de_length_size
It
does
not
recognize
any
but
the
one
distinguished
value
the
only
one
with
defined
meaning
It
assumes
that
no
CU
will
have
a
length
length
or
xxxxxxxx
length
which
makes
possible
auto
detection
of
the
extension
This
depends
on
knowing
that
only
a
non
zero
length
is
legitimate
AFAICT
and
for
IRIX
non
standard
dwarf
that
the
first
bits
of
the
offset
will
be
zero
because
the
compiler
could
not
handle
a
truly
large
value
as
of
Jan
and
because
no
app
has
that
much
debug
info
anyway
at
least
not
in
the
IRIX
case
At
present
not
testing
for
elf
here
as
that
does
not
seem
necessary
none
of
the
length
seems
appropriate
unless
it
s
ident
EI_CLASS
ELFCLASS64
The
w_target
r_sectionlen
compare
is
done
without
adding
in
case
the
w_target
value
read
is
so
large
any
addition
would
overflow
A
basic
value
sanity
check
define
READ_AREA_LENGTH_CK
r_dbg
w_target
r_targtype
rw_src_data_p
w_length_size
w_exten_size
w_error
r_sectionlen
r_endptr
do
READ_UNALIGNED_CK
r_dbg
w_target
r_targtype
rw_src_data_p
ORIGINAL_DWARF_OFFSET_SIZE
w_error
r_endptr
if
w_target
DISTINGUISHED_VALUE
dwarf3
extension
w_length_size
DISTINGUISHED_VALUE_OFFSET_SIZE
rw_src_data_p
ORIGINAL_DWARF_OFFSET_SIZE
w_exten_size
ORIGINAL_DWARF_OFFSET_SIZE
READ_UNALIGNED_CK
r_dbg
w_target
r_targtype
rw_src_data_p
DISTINGUISHED_VALUE_OFFSET_SIZE
w_error
r_endptr
if
w_target
r_sectionlen
_dwarf_create_area_len_error
r_dbg
w_error
w_target
r_sectionlen
return
DW_DLV_ERROR
rw_src_data_p
DISTINGUISHED_VALUE_OFFSET_SIZE
else
if
w_target
r_dbg
de_big_endian_object
Might
be
IRIX
We
have
to
distinguish
between
bit
DWARF
format
and
IRIX
bit
DWARF
format
if
r_dbg
de_length_size
IRIX
bit
big
endian
This
test
is
not
a
truly
precise
test
a
precise
test
would
check
if
the
target
was
IRIX
READ_UNALIGNED_CK
r_dbg
w_target
r_targtype
rw_src_data_p
DISTINGUISHED_VALUE_OFFSET_SIZE
w_error
r_endptr
if
w_target
r_sectionlen
_dwarf_create_area_len_error
r_dbg
w_error
w_target
r_sectionlen
return
DW_DLV_ERROR
w_length_size
DISTINGUISHED_VALUE_OFFSET_SIZE
rw_src_data_p
DISTINGUISHED_VALUE_OFFSET_SIZE
w_exten_size
else
bit
big
endian
w_length_size
ORIGINAL_DWARF_OFFSET_SIZE
rw_src_data_p
w_length_size
w_exten_size
else
if
w_target
r_sectionlen
_dwarf_create_area_len_error
r_dbg
w_error
w_target
r_sectionlen
return
DW_DLV_ERROR
Standard
bit
dwarf2
dwarf3
w_exten_size
w_length_size
ORIGINAL_DWARF_OFFSET_SIZE
rw_src_data_p
w_length_size
while
int
_dwarf_format_TAG_err_msg
Dwarf_Debug
dbg
Dwarf_Unsigned
tag
const
char
m
Dwarf_Error
error
int
_dwarf_get_size_of_val
Dwarf_Debug
dbg
Dwarf_Unsigned
form
Dwarf_Half
cu_version
Dwarf_Half
address_size
Dwarf_Small
val_ptr
int
v_length_size
Dwarf_Unsigned
size_out
Dwarf_Small
section_end_ptr
Dwarf_Error
error
struct
Dwarf_Hash_Table_Entry_s
This
single
struct
is
the
base
for
the
hash
table
The
intent
is
that
once
the
total_abbrev_count
across
all
the
entries
is
greater
than
current_table_entry_count
one
should
build
a
new
Dwarf_Hash_Table_Base_s
rehash
all
the
existing
entries
and
delete
the
old
table
and
entries
is
a
heuristic
nothing
magic
about
it
but
once
the
count
gets
to
or
times
current_table_entry_count
things
really
slow
down
a
lot
One
application
had
abbreviations
in
one
compilation
unit
The
incoming
code
is
an
abbrev
number
and
those
simply
increase
linearly
so
the
hashing
is
perfect
always
struct
Dwarf_Hash_Table_s
unsigned
long
tb_table_entry_count
unsigned
long
tb_total_abbrev_count
Each
table
entry
is
a
list
of
abbreviations
struct
Dwarf_Hash_Table_Entry_s
tb_entries
This
struct
is
used
to
build
a
hash
table
for
the
abbreviation
codes
for
a
compile
unit
struct
Dwarf_Hash_Table_Entry_s
Dwarf_Abbrev_List
at_head
int
_dwarf_get_abbrev_for_code
Dwarf_CU_Context
cu_context
Dwarf_Unsigned
code
Dwarf_Abbrev_List
list_out
Dwarf_Unsigned
highest_known_code
Dwarf_Error
error
return
if
string
ends
before
endptr
else
return
meaning
string
is
not
properly
terminated
Presumption
is
the
endptr
pts
to
end
of
some
dwarf
section
data
int
_dwarf_check_string_valid
Dwarf_Debug
dbg
void
areaptr
void
startptr
void
endptr
int
suggested_error
Dwarf_Error
error
int
_dwarf_length_of_cu_header
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Bool
is_info
Dwarf_Unsigned
area_length_out
Dwarf_Error
error
Dwarf_Unsigned
_dwarf_length_of_cu_header_simple
Dwarf_Debug
Dwarf_Bool
dinfo
int
_dwarf_load_debug_info
Dwarf_Debug
dbg
Dwarf_Error
error
int
_dwarf_load_debug_types
Dwarf_Debug
dbg
Dwarf_Error
error
void
_dwarf_free_abbrev_hash_table_contents
Dwarf_Debug
dbg
struct
Dwarf_Hash_Table_s
hash_table
int
_dwarf_get_address_size
Dwarf_Debug
dbg
Dwarf_Die
die
int
_dwarf_reference_outside_section
Dwarf_Die
die
Dwarf_Small
startaddr
Dwarf_Small
pastend
void
_dwarf_error_mv_s_to_t
Dwarf_Debug
dbgs
Dwarf_Error
errs
Dwarf_Debug
dbgt
Dwarf_Error
errt
int
_dwarf_internal_get_die_comp_dir
Dwarf_Die
die
const
char
compdir_out
const
char
comp_name_out
Dwarf_Error
error
int
_dwarf_what_section_are_we
Dwarf_Debug
dbg
Dwarf_Small
our_pointer
const
char
section_name_out
Dwarf_Small
sec_start_ptr_out
Dwarf_Unsigned
sec_len_out
Dwarf_Small
sec_end_ptr_out
Dwarf_Error
error
wrappers
return
either
DW_DLV_OK
or
DW_DLV_ERROR
Never
DW_DLV_NO_ENTRY
int
_dwarf_read_unaligned_ck_wrapper
Dwarf_Debug
dbg
Dwarf_Unsigned
out_value
Dwarf_Small
readfrom
int
readlength
Dwarf_Small
end_arange
Dwarf_Error
err
int
_dwarf_read_area_length_ck_wrapper
Dwarf_Debug
dbg
Dwarf_Unsigned
out_value
Dwarf_Small
readfrom
int
length_size_out
int
exten_size_out
Dwarf_Unsigned
sectionlength
Dwarf_Small
endsection
Dwarf_Error
err
int
_dwarf_leb128_uword_wrapper
Dwarf_Debug
dbg
Dwarf_Small
startptr
Dwarf_Small
endptr
Dwarf_Unsigned
out_value
Dwarf_Error
error
int
_dwarf_leb128_sword_wrapper
Dwarf_Debug
dbg
Dwarf_Small
startptr
Dwarf_Small
endptr
Dwarf_Signed
out_value
Dwarf_Error
error
endif
DWARF_UTIL_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
typedef
struct
Dwarf_Var_Context_s
Dwarf_Var_Context
struct
never
completed
see
dwarf_global
h
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
typedef
struct
Dwarf_Weak_Context_s
Dwarf_Weak_Context
struct
never
completed
see
dwarf_global
h
ifndef
DWARF_XU_INDEX_H
define
DWARF_XU_INDEX_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
following
is
based
on
The
gdb
online
documentation
at
https
gcc
gnu
org
wiki
DebugFissionDWP
and
the
draft
DWARF5
standard
struct
Dwarf_Xu_Index_Header_s
Dwarf_Debug
gx_dbg
Dwarf_Small
gx_section_data
Dwarf_Unsigned
gx_section_length
Dwarf_Unsigned
gx_version
Dwarf_Unsigned
gx_column_count_sections
N
Dwarf_Unsigned
gx_units_in_index
U
Dwarf_Unsigned
gx_slots_in_hash
S
Dwarf_Unsigned
gx_hash_table_offset
Dwarf_Unsigned
gx_index_table_offset
Dwarf_Unsigned
gx_section_offsets_headerline_offset
Dwarf_Unsigned
gx_section_offsets_offset
Dwarf_Unsigned
gx_section_sizes_offset
Taken
from
gx_section_offsets_headerline
these
are
the
section
ids
DW_SECT_
N
unsigned
long
gx_section_id
tu
or
cu
without
the
quotes
of
course
NUL
terminated
char
gx_type
Do
not
free
gx_section_name
const
char
gx_section_name
endif
DWARF_XU_INDEX_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
A
lightly
generalized
string
buffer
for
libdwarf
The
functions
that
return
anything
return
either
TRUE
nonzero
int
or
FALSE
zero
On
return
of
FALSE
the
dwarfstring_s
struct
remains
in
a
usable
state
It
is
expected
that
most
users
will
not
check
the
return
value
ifndef
DWARFSTRING_H
define
DWARFSTRING_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
struct
dwarfstring_s
char
s_data
unsigned
long
s_size
unsigned
long
s_avail
unsigned
char
s_malloc
typedef
unsigned
long
long
dwarfstring_u
typedef
signed
long
long
dwarfstring_i
typedef
struct
dwarfstring_s
dwarfstring
int
dwarfstring_constructor
struct
dwarfstring_s
g
int
dwarfstring_constructor_fixed
struct
dwarfstring_s
g
unsigned
long
len
int
dwarfstring_constructor_static
struct
dwarfstring_s
g
char
space
unsigned
long
len
void
dwarfstring_destructor
struct
dwarfstring_s
g
int
dwarfstring_reset
struct
dwarfstring_s
g
int
dwarfstring_append
struct
dwarfstring_s
g
char
str
When
one
wants
the
first
len
characters
of
str
appended
NUL
termination
is
provided
by
dwarfstrings
int
dwarfstring_append_length
struct
dwarfstring_s
g
char
str
unsigned
long
len
int
dwarfstring_append_printf_s
dwarfstring
data
char
format
char
s
int
dwarfstring_append_printf_i
dwarfstring
data
char
format
dwarfstring_i
int
dwarfstring_append_printf_u
dwarfstring
data
char
format
dwarfstring_u
char
dwarfstring_string
struct
dwarfstring_s
g
unsigned
long
dwarfstring_strlen
struct
dwarfstring_s
g
ifdef
__cplusplus
endif
__cplusplus
endif
DWARFSTRING_H
getopt
c
v
joerg
Exp
Modified
by
David
Anderson
to
work
with
GNU
Linux
and
freebsd
Added
for
clarity
Switched
to
standard
dwarfdump
formatting
Treatment
of
modified
so
that
gets
dwoptarg
NULL
if
space
follows
the
letter
the
dwoptarg
is
set
to
null
Copyright
c
The
Regents
of
the
University
of
California
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
Neither
the
name
of
the
University
nor
the
names
of
its
contributors
may
be
used
to
endorse
or
promote
products
derived
from
this
software
without
specific
prior
written
permission
THIS
SOFTWARE
IS
PROVIDED
BY
THE
REGENTS
AND
CONTRIBUTORS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
REGENTS
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifdef
__cplusplus
extern
C
endif
__cplusplus
extern
int
dwopterr
extern
int
dwoptind
extern
int
dwoptopt
extern
int
dwoptreset
extern
char
dwoptarg
int
dwgetopt
int
nargc
char
const
nargv
const
char
ostr
As
of
October
it
seems
adviseable
to
allow
long
option
names
So
based
on
a
reading
of
man
getopt
we
reimplement
a
portion
of
GNU
getopt_long
It
s
a
wonderfully
sensible
design
and
all
the
credit
should
go
to
the
original
designers
We
are
not
implementing
all
the
features
of
GNU
Linux
getopt_long
just
the
features
we
wish
to
use
Specifically
we
require
val
be
and
flag
be
NULL
and
ignore
those
fields
We
do
not
implement
GNU
digit_optind
at
all
Within
these
restrictions
the
interface
behaves
the
same
as
GNU
getopt_long
or
so
it
appears
from
the
getopt
documentation
release
of
the
Linux
man
pages
project
GETOPT
http
www
kernel
org
doc
man
pages
struct
dwoption
const
char
name
int
has_arg
int
flag
int
val
define
dwno_argument
define
dwrequired_argument
define
dwoptional_argument
int
dwgetopt_long
int
nargc
char
const
nargv
const
char
ostr
const
struct
dwoption
longopts
int
longindex
ifdef
__cplusplus
endif
__cplusplus
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
Arxan
Technologies
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
_LIBDWARF_H
define
_LIBDWARF_H
ifdef
__cplusplus
extern
C
endif
libdwarf
h
For
libdwarf
consumers
reading
DWARF2
and
later
The
interface
is
defined
as
having
byte
signed
and
unsigned
values
so
it
can
handle
or
target
on
or
host
Dwarf_Ptr
is
the
native
size
it
represents
pointers
on
the
host
machine
not
the
target
This
contains
declarations
for
types
and
all
producer
and
consumer
functions
Function
declarations
are
written
on
a
single
line
each
here
so
one
can
use
grep
to
each
declaration
in
its
entirety
The
declarations
are
a
little
harder
to
read
this
way
but
typedef
unsigned
long
long
Dwarf_Unsigned
typedef
signed
long
long
Dwarf_Signed
typedef
unsigned
long
long
Dwarf_Off
typedef
unsigned
long
long
Dwarf_Addr
Dwarf_Bool
as
int
is
wasteful
but
for
compatibility
it
must
stay
as
int
not
unsigned
char
typedef
int
Dwarf_Bool
boolean
type
typedef
unsigned
short
Dwarf_Half
byte
unsigned
value
typedef
unsigned
char
Dwarf_Small
byte
unsigned
value
If
sizeof
Dwarf_Half
is
greater
than
we
believe
libdwarf
still
works
properly
typedef
void
Dwarf_Ptr
host
machine
pointer
DWARF5
a
container
for
a
DW_FORM_data16
data
item
We
have
no
integer
types
suitable
so
this
special
struct
is
used
instead
It
is
up
to
consumers
producers
to
deal
with
the
contents
New
October
typedef
struct
Dwarf_Form_Data16_s
unsigned
char
fd_data
Dwarf_Form_Data16
Used
for
signatures
where
ever
they
appear
It
is
not
a
string
it
is
bytes
of
a
signature
one
would
use
to
find
a
type
unit
See
dwarf_formsig8
Sometimes
it
is
used
in
calculations
as
Dwarf_Unsigned
but
that
is
done
inside
libdwarf
and
the
endianness
question
makes
it
a
bit
sketchy
struct
Dwarf_Sig8_s
char
signature
typedef
struct
Dwarf_Sig8_s
Dwarf_Sig8
Contains
info
on
an
uninterpreted
block
of
data
Used
with
certain
location
information
functions
a
frame
expression
function
and
also
used
with
DW_FORM_block
functions
typedef
struct
Dwarf_Block_s
Dwarf_Unsigned
bl_len
length
of
block
bl_data
points
at
Dwarf_Ptr
bl_data
uninterpreted
data
See
libdwarf
h
DW_LKIND
Dwarf_Small
bl_from_loclist
Section
not
CU
offset
which
data
comes
from
Dwarf_Unsigned
bl_section_offset
Dwarf_Block
NEW
October
This
provides
access
to
Dwarf_Locdesc_c
a
single
location
description
struct
Dwarf_Locdesc_c_s
typedef
struct
Dwarf_Locdesc_c_s
Dwarf_Locdesc_c
NEW
October
This
provides
access
to
Dwarf_Locdesc_c
a
single
location
list
entry
or
for
a
locexpr
the
fake
Loc_Head
for
the
locexpr
struct
Dwarf_Loc_Head_c_s
typedef
struct
Dwarf_Loc_Head_c_s
Dwarf_Loc_Head_c
NEW
July
This
provides
access
to
data
from
sections
debug_gnu_pubtypes
or
debug_gnu_pubnames
These
are
not
standard
DWARF
and
can
appear
with
gcc
gdwarf
struct
Dwarf_Gnu_Index_Head_s
typedef
struct
Dwarf_Gnu_Index_Head_s
Dwarf_Gnu_Index_Head
NEW
November
For
DWARF5
debug_macro
section
struct
Dwarf_Macro_Context_s
typedef
struct
Dwarf_Macro_Context_s
Dwarf_Loc_Macro_Context
NEW
September
Allows
easy
access
to
DW_AT_discr_list
array
of
discriminant
values
Input
in
blockpointer
is
a
block
with
a
list
of
uleb
or
sleb
numbers
all
one
or
the
other
lebunsignedflag
instructs
how
to
read
the
leb
values
properly
typedef
struct
Dwarf_Dsc_Head_s
Dwarf_Dsc_Head
First
appears
in
DWARF3
and
only
ranges
entries
exist
The
dwr_addr1
addr2
data
is
either
an
offset
DW_RANGES_ENTRY
or
an
address
dwr_addr2
in
DW_RANGES_ADDRESS_SELECTION
or
both
are
zero
DW_RANGES_END
For
DWARF5
each
table
starts
with
a
header
followed
by
range
list
entries
defined
as
here
enum
Dwarf_Ranges_Entry_Type
DW_RANGES_ENTRY
DW_RANGES_ADDRESS_SELECTION
DW_RANGES_END
typedef
struct
Dwarf_Ranges_s
Dwarf_Addr
dwr_addr1
Dwarf_Addr
dwr_addr2
enum
Dwarf_Ranges_Entry_Type
dwr_type
Dwarf_Ranges
Frame
description
instructions
expanded
typedef
struct
Dwarf_Frame_Op_s
Dwarf_Small
fp_base_op
Dwarf_Small
fp_extended_op
Dwarf_Half
fp_register
Value
may
be
signed
depends
on
op
Any
applicable
data_alignment_factor
has
not
been
applied
this
is
the
raw
offset
Dwarf_Unsigned
fp_offset
Dwarf_Off
fp_instr_offset
Dwarf_Frame_Op
DWARF2
IMPORTANT
NOTE
TARGET
DEPENDENCY
DW_REG_TABLE_SIZE
must
be
at
least
as
large
as
the
number
of
registers
DW_FRAME_LAST_REG_NUM
as
defined
in
dwarf
h
Preferably
identical
to
DW_FRAME_LAST_REG_NUM
Ensure
DW_REG_TABLE_SIZE
does
not
overlap
DW_FRAME_UNDEFINED_VAL
or
DW_FRAME_SAME_VAL
Also
ensure
DW_FRAME_REG_INITIAL_VALUE
is
set
to
what
is
appropriate
to
your
cpu
For
various
CPUs
DW_FRAME_UNDEFINED_VAL
is
correct
as
the
value
for
DW_FRAME_REG_INITIAL_VALUE
For
consumer
apps
this
can
be
set
dynamically
see
dwarf_set_frame_rule_table_size
ifndef
DW_REG_TABLE_SIZE
define
DW_REG_TABLE_SIZE
endif
For
MIPS
DW_FRAME_SAME_VAL
is
the
correct
default
value
for
a
frame
register
value
For
other
CPUS
another
value
may
be
better
such
as
DW_FRAME_UNDEFINED_VAL
See
dwarf_set_frame_rule_table_size
ifndef
DW_FRAME_REG_INITIAL_VALUE
define
DW_FRAME_REG_INITIAL_VALUE
DW_FRAME_SAME_VAL
endif
Taken
as
meaning
undefined
value
this
is
not
a
column
or
register
number
Only
present
at
libdwarf
runtime
in
the
consumer
interfaces
Never
on
disk
DW_FRAME_
Values
present
on
disk
are
in
dwarf
h
Ensure
this
is
DW_REG_TABLE_SIZE
the
reg
table
size
is
changeable
at
runtime
with
the
reg3
interfaces
and
this
value
must
be
greater
than
the
reg
table
size
define
DW_FRAME_UNDEFINED_VAL
Taken
as
meaning
same
value
as
caller
had
not
a
column
or
register
number
Only
present
at
libdwarf
runtime
in
the
consumer
interfaces
Never
on
disk
DW_FRAME_
Values
present
on
disk
are
in
dwarf
h
Ensure
this
is
DW_REG_TABLE_SIZE
the
reg
table
size
is
changeable
at
runtime
with
the
reg3
interfaces
and
this
value
must
be
greater
than
the
reg
table
size
define
DW_FRAME_SAME_VAL
For
DWARF3
consumer
interfaces
make
the
CFA
a
column
with
no
real
table
number
This
is
what
should
have
been
done
for
the
DWARF2
interfaces
This
actually
works
for
both
DWARF2
and
DWARF3
but
see
the
libdwarf
documentation
on
Dwarf_Regtable3
and
dwarf_get_fde_info_for_reg3
and
dwarf_get_fde_info_for_all_regs3
Do
NOT
use
this
with
the
older
dwarf_get_fde_info_for_reg
or
dwarf_get_fde_info_for_all_regs
consumer
interfaces
Must
be
higher
than
any
register
count
for
any
ABI
ensures
maximum
applicability
with
minimum
effort
Ensure
this
is
DW_REG_TABLE_SIZE
the
reg
table
size
is
changeable
at
runtime
with
the
reg3
interfaces
and
this
value
must
be
greater
than
the
reg
table
size
Only
present
at
libdwarf
runtime
in
the
consumer
interfaces
Never
on
disk
define
DW_FRAME_CFA_COL3
The
following
are
all
needed
to
evaluate
DWARF3
register
rules
define
DW_EXPR_OFFSET
DWARF2
only
sees
this
define
DW_EXPR_VAL_OFFSET
define
DW_EXPR_EXPRESSION
define
DW_EXPR_VAL_EXPRESSION
opaque
type
Functional
interface
shown
later
struct
Dwarf_Reg_value3_s
typedef
struct
Dwarf_Reg_value3_s
Dwarf_Reg_Value3
typedef
struct
Dwarf_Regtable_Entry3_s
For
each
index
i
naming
a
hardware
register
with
dwarf
number
i
the
following
is
true
and
defines
the
value
of
that
register
If
dw_regnum
is
Register
DW_FRAME_UNDEFINED_VAL
it
is
not
DWARF
register
number
but
a
place
holder
indicating
the
register
has
no
defined
value
If
dw_regnum
is
Register
DW_FRAME_SAME_VAL
it
is
not
DWARF
register
number
but
a
place
holder
indicating
the
register
has
the
same
value
in
the
previous
frame
DW_FRAME_UNDEFINED_VAL
DW_FRAME_SAME_VAL
and
DW_FRAME_CFA_COL3
are
only
present
at
libdwarf
runtime
Never
on
disk
DW_FRAME_
Values
present
on
disk
are
in
dwarf
h
Because
DW_FRAME_SAME_VAL
and
DW_FRAME_UNDEFINED_VAL
and
DW_FRAME_CFA_COL3
are
definable
at
runtime
consider
the
names
symbolic
in
this
comment
not
absolute
Otherwise
the
register
number
is
a
DWARF
register
number
see
ABI
documents
for
how
this
translates
to
hardware
software
register
numbers
in
the
machine
hardware
and
the
following
applies
In
a
cfa
defining
entry
rt3_cfa_rule
the
regnum
is
the
CFA
register
number
Which
is
some
normal
register
not
DW_FRAME_CFA_COL3
nor
DW_FRAME_SAME_VAL
nor
DW_FRAME_UNDEFINED_VAL
If
dw_value_type
DW_EXPR_OFFSET
the
only
possible
case
for
dwarf2
If
dw_offset_relevant
is
non
zero
then
the
value
is
stored
at
at
the
address
CFA
N
where
N
is
a
signed
offset
dw_regnum
is
the
cfa
register
rule
which
means
one
ignores
dw_regnum
and
uses
the
CFA
appropriately
So
dw_offset_or_block_len
is
a
signed
value
really
and
must
be
printed
evaluated
as
such
Rule
Offset
N
If
dw_offset_relevant
is
zero
then
the
value
of
the
register
is
the
value
of
DWARF
register
number
dw_regnum
Rule
register
R
If
dw_value_type
DW_EXPR_VAL_OFFSET
the
value
of
this
register
is
CFA
N
where
N
is
a
signed
offset
dw_regnum
is
the
cfa
register
rule
which
means
one
ignores
dw_regnum
and
uses
the
CFA
appropriately
Rule
val_offset
N
If
dw_value_type
DW_EXPR_EXPRESSION
The
value
of
the
register
is
the
value
at
the
address
computed
by
evaluating
the
DWARF
expression
E
Rule
expression
E
The
expression
E
byte
stream
is
pointed
to
by
dw_block_ptr
The
expression
length
in
bytes
is
given
by
dw_offset_or_block_len
If
dw_value_type
DW_EXPR_VAL_EXPRESSION
The
value
of
the
register
is
the
value
computed
by
evaluating
the
DWARF
expression
E
Rule
val_expression
E
The
expression
E
byte
stream
is
pointed
to
by
dw_block_ptr
The
expression
length
in
bytes
is
given
by
dw_offset_or_block_len
Other
values
of
dw_value_type
are
an
error
Dwarf_Small
dw_offset_relevant
Dwarf_Small
dw_value_type
Dwarf_Half
dw_regnum
Dwarf_Unsigned
dw_offset_or_block_len
Dwarf_Ptr
dw_block_ptr
Dwarf_Regtable_Entry3
For
the
DWARF3
version
moved
the
DW_FRAME_CFA_COL
out
of
the
array
and
into
its
own
struct
Having
it
part
of
the
array
is
not
very
easy
to
work
with
from
a
portability
point
of
view
changing
the
number
for
every
architecture
is
a
pain
if
one
fails
to
set
it
correctly
a
register
rule
gets
clobbered
when
setting
CFA
With
MIPS
it
just
happened
to
be
easy
to
use
DW_FRAME_CFA_COL
it
was
wrong
conceptually
but
it
was
easy
rt3_rules
and
rt3_reg_table_size
must
be
filled
in
before
calling
libdwarf
Filled
in
with
a
pointer
to
an
array
pointer
and
array
set
up
by
the
calling
application
of
rt3_reg_table_size
Dwarf_Regtable_Entry3_s
structs
libdwarf
does
not
allocate
or
deallocate
space
for
the
rules
you
must
do
so
libdwarf
will
initialize
the
contents
rules
array
you
do
not
need
to
do
so
though
if
you
choose
to
initialize
the
array
somehow
that
is
ok
libdwarf
will
overwrite
your
initializations
with
its
own
typedef
struct
Dwarf_Regtable3_s
struct
Dwarf_Regtable_Entry3_s
rt3_cfa_rule
Dwarf_Half
rt3_reg_table_size
struct
Dwarf_Regtable_Entry3_s
rt3_rules
Dwarf_Regtable3
Use
for
DW_EPXR_STANDARD
DW_EXPR_VAL_OFFSET
Returns
DW_DLV_OK
if
the
value
is
available
If
DW_DLV_OK
returns
the
regnum
and
offset
thru
the
pointers
which
the
consumer
must
use
appropriately
int
dwarf_frame_get_reg_register
struct
Dwarf_Regtable_Entry3_s
Dwarf_Small
offset_relevant
Dwarf_Half
regnum_out
Dwarf_Signed
offset_out
Use
for
DW_EXPR_EXPRESSION
DW_EXPR_VAL_EXPRESSION
Returns
DW_DLV_OK
if
the
value
is
available
The
caller
must
pass
in
the
address
of
a
valid
Dwarf_Block
the
caller
need
not
initialize
it
int
dwarf_frame_get_reg_expression
struct
Dwarf_Regtable_Entry3_s
Dwarf_Block
block_out
Opaque
types
for
Consumer
Library
typedef
struct
Dwarf_Debug_s
Dwarf_Debug
typedef
struct
Dwarf_Die_s
Dwarf_Die
typedef
struct
Dwarf_Line_s
Dwarf_Line
typedef
struct
Dwarf_Global_s
Dwarf_Global
typedef
struct
Dwarf_Func_s
Dwarf_Func
typedef
struct
Dwarf_Type_s
Dwarf_Type
typedef
struct
Dwarf_Var_s
Dwarf_Var
typedef
struct
Dwarf_Weak_s
Dwarf_Weak
typedef
struct
Dwarf_Error_s
Dwarf_Error
typedef
struct
Dwarf_Attribute_s
Dwarf_Attribute
typedef
struct
Dwarf_Abbrev_s
Dwarf_Abbrev
typedef
struct
Dwarf_Fde_s
Dwarf_Fde
typedef
struct
Dwarf_Cie_s
Dwarf_Cie
typedef
struct
Dwarf_Arange_s
Dwarf_Arange
typedef
struct
Dwarf_Gdbindex_s
Dwarf_Gdbindex
struct
Dwarf_Xu_Index_Header_s
typedef
struct
Dwarf_Xu_Index_Header_s
Dwarf_Xu_Index_Header
struct
Dwarf_Line_Context_s
typedef
struct
Dwarf_Line_Context_s
Dwarf_Line_Context
struct
Dwarf_Macro_Context_s
typedef
struct
Dwarf_Macro_Context_s
Dwarf_Macro_Context
struct
Dwarf_Dnames_Head_s
typedef
struct
Dwarf_Dnames_Head_s
Dwarf_Dnames_Head
error
handler
function
typedef
void
Dwarf_Handler
Dwarf_Error
error
Dwarf_Ptr
errarg
Begin
libdwarf
Object
File
Interface
declarations
As
of
February
there
are
multiple
dwarf_reader
object
access
initialization
methods
available
None
of
them
use
libelf
as
of
June
An
object
file
and
library
agnostic
dwarf_object_init_b
and
dwarf_object_finish
which
allow
the
coder
to
provide
object
access
routines
abstracting
away
the
elf
interface
So
there
is
no
dependence
in
the
reader
code
on
the
object
format
and
no
dependence
on
libelf
Projects
using
dwarf_init
can
ignore
the
Dwarf_Obj_Access
structures
entirely
as
all
these
details
are
completed
for
you
As
of
March
additional
and
dwarf_init_b
and
dwarf_object_init_b
add
a
groupnumber
argument
so
DWARF5
split
dwarf
sections
can
be
accessed
typedef
struct
Dwarf_Obj_Access_Interface_s
Dwarf_Obj_Access_Interface
typedef
struct
Dwarf_Obj_Access_Methods_s
Dwarf_Obj_Access_Methods
typedef
struct
Dwarf_Obj_Access_Section_s
Dwarf_Obj_Access_Section
Used
in
the
get_section
interface
function
in
Dwarf_Obj_Access_Section_s
Since
libdwarf
depends
on
standard
DWARF
section
names
an
object
format
that
has
no
such
names
but
has
some
method
of
setting
up
sections
equivalents
must
arrange
to
return
standard
DWARF
section
names
in
the
name
field
libdwarf
does
not
free
the
strings
in
name
struct
Dwarf_Obj_Access_Section_s
addr
is
the
virtual
address
of
the
first
byte
of
the
section
data
Usually
zero
when
the
address
makes
no
sense
for
a
given
section
Dwarf_Addr
addr
Section
type
Dwarf_Unsigned
type
Size
in
bytes
of
the
section
Dwarf_Unsigned
size
Having
an
accurate
section
name
makes
debugging
of
libdwarf
easier
and
is
essential
to
find
the
debug_
sections
const
char
name
Set
link
to
zero
if
it
is
meaningless
If
non
zero
it
should
be
a
link
to
a
rela
section
or
from
symtab
to
strtab
In
Elf
it
is
sh_link
Dwarf_Unsigned
link
The
section
header
index
of
the
section
to
which
the
relocation
applies
In
Elf
it
is
sh_info
Dwarf_Unsigned
info
Elf
sections
that
are
tables
have
a
non
zero
entrysize
so
the
count
of
entries
can
be
calculated
even
without
the
right
structure
definition
If
your
object
format
does
not
have
this
data
leave
this
zero
Dwarf_Unsigned
entrysize
Returned
by
the
get_endianness
function
in
Dwarf_Obj_Access_Methods_s
typedef
enum
DW_OBJECT_MSB
DW_OBJECT_LSB
Dwarf_Endianness
The
functions
we
need
to
access
object
data
from
libdwarf
are
declared
here
In
these
function
pointer
declarations
void
obj
is
intended
to
be
a
pointer
the
object
field
in
Dwarf_Obj_Access_Interface_s
that
hides
the
library
specific
and
object
specific
data
that
makes
it
possible
to
handle
multiple
object
formats
and
multiple
libraries
It
s
not
required
that
one
handles
multiple
such
in
a
single
libdwarf
archive
shared
library
but
not
ruled
out
either
See
dwarf_elf_object_access_internals_t
and
dwarf_elf_access
c
for
an
example
struct
Dwarf_Obj_Access_Methods_s
get_section_info
Get
address
size
and
name
info
about
a
section
Parameters
section_index
Zero
based
index
return_section
Pointer
to
a
structure
in
which
section
info
will
be
placed
Caller
must
provide
a
valid
pointer
to
a
structure
area
The
structure
s
contents
will
be
overwritten
by
the
call
to
get_section_info
error
A
pointer
to
an
integer
in
which
an
error
code
may
be
stored
Return
DW_DLV_OK
Everything
ok
DW_DLV_ERROR
Error
occurred
Use
error
to
determine
the
libdwarf
defined
error
DW_DLV_NO_ENTRY
No
such
section
int
get_section_info
void
obj
Dwarf_Half
section_index
Dwarf_Obj_Access_Section
return_section
int
error
get_byte_order
Get
whether
the
object
file
represented
by
this
interface
is
big
endian
DW_OBJECT_MSB
or
little
endian
DW_OBJECT_LSB
Parameters
obj
Equivalent
to
this
in
OO
languages
Return
Endianness
of
object
Cannot
fail
Dwarf_Endianness
get_byte_order
void
obj
get_length_size
Get
the
size
of
a
length
field
in
the
underlying
object
file
libdwarf
currently
supports
and
byte
sizes
but
may
support
larger
in
the
future
Perhaps
the
return
type
should
be
an
enumeration?
Parameters
obj
Equivalent
to
this
in
OO
languages
Return
Size
of
length
Cannot
fail
Dwarf_Small
get_length_size
void
obj
get_pointer_size
Get
the
size
of
a
pointer
field
in
the
underlying
object
file
libdwarf
currently
supports
and
byte
sizes
Perhaps
the
return
type
should
be
an
enumeration?
Return
Size
of
pointer
Cannot
fail
Dwarf_Small
get_pointer_size
void
obj
get_section_count
Get
the
number
of
sections
in
the
object
file
Parameters
Return
Number
of
sections
Dwarf_Unsigned
get_section_count
void
obj
load_section
Get
a
pointer
to
an
array
of
bytes
that
represent
the
section
Parameters
section_index
Zero
based
index
return_data
The
address
of
a
pointer
to
which
the
section
data
block
will
be
assigned
error
Pointer
to
an
integer
for
returning
libdwarf
defined
error
numbers
Return
DW_DLV_OK
No
error
DW_DLV_ERROR
Error
Use
error
to
indicate
a
libdwarf
defined
error
number
DW_DLV_NO_ENTRY
No
such
section
int
load_section
void
obj
Dwarf_Half
section_index
Dwarf_Small
return_data
int
error
relocate_a_section
If
relocations
are
not
supported
leave
this
pointer
NULL
Get
a
pointer
to
an
array
of
bytes
that
represent
the
section
Parameters
section_index
Zero
based
index
of
the
section
to
be
relocated
error
Pointer
to
an
integer
for
returning
libdwarf
defined
error
numbers
Return
DW_DLV_OK
No
error
DW_DLV_ERROR
Error
Use
error
to
indicate
a
libdwarf
defined
error
number
DW_DLV_NO_ENTRY
No
such
section
int
relocate_a_section
void
obj
Dwarf_Half
section_index
Dwarf_Debug
dbg
int
error
These
structures
are
allocated
and
deallocated
by
your
code
when
you
are
using
the
libdwarf
Object
File
Interface
dwarf_object_init_b
and
dwarf_object_finish
directly
dwarf_object_finish
does
not
free
struct
Dwarf_Obj_Access_Interface_s
or
its
content
libdwarf
does
record
a
pointer
to
this
struct
you
must
ensure
that
pointer
remains
valid
for
as
long
as
a
libdwarf
instance
is
open
meaning
after
dwarf_init_b
and
before
dwarf_finish
dwarf_init_path_dl
or
dwarf_init_path
take
care
of
these
details
struct
Dwarf_Obj_Access_Interface_s
object
is
a
void
as
it
hides
the
data
the
object
access
routines
need
which
varies
by
library
in
use
and
object
format
void
object
const
Dwarf_Obj_Access_Methods
methods
End
libdwarf
Object
File
Interface
Dwarf_dealloc
alloc_type
arguments
Argument
points
to
define
DW_DLA_STRING
char
define
DW_DLA_LOC
Dwarf_Loc
define
DW_DLA_LOCDESC
Dwarf_Locdesc
define
DW_DLA_ELLIST
Dwarf_Ellist
not
used
define
DW_DLA_BOUNDS
Dwarf_Bounds
not
used
define
DW_DLA_BLOCK
Dwarf_Block
define
DW_DLA_DEBUG
Dwarf_Debug
define
DW_DLA_DIE
Dwarf_Die
define
DW_DLA_LINE
Dwarf_Line
define
DW_DLA_ATTR
Dwarf_Attribute
define
DW_DLA_TYPE
Dwarf_Type
not
used
define
DW_DLA_SUBSCR
Dwarf_Subscr
not
used
define
DW_DLA_GLOBAL
Dwarf_Global
define
DW_DLA_ERROR
Dwarf_Error
define
DW_DLA_LIST
a
list
define
DW_DLA_LINEBUF
Dwarf_Line
not
used
define
DW_DLA_ARANGE
Dwarf_Arange
define
DW_DLA_ABBREV
Dwarf_Abbrev
define
DW_DLA_FRAME_OP
Dwarf_Frame_Op
define
DW_DLA_CIE
Dwarf_Cie
define
DW_DLA_FDE
Dwarf_Fde
define
DW_DLA_LOC_BLOCK
Dwarf_Loc
Dwarf_Frame
Block
not
used
define
DW_DLA_FRAME_BLOCK
define
DW_DLA_FUNC
Dwarf_Func
define
DW_DLA_TYPENAME
Dwarf_Type
define
DW_DLA_VAR
Dwarf_Var
define
DW_DLA_WEAK
Dwarf_Weak
define
DW_DLA_ADDR
Dwarf_Addr
sized
entries
define
DW_DLA_RANGES
Dwarf_Ranges
to
reserved
for
internal
to
libdwarf
types
debug_gnu_typenames
pubnames
define
DW_DLA_GNU_INDEX_HEAD
define
DW_DLA_RNGLISTS_HEAD
debug_rnglists
DW5
define
DW_DLA_GDBINDEX
Dwarf_Gdbindex
define
DW_DLA_XU_INDEX
Dwarf_Xu_Index_Header
define
DW_DLA_LOC_BLOCK_C
Dwarf_Loc_c
define
DW_DLA_LOCDESC_C
Dwarf_Locdesc_c
define
DW_DLA_LOC_HEAD_C
Dwarf_Loc_Head_c
define
DW_DLA_MACRO_CONTEXT
Dwarf_Macro_Context
is
for
libdwarf
internal
use
define
DW_DLA_DSC_HEAD
Dwarf_Dsc_Head
define
DW_DLA_DNAMES_HEAD
Dwarf_Dnames_Head
struct
Dwarf_Str_Offsets_Table_s
define
DW_DLA_STR_OFFSETS
The
augmenter
string
for
CIE
define
DW_CIE_AUGMENTER_STRING_V0
z
dwarf_pcline
function
slide
arguments
define
DW_DLS_BACKWARD
slide
backward
to
find
line
define
DW_DLS_NOSLIDE
match
exactly
without
sliding
define
DW_DLS_FORWARD
slide
forward
to
find
line
libdwarf
error
numbers
define
DW_DLE_NE
no
error
define
DW_DLE_VMM
dwarf
format
library
version
mismatch
define
DW_DLE_MAP
memory
map
failure
define
DW_DLE_LEE
libelf
error
define
DW_DLE_NDS
no
debug
section
define
DW_DLE_NLS
no
line
section
define
DW_DLE_ID
invalid
descriptor
for
query
define
DW_DLE_IOF
I
O
failure
define
DW_DLE_MAF
memory
allocation
failure
define
DW_DLE_IA
invalid
argument
define
DW_DLE_MDE
mangled
debugging
entry
define
DW_DLE_MLE
mangled
line
number
entry
define
DW_DLE_FNO
file
not
open
define
DW_DLE_FNR
file
not
a
regular
file
define
DW_DLE_FWA
file
open
with
wrong
access
define
DW_DLE_NOB
not
an
object
file
define
DW_DLE_MOF
mangled
object
file
header
define
DW_DLE_EOLL
end
of
location
list
entries
define
DW_DLE_NOLL
no
location
list
section
define
DW_DLE_BADOFF
Invalid
offset
define
DW_DLE_EOS
end
of
section
define
DW_DLE_ATRUNC
abbreviations
section
appears
truncated
define
DW_DLE_BADBITC
Address
size
passed
to
dwarf
bad
It
is
not
an
allowed
size
or
Error
codes
defined
by
the
current
Libdwarf
Implementation
define
DW_DLE_DBG_ALLOC
define
DW_DLE_FSTAT_ERROR
define
DW_DLE_FSTAT_MODE_ERROR
define
DW_DLE_INIT_ACCESS_WRONG
define
DW_DLE_ELF_BEGIN_ERROR
define
DW_DLE_ELF_GETEHDR_ERROR
define
DW_DLE_ELF_GETSHDR_ERROR
define
DW_DLE_ELF_STRPTR_ERROR
define
DW_DLE_DEBUG_INFO_DUPLICATE
define
DW_DLE_DEBUG_INFO_NULL
define
DW_DLE_DEBUG_ABBREV_DUPLICATE
define
DW_DLE_DEBUG_ABBREV_NULL
define
DW_DLE_DEBUG_ARANGES_DUPLICATE
define
DW_DLE_DEBUG_ARANGES_NULL
define
DW_DLE_DEBUG_LINE_DUPLICATE
define
DW_DLE_DEBUG_LINE_NULL
define
DW_DLE_DEBUG_LOC_DUPLICATE
define
DW_DLE_DEBUG_LOC_NULL
define
DW_DLE_DEBUG_MACINFO_DUPLICATE
define
DW_DLE_DEBUG_MACINFO_NULL
define
DW_DLE_DEBUG_PUBNAMES_DUPLICATE
define
DW_DLE_DEBUG_PUBNAMES_NULL
define
DW_DLE_DEBUG_STR_DUPLICATE
define
DW_DLE_DEBUG_STR_NULL
define
DW_DLE_CU_LENGTH_ERROR
define
DW_DLE_VERSION_STAMP_ERROR
define
DW_DLE_ABBREV_OFFSET_ERROR
define
DW_DLE_ADDRESS_SIZE_ERROR
define
DW_DLE_DEBUG_INFO_PTR_NULL
define
DW_DLE_DIE_NULL
define
DW_DLE_STRING_OFFSET_BAD
define
DW_DLE_DEBUG_LINE_LENGTH_BAD
define
DW_DLE_LINE_PROLOG_LENGTH_BAD
define
DW_DLE_LINE_NUM_OPERANDS_BAD
define
DW_DLE_LINE_SET_ADDR_ERROR
define
DW_DLE_LINE_EXT_OPCODE_BAD
define
DW_DLE_DWARF_LINE_NULL
define
DW_DLE_INCL_DIR_NUM_BAD
define
DW_DLE_LINE_FILE_NUM_BAD
define
DW_DLE_ALLOC_FAIL
define
DW_DLE_NO_CALLBACK_FUNC
define
DW_DLE_SECT_ALLOC
define
DW_DLE_FILE_ENTRY_ALLOC
define
DW_DLE_LINE_ALLOC
define
DW_DLE_FPGM_ALLOC
define
DW_DLE_INCDIR_ALLOC
define
DW_DLE_STRING_ALLOC
define
DW_DLE_CHUNK_ALLOC
define
DW_DLE_BYTEOFF_ERR
define
DW_DLE_CIE_ALLOC
define
DW_DLE_FDE_ALLOC
define
DW_DLE_REGNO_OVFL
define
DW_DLE_CIE_OFFS_ALLOC
define
DW_DLE_WRONG_ADDRESS
define
DW_DLE_EXTRA_NEIGHBORS
define
DW_DLE_WRONG_TAG
define
DW_DLE_DIE_ALLOC
define
DW_DLE_PARENT_EXISTS
define
DW_DLE_DBG_NULL
define
DW_DLE_DEBUGLINE_ERROR
define
DW_DLE_DEBUGFRAME_ERROR
define
DW_DLE_DEBUGINFO_ERROR
define
DW_DLE_ATTR_ALLOC
define
DW_DLE_ABBREV_ALLOC
define
DW_DLE_OFFSET_UFLW
define
DW_DLE_ELF_SECT_ERR
define
DW_DLE_DEBUG_FRAME_LENGTH_BAD
define
DW_DLE_FRAME_VERSION_BAD
define
DW_DLE_CIE_RET_ADDR_REG_ERROR
define
DW_DLE_FDE_NULL
define
DW_DLE_FDE_DBG_NULL
define
DW_DLE_CIE_NULL
define
DW_DLE_CIE_DBG_NULL
define
DW_DLE_FRAME_TABLE_COL_BAD
define
DW_DLE_PC_NOT_IN_FDE_RANGE
define
DW_DLE_CIE_INSTR_EXEC_ERROR
define
DW_DLE_FRAME_INSTR_EXEC_ERROR
define
DW_DLE_FDE_PTR_NULL
define
DW_DLE_RET_OP_LIST_NULL
define
DW_DLE_LINE_CONTEXT_NULL
define
DW_DLE_DBG_NO_CU_CONTEXT
define
DW_DLE_DIE_NO_CU_CONTEXT
define
DW_DLE_FIRST_DIE_NOT_CU
define
DW_DLE_NEXT_DIE_PTR_NULL
define
DW_DLE_DEBUG_FRAME_DUPLICATE
define
DW_DLE_DEBUG_FRAME_NULL
define
DW_DLE_ABBREV_DECODE_ERROR
define
DW_DLE_DWARF_ABBREV_NULL
define
DW_DLE_ATTR_NULL
define
DW_DLE_DIE_BAD
define
DW_DLE_DIE_ABBREV_BAD
define
DW_DLE_ATTR_FORM_BAD
define
DW_DLE_ATTR_NO_CU_CONTEXT
define
DW_DLE_ATTR_FORM_SIZE_BAD
define
DW_DLE_ATTR_DBG_NULL
define
DW_DLE_BAD_REF_FORM
define
DW_DLE_ATTR_FORM_OFFSET_BAD
define
DW_DLE_LINE_OFFSET_BAD
define
DW_DLE_DEBUG_STR_OFFSET_BAD
define
DW_DLE_STRING_PTR_NULL
define
DW_DLE_PUBNAMES_VERSION_ERROR
define
DW_DLE_PUBNAMES_LENGTH_BAD
define
DW_DLE_GLOBAL_NULL
define
DW_DLE_GLOBAL_CONTEXT_NULL
define
DW_DLE_DIR_INDEX_BAD
define
DW_DLE_LOC_EXPR_BAD
define
DW_DLE_DIE_LOC_EXPR_BAD
define
DW_DLE_ADDR_ALLOC
define
DW_DLE_OFFSET_BAD
define
DW_DLE_MAKE_CU_CONTEXT_FAIL
define
DW_DLE_REL_ALLOC
define
DW_DLE_ARANGE_OFFSET_BAD
define
DW_DLE_SEGMENT_SIZE_BAD
define
DW_DLE_ARANGE_LENGTH_BAD
define
DW_DLE_ARANGE_DECODE_ERROR
define
DW_DLE_ARANGES_NULL
define
DW_DLE_ARANGE_NULL
define
DW_DLE_NO_FILE_NAME
define
DW_DLE_NO_COMP_DIR
define
DW_DLE_CU_ADDRESS_SIZE_BAD
define
DW_DLE_INPUT_ATTR_BAD
define
DW_DLE_EXPR_NULL
define
DW_DLE_BAD_EXPR_OPCODE
define
DW_DLE_EXPR_LENGTH_BAD
define
DW_DLE_MULTIPLE_RELOC_IN_EXPR
define
DW_DLE_ELF_GETIDENT_ERROR
define
DW_DLE_NO_AT_MIPS_FDE
define
DW_DLE_NO_CIE_FOR_FDE
define
DW_DLE_DIE_ABBREV_LIST_NULL
define
DW_DLE_DEBUG_FUNCNAMES_DUPLICATE
define
DW_DLE_DEBUG_FUNCNAMES_NULL
define
DW_DLE_DEBUG_FUNCNAMES_VERSION_ERROR
define
DW_DLE_DEBUG_FUNCNAMES_LENGTH_BAD
define
DW_DLE_FUNC_NULL
define
DW_DLE_FUNC_CONTEXT_NULL
define
DW_DLE_DEBUG_TYPENAMES_DUPLICATE
define
DW_DLE_DEBUG_TYPENAMES_NULL
define
DW_DLE_DEBUG_TYPENAMES_VERSION_ERROR
define
DW_DLE_DEBUG_TYPENAMES_LENGTH_BAD
define
DW_DLE_TYPE_NULL
define
DW_DLE_TYPE_CONTEXT_NULL
define
DW_DLE_DEBUG_VARNAMES_DUPLICATE
define
DW_DLE_DEBUG_VARNAMES_NULL
define
DW_DLE_DEBUG_VARNAMES_VERSION_ERROR
define
DW_DLE_DEBUG_VARNAMES_LENGTH_BAD
define
DW_DLE_VAR_NULL
define
DW_DLE_VAR_CONTEXT_NULL
define
DW_DLE_DEBUG_WEAKNAMES_DUPLICATE
define
DW_DLE_DEBUG_WEAKNAMES_NULL
define
DW_DLE_DEBUG_WEAKNAMES_VERSION_ERROR
define
DW_DLE_DEBUG_WEAKNAMES_LENGTH_BAD
define
DW_DLE_WEAK_NULL
define
DW_DLE_WEAK_CONTEXT_NULL
define
DW_DLE_LOCDESC_COUNT_WRONG
define
DW_DLE_MACINFO_STRING_NULL
define
DW_DLE_MACINFO_STRING_EMPTY
define
DW_DLE_MACINFO_INTERNAL_ERROR_SPACE
define
DW_DLE_MACINFO_MALLOC_FAIL
define
DW_DLE_DEBUGMACINFO_ERROR
define
DW_DLE_DEBUG_MACRO_LENGTH_BAD
define
DW_DLE_DEBUG_MACRO_MAX_BAD
define
DW_DLE_DEBUG_MACRO_INTERNAL_ERR
define
DW_DLE_DEBUG_MACRO_MALLOC_SPACE
define
DW_DLE_DEBUG_MACRO_INCONSISTENT
define
DW_DLE_DF_NO_CIE_AUGMENTATION
define
DW_DLE_DF_REG_NUM_TOO_HIGH
define
DW_DLE_DF_MAKE_INSTR_NO_INIT
define
DW_DLE_DF_NEW_LOC_LESS_OLD_LOC
define
DW_DLE_DF_POP_EMPTY_STACK
define
DW_DLE_DF_ALLOC_FAIL
define
DW_DLE_DF_FRAME_DECODING_ERROR
define
DW_DLE_DEBUG_LOC_SECTION_SHORT
define
DW_DLE_FRAME_AUGMENTATION_UNKNOWN
define
DW_DLE_PUBTYPE_CONTEXT
Unused
define
DW_DLE_DEBUG_PUBTYPES_LENGTH_BAD
define
DW_DLE_DEBUG_PUBTYPES_VERSION_ERROR
define
DW_DLE_DEBUG_PUBTYPES_DUPLICATE
define
DW_DLE_FRAME_CIE_DECODE_ERROR
define
DW_DLE_FRAME_REGISTER_UNREPRESENTABLE
define
DW_DLE_FRAME_REGISTER_COUNT_MISMATCH
define
DW_DLE_LINK_LOOP
define
DW_DLE_STRP_OFFSET_BAD
define
DW_DLE_DEBUG_RANGES_DUPLICATE
define
DW_DLE_DEBUG_RANGES_OFFSET_BAD
define
DW_DLE_DEBUG_RANGES_MISSING_END
define
DW_DLE_DEBUG_RANGES_OUT_OF_MEM
define
DW_DLE_DEBUG_SYMTAB_ERR
define
DW_DLE_DEBUG_STRTAB_ERR
define
DW_DLE_RELOC_MISMATCH_INDEX
define
DW_DLE_RELOC_MISMATCH_RELOC_INDEX
define
DW_DLE_RELOC_MISMATCH_STRTAB_INDEX
define
DW_DLE_RELOC_SECTION_MISMATCH
define
DW_DLE_RELOC_SECTION_MISSING_INDEX
define
DW_DLE_RELOC_SECTION_LENGTH_ODD
define
DW_DLE_RELOC_SECTION_PTR_NULL
define
DW_DLE_RELOC_SECTION_MALLOC_FAIL
define
DW_DLE_NO_ELF64_SUPPORT
define
DW_DLE_MISSING_ELF64_SUPPORT
define
DW_DLE_ORPHAN_FDE
define
DW_DLE_DUPLICATE_INST_BLOCK
define
DW_DLE_BAD_REF_SIG8_FORM
define
DW_DLE_ATTR_EXPRLOC_FORM_BAD
define
DW_DLE_FORM_SEC_OFFSET_LENGTH_BAD
define
DW_DLE_NOT_REF_FORM
define
DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE
define
DW_DLE_REF_SIG8_NOT_HANDLED
define
DW_DLE_DEBUG_FRAME_POSSIBLE_ADDRESS_BOTCH
define
DW_DLE_LOC_BAD_TERMINATION
define
DW_DLE_SYMTAB_SECTION_LENGTH_ODD
define
DW_DLE_RELOC_SECTION_SYMBOL_INDEX_BAD
define
DW_DLE_RELOC_SECTION_RELOC_TARGET_SIZE_UNKNOWN
define
DW_DLE_SYMTAB_SECTION_ENTRYSIZE_ZERO
define
DW_DLE_LINE_NUMBER_HEADER_ERROR
define
DW_DLE_DEBUG_TYPES_NULL
define
DW_DLE_DEBUG_TYPES_DUPLICATE
define
DW_DLE_DEBUG_TYPES_ONLY_DWARF4
define
DW_DLE_DEBUG_TYPEOFFSET_BAD
define
DW_DLE_GNU_OPCODE_ERROR
define
DW_DLE_DEBUGPUBTYPES_ERROR
define
DW_DLE_AT_FIXUP_NULL
define
DW_DLE_AT_FIXUP_DUP
define
DW_DLE_BAD_ABINAME
define
DW_DLE_TOO_MANY_DEBUG
define
DW_DLE_DEBUG_STR_OFFSETS_DUPLICATE
define
DW_DLE_SECTION_DUPLICATION
define
DW_DLE_SECTION_ERROR
define
DW_DLE_DEBUG_ADDR_DUPLICATE
define
DW_DLE_DEBUG_CU_UNAVAILABLE_FOR_FORM
define
DW_DLE_DEBUG_FORM_HANDLING_INCOMPLETE
define
DW_DLE_NEXT_DIE_PAST_END
define
DW_DLE_NEXT_DIE_WRONG_FORM
define
DW_DLE_NEXT_DIE_NO_ABBREV_LIST
define
DW_DLE_NESTED_FORM_INDIRECT_ERROR
define
DW_DLE_CU_DIE_NO_ABBREV_LIST
define
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
define
DW_DLE_ATTR_FORM_NOT_ADDR_INDEX
define
DW_DLE_ATTR_FORM_NOT_STR_INDEX
define
DW_DLE_DUPLICATE_GDB_INDEX
define
DW_DLE_ERRONEOUS_GDB_INDEX_SECTION
define
DW_DLE_GDB_INDEX_COUNT_ERROR
define
DW_DLE_GDB_INDEX_COUNT_ADDR_ERROR
define
DW_DLE_GDB_INDEX_INDEX_ERROR
define
DW_DLE_GDB_INDEX_CUVEC_ERROR
define
DW_DLE_DUPLICATE_CU_INDEX
define
DW_DLE_DUPLICATE_TU_INDEX
define
DW_DLE_XU_TYPE_ARG_ERROR
define
DW_DLE_XU_IMPOSSIBLE_ERROR
define
DW_DLE_XU_NAME_COL_ERROR
define
DW_DLE_XU_HASH_ROW_ERROR
define
DW_DLE_XU_HASH_INDEX_ERROR
_FAILSAFE_ERRVAL
is
an
aid
when
out
of
memory
define
DW_DLE_FAILSAFE_ERRVAL
define
DW_DLE_ARANGE_ERROR
define
DW_DLE_PUBNAMES_ERROR
define
DW_DLE_FUNCNAMES_ERROR
define
DW_DLE_TYPENAMES_ERROR
define
DW_DLE_VARNAMES_ERROR
define
DW_DLE_WEAKNAMES_ERROR
define
DW_DLE_RELOCS_ERROR
define
DW_DLE_ATTR_OUTSIDE_SECTION
define
DW_DLE_FISSION_INDEX_WRONG
define
DW_DLE_FISSION_VERSION_ERROR
define
DW_DLE_NEXT_DIE_LOW_ERROR
define
DW_DLE_CU_UT_TYPE_ERROR
define
DW_DLE_NO_SUCH_SIGNATURE_FOUND
define
DW_DLE_SIGNATURE_SECTION_NUMBER_WRONG
define
DW_DLE_ATTR_FORM_NOT_DATA8
define
DW_DLE_SIG_TYPE_WRONG_STRING
define
DW_DLE_MISSING_REQUIRED_TU_OFFSET_HASH
define
DW_DLE_MISSING_REQUIRED_CU_OFFSET_HASH
define
DW_DLE_DWP_MISSING_DWO_ID
define
DW_DLE_DWP_SIBLING_ERROR
define
DW_DLE_DEBUG_FISSION_INCOMPLETE
define
DW_DLE_FISSION_SECNUM_ERR
define
DW_DLE_DEBUG_MACRO_DUPLICATE
define
DW_DLE_DEBUG_NAMES_DUPLICATE
define
DW_DLE_DEBUG_LINE_STR_DUPLICATE
define
DW_DLE_DEBUG_SUP_DUPLICATE
define
DW_DLE_NO_SIGNATURE_TO_LOOKUP
define
DW_DLE_NO_TIED_ADDR_AVAILABLE
define
DW_DLE_NO_TIED_SIG_AVAILABLE
define
DW_DLE_STRING_NOT_TERMINATED
define
DW_DLE_BAD_LINE_TABLE_OPERATION
define
DW_DLE_LINE_CONTEXT_BOTCH
define
DW_DLE_LINE_CONTEXT_INDEX_WRONG
define
DW_DLE_NO_TIED_STRING_AVAILABLE
define
DW_DLE_NO_TIED_FILE_AVAILABLE
define
DW_DLE_CU_TYPE_MISSING
define
DW_DLE_LLE_CODE_UNKNOWN
define
DW_DLE_LOCLIST_INTERFACE_ERROR
define
DW_DLE_LOCLIST_INDEX_ERROR
define
DW_DLE_INTERFACE_NOT_SUPPORTED
define
DW_DLE_ZDEBUG_REQUIRES_ZLIB
define
DW_DLE_ZDEBUG_INPUT_FORMAT_ODD
define
DW_DLE_ZLIB_BUF_ERROR
define
DW_DLE_ZLIB_DATA_ERROR
define
DW_DLE_MACRO_OFFSET_BAD
define
DW_DLE_MACRO_OPCODE_BAD
define
DW_DLE_MACRO_OPCODE_FORM_BAD
define
DW_DLE_UNKNOWN_FORM
define
DW_DLE_BAD_MACRO_HEADER_POINTER
define
DW_DLE_BAD_MACRO_INDEX
define
DW_DLE_MACRO_OP_UNHANDLED
define
DW_DLE_MACRO_PAST_END
define
DW_DLE_LINE_STRP_OFFSET_BAD
define
DW_DLE_STRING_FORM_IMPROPER
define
DW_DLE_ELF_FLAGS_NOT_AVAILABLE
define
DW_DLE_LEB_IMPROPER
define
DW_DLE_DEBUG_LINE_RANGE_ZERO
define
DW_DLE_READ_LITTLEENDIAN_ERROR
define
DW_DLE_READ_BIGENDIAN_ERROR
define
DW_DLE_RELOC_INVALID
define
DW_DLE_INFO_HEADER_ERROR
define
DW_DLE_ARANGES_HEADER_ERROR
define
DW_DLE_LINE_OFFSET_WRONG_FORM
define
DW_DLE_FORM_BLOCK_LENGTH_ERROR
define
DW_DLE_ZLIB_SECTION_SHORT
define
DW_DLE_CIE_INSTR_PTR_ERROR
define
DW_DLE_FDE_INSTR_PTR_ERROR
define
DW_DLE_FISSION_ADDITION_ERROR
define
DW_DLE_HEADER_LEN_BIGGER_THAN_SECSIZE
define
DW_DLE_LOCEXPR_OFF_SECTION_END
define
DW_DLE_POINTER_SECTION_UNKNOWN
define
DW_DLE_ERRONEOUS_XU_INDEX_SECTION
define
DW_DLE_DIRECTORY_FORMAT_COUNT_VS_DIRECTORIES_MISMATCH
define
DW_DLE_COMPRESSED_EMPTY_SECTION
define
DW_DLE_SIZE_WRAPAROUND
define
DW_DLE_ILLOGICAL_TSEARCH
define
DW_DLE_BAD_STRING_FORM
define
DW_DLE_DEBUGSTR_ERROR
define
DW_DLE_DEBUGSTR_UNEXPECTED_REL
define
DW_DLE_DISCR_ARRAY_ERROR
define
DW_DLE_LEB_OUT_ERROR
define
DW_DLE_SIBLING_LIST_IMPROPER
define
DW_DLE_LOCLIST_OFFSET_BAD
define
DW_DLE_LINE_TABLE_BAD
define
DW_DLE_DEBUG_LOClISTS_DUPLICATE
define
DW_DLE_DEBUG_RNGLISTS_DUPLICATE
define
DW_DLE_ABBREV_OFF_END
define
DW_DLE_FORM_STRING_BAD_STRING
define
DW_DLE_AUGMENTATION_STRING_OFF_END
define
DW_DLE_STRING_OFF_END_PUBNAMES_LIKE
define
DW_DLE_LINE_STRING_BAD
define
DW_DLE_DEFINE_FILE_STRING_BAD
define
DW_DLE_MACRO_STRING_BAD
define
DW_DLE_MACINFO_STRING_BAD
define
DW_DLE_ZLIB_UNCOMPRESS_ERROR
define
DW_DLE_IMPROPER_DWO_ID
define
DW_DLE_GROUPNUMBER_ERROR
define
DW_DLE_ADDRESS_SIZE_ZERO
define
DW_DLE_DEBUG_NAMES_HEADER_ERROR
define
DW_DLE_DEBUG_NAMES_AUG_STRING_ERROR
define
DW_DLE_DEBUG_NAMES_PAD_NON_ZERO
define
DW_DLE_DEBUG_NAMES_OFF_END
define
DW_DLE_DEBUG_NAMES_ABBREV_OVERFLOW
define
DW_DLE_DEBUG_NAMES_ABBREV_CORRUPTION
define
DW_DLE_DEBUG_NAMES_NULL_POINTER
define
DW_DLE_DEBUG_NAMES_BAD_INDEX_ARG
define
DW_DLE_DEBUG_NAMES_ENTRYPOOL_OFFSET
define
DW_DLE_DEBUG_NAMES_UNHANDLED_FORM
define
DW_DLE_LNCT_CODE_UNKNOWN
define
DW_DLE_LNCT_FORM_CODE_NOT_HANDLED
define
DW_DLE_LINE_HEADER_LENGTH_BOTCH
define
DW_DLE_STRING_HASHTAB_IDENTITY_ERROR
define
DW_DLE_UNIT_TYPE_NOT_HANDLED
define
DW_DLE_GROUP_MAP_ALLOC
define
DW_DLE_GROUP_MAP_DUPLICATE
define
DW_DLE_GROUP_COUNT_ERROR
define
DW_DLE_GROUP_INTERNAL_ERROR
define
DW_DLE_GROUP_LOAD_ERROR
define
DW_DLE_GROUP_LOAD_READ_ERROR
define
DW_DLE_AUG_DATA_LENGTH_BAD
define
DW_DLE_ABBREV_MISSING
define
DW_DLE_NO_TAG_FOR_DIE
define
DW_DLE_LOWPC_WRONG_CLASS
define
DW_DLE_HIGHPC_WRONG_FORM
define
DW_DLE_STR_OFFSETS_BASE_WRONG_FORM
define
DW_DLE_DATA16_OUTSIDE_SECTION
define
DW_DLE_LNCT_MD5_WRONG_FORM
define
DW_DLE_LINE_HEADER_CORRUPT
define
DW_DLE_STR_OFFSETS_NULLARGUMENT
define
DW_DLE_STR_OFFSETS_NULL_DBG
define
DW_DLE_STR_OFFSETS_NO_MAGIC
define
DW_DLE_STR_OFFSETS_ARRAY_SIZE
define
DW_DLE_STR_OFFSETS_VERSION_WRONG
define
DW_DLE_STR_OFFSETS_ARRAY_INDEX_WRONG
define
DW_DLE_STR_OFFSETS_EXTRA_BYTES
define
DW_DLE_DUP_ATTR_ON_DIE
define
DW_DLE_SECTION_NAME_BIG
define
DW_DLE_FILE_UNAVAILABLE
define
DW_DLE_FILE_WRONG_TYPE
define
DW_DLE_SIBLING_OFFSET_WRONG
define
DW_DLE_OPEN_FAIL
define
DW_DLE_OFFSET_SIZE
define
DW_DLE_MACH_O_SEGOFFSET_BAD
define
DW_DLE_FILE_OFFSET_BAD
define
DW_DLE_SEEK_ERROR
define
DW_DLE_READ_ERROR
define
DW_DLE_ELF_CLASS_BAD
define
DW_DLE_ELF_ENDIAN_BAD
define
DW_DLE_ELF_VERSION_BAD
define
DW_DLE_FILE_TOO_SMALL
define
DW_DLE_PATH_SIZE_TOO_SMALL
define
DW_DLE_BAD_TYPE_SIZE
define
DW_DLE_PE_SIZE_SMALL
define
DW_DLE_PE_OFFSET_BAD
define
DW_DLE_PE_STRING_TOO_LONG
define
DW_DLE_IMAGE_FILE_UNKNOWN_TYPE
define
DW_DLE_LINE_TABLE_LINENO_ERROR
define
DW_DLE_PRODUCER_CODE_NOT_AVAILABLE
define
DW_DLE_NO_ELF_SUPPORT
define
DW_DLE_NO_STREAM_RELOC_SUPPORT
define
DW_DLE_RETURN_EMPTY_PUBNAMES_ERROR
define
DW_DLE_SECTION_SIZE_ERROR
define
DW_DLE_INTERNAL_NULL_POINTER
define
DW_DLE_SECTION_STRING_OFFSET_BAD
define
DW_DLE_SECTION_INDEX_BAD
define
DW_DLE_INTEGER_TOO_SMALL
define
DW_DLE_ELF_SECTION_LINK_ERROR
define
DW_DLE_ELF_SECTION_GROUP_ERROR
define
DW_DLE_ELF_SECTION_COUNT_MISMATCH
define
DW_DLE_ELF_STRING_SECTION_MISSING
define
DW_DLE_SEEK_OFF_END
define
DW_DLE_READ_OFF_END
define
DW_DLE_ELF_SECTION_ERROR
define
DW_DLE_ELF_STRING_SECTION_ERROR
define
DW_DLE_MIXING_SPLIT_DWARF_VERSIONS
define
DW_DLE_TAG_CORRUPT
define
DW_DLE_FORM_CORRUPT
define
DW_DLE_ATTR_CORRUPT
define
DW_DLE_ABBREV_ATTR_DUPLICATION
define
DW_DLE_DWP_SIGNATURE_MISMATCH
define
DW_DLE_CU_UT_TYPE_VALUE
define
DW_DLE_DUPLICATE_GNU_DEBUGLINK
define
DW_DLE_CORRUPT_GNU_DEBUGLINK
define
DW_DLE_CORRUPT_NOTE_GNU_DEBUGID
define
DW_DLE_CORRUPT_GNU_DEBUGID_SIZE
define
DW_DLE_CORRUPT_GNU_DEBUGID_STRING
define
DW_DLE_HEX_STRING_ERROR
define
DW_DLE_DECIMAL_STRING_ERROR
define
DW_DLE_PRO_INIT_EXTRAS_UNKNOWN
define
DW_DLE_PRO_INIT_EXTRAS_ERR
define
DW_DLE_NULL_ARGS_DWARF_ADD_PATH
define
DW_DLE_DWARF_INIT_DBG_NULL
define
DW_DLE_ELF_RELOC_SECTION_ERROR
define
DW_DLE_USER_DECLARED_ERROR
define
DW_DLE_RNGLISTS_ERROR
define
DW_DLE_LOCLISTS_ERROR
define
DW_DLE_SECTION_SIZE_OR_OFFSET_LARGE
define
DW_DLE_GDBINDEX_STRING_ERROR
define
DW_DLE_GNU_PUBNAMES_ERROR
define
DW_DLE_GNU_PUBTYPES_ERROR
define
DW_DLE_DUPLICATE_GNU_DEBUG_PUBNAMES
define
DW_DLE_DUPLICATE_GNU_DEBUG_PUBTYPES
define
DW_DLE_DEBUG_SUP_STRING_ERROR
define
DW_DLE_DEBUG_SUP_ERROR
define
DW_DLE_LOCATION_ERROR
define
DW_DLE_DEBUGLINK_PATH_SHORT
define
DW_DLE_SIGNATURE_MISMATCH
define
DW_DLE_MACRO_VERSION_ERROR
define
DW_DLE_NEGATIVE_SIZE
define
DW_DLE_UDATA_VALUE_NEGATIVE
LAST
MUST
EQUAL
LAST
ERROR
NUMBER
define
DW_DLE_LAST
define
DW_DLE_LO_USER
Taken
as
meaning
undefined
value
this
is
not
a
column
or
register
number
Only
present
at
libdwarf
runtime
Never
on
disk
DW_FRAME_
Values
present
on
disk
are
in
dwarf
h
define
DW_FRAME_UNDEFINED_VAL
Taken
as
meaning
same
value
as
caller
had
not
a
column
or
register
number
Only
present
at
libdwarf
runtime
Never
on
disk
DW_FRAME_
Values
present
on
disk
are
in
dwarf
h
define
DW_FRAME_SAME_VAL
error
return
values
define
DW_DLV_BADADDR
Dwarf_Addr
for
functions
returning
target
address
define
DW_DLV_NOCOUNT
Dwarf_Signed
for
functions
returning
count
define
DW_DLV_BADOFFSET
Dwarf_Off
for
functions
returning
offset
standard
return
values
for
functions
define
DW_DLV_NO_ENTRY
define
DW_DLV_OK
define
DW_DLV_ERROR
Special
values
for
offset_into_exception_table
field
of
dwarf
fde
s
The
following
value
indicates
that
there
is
no
Exception
table
offset
associated
with
a
dwarf
frame
define
DW_DLX_NO_EH_OFFSET
The
following
value
indicates
that
the
producer
was
unable
to
analyse
the
source
file
to
generate
Exception
tables
for
this
function
define
DW_DLX_EH_OFFSET_UNAVAILABLE
The
dwarf
specification
separates
FORMs
into
different
classes
To
do
the
separation
properly
requires
pieces
of
data
as
of
DWARF4
thus
the
function
arguments
listed
here
The
DWARF4
specification
class
definition
suffices
to
describe
all
DWARF
versions
See
section
Attribute
Encodings
A
return
of
DW_FORM_CLASS_UNKNOWN
means
we
could
not
properly
figure
out
what
form
class
it
is
DW_FORM_CLASS_FRAMEPTR
is
MIPS
IRIX
only
and
refers
to
the
DW_AT_MIPS_fde
attribute
a
reference
to
the
debug_frame
section
DWARF5
DW_FORM_CLASS_LOCLISTSPTR
is
like
DW_FORM_CLASS_LOCLIST
except
that
LOCLISTSPTR
is
aways
a
section
offset
never
an
index
and
LOCLISTSPTR
is
only
referenced
by
DW_AT_loclists_base
Note
DW_FORM_CLASS_LOCLISTSPTR
spelling
to
distinguish
from
DW_FORM_CLASS_LOCLISTPTR
DWARF5
DW_FORM_CLASS_RNGLISTSPTR
is
like
DW_FORM_CLASS_RNGLIST
except
that
RNGLISTSPTR
is
aways
a
section
offset
never
an
index
DW_FORM_CLASS_RNGLISTSPTR
is
only
referenced
by
DW_AT_rnglists_base
enum
Dwarf_Form_Class
DW_FORM_CLASS_UNKNOWN
DW_FORM_CLASS_ADDRESS
DW_FORM_CLASS_BLOCK
DW_FORM_CLASS_CONSTANT
DW_FORM_CLASS_EXPRLOC
DW_FORM_CLASS_FLAG
DW_FORM_CLASS_LINEPTR
DW_FORM_CLASS_LOCLISTPTR
DWARF2
only
DW_FORM_CLASS_MACPTR
DWARF2
only
DW_FORM_CLASS_RANGELISTPTR
DWARF2
only
DW_FORM_CLASS_REFERENCE
DW_FORM_CLASS_STRING
DW_FORM_CLASS_FRAMEPTR
MIPS
IRIX
DWARF2
only
DW_FORM_CLASS_MACROPTR
DWARF5
DW_FORM_CLASS_ADDRPTR
DWARF5
DW_FORM_CLASS_LOCLIST
DWARF5
DW_FORM_CLASS_LOCLISTSPTR
DWARF5
DW_FORM_CLASS_RNGLIST
DWARF5
DW_FORM_CLASS_RNGLISTSPTR
DWARF5
DW_FORM_CLASS_STROFFSETSPTR
DWARF5
These
support
opening
DWARF5
split
dwarf
objects
and
Elf
SHT_GROUP
blocks
of
DWARF
sections
define
DW_GROUPNUMBER_ANY
define
DW_GROUPNUMBER_BASE
define
DW_GROUPNUMBER_DWO
Dwarf
consumer
interface
initialization
and
termination
operations
Initialization
based
on
path
This
is
new
October
The
path
actually
used
is
copied
to
true_path_out
and
in
the
case
of
MacOS
dSYM
may
not
match
path
If
true_path_buffer
len
is
zero
or
true_path_out_buffer
is
zero
then
the
Special
MacOS
processing
will
not
occur
nor
will
the
GNU_debuglink
processing
occur
In
case
GNU
debuglink
data
was
followed
or
MacOS
dSYM
applies
the
true_path_out
will
not
match
path
So
consider
the
value
put
in
true_path_out
the
actual
file
name
reserved1
should
all
be
passed
as
zero
int
dwarf_init_path
const
char
path
char
true_path_out_buffer
unsigned
int
true_path_bufferlen
unsigned
int
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Error
error
New
October
Following
GNU
debuglink
to
the
true
path
with
DWARF
if
there
is
appropriate
debuglink
data
available
The
path
actually
used
is
copied
to
true_path_out
and
in
the
case
of
MacOS
dSYM
may
not
match
path
In
case
GNU
debuglink
data
was
followed
the
true_path_out
will
not
match
path
If
debuglink
missing
from
the
Elf
executable
or
shared
object
ie
it
is
a
normal
object
or
unusable
by
libdwarf
or
true_path_buffer
len
is
zero
or
true_path_out_buffer
is
zero
the
accepts
the
path
given
as
the
object
to
report
on
Passing
dl_path_array
and
dl_path_array
size
zero
suffices
unless
one
has
unusual
locations
for
debuglink
objects
If
true_path_buffer
len
is
zero
or
true_path_out_buffer
is
zero
then
the
Special
MacOS
processing
will
not
occur
either
int
dwarf_init_path_dl
const
char
path
char
true_path_out_buffer
unsigned
int
true_path_bufferlen
unsigned
int
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
char
dl_path
array
unsigned
int
dl_path
array
size
unsigned
char
path_source
const
char
reserved1
Dwarf_Unsigned
reserved2
Dwarf_Unsigned
reserved3
Dwarf_Error
error
Initialization
based
on
Unix
etc
open
fd
New
March
int
dwarf_init_b
int
fd
unsigned
int
groupnumber
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
Dwarf_Debug
dbg
Dwarf_Error
error
int
dwarf_add_file_path
Dwarf_Debug
dbg
const
char
file_name
Dwarf_Error
error
Undocumented
function
for
memory
allocator
void
dwarf_print_memory_stats
Dwarf_Debug
dbg
int
dwarf_get_elf
Dwarf_Debug
dbg
void
return_elfptr
Dwarf_Error
error
int
dwarf_finish
Dwarf_Debug
dbg
Dwarf_Error
error
NEW
March
int
dwarf_object_init_b
Dwarf_Obj_Access_Interface
obj
Dwarf_Handler
errhand
Dwarf_Ptr
errarg
unsigned
int
groupnumber
Dwarf_Debug
dbg
Dwarf_Error
error
int
dwarf_set_tied_dbg
Dwarf_Debug
basedbg
Dwarf_Debug
tied_dbg
Dwarf_Error
error
Likely
not
very
useful
int
dwarf_get_tied_dbg
Dwarf_Debug
dbg
Dwarf_Debug
tieddbg_out
Dwarf_Error
error
int
dwarf_object_finish
Dwarf_Debug
dbg
Dwarf_Error
error
Returns
the
version
string
Example
which
is
in
ISO
date
format
const
char
dwarf_package_version
void
Section
name
access
Because
sections
might
now
end
with
dwo
or
be
zdebug
or
might
not
int
dwarf_get_die_section_name
Dwarf_Debug
dbg
Dwarf_Bool
is_info
const
char
sec_name
Dwarf_Error
error
int
dwarf_get_die_section_name_b
Dwarf_Die
die
const
char
sec_name
Dwarf_Error
error
int
dwarf_get_real_section_name
Dwarf_Debug
dbg
const
char
std_section_name
const
char
actual_sec_name_out
Dwarf_Small
marked_compressed
zdebug
Dwarf_Small
marked_zlib_compressed
ZLIB
string
Dwarf_Small
marked_shf_compressed
SHF_COMPRESSED
Dwarf_Unsigned
compressed_length
Dwarf_Unsigned
uncompressed_length
Dwarf_Error
error
dwarf_next_cu_header_d
traverses
debug_types
CU
headers
New
in
May
int
dwarf_next_cu_header_d
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Unsigned
cu_header_length
Dwarf_Half
version_stamp
Dwarf_Off
abbrev_offset
Dwarf_Half
address_size
Dwarf_Half
length_size
Dwarf_Half
extension_size
Dwarf_Sig8
type
signature
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_header_offset
Dwarf_Half
header_cu_type
Dwarf_Error
error
int
dwarf_siblingof_b
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Bool
is_info
Dwarf_Die
return_siblingdie
Dwarf_Error
error
New
April
int
dwarf_die_from_hash_signature
Dwarf_Debug
dbg
Dwarf_Sig8
hash_sig
const
char
sig_type
tu
or
cu
Dwarf_Die
returned_CU_die
Dwarf_Error
error
int
dwarf_child
Dwarf_Die
die
Dwarf_Die
return_childdie
Dwarf_Error
error
dwarf_offdie_b
new
October
Finding
die
given
global
not
CU
relative
offset
Applies
to
debug_info
is_info
true
or
debug_types
is_info
false
int
dwarf_offdie_b
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Die
return_die
Dwarf_Error
error
New
February
returns
DIE
and
is_info
flag
if
it
finds
the
referenced
DW_UT_split_type
or
DW_UT_type
CU
int
dwarf_find_die_given_sig8
Dwarf_Debug
dbg
Dwarf_Sig8
ref
Dwarf_Die
die_out
Dwarf_Bool
is_info
Dwarf_Error
error
Returns
the
is_info
flag
Needed
so
client
software
knows
if
a
DIE
is
in
debug_info
or
debug_types
New
October
Dwarf_Bool
dwarf_get_die_infotypes_flag
Dwarf_Die
die
New
December
Any
Dwarf_Die
will
work
The
values
returned
are
about
the
CU
itself
not
a
DIE
int
dwarf_cu_header_basics
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Bool
is_info
Dwarf_Bool
is_dwo
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Off
offset_of_length
Dwarf_Unsigned
total_byte_length
Dwarf_Error
error
New
March
So
we
can
associate
a
DIE
s
abbreviations
with
the
contents
the
abbreviations
section
int
dwarf_die_abbrev_global_offset
Dwarf_Die
die
Dwarf_Off
abbrev_offset
Dwarf_Unsigned
abbrev_count
Dwarf_Error
error
operations
on
DIEs
int
dwarf_tag
Dwarf_Die
die
Dwarf_Half
return_tag
Dwarf_Error
error
dwarf_dieoffset
returns
the
global
debug_info
section
offset
not
the
CU
relative
offset
int
dwarf_dieoffset
Dwarf_Die
die
Dwarf_Off
return_offset
Dwarf_Error
error
NEW
October
DWARF5
The
DIE
here
can
be
any
DIE
in
the
relevant
CU
index
is
an
index
into
debug_addr
This
will
look
first
for
debug_addr
in
the
dbg
object
DIE
and
if
not
there
because
the
dbg
object
is
a
dwo
or
dwp
split
dwarf
object
will
look
in
the
tied
object
if
tied
is
available
int
dwarf_debug_addr_index_to_addr
Dwarf_Die
die
Dwarf_Unsigned
index
Dwarf_Addr
return_addr
Dwarf_Error
error
Reading
a
CU
DIE
with
DW_AT_low_pc
an
indexed
value
can
be
problematic
as
that
interacts
with
DW_AT_addr_base
in
that
DIE
Here
is
a
test
readers
may
find
useful
Dwarf_Bool
dwarf_addr_form_is_indexed
int
form
dwarf_CU_dieoffset_given_die
returns
the
global
debug_info
section
offset
of
the
CU
die
that
is
the
CU
containing
the
given_die
the
passed
in
DIE
can
be
any
DIE
This
information
makes
it
possible
for
a
consumer
to
find
and
print
CU
context
information
for
any
die
See
also
dwarf_get_cu_die_offset_given_cu_header_offset_b
int
dwarf_CU_dieoffset_given_die
Dwarf_Die
given_die
Dwarf_Off
return_offset
Dwarf_Error
error
dwarf_die_CU_offset
returns
the
CU
relative
offset
not
the
global
debug_info
section
offset
given
any
DIE
in
the
CU
See
also
dwarf_CU_dieoffset_given_die
int
dwarf_die_CU_offset
Dwarf_Die
die
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_die_CU_offset_range
Dwarf_Die
die
Dwarf_Off
return_CU_header_offset
Dwarf_Off
return_CU_length_bytes
Dwarf_Error
error
int
dwarf_attr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Attribute
returned_attr
Dwarf_Error
error
int
dwarf_die_text
Dwarf_Die
die
Dwarf_Half
attr
char
ret_name
Dwarf_Error
error
int
dwarf_diename
Dwarf_Die
die
char
diename
Dwarf_Error
error
Returns
the
abbrev
code
of
the
die
Cannot
fail
int
dwarf_die_abbrev_code
Dwarf_Die
die
Returns
a
flag
through
ab_has_child
Non
zero
if
the
DIE
has
children
zero
if
it
does
not
int
dwarf_die_abbrev_children_flag
Dwarf_Die
die
Dwarf_Half
ab_has_child
Validate
the
sibling
DIE
This
only
makes
sense
to
call
if
the
sibling
s
DIEs
have
been
travsersed
and
dwarf_child
called
on
each
so
that
the
last
DIE
dwarf_child
saw
was
the
last
Essentially
ensuring
that
after
such
traversal
that
we
are
in
the
same
place
a
sibling
attribute
would
identify
In
case
we
return
DW_DLV_ERROR
the
global
offset
of
the
last
DIE
traversed
by
dwarf_child
is
returned
through
offset
int
dwarf_validate_die_sibling
Dwarf_Die
sibling
Dwarf_Off
offset
convenience
functions
alternative
to
using
dwarf_attrlist
int
dwarf_hasattr
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Bool
returned_bool
Dwarf_Error
error
Returns
the
children
offsets
for
the
given
offset
int
dwarf_offset_list
Dwarf_Debug
dbg
Dwarf_Off
offset
Dwarf_Bool
is_info
Dwarf_Off
offbuf
Dwarf_Unsigned
offcnt
Dwarf_Error
error
BEGIN
debug_gnu_pubnames
typenames
access
calling
these
Gnu_Index
as
a
general
reference
int
dwarf_get_gnu_index_head
Dwarf_Debug
dbg
The
following
arg
false
to
select
gnu_pubtypes
Dwarf_Bool
for_gdb_pubnames
Dwarf_Gnu_Index_Head
index_head_out
Dwarf_Unsigned
index_block_count_out
Dwarf_Error
error
Frees
all
resources
used
for
the
indexes
void
dwarf_gnu_index_dealloc
Dwarf_Gnu_Index_Head
head
int
dwarf_get_gnu_index_block
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
number
Dwarf_Unsigned
block_length
Dwarf_Half
version
Dwarf_Unsigned
offset_into_debug_info
Dwarf_Unsigned
size_of_debug_info_area
Dwarf_Unsigned
count_of_index_entries
Dwarf_Error
error
int
dwarf_get_gnu_index_block_entry
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
blocknumber
Dwarf_Unsigned
entrynumber
Dwarf_Unsigned
offset_in_debug_info
const
char
name_string
unsigned
char
flagbyte
unsigned
char
staticorglobal
unsigned
char
typeofentry
Dwarf_Error
error
END
debug_gnu_pubnames
typenames
access
BEGIN
loclist_c
interfaces
NEW
October
This
works
for
any
attribute
that
identifies
a
loclist
or
a
locexpr
When
the
attribute
is
a
locexpr
a
single
loclist
created
by
libdwarf
is
attached
to
loclist_head
int
dwarf_get_loclist_c
Dwarf_Attribute
attr
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
locCount
Dwarf_Error
error
define
DW_LKIND_expression
DWARF2
define
DW_LKIND_loclist
DWARF
define
DW_LKIND_GNU_exp_list
GNU
DWARF4
dwo
extension
define
DW_LKIND_loclists
DWARF5
loclists
define
DW_LKIND_unknown
DWARF2
kind
is
DWARF3
kind
is
DWARF5
kind
is
int
dwarf_get_loclist_head_kind
Dwarf_Loc_Head_c
ll_header
unsigned
int
lkind
Dwarf_Error
error
Cooked
value
means
the
values
from
the
location
description
raw
values
after
base
values
applied
debug_addr_unavailable
non
zero
means
the
record
from
a
skeleton
unit
could
not
be
accessed
from
the
dwo
section
or
dwp
object
so
the
cooked
values
could
not
be
calculated
int
dwarf_get_locdesc_entry_d
Dwarf_Loc_Head_c
loclist_head
Dwarf_Unsigned
index
identifies
type
of
locdesc
entry
Dwarf_Small
lle_value_out
Dwarf_Unsigned
rawlowpc
Dwarf_Unsigned
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lowpc_out
cooked
value
Dwarf_Addr
hipc_out
cooked
value
Dwarf_Unsigned
loclist_count_out
Dwarf_Locdesc_c
locentry_out
Dwarf_Small
loclist_source_out
or
Dwarf_Unsigned
expression_offset_out
Dwarf_Unsigned
locdesc_offset_out
Dwarf_Error
error
New
June
for
DWARF5
and
all
earlier
int
dwarf_get_location_op_value_d
Dwarf_Locdesc_c
locdesc
Dwarf_Unsigned
index
Dwarf_Small
atom_out
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Unsigned
rawop1
Dwarf_Unsigned
rawop2
Dwarf_Unsigned
rawop3
Dwarf_Unsigned
offset_for_branch
Dwarf_Error
error
int
dwarf_get_location_op_value_c
Dwarf_Locdesc_c
locdesc
Dwarf_Unsigned
index
Dwarf_Small
atom_out
Dwarf_Unsigned
operand1
Dwarf_Unsigned
operand2
Dwarf_Unsigned
operand3
Dwarf_Unsigned
offset_for_branch
Dwarf_Error
error
int
dwarf_loclist_from_expr_c
Dwarf_Debug
dbg
Dwarf_Ptr
expression_in
Dwarf_Unsigned
expression_length
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Small
dwarf_version
Dwarf_Loc_Head_c
loc_head
Dwarf_Unsigned
listlen
Dwarf_Error
error
This
frees
all
memory
allocated
by
the
applicable
dwarf_get_loclist_c
void
dwarf_loc_head_c_dealloc
Dwarf_Loc_Head_c
loclist_head
END
loclist_c
interfaces
int
dwarf_lowpc
Dwarf_Die
die
Dwarf_Addr
returned_addr
Dwarf_Error
error
When
the
highpc
attribute
is
of
class
constant
it
is
not
an
address
it
is
an
offset
from
the
base
address
such
as
lowpc
of
the
function
This
is
therefore
a
required
interface
for
DWARF4
style
DW_AT_highpc
int
dwarf_highpc_b
Dwarf_Die
die
Dwarf_Addr
return_value
Dwarf_Half
return_form
enum
Dwarf_Form_Class
return_class
Dwarf_Error
error
This
works
for
DWARF2
and
DWARF3
styles
of
DW_AT_highpc
but
not
for
the
DWARF4
class
constant
forms
If
the
FORM
is
of
class
constant
this
returns
an
error
int
dwarf_highpc
Dwarf_Die
die
Dwarf_Addr
returned_addr
Dwarf_Error
error
New
January
int
dwarf_dietype_offset
Dwarf_Die
die
Dwarf_Off
return_off
Dwarf_Error
error
int
dwarf_bytesize
Dwarf_Die
die
Dwarf_Unsigned
returned_size
Dwarf_Error
error
int
dwarf_bitsize
Dwarf_Die
die
Dwarf_Unsigned
returned_size
Dwarf_Error
error
int
dwarf_bitoffset
Dwarf_Die
die
Dwarf_Unsigned
returned_offset
Dwarf_Error
error
int
dwarf_srclang
Dwarf_Die
die
Dwarf_Unsigned
returned_lang
Dwarf_Error
error
int
dwarf_arrayorder
Dwarf_Die
die
Dwarf_Unsigned
returned_order
Dwarf_Error
error
end
of
convenience
function
list
this
is
the
main
interface
to
attributes
of
a
DIE
int
dwarf_attrlist
Dwarf_Die
die
Dwarf_Attribute
attrbuf
Dwarf_Signed
attrcount
Dwarf_Error
error
query
operations
for
attributes
int
dwarf_hasform
Dwarf_Attribute
attr
Dwarf_Half
form
Dwarf_Bool
returned_bool
Dwarf_Error
error
int
dwarf_whatform
Dwarf_Attribute
attr
Dwarf_Half
returned_final_form
Dwarf_Error
error
int
dwarf_whatform_direct
Dwarf_Attribute
attr
Dwarf_Half
returned_initial_form
Dwarf_Error
error
int
dwarf_whatattr
Dwarf_Attribute
attr
Dwarf_Half
returned_attr_num
Dwarf_Error
error
The
following
are
concerned
with
the
Primary
Interface
getting
the
actual
data
values
One
function
per
kind
of
FORM
dwarf_formref
returns
thru
return_offset
a
CU
relative
offset
and
does
not
allow
DW_FORM_ref_addr
int
dwarf_formref
Dwarf_Attribute
attr
Dwarf_Off
return_offset
Dwarf_Error
error
dwarf_global_formref
returns
thru
return_offset
a
debug_info
relative
offset
and
does
allow
all
reference
forms
int
dwarf_global_formref
Dwarf_Attribute
attr
Dwarf_Off
return_offset
Dwarf_Error
error
dwarf_formsig8
returns
in
the
caller
provided
byte
area
the
bytes
of
a
DW_FORM_ref_sig8
Not
a
string
int
dwarf_formsig8
Dwarf_Attribute
attr
Dwarf_Sig8
returned
sig
bytes
Dwarf_Error
error
dwarf_formsig8_const
returns
in
the
caller
provided
byte
area
the
bytes
of
a
form
const
DW_FORM_data8
Not
a
string
int
dwarf_formsig8_const
Dwarf_Attribute
attr
Dwarf_Sig8
returned
sig
bytes
Dwarf_Error
error
int
dwarf_formaddr
Dwarf_Attribute
attr
Dwarf_Addr
returned_addr
Dwarf_Error
error
Part
of
DebugFission
So
a
consumer
can
get
the
index
when
the
object
with
the
actual
debug_addr
section
is
elsewhere
And
so
a
print
application
can
print
the
index
New
May
int
dwarf_get_debug_addr_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
int
dwarf_formflag
Dwarf_Attribute
attr
Dwarf_Bool
returned_bool
Dwarf_Error
error
int
dwarf_formdata16
Dwarf_Attribute
attr
Dwarf_Form_Data16
returned_val
Dwarf_Error
error
int
dwarf_formudata
Dwarf_Attribute
attr
Dwarf_Unsigned
returned_val
Dwarf_Error
error
int
dwarf_formsdata
Dwarf_Attribute
attr
Dwarf_Signed
returned_val
Dwarf_Error
error
int
dwarf_formblock
Dwarf_Attribute
attr
Dwarf_Block
returned_block
Dwarf_Error
error
int
dwarf_formstring
Dwarf_Attribute
attr
char
returned_string
Dwarf_Error
error
DebugFission
So
a
DWARF
print
application
can
get
the
string
index
DW_FORM_strx
and
print
it
A
convenience
function
New
May
int
dwarf_get_debug_str_index
Dwarf_Attribute
attr
Dwarf_Unsigned
return_index
Dwarf_Error
error
int
dwarf_formexprloc
Dwarf_Attribute
attr
Dwarf_Unsigned
return_exprlen
Dwarf_Ptr
block_ptr
Dwarf_Error
error
end
attribute
query
operations
If
we
have
two
level
line
tables
this
will
return
the
logicals
table
in
linebuf
and
the
actuals
table
in
linebuf_actuals
For
old
style
one
level
tables
it
will
return
the
single
table
through
linebuf
and
the
value
returned
through
linecount_actuals
will
be
The
actual
version
number
is
returned
through
version
For
two
level
line
tables
the
version
returned
will
be
This
interface
can
return
data
from
two
level
line
tables
which
are
experimental
Most
users
will
not
wish
to
use
dwarf_srclines_two_level
int
dwarf_srclines_two_level
Dwarf_Die
die
Dwarf_Unsigned
version
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Error
error
New
October
must
be
used
to
deallocating
what
is
allocated
by
dwarf_srclines_b
and
dwarf_srclines_from_linecontext
use
Works
for
DWARF2
and
for
experimental
line
tables
New
work
should
use
the
new
Dwarf_Line_Context
interface
This
interface
only
reads
the
line
table
header
so
it
takes
relatively
little
time
int
dwarf_srclines_b
Dwarf_Die
die
Dwarf_Unsigned
version_out
Dwarf_Small
table_count
Dwarf_Line_Context
linecontext
Dwarf_Error
error
Functions
passing
in
a
Dwarf_Line_Context
are
only
available
if
dwarf_srclines_b
was
used
to
access
line
table
information
New
October
Returns
line
details
Works
for
DWARF2
If
linecount
returned
is
zero
this
is
a
line
table
with
no
lines
int
dwarf_srclines_from_linecontext
Dwarf_Line_Context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Error
error
New
October
Returns
line
details
Works
for
DWARF2
and
for
experimental
two
level
line
tables
A
single
level
table
will
have
linebuf_actuals
and
linecount_actuals
set
to
int
dwarf_srclines_two_level_from_linecontext
Dwarf_Line_Context
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Line
linebuf_actuals
Dwarf_Signed
linecount_actuals
Dwarf_Error
error
dwarf_srclines_dealloc_b
created
October
is
the
appropriate
method
for
deallocating
everything
and
dwarf_srclines_from_linecontext
dwarf_srclines_twolevel_from_linecontext
and
dwarf_srclines_b
allocate
void
dwarf_srclines_dealloc_b
Dwarf_Line_Context
line_context
New
October
The
offset
is
in
the
relevent
debug_line
or
debug_line
dwo
section
and
in
a
split
dwarf
package
file
includes
the
base
line
table
offset
int
dwarf_srclines_table_offset
Dwarf_Line_Context
line_context
Dwarf_Unsigned
offset
Dwarf_Error
error
New
October
Compilation
Directory
name
for
the
current
CU
section
and
in
a
split
dwarf
package
file
includes
the
base
line
table
offset
Do
not
free
the
string
it
is
in
a
dwarf
section
int
dwarf_srclines_comp_dir
Dwarf_Line_Context
line_context
const
char
compilation_directory
Dwarf_Error
error
New
October
Part
of
the
two
level
line
table
extension
Count
is
the
real
count
of
suprogram
array
entries
int
dwarf_srclines_subprog_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
New
October
Index
starts
with
last
is
count
int
dwarf_srclines_subprog_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Unsigned
decl_file
Dwarf_Unsigned
decl_line
Dwarf_Error
error
New
October
Count
is
the
real
count
of
files
array
entries
This
remains
supported
though
it
is
pretty
useless
for
DWARF5
To
process
DWARF5
as
well
as
DWARF
in
a
uniform
fashion
use
dwarf_srclines_files_indexes
instead
int
dwarf_srclines_files_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
New
March
Count
is
the
real
count
of
files
array
entries
Since
DWARF
are
zero
origin
indexes
and
DWARF5
and
later
are
one
origin
this
function
replaces
dwarf_srclines_files_count
int
dwarf_srclines_files_indexes
Dwarf_Line_Context
line_context
Dwarf_Signed
baseindex
Dwarf_Signed
count
Dwarf_Signed
endindex
Dwarf_Error
error
New
March
Has
the
md5ptr
field
so
cases
where
DW_LNCT_MD5
is
present
can
return
pointer
to
the
MD5
value
With
DWARF
index
starts
with
See
dwarf_srclines_files_indexes
which
makes
indexing
through
the
files
easy
int
dwarf_srclines_files_data_b
Dwarf_Line_Context
line_context
Dwarf_Signed
index_in
const
char
name
Dwarf_Unsigned
directory_index
Dwarf_Unsigned
last_mod_time
Dwarf_Unsigned
file_length
Dwarf_Form_Data16
md5ptr
Dwarf_Error
error
New
October
Count
is
the
real
count
of
include
array
entries
int
dwarf_srclines_include_dir_count
Dwarf_Line_Context
line_context
Dwarf_Signed
count
Dwarf_Error
error
New
October
Index
starts
with
last
is
count
int
dwarf_srclines_include_dir_data
Dwarf_Line_Context
line_context
Dwarf_Signed
index
const
char
name
Dwarf_Error
error
New
October
The
DWARF
version
number
of
this
compile
unit
in
the
debug_lines
section
and
the
number
of
actual
tables
header
with
no
lines
standard
table
or
experimental
int
dwarf_srclines_version
Dwarf_Line_Context
line_context
Dwarf_Unsigned
version
Dwarf_Small
table_count
Dwarf_Error
error
int
dwarf_get_line_section_name_from_die
Dwarf_Die
die
const
char
section_name_out
Dwarf_Error
error
While
filecount
is
signed
the
value
returned
through
the
pointer
is
never
negative
Original
libdwarf
from
int
dwarf_srcfiles
Dwarf_Die
die
char
srcfiles
Dwarf_Signed
filecount
Dwarf_Error
error
int
dwarf_linebeginstatement
Dwarf_Line
line
Dwarf_Bool
returned_bool
Dwarf_Error
error
int
dwarf_lineendsequence
Dwarf_Line
line
Dwarf_Bool
returned_bool
Dwarf_Error
error
int
dwarf_lineno
Dwarf_Line
line
Dwarf_Unsigned
returned_lineno
Dwarf_Error
error
int
dwarf_line_srcfileno
Dwarf_Line
line
Dwarf_Unsigned
ret_fileno
Dwarf_Error
error
Is
the
line
address
from
DW_LNS_set_address?
int
dwarf_line_is_addr_set
Dwarf_Line
line
Dwarf_Bool
is_addr_set
Dwarf_Error
error
int
dwarf_lineaddr
Dwarf_Line
line
Dwarf_Addr
returned_addr
Dwarf_Error
error
dwarf_lineoff
is
OBSOLETE
as
of
December
Do
not
use
int
dwarf_lineoff
Dwarf_Line
line
Dwarf_Signed
returned_lineoffset
Dwarf_Error
error
dwarf_lineoff_b
correctly
returns
an
unsigned
column
number
through
the
pointer
returned_lineoffset
dwarf_lineoff_b
is
new
in
December
int
dwarf_lineoff_b
Dwarf_Line
line
Dwarf_Unsigned
returned_lineoffset
Dwarf_Error
error
int
dwarf_linesrc
Dwarf_Line
line
char
returned_name
Dwarf_Error
error
int
dwarf_lineblock
Dwarf_Line
line
Dwarf_Bool
returned_bool
Dwarf_Error
error
We
gather
these
into
one
call
as
it
s
likely
one
will
want
all
or
none
of
them
int
dwarf_prologue_end_etc
Dwarf_Line
line
Dwarf_Bool
prologue_end
Dwarf_Bool
eplogue_begin
Dwarf_Unsigned
isa
Dwarf_Unsigned
discriminator
Dwarf_Error
error
End
line
table
operations
Two
level
line
tables
When
reading
from
an
actuals
table
dwarf_line_logical
returns
the
logical
row
number
for
the
line
int
dwarf_linelogical
Dwarf_Line
line
Dwarf_Unsigned
returned_logical
Dwarf_Error
error
Two
level
line
tables
When
reading
from
a
logicals
table
dwarf_linecontext
returns
the
logical
row
number
corresponding
the
the
calling
context
for
an
inlined
call
int
dwarf_linecontext
Dwarf_Line
line
Dwarf_Unsigned
returned_context
Dwarf_Error
error
Two
level
line
tables
When
reading
from
a
logicals
table
dwarf_linesubprogno
returns
the
index
in
the
subprograms
table
of
the
inlined
subprogram
int
dwarf_line_subprogno
Dwarf_Line
line
Dwarf_Unsigned
ret_subprogno
Dwarf_Error
error
Two
level
line
tables
When
reading
from
a
logicals
table
dwarf_linesubprog
returns
the
name
of
the
inlined
subprogram
its
declaration
filename
and
its
declaration
line
number
if
available
int
dwarf_line_subprog
Dwarf_Line
line
char
returned_subprog_name
char
returned_filename
Dwarf_Unsigned
returned_lineno
Dwarf_Error
error
End
of
line
table
interfaces
debug_names
names
table
interfaces
DWARF5
New
April
int
dwarf_debugnames_header
Dwarf_Debug
dbg
Dwarf_Dnames_Head
dn_out
dn_count_out
returns
the
number
of
name
indexes
in
the
debug_names
section
Dwarf_Unsigned
dn_index_count_out
Dwarf_Error
error
Since
there
may
be
multiple
name
indexes
in
a
debug_names
section
we
use
index_number
starting
at
through
dn_index_count_out
int
dwarf_debugnames_sizes
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
section_offset
Dwarf_Unsigned
version
Dwarf_Unsigned
offset_size
or
The
counts
are
entry
counts
not
byte
sizes
Dwarf_Unsigned
comp_unit_count
Dwarf_Unsigned
local_type_unit_count
Dwarf_Unsigned
foreign_type_unit_count
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
name_count
The
following
are
counted
in
bytes
Dwarf_Unsigned
indextable_overall_length
Dwarf_Unsigned
abbrev_table_size
Dwarf_Unsigned
entry_pool_size
Dwarf_Unsigned
augmentation_string_size
Dwarf_Error
error
int
dwarf_debugnames_cu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
int
dwarf_debugnames_local_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_number
Dwarf_Unsigned
offset_count
Dwarf_Unsigned
offset
Dwarf_Error
error
int
dwarf_debugnames_foreign_tu_entry
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
sig_number
Dwarf_Unsigned
sig_mininum
Dwarf_Unsigned
sig_count
Dwarf_Sig8
signature
Dwarf_Error
error
int
dwarf_debugnames_bucket
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
bucket_number
Dwarf_Unsigned
bucket_count
Dwarf_Unsigned
index_of_name_entry
Dwarf_Error
error
int
dwarf_debugnames_name
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
name_entry
Dwarf_Unsigned
names_count
Dwarf_Sig8
signature
Dwarf_Unsigned
offset_to_debug_str
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Error
error
int
dwarf_debugnames_abbrev_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
The
number
of
valid
abbrev_entry
values
to
number_of_abbrev
Dwarf_Unsigned
number_of_abbrev
The
number
of
attr
form
pairs
not
counting
the
trailing
pair
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
int
dwarf_debugnames_abbrev_by_code
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
The
number
of
this
code
tag
as
an
array
index
Dwarf_Unsigned
index_of_abbrev
The
number
of
attr
form
pairs
not
counting
the
trailing
pair
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
int
dwarf_debugnames_abbrev_form_by_index
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
abbrev_entry_index
Dwarf_Unsigned
abbrev_form_index
Dwarf_Unsigned
name_index_attr
Dwarf_Unsigned
form
Dwarf_Unsigned
number_of_attr_form_entries
Dwarf_Error
error
This
combined
with
dwarf_debugnames_entrypool_values
lets
one
examine
as
much
or
as
little
of
an
entrypool
as
one
wants
to
by
alternately
calling
these
two
functions
int
dwarf_debugnames_entrypool
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
offset_in_entrypool
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
tag
Dwarf_Unsigned
value_count
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_of_initial_value
Dwarf_Error
error
Caller
knowing
array
size
needed
passes
in
arrays
it
allocates
of
for
idx
form
offset
size
values
and
signature
values
Caller
must
examine
idx
number
and
form
to
decide
for
each
array
element
whether
the
offset
or
the
signature
contains
the
value
So
this
returns
all
the
values
for
the
abbrev
code
And
points
via
offset_of_next
to
the
next
abbrev
code
int
dwarf_debugnames_entrypool_values
Dwarf_Dnames_Head
dn
Dwarf_Unsigned
index_number
Dwarf_Unsigned
index_of_abbrev
Dwarf_Unsigned
offset_in_entrypool_of_values
Dwarf_Unsigned
array_dw_idx_number
Dwarf_Unsigned
array_form
Dwarf_Unsigned
array_of_offsets
Dwarf_Sig8
array_of_signatures
offset
of
the
next
entrypool
entry
Dwarf_Unsigned
offset_of_next_entrypool
Dwarf_Error
error
FIXME
add
interfaces
for
string
search
given
hash
and
string
end
of
debug_names
interfaces
New
October
Access
to
the
GNU
section
named
gnu_debuglink
and
or
the
section
note
gnu
build
id
See
https
sourceware
org
gdb
onlinedocs
gdb
Separate
Debug
Files
html
If
no
debuglink
then
name_returned
crc_returned
and
debuglink_path_returned
will
get
set
through
the
pointers
If
no
note
gnu
build
id
then
buildid_length_returned
and
buildid_returned
will
be
set
through
the
pointers
Caller
frees
space
returned
by
debuglink_fullpath_returned
See
libdwarf2
mm
revision
or
later
for
additional
important
details
int
dwarf_gnu_debuglink
Dwarf_Debug
dbg
char
debuglink_path_returned
unsigned
char
crc_returned
from
the
debuglink
section
char
debuglink_fullpath_returned
free
this
unsigned
int
debuglink_path_count_returned
unsigned
int
buildid_type_returned
char
buildid_owner_name_returned
unsigned
char
buildid_returned
unsigned
int
buildid_length_returned
char
paths_returned
unsigned
int
paths_length_returned
Dwarf_Error
error
Only
useful
inside
dwarfexample
dwdebuglink
c
so
we
can
show
all
that
is
going
on
int
dwarf_add_debuglink_global_path
Dwarf_Debug
dbg
const
char
pathname
Dwarf_Error
error
crc32
used
for
debuglink
crc
calculation
Caller
passes
pointer
to
array
of
unsigned
char
provided
by
the
caller
and
if
this
returns
DW_DLV_OK
that
is
filled
in
int
dwarf_crc32
Dwarf_Debug
dbg
unsigned
char
crcbuf
Dwarf_Error
error
Public
interface
to
the
real
crc
calculation
just
in
case
some
find
it
useful
unsigned
int
dwarf_basic_crc32
const
unsigned
char
buf
unsigned
long
len
unsigned
int
init
global
name
space
operations
debug_pubnames
access
The
pubnames
and
similar
sections
are
rarely
used
Few
compilers
emit
them
They
are
DWARF
only
not
DWARF
New
March
Special
for
dwarfdump
Sets
a
flag
in
the
dbg
Always
returns
DW_DLV_OK
and
as
of
March
never
touches
error
int
dwarf_return_empty_pubnames
Dwarf_Debug
dbg
int
flag
Dwarf_Error
error
int
dwarf_get_globals
Dwarf_Debug
dbg
Dwarf_Global
globals
Dwarf_Signed
number_of_globals
Dwarf_Error
error
void
dwarf_globals_dealloc
Dwarf_Debug
dbg
Dwarf_Global
globals
Dwarf_Signed
number_of_globals
int
dwarf_globname
Dwarf_Global
glob
char
returned_name
Dwarf_Error
error
int
dwarf_global_die_offset
Dwarf_Global
global
Dwarf_Off
return_offset
Dwarf_Error
error
This
returns
the
CU
die
global
offset
if
one
knows
the
CU
header
global
offset
See
also
dwarf_CU_dieoffset_given_die
The
_b
form
is
new
October
int
dwarf_get_cu_die_offset_given_cu_header_offset_b
Dwarf_Debug
Dwarf_Off
in_cu_header_offset
Dwarf_Bool
is_info
True
means
look
in
debug_Info
false
use
debug_types
Dwarf_Off
out_cu_die_offset
Dwarf_Error
err
int
dwarf_global_cu_offset
Dwarf_Global
global
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_global_name_offsets
Dwarf_Global
global
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
New
February
For
more
complete
dwarfdump
printing
For
each
CU
represented
in
debug_pubnames
etc
there
is
a
debug_pubnames
header
For
any
given
Dwarf_Global
this
returns
the
content
of
the
applicable
header
int
dwarf_get_globals_header
Dwarf_Global
global
Dwarf_Off
offset_pub_header
Dwarf_Unsigned
length_size
Dwarf_Unsigned
length_pub
Dwarf_Unsigned
version
Dwarf_Unsigned
header_info_offset
Dwarf_Unsigned
info_length
Dwarf_Error
error
Static
function
name
operations
int
dwarf_get_funcs
Dwarf_Debug
dbg
Dwarf_Func
funcs
Dwarf_Signed
number_of_funcs
Dwarf_Error
error
void
dwarf_funcs_dealloc
Dwarf_Debug
dbg
Dwarf_Func
funcs
Dwarf_Signed
number_of_funcs
int
dwarf_funcname
Dwarf_Func
func
char
returned_name
Dwarf_Error
error
int
dwarf_func_die_offset
Dwarf_Func
func
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_func_cu_offset
Dwarf_Func
func
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_func_name_offsets
Dwarf_Func
func
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
jUser
defined
type
name
operations
SGI
IRIX
debug_typenames
section
Same
content
as
DWARF3
debug_pubtypes
but
defined
years
before
debug_pubtypes
was
defined
SGI
IRIX
only
int
dwarf_get_types
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
number_of_types
Dwarf_Error
error
void
dwarf_types_dealloc
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
number_of_types
int
dwarf_typename
Dwarf_Type
type
char
returned_name
Dwarf_Error
error
int
dwarf_type_die_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_type_cu_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_type_name_offsets
Dwarf_Type
type
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
User
defined
type
name
operations
DWARF3
debug_pubtypes
section
int
dwarf_get_pubtypes
Dwarf_Debug
dbg
Dwarf_Type
types
Dwarf_Signed
number_of_types
Dwarf_Error
error
void
dwarf_pubtypes_dealloc
Dwarf_Debug
dbg
Dwarf_Type
pubtypes
Dwarf_Signed
number_of_pubtypes
int
dwarf_pubtypename
Dwarf_Type
type
char
returned_name
Dwarf_Error
error
int
dwarf_pubtype_type_die_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_pubtype_cu_offset
Dwarf_Type
type
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_pubtype_name_offsets
Dwarf_Type
type
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
File
scope
static
variable
name
operations
int
dwarf_get_vars
Dwarf_Debug
dbg
Dwarf_Var
vars
Dwarf_Signed
number_of_vars
Dwarf_Error
error
void
dwarf_vars_dealloc
Dwarf_Debug
dbg
Dwarf_Var
vars
Dwarf_Signed
number_of_vars
int
dwarf_varname
Dwarf_Var
var
char
returned_name
Dwarf_Error
error
int
dwarf_var_die_offset
Dwarf_Var
var
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_var_cu_offset
Dwarf_Var
var
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_var_name_offsets
Dwarf_Var
var
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
weak
name
operations
int
dwarf_get_weaks
Dwarf_Debug
dbg
Dwarf_Weak
weaks
Dwarf_Signed
number_of_weaks
Dwarf_Error
error
void
dwarf_weaks_dealloc
Dwarf_Debug
dbg
Dwarf_Weak
weaks
Dwarf_Signed
number_of_weaks
int
dwarf_weakname
Dwarf_Weak
weak
char
returned_name
Dwarf_Error
error
int
dwarf_weak_die_offset
Dwarf_Weak
weak
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_weak_cu_offset
Dwarf_Weak
weak
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_weak_name_offsets
Dwarf_Weak
weak
char
returned_name
Dwarf_Off
die_offset
Dwarf_Off
cu_offset
Dwarf_Error
error
location
list
section
operation
debug_loc
access
DO
NOT
USE
it
cannot
deal
with
recent
dwarf
or
CUs
with
different
address
sizes
Use
dwarf_get_locdesc_entry_c
instead
int
dwarf_get_loclist_entry
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Addr
hipc
Dwarf_Addr
lopc
Dwarf_Ptr
data
Dwarf_Unsigned
entry_len
Dwarf_Unsigned
next_entry
Dwarf_Error
error
abbreviation
section
operations
int
dwarf_get_abbrev
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Abbrev
returned_abbrev
Dwarf_Unsigned
length
Dwarf_Unsigned
attr_count
Dwarf_Error
error
int
dwarf_get_abbrev_tag
Dwarf_Abbrev
abbrev
Dwarf_Half
return_tag_number
Dwarf_Error
error
int
dwarf_get_abbrev_code
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
return_code_number
Dwarf_Error
error
See
comments
in
dwarf_abbrev
c
Not
an
entirely
safe
function
int
dwarf_get_abbrev_count
Dwarf_Debug
dbg
int
dwarf_get_abbrev_children_flag
Dwarf_Abbrev
abbrev
Dwarf_Signed
return_flag
Dwarf_Error
error
New
August
Most
uses
will
call
with
filter_outliers
non
zero
In
that
case
impossible
values
return
DW_DLV_ERROR
Those
doing
extra
things
like
dwarfdump
will
call
with
filter_outliers
zero
to
get
the
raw
data
effectively
int
dwarf_get_abbrev_entry_b
Dwarf_Abbrev
abbrev
Dwarf_Unsigned
indx
Dwarf_Bool
filter_outliers
Dwarf_Unsigned
returned_attr_num
Dwarf_Unsigned
returned_form
Dwarf_Signed
returned_implicit_const
Dwarf_Off
offset
Dwarf_Error
error
int
dwarf_get_string_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
consumer
string
section
operation
int
dwarf_get_str
Dwarf_Debug
dbg
Dwarf_Off
offset
char
string
Dwarf_Signed
strlen_of_string
Dwarf_Error
error
New
November
int
dwarf_get_frame_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
New
November
int
dwarf_get_frame_section_name_eh_gnu
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
Consumer
op
on
gnu
eh_frame
info
int
dwarf_get_fde_list_eh
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
consumer
operations
on
frame
info
debug_frame
int
dwarf_get_fde_list
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Error
error
Release
storage
gotten
by
dwarf_get_fde_list_eh
or
dwarf_get_fde_list
void
dwarf_fde_cie_list_dealloc
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
int
dwarf_get_fde_range
Dwarf_Fde
fde
Dwarf_Addr
low_pc
Dwarf_Unsigned
func_length
Dwarf_Ptr
fde_bytes
Dwarf_Unsigned
fde_byte_length
Dwarf_Off
cie_offset
Dwarf_Signed
cie_index
Dwarf_Off
fde_offset
Dwarf_Error
error
Useful
for
IRIX
only
see
dwarf_get_cie_augmentation_data
dwarf_get_fde_augmentation_data
for
GNU
eh_frame
int
dwarf_get_fde_exception_info
Dwarf_Fde
fde
Dwarf_Signed
offset_into_exception_tables
Dwarf_Error
error
int
dwarf_get_cie_of_fde
Dwarf_Fde
fde
Dwarf_Cie
cie_returned
Dwarf_Error
error
int
dwarf_get_cie_info_b
Dwarf_Cie
cie
Dwarf_Unsigned
bytes_in_cie
Dwarf_Small
version
char
augmenter
Dwarf_Unsigned
code_alignment_factor
Dwarf_Signed
data_alignment_factor
Dwarf_Half
return_address_register_rule
Dwarf_Ptr
initial_instructions
Dwarf_Unsigned
initial_instructions_length
Dwarf_Half
offset_size
Dwarf_Error
error
dwarf_get_cie_index
new
September
int
dwarf_get_cie_index
Dwarf_Cie
cie
Dwarf_Signed
index
Dwarf_Error
error
int
dwarf_get_fde_instr_bytes
Dwarf_Fde
fde
Dwarf_Ptr
outinstrs
Dwarf_Unsigned
outlen
Dwarf_Error
error
int
dwarf_get_fde_info_for_all_regs3
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Regtable3
reg_table
Dwarf_Addr
row_pc
Dwarf_Error
error
See
discussion
of
dw_value_type
libdwarf
h
dwarf_get_fde_info_for_reg3_b
is
useful
on
a
single
column
but
it
is
inefficient
to
iterate
across
all
table_columns
using
this
function
Instead
call
dwarf_get_fde_info_for_all_regs3
and
index
into
the
table
it
fills
in
int
dwarf_get_fde_info_for_reg3_b
Dwarf_Fde
fde
Dwarf_Half
table_column
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
Use
this
to
get
the
cfa
New
function
June
int
dwarf_get_fde_info_for_cfa_reg3_b
Dwarf_Fde
fde
Dwarf_Addr
pc_requested
Dwarf_Small
value_type
Dwarf_Signed
offset_relevant
Dwarf_Signed
register
Dwarf_Signed
offset_or_block_len
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc_out
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
Dwarf_Error
error
int
dwarf_get_fde_for_die
Dwarf_Debug
dbg
Dwarf_Die
subr_die
Dwarf_Fde
returned_fde
Dwarf_Error
error
int
dwarf_get_fde_n
Dwarf_Fde
fde_data
Dwarf_Unsigned
fde_index
Dwarf_Fde
returned_fde
Dwarf_Error
error
int
dwarf_get_fde_at_pc
Dwarf_Fde
fde_data
Dwarf_Addr
pc_of_interest
Dwarf_Fde
returned_fde
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Error
error
GNU
eh_frame
augmentation
information
raw
form
see
Linux
Standard
Base
Core
Specification
version
int
dwarf_get_cie_augmentation_data
Dwarf_Cie
cie
Dwarf_Small
augdata
Dwarf_Unsigned
augdata_len
Dwarf_Error
error
GNU
eh_frame
augmentation
information
raw
form
see
Linux
Standard
Base
Core
Specification
version
int
dwarf_get_fde_augmentation_data
Dwarf_Fde
fde
Dwarf_Small
augdata
Dwarf_Unsigned
augdata_len
Dwarf_Error
error
int
dwarf_expand_frame_instructions
Dwarf_Cie
cie
Dwarf_Ptr
instruction
Dwarf_Unsigned
i_length
Dwarf_Frame_Op
returned_op_list
Dwarf_Signed
op_count
Dwarf_Error
error
Operations
on
debug_aranges
int
dwarf_get_aranges
Dwarf_Debug
dbg
Dwarf_Arange
aranges
Dwarf_Signed
arange_count
Dwarf_Error
error
int
dwarf_get_ranges_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
int
dwarf_get_aranges_section_name
Dwarf_Debug
dbg
const
char
section_name_out
Dwarf_Error
error
int
dwarf_get_arange
Dwarf_Arange
aranges
Dwarf_Unsigned
arange_count
Dwarf_Addr
address
Dwarf_Arange
returned_arange
Dwarf_Error
error
int
dwarf_get_cu_die_offset
Dwarf_Arange
arange
Dwarf_Off
return_offset
Dwarf_Error
error
int
dwarf_get_arange_cu_header_offset
Dwarf_Arange
arange
Dwarf_Off
return_cu_header_offset
Dwarf_Error
error
ifdef
__sgi
pragma
is
sgi
MIPS
only
pragma
optional
dwarf_get_arange_cu_header_offset
endif
DWARF2
interface
New
for
DWARF4
entries
may
have
segment
information
segment
is
only
meaningful
if
segment_entry_size
is
non
zero
int
dwarf_get_arange_info_b
Dwarf_Arange
arange
Dwarf_Unsigned
segment
Dwarf_Unsigned
segment_entry_size
Dwarf_Addr
start
Dwarf_Unsigned
length
Dwarf_Off
cu_die_offset
Dwarf_Error
error
BEGIN
DWARF5
debug_macro
interfaces
NEW
November
int
dwarf_get_macro_context
Dwarf_Die
die
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_unit_offset_out
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length_out
Dwarf_Error
error
Just
like
dwarf_get_macro_context
but
instead
of
using
DW_AT_macros
or
DW_AT_GNU_macros
to
get
the
offset
we
just
take
the
offset
given
int
dwarf_get_macro_context_by_offset
Dwarf_Die
die
Dwarf_Unsigned
offset
Dwarf_Unsigned
version_out
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_ops_count_out
Dwarf_Unsigned
macro_ops_data_length
Dwarf_Error
error
New
December
Sometimes
its
necessary
to
know
a
context
total
length
including
macro
header
int
dwarf_macro_context_total_length
Dwarf_Macro_Context
head
Dwarf_Unsigned
mac_total_len
Dwarf_Error
error
void
dwarf_dealloc_macro_context
Dwarf_Macro_Context
mc
int
dwarf_get_macro_section_name
Dwarf_Debug
dbg
const
char
sec_name_out
Dwarf_Error
err
int
dwarf_macro_context_head
Dwarf_Macro_Context
head
Dwarf_Half
version
Dwarf_Unsigned
mac_offset
Dwarf_Unsigned
mac_len
Dwarf_Unsigned
mac_header_len
unsigned
int
flags
Dwarf_Bool
has_line_offset
Dwarf_Unsigned
line_offset
Dwarf_Bool
has_offset_size_64
Dwarf_Bool
has_operands_table
Dwarf_Half
opcode_count
Dwarf_Error
error
Returns
data
from
the
operands
table
in
the
macro
unit
header
The
last
op
has
as
opcode_number
operand_count
and
operand_array
int
dwarf_macro_operands_table
Dwarf_Macro_Context
head
Dwarf_Half
index
to
opcode_count
Dwarf_Half
opcode_number
Dwarf_Half
operand_count
const
Dwarf_Small
operand_array
Dwarf_Error
error
Access
to
the
macro
operations
to
macro_ops_count_out
Where
the
last
of
these
will
have
macro_operator
which
appears
in
the
ops
data
and
means
end
of
ops
op_start_section_offset
is
the
section
offset
of
the
macro
operator
which
is
a
single
unsigned
byte
and
is
followed
by
the
macro
operand
data
int
dwarf_get_macro_op
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
op_start_section_offset
Dwarf_Half
macro_operator
Dwarf_Half
forms_count
const
Dwarf_Small
formcode_array
Dwarf_Error
error
int
dwarf_get_macro_defundef
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Unsigned
offset
Dwarf_Half
forms_count
const
char
macro_string
Dwarf_Error
error
int
dwarf_get_macro_startend_file
Dwarf_Macro_Context
context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
line_number
Dwarf_Unsigned
name_index_to_line_tab
const
char
src_file_name
Dwarf_Error
error
int
dwarf_get_macro_import
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
op_number
Dwarf_Unsigned
target_offset
Dwarf_Error
error
END
DWARF5
debug_macro
interfaces
consumer
debug_macinfo
information
interface
struct
Dwarf_Macro_Details_s
Dwarf_Off
dmd_offset
offset
in
the
section
of
this
macro
info
Dwarf_Small
dmd_type
the
type
DW_MACINFO_define
etc
Dwarf_Signed
dmd_lineno
the
source
line
number
where
applicable
and
vend_def
number
if
vendor_extension
op
Dwarf_Signed
dmd_fileindex
the
source
file
index
applies
to
define
undef
start_file
char
dmd_macro
macro
name
with
value
for
defineop
string
from
vendor
ext
dwarf_print_lines
is
for
use
by
dwarfdump
it
prints
line
info
to
stdout
int
dwarf_print_lines
Dwarf_Die
cu_die
Dwarf_Error
error
int
error_count_out
As
of
August
dwarf_print_lines
no
longer
uses
printf
Instead
it
calls
back
to
the
application
using
a
function
pointer
once
per
line
to
print
The
lines
passed
back
already
have
any
needed
newlines
The
following
struct
is
used
to
initialize
the
callback
mechanism
Failing
to
call
the
dwarf_register_printf_callback
function
will
prevent
the
lines
from
being
passed
back
but
such
omission
is
not
an
error
See
libdwarf2
mm
for
further
documentation
The
return
value
is
the
previous
set
of
callback
values
typedef
void
dwarf_printf_callback_function_type
void
user_pointer
const
char
linecontent
struct
Dwarf_Printf_Callback_Info_s
void
dp_user_pointer
dwarf_printf_callback_function_type
dp_fptr
char
dp_buffer
unsigned
int
dp_buffer_len
int
dp_buffer_user_provided
void
dp_reserved
If
called
with
a
NULL
newvalues
pointer
it
simply
returns
the
current
set
of
values
for
this
Dwarf_Debug
struct
Dwarf_Printf_Callback_Info_s
dwarf_register_printf_callback
Dwarf_Debug
dbg
struct
Dwarf_Printf_Callback_Info_s
newvalues
dwarf_check_lineheader
lets
dwarfdump
get
detailed
messages
about
some
compiler
errors
we
detect
We
return
the
count
of
detected
errors
through
the
pointer
int
dwarf_check_lineheader_b
Dwarf_Die
cu_die
int
errcount_out
Dwarf_Error
error
Used
by
dwarfdump
v
to
print
fde
offsets
from
debugging
info
int
dwarf_fde_section_offset
Dwarf_Debug
dbg
Dwarf_Fde
in_fde
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Dwarf_Error
err
Used
by
dwarfdump
v
to
print
cie
offsets
from
debugging
info
int
dwarf_cie_section_offset
Dwarf_Debug
dbg
Dwarf_Cie
in_cie
Dwarf_Off
cie_off
Dwarf_Error
err
typedef
struct
Dwarf_Macro_Details_s
Dwarf_Macro_Details
char
dwarf_find_macro_value_start
char
macro_string
int
dwarf_get_macro_details
Dwarf_Debug
dbg
Dwarf_Off
macro_offset
Dwarf_Unsigned
maximum_count
Dwarf_Signed
entry_count
Dwarf_Macro_Details
details
Dwarf_Error
err
dwarf_get_offset_size
New
October
int
dwarf_get_offset_size
Dwarf_Debug
dbg
Dwarf_Half
offset_size
Dwarf_Error
error
int
dwarf_get_address_size
Dwarf_Debug
dbg
Dwarf_Half
addr_size
Dwarf_Error
error
int
dwarf_get_die_address_size
Dwarf_Die
die
Dwarf_Half
addr_size
Dwarf_Error
error
enum
Dwarf_Form_Class
dwarf_get_form_class
Dwarf_Half
dwversion
Dwarf_Half
attrnum
Dwarf_Half
offset_size
Dwarf_Half
form
BEGIN
gdbindex
operations
interfaces
gdb_index
section
operations
A
GDB
extension
Completely
different
than
debug_gnu_pubnames
or
debug_gnu_pubtypes
sections
The
section
is
in
some
executables
and
if
present
is
used
to
quickly
map
an
address
or
name
to
a
skeleton
CU
or
TU
If
present
then
there
are
dwo
or
dwp
files
somewhere
to
make
detailed
debugging
possible
up
to
user
code
to
find
it
them
and
deal
with
them
Version
built
by
gdb
so
type
entries
are
ok
as
is
Version
built
by
the
gold
linker
and
type
index
entries
for
a
CU
must
be
derived
othewise
the
type
index
is
not
correct
FIXME
Creates
a
Dwarf_Gdbindex
returning
it
and
its
values
through
the
pointers
int
dwarf_gdbindex_header
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
version
Dwarf_Unsigned
cu_list_offset
Dwarf_Unsigned
types_cu_list_offset
Dwarf_Unsigned
address_area_offset
Dwarf_Unsigned
symbol_table_offset
Dwarf_Unsigned
constant_pool_offset
Dwarf_Unsigned
section_size
Dwarf_Unsigned
unused_reserved
const
char
section_name
Dwarf_Error
error
int
dwarf_gdbindex_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
list_length
Dwarf_Error
error
entryindex
to
list_length
int
dwarf_gdbindex_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
cu_offset
Dwarf_Unsigned
cu_length
Dwarf_Error
error
int
dwarf_gdbindex_types_culist_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
types_list_length
Dwarf_Error
error
entryindex
to
types_list_length
int
dwarf_gdbindex_types_culist_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
cu_offset
Dwarf_Unsigned
tu_offset
Dwarf_Unsigned
type_signature
Dwarf_Error
error
int
dwarf_gdbindex_addressarea
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
addressarea_list_length
Dwarf_Error
error
entryindex
to
addressarea_list_length
int
dwarf_gdbindex_addressarea_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
low_adddress
Dwarf_Unsigned
high_address
Dwarf_Unsigned
cu_index
Dwarf_Error
error
int
dwarf_gdbindex_symboltable_array
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
symtab_list_length
Dwarf_Error
error
entryindex
to
symtab_list_length
int
dwarf_gdbindex_symboltable_entry
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
entryindex
Dwarf_Unsigned
string_offset
Dwarf_Unsigned
cu_vector_offset
Dwarf_Error
error
int
dwarf_gdbindex_cuvector_length
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innercount
Dwarf_Error
error
int
dwarf_gdbindex_cuvector_inner_attributes
Dwarf_Gdbindex
index
Dwarf_Unsigned
cuvector_offset
Dwarf_Unsigned
innerindex
The
attr_value
is
a
field
of
bits
For
expanded
version
use
dwarf_gdbindex_cuvector_expand_value
Dwarf_Unsigned
attr_value
Dwarf_Error
error
int
dwarf_gdbindex_cuvector_instance_expand_value
Dwarf_Gdbindex
Dwarf_Unsigned
value
Dwarf_Unsigned
cu_index
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
symbol_kind
Dwarf_Unsigned
is_static
Dwarf_Error
error
The
strings
in
the
pool
follow
in
memory
the
cu
index
set
and
are
NUL
terminated
int
dwarf_gdbindex_string_by_offset
Dwarf_Gdbindex
gdbindexptr
Dwarf_Unsigned
stringoffset
const
char
string_ptr
Dwarf_Error
error
void
dwarf_gdbindex_free
Dwarf_Gdbindex
gdbindexptr
END
gdbindex
debugfission
operations
START
debugfission
dwp
debug_cu_index
and
debug_tu_index
operations
int
dwarf_get_xu_index_header
Dwarf_Debug
dbg
const
char
section_type
tu
or
cu
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
version_number
Dwarf_Unsigned
offsets_count
L
Dwarf_Unsigned
units_count
N
Dwarf_Unsigned
hash_slots_count
M
const
char
sect_name
Dwarf_Error
err
int
dwarf_get_xu_index_section_type
Dwarf_Xu_Index_Header
xuhdr
the
function
returns
a
pointer
to
the
immutable
string
tu
or
cu
via
this
arg
Do
not
free
const
char
typename
the
function
returns
a
pointer
to
the
immutable
section
name
Do
not
free
debug_cu_index
or
debug_tu_index
const
char
sectionname
Dwarf_Error
err
Index
values
to
M
are
valid
int
dwarf_get_xu_hash_entry
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
index
Returns
the
hash
value
bits
Dwarf_Sig8
hash_value
returns
the
index
into
rows
of
offset
size
tables
Dwarf_Unsigned
index_to_sections
Dwarf_Error
err
Columns
to
L
valid
int
dwarf_get_xu_section_names
Dwarf_Xu_Index_Header
xuhdr
Row
index
defined
to
be
row
zero
Dwarf_Unsigned
column_index
Dwarf_Unsigned
DW_SECT_
number
const
char
DW_SECT_
name
Dwarf_Error
err
Rows
to
N
col
to
L
are
valid
int
dwarf_get_xu_section_offset
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
row_index
Dwarf_Unsigned
column_index
Dwarf_Unsigned
sec_offset
Dwarf_Unsigned
sec_size
Dwarf_Error
err
void
dwarf_xu_header_free
Dwarf_Xu_Index_Header
xuhdr
Defined
larger
than
necessary
This
struct
being
visible
will
be
difficult
to
change
binary
compatibility
define
DW_FISSION_SECT_COUNT
User
must
allocate
this
struct
zero
it
and
pass
a
pointer
to
it
into
dwarf_get_debugfission_for_cu
struct
Dwarf_Debug_Fission_Per_CU_s
Do
not
free
the
string
It
contains
cu
or
tu
If
this
is
not
set
ie
not
a
CU
TU
in
DWP
Package
File
then
pcu_type
will
be
NULL
const
char
pcu_type
pcu_index
is
the
index
range
to
N
into
the
tu
cu
table
of
offsets
and
the
table
of
sizes
to
N
as
the
zero
index
is
reserved
for
special
purposes
Not
a
value
one
actually
needs
Dwarf_Unsigned
pcu_index
Dwarf_Sig8
pcu_hash
byte
has
offset
and
size
are
DW_SECT_
indexes
and
the
values
are
the
offset
and
size
of
the
respective
section
contribution
of
a
single
dwo
object
When
pcu_size
n
is
zero
the
corresponding
section
is
not
present
Dwarf_Unsigned
pcu_offset
DW_FISSION_SECT_COUNT
Dwarf_Unsigned
pcu_size
DW_FISSION_SECT_COUNT
Dwarf_Unsigned
unused1
Dwarf_Unsigned
unused2
typedef
struct
Dwarf_Debug_Fission_Per_CU_s
Dwarf_Debug_Fission_Per_CU
For
any
Dwarf_Die
in
a
compilation
unit
return
the
debug
fission
table
data
through
percu_out
Usually
applications
will
pass
in
the
CU
die
Calling
code
should
zero
all
of
the
struct
Dwarf_Debug_Fission_Per_CU_s
before
calling
this
If
there
is
no
debugfission
data
this
returns
DW_DLV_NO_ENTRY
only
dwp
objects
have
debugfission
data
int
dwarf_get_debugfission_for_die
Dwarf_Die
die
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
err
Given
a
key
hash
signature
from
a
o
find
the
per
cu
information
for
the
CU
with
that
key
int
dwarf_get_debugfission_for_key
Dwarf_Debug
dbg
Dwarf_Sig8
key
hash
signature
const
char
key_type
cu
or
tu
Dwarf_Debug_Fission_Per_CU
percu_out
Dwarf_Error
err
END
debugfission
dwp
debug_cu_index
and
debug_tu_index
operations
Utility
operations
Dwarf_Unsigned
dwarf_errno
Dwarf_Error
error
char
dwarf_errmsg
Dwarf_Error
error
char
dwarf_errmsg_by_number
Dwarf_Unsigned
errornum
void
dwarf_error_creation
Dwarf_Debug
dbg
Dwarf_Error
error
char
errmsg
stringcheck
zero
is
default
and
means
do
all
string
length
validity
checks
Call
with
parameter
value
to
turn
off
many
such
checks
and
increase
performance
Call
with
zero
for
safest
running
Actual
value
saved
and
returned
is
only
bits
Upper
bits
ignored
by
libdwarf
and
zero
on
return
Returns
previous
value
int
dwarf_set_stringcheck
int
stringcheck
apply
defaults
to
and
means
do
all
rela
relocations
on
reading
in
a
dwarf
object
section
with
such
relocations
Call
with
parameter
value
to
turn
off
application
of
such
relocations
Since
the
static
linker
leaves
bogus
data
in
object
sections
with
a
rela
relocation
section
such
data
cannot
be
read
sensibly
without
processing
the
relocations
Such
relocations
do
not
exist
in
executables
and
shared
objects
so
the
relocations
only
exist
in
plain
o
relocatable
object
files
Actual
value
saved
and
returned
is
only
bits
Upper
bits
ignored
by
libdwarf
and
zero
on
return
Returns
previous
value
int
dwarf_set_reloc_application
int
apply
Never
Implemented
Dwarf_Handler
dwarf_seterrhand
Dwarf_Debug
dbg
Dwarf_Handler
errhand
Unimplemented
Dwarf_Ptr
dwarf_seterrarg
Dwarf_Debug
dbg
Dwarf_Ptr
errarg
void
dwarf_dealloc
Dwarf_Debug
dbg
void
space
Dwarf_Unsigned
type
These
convenience
functions
allow
type
checking
at
the
call
whereas
dwarf_dealloc
itself
uses
void
so
easy
to
misuse
void
dwarf_dealloc_error
Dwarf_Debug
dbg
Dwarf_Error
err
void
dwarf_dealloc_die
Dwarf_Die
die
void
dwarf_dealloc_attribute
Dwarf_Attribute
attr
int
dwarf_attr_offset
Dwarf_Die
die
Dwarf_Attribute
attr
of
above
die
Dwarf_Off
returns
offset
thru
this
ptr
Dwarf_Error
error
This
is
a
hack
so
clients
can
verify
offsets
Added
April
so
that
debugger
can
detect
broken
offsets
which
happened
in
an
IRIX
executable
larger
than
with
MIPSpro
toolchain
This
has
arguments
which
is
unusual
int
dwarf_get_section_max_offsets_d
Dwarf_Debug
dbg
Dwarf_Unsigned
debug_info_size
Dwarf_Unsigned
debug_abbrev_size
Dwarf_Unsigned
debug_line_size
Dwarf_Unsigned
debug_loc_size
Dwarf_Unsigned
debug_aranges_size
Dwarf_Unsigned
debug_macinfo_size
Dwarf_Unsigned
debug_pubnames_size
Dwarf_Unsigned
debug_str_size
Dwarf_Unsigned
debug_frame_size
Dwarf_Unsigned
debug_ranges_size
Dwarf_Unsigned
debug_pubtypes_size
Dwarf_Unsigned
debug_types_size
Dwarf_Unsigned
debug_macro_size
Dwarf_Unsigned
debug_str_offsets_size
Dwarf_Unsigned
debug_sup_size
Dwarf_Unsigned
debug_cu_index_size
Dwarf_Unsigned
debug_tu_index_size
Dwarf_Unsigned
debug_names_size
Dwarf_Unsigned
debug_loclists_size
Dwarf_Unsigned
debug_rnglists_size
The
set
calls
here
return
the
original
before
any
change
by
these
set
routines
of
the
respective
fields
Multiple
releases
spelled
initial
as
inital
The
inital
spelling
should
not
be
used
Dwarf_Half
dwarf_set_frame_rule_inital_value
Dwarf_Debug
dbg
Dwarf_Half
value
Additional
interface
with
correct
initial
spelling
It
is
likely
you
will
want
to
call
the
following
functions
before
accessing
any
frame
information
All
are
useful
to
tailor
handling
of
pseudo
registers
needed
to
turn
frame
operation
references
into
simpler
forms
and
to
reflect
ABI
specific
data
Of
course
altering
libdwarf
h
and
dwarf
h
allow
the
same
capabilities
but
header
changes
in
the
distribution
would
require
you
re
integrate
your
libdwarf
h
changes
into
the
distributed
libdwarf
h
so
use
the
following
functions
instead
Dwarf_Half
dwarf_set_frame_rule_initial_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
dwarf_set_frame_rule_table_size
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
dwarf_set_frame_cfa_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
dwarf_set_frame_same_value
Dwarf_Debug
dbg
Dwarf_Half
value
Dwarf_Half
dwarf_set_frame_undefined_value
Dwarf_Debug
dbg
Dwarf_Half
value
dwarf_set_default_address_size
only
sets
value
if
value
is
greater
than
zero
Dwarf_Small
dwarf_set_default_address_size
Dwarf_Debug
dbg
Dwarf_Small
value
Adds
return
of
the
final
offset
to
accommodate
DWARF4
GNU
split
dwarf
Other
than
for
split
dwarf
the
realoffset
will
be
set
by
the
function
to
be
the
same
as
rangesoffset
New
September
int
dwarf_get_ranges_b
Dwarf_Debug
dbg
Dwarf_Off
rangesoffset
Dwarf_Die
diepointer
Dwarf_Off
realoffset
Dwarf_Ranges
rangesbuf
Dwarf_Signed
listlen
Dwarf_Unsigned
bytecount
Dwarf_Error
error
void
dwarf_ranges_dealloc
Dwarf_Debug
dbg
Dwarf_Ranges
rangesbuf
Dwarf_Signed
rangecount
New
July
for
DWARF5
int
dwarf_get_debug_sup
Dwarf_Debug
dbg
Dwarf_Half
version
Dwarf_Small
is_supplementary
char
filename
Dwarf_Unsigned
checksum_len
Dwarf_Small
checksum
Dwarf_Error
error
START
debug_rnglists
interfaces
New
May
struct
Dwarf_Rnglists_Entry_s
typedef
struct
Dwarf_Rnglists_Entry_s
Dwarf_Rnglists_Entry
struct
Dwarf_Rnglists_Head_s
typedef
struct
Dwarf_Rnglists_Head_s
Dwarf_Rnglists_Head
For
DWARF5
DW_AT_ranges
DW_FORM_sec_offset
DW_FORM_rnglistx
int
dwarf_rnglists_get_rle_head
Dwarf_Attribute
attr
Dwarf_Half
theform
Dwarf_Unsigned
index_or_offset_value
Dwarf_Rnglists_Head
head_out
Dwarf_Unsigned
count_of_entries_in_head
Dwarf_Unsigned
global_offset_of_rle_set
Dwarf_Error
error
Get
the
rnglist
entries
details
int
dwarf_get_rnglists_entry_fields_a
Dwarf_Rnglists_Head
Dwarf_Unsigned
entrynum
unsigned
entrylen
unsigned
rle_value_out
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Bool
debug_addr_unavailable
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
Dwarf_Error
err
int
dwarf_dealloc_rnglists_head
Dwarf_Rnglists_Head
Loads
all
the
rnglists
headers
and
returns
DW_DLV_NO_ENTRY
if
the
section
is
missing
or
empty
Intended
to
be
done
quite
early
and
it
is
automatically
done
if
debug_info
is
loaded
Doing
it
more
than
once
is
never
necessary
or
harmful
There
is
no
deallocation
call
made
visible
deallocation
happens
when
dwarf_finish
is
called
With
DW_DLV_OK
it
returns
the
number
of
rnglists
headers
in
the
section
through
rnglists_count
int
dwarf_load_rnglists
Dwarf_Debug
dbg
Dwarf_Unsigned
rnglists_count
Dwarf_Error
err
Retrieve
the
offset
from
the
context
index
th
rangelists
context
and
the
offsetentry_index
element
of
the
array
of
offsets
If
an
index
is
too
large
to
be
correct
this
returns
DW_DLV_NO_ENTRY
If
all
is
correct
it
returns
DW_DLV_OK
and
sets
offset_value_out
to
the
offset
of
the
range
list
from
the
base
of
the
offset
array
and
global_offset_value_out
is
set
to
the
debug_rnglists
section
offset
of
the
range
list
int
dwarf_get_rnglist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
Used
by
dwarfdump
to
print
basic
data
from
the
data
generated
to
look
at
a
specific
rangelist
as
returned
by
dwarf_rnglists_index_get_rle_head
or
dwarf_rnglists_offset_get_rle_head
int
dwarf_get_rnglist_head_basics
Dwarf_Rnglists_Head
head
Dwarf_Unsigned
rle_count
Dwarf_Unsigned
rnglists_version
Dwarf_Unsigned
rnglists_index_returned
Dwarf_Unsigned
bytes_total_in_rle
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Unsigned
overall
offset_of_this_context
Dwarf_Unsigned
total_length
of
this
context
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
Dwarf_Bool
rnglists_base_present
Dwarf_Unsigned
rnglists_base
Dwarf_Bool
rnglists_base_address_present
Dwarf_Unsigned
rnglists_base_address
Dwarf_Bool
rnglists_debug_addr_base_present
Dwarf_Unsigned
rnglists_debug_addr_base
Dwarf_Error
error
Enables
printing
of
details
about
the
Range
List
Table
Headers
one
header
per
call
Index
starting
at
Returns
DW_DLV_NO_ENTRY
if
index
is
too
high
for
the
table
A
debug_rnglists
section
may
contain
any
number
of
Range
List
Table
Headers
with
their
details
int
dwarf_get_rnglist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
int
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_rangeentry
Dwarf_Unsigned
offset_past_last_rangeentry
Dwarf_Error
err
entry
offset
is
offset_of_first_rangeentry
Stop
when
the
returned
next_entry_offset
is
offset_past_last_rangentry
from
dwarf_get_rnglist_context_plus
This
only
makes
sense
within
those
ranges
This
retrieves
raw
detail
from
the
section
no
base
values
or
anything
are
added
So
this
returns
raw
individual
entries
for
a
single
rnglist
header
meaning
a
a
single
Dwarf_Rnglists_Context
This
interface
assumes
there
is
no
segment
selector
int
dwarf_get_rnglist_raw_entry_detail
Dwarf_Debug
dbg
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
next_entry_offset
Dwarf_Error
err
If
no
error
returns
DW_DLV_OK
and
sets
the
entry
length
kind
and
operands
through
the
pointers
If
any
missing
operands
assign
zero
back
through
tye
operand
pointers
int
dwarf_get_rnglist_rle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
int
entrylen
unsigned
int
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Error
err
END
debug_rnglists
interfaces
START
debug_loclists
interfaces
New
May
These
interfaces
allow
reading
the
debug_loclists
section
Normal
use
of
debug_loclists
uses
dwarf_get_loclist_c
to
open
access
to
any
kind
of
location
or
loclist
and
uses
dwarf_loc_head_c_dealloc
to
deallocate
that
memory
once
one
is
finished
with
that
data
So
for
most
purposes
you
do
not
need
to
use
these
functions
See
dwarf_get_loclist_c
to
open
a
Dwarf_Loc_Head_c
on
any
type
of
location
list
or
expression
Get
the
loclists
entries
details
int
dwarf_get_loclists_entry_fields
Dwarf_Loc_Head_c
head
Dwarf_Unsigned
entrynum
unsigned
int
entrylen
unsigned
int
code
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
Dwarf_Error
error
Loads
all
the
loclists
headers
and
returns
DW_DLV_NO_ENTRY
if
the
section
is
missing
or
empty
Intended
to
be
done
quite
early
and
it
is
automatically
done
if
debug_info
is
loaded
Doing
it
more
than
once
is
never
necessary
or
harmful
There
is
no
deallocation
call
made
visible
deallocation
happens
when
dwarf_finish
is
called
With
DW_DLV_OK
it
returns
the
number
of
loclists
headers
in
the
section
through
loclists_count
int
dwarf_load_loclists
Dwarf_Debug
dbg
Dwarf_Unsigned
loclists_count
Dwarf_Error
err
Retrieve
the
offset
from
the
context
index
th
loclists
context
and
the
offsetentry_index
element
of
the
array
of
offsets
If
an
index
is
too
large
to
be
correct
this
returns
DW_DLV_NO_ENTRY
If
all
is
correct
it
returns
DW_DLV_OK
and
sets
offset_value_out
to
the
offset
of
the
range
list
from
the
base
of
the
offset
array
and
global_offset_value_out
is
set
to
the
debug_loclists
section
offset
of
the
range
list
int
dwarf_get_loclist_offset_index_value
Dwarf_Debug
dbg
Dwarf_Unsigned
context_index
Dwarf_Unsigned
offsetentry_index
Dwarf_Unsigned
offset_value_out
Dwarf_Unsigned
global_offset_value_out
Dwarf_Error
error
Used
by
dwarfdump
to
print
basic
data
from
the
data
generated
to
look
at
a
specific
rangelist
as
returned
by
dwarf_loclists_index_get_lle_head
or
dwarf_loclists_offset_get_lle_head
int
dwarf_get_loclist_head_basics
Dwarf_Loc_Head_c
head
Dwarf_Small
lkind
Dwarf_Unsigned
lle_count
Dwarf_Unsigned
loclists_version
Dwarf_Unsigned
loclists_index_returned
Dwarf_Unsigned
bytes_total_in_rle
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Unsigned
overall
offset_of_this_context
Dwarf_Unsigned
total_length
of
this
context
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
Dwarf_Bool
loclists_base_present
Dwarf_Unsigned
loclists_base
Dwarf_Bool
loclists_base_address_present
Dwarf_Unsigned
loclists_base_address
Dwarf_Bool
loclists_debug_addr_base_present
Dwarf_Unsigned
loclists_debug_addr_base
Dwarf_Unsigned
offset_this_lle_area
Dwarf_Error
error
Enables
printing
of
details
about
the
Range
List
Table
Headers
one
header
per
call
Index
starting
at
Returns
DW_DLV_NO_ENTRY
if
index
is
too
high
for
the
table
A
debug_loclists
section
may
contain
any
number
of
Location
List
Table
Headers
with
their
details
int
dwarf_get_loclist_context_basics
Dwarf_Debug
dbg
Dwarf_Unsigned
index
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
int
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_locentry
Dwarf_Unsigned
offset_past_last_locentry
Dwarf_Error
err
entry
offset
is
offset_of_first_locentry
Stop
when
the
returned
next_entry_offset
is
offset_past_last_locentry
from
dwarf_get_loclist_context_plus
This
only
makes
sense
within
those
ranges
This
retrieves
raw
detail
from
the
section
no
base
values
or
anything
are
added
So
this
returns
raw
individual
entries
for
a
single
loclist
header
meaning
a
a
single
Dwarf_Loclists_Context
This
interface
assumes
there
is
no
segment
selector
int
dwarf_get_loclist_raw_entry_detail
Dwarf_Debug
dbg
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
next_entry_offset
Dwarf_Error
err
If
no
error
returns
DW_DLV_OK
and
sets
the
entry
length
kind
and
operands
through
the
pointers
If
any
missing
operands
assign
zero
back
through
tye
operand
pointers
int
dwarf_get_loclist_lle
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
entry_offset
Dwarf_Unsigned
endoffset
unsigned
int
entrylen
unsigned
int
entry_kind
Dwarf_Unsigned
entry_operand1
Dwarf_Unsigned
entry_operand2
Dwarf_Unsigned
expr_ops_blocksize
Dwarf_Unsigned
expr_ops_offset
Dwarf_Small
expr_opsdata
Dwarf_Error
err
END
debug_loclists
interfaces
New
April
Allows
applications
to
print
the
debug_str_offsets
section
Beginning
at
starting_offset
zero
returns
data
about
the
first
table
found
The
value
next_table_offset
is
the
value
of
the
next
table
if
any
one
byte
past
the
end
of
the
table
whose
data
is
returned
Returns
DW_DLV_NO_ENTRY
if
the
starting
offset
is
past
the
end
of
valid
data
There
is
no
guarantee
that
there
are
no
non
nonsense
bytes
in
the
section
outside
of
useful
tables
so
this
can
fail
and
return
nonsense
or
DW_DLV_ERROR
if
such
garbage
exists
struct
Dwarf_Str_Offsets_Table_s
typedef
struct
Dwarf_Str_Offsets_Table_s
Dwarf_Str_Offsets_Table
Allocates
a
struct
Dwarf_Str_Offsets_Table_s
for
the
section
and
returns
DW_DLV_OK
and
sets
a
pointer
to
the
struct
through
the
table_data
pointer
if
successful
If
there
is
no
such
section
it
returns
DW_DLV_NO_ENTRY
int
dwarf_open_str_offsets_table_access
Dwarf_Debug
dbg
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
Close
access
free
table_data
int
dwarf_close_str_offsets_table_access
Dwarf_Str_Offsets_Table
table_data
Dwarf_Error
error
Call
till
it
returns
DW_DLV_NO_ENTRY
normal
end
or
DW_DLV_ERROR
error
and
stop
On
successful
call
call
dwarf_str_offsets_table_entry
to
get
the
individual
table
values
on
the
now
active
table
int
dwarf_next_str_offsets_table
Dwarf_Str_Offsets_Table
Dwarf_Unsigned
unit_length
Dwarf_Unsigned
unit_length_offset
Dwarf_Unsigned
table_start_offset
Dwarf_Half
entry_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
table_value_count
Dwarf_Error
error
Valid
index
values
n
n
table_entry_count
for
the
active
table
int
dwarf_str_offsets_value_by_index
Dwarf_Str_Offsets_Table
Dwarf_Unsigned
index_to_entry
Dwarf_Unsigned
entry_value
Dwarf_Error
error
After
all
str_offsets
read
this
reports
final
wasted
bytes
count
int
dwarf_str_offsets_statistics
Dwarf_Str_Offsets_Table
Dwarf_Unsigned
wasted_byte_count
Dwarf_Unsigned
table_count
Dwarf_Error
error
The
harmless
error
list
is
a
circular
buffer
of
errors
we
note
but
which
do
not
stop
us
from
processing
the
object
Created
so
dwarfdump
or
other
tools
can
report
such
inconsequential
errors
without
causing
anything
to
stop
early
define
DW_HARMLESS_ERROR_CIRCULAR_LIST_DEFAULT_SIZE
define
DW_HARMLESS_ERROR_MSG_STRING_SIZE
User
code
supplies
size
of
array
of
pointers
errmsg_ptrs_array
in
count
and
the
array
of
pointers
the
pointers
themselves
need
not
be
initialized
The
pointers
returned
in
the
array
of
pointers
are
invalidated
by
ANY
call
to
libdwarf
Use
them
before
making
another
libdwarf
call
The
array
of
string
pointers
passed
in
always
has
a
final
null
pointer
so
if
there
are
N
pointers
the
and
M
actual
strings
then
MIN
M
N
pointers
are
set
to
point
to
error
strings
The
array
of
pointers
to
strings
always
terminates
with
a
NULL
pointer
If
count
is
passed
in
zero
then
errmsg_ptrs_array
is
not
touched
The
function
returns
DW_DLV_NO_ENTRY
if
no
harmless
errors
were
noted
so
far
Returns
DW_DLV_OK
if
there
are
errors
Never
returns
DW_DLV_ERROR
Each
call
empties
the
error
list
discarding
all
current
entries
If
newerr_count
is
non
NULL
the
count
of
harmless
errors
since
the
last
call
is
returned
through
the
pointer
some
may
have
been
discarded
or
not
returned
it
is
a
circular
list
If
DW_DLV_NO_ENTRY
is
returned
none
of
the
arguments
here
are
touched
or
used
int
dwarf_get_harmless_error_list
Dwarf_Debug
dbg
unsigned
int
count
const
char
errmsg_ptrs_array
unsigned
int
newerr_count
Insertion
is
only
for
testing
the
harmless
error
code
it
is
not
necessarily
useful
otherwise
void
dwarf_insert_harmless_error
Dwarf_Debug
dbg
char
newerror
The
size
of
the
circular
list
of
strings
may
be
set
and
reset
as
needed
If
it
is
shortened
excess
messages
are
simply
dropped
It
returns
the
previous
size
If
zero
passed
in
the
size
is
unchanged
and
it
simply
returns
the
current
size
unsigned
int
dwarf_set_harmless_error_list_size
Dwarf_Debug
dbg
unsigned
int
maxcount
The
harmless
error
strings
if
any
are
freed
when
the
dbg
is
dwarf_finish
ed
When
the
val_in
is
known
these
dwarf_get_TAG_name
etc
functions
return
the
string
corresponding
to
the
val_in
passed
in
through
the
pointer
s_out
and
the
value
returned
is
DW_DLV_OK
The
strings
are
in
static
storage
and
must
not
be
freed
If
DW_DLV_NO_ENTRY
is
returned
the
val_in
is
not
known
and
s_out
is
not
set
DW_DLV_ERROR
is
never
returned
The
following
copied
from
a
generated
dwarf_names
h
BEGIN
FILE
extern
int
dwarf_get_ACCESS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ADDR_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATCF_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_AT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CFA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_children_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CHILDREN_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DEFAULTED_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DSC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_EH_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_END_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FORM_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FRAME_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIKIND_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIVIS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ID_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_IDX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_INL_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ISA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LANG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LLE_name
unsigned
int
val_in
const
char
s_out
dwarf_get_LLEX_name
is
for
a
GNU
extension
Not
defined
by
the
GNU
folks
nor
a
DWARF
standard
but
it
seemed
essential
extern
int
dwarf_get_LLEX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNCT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACINFO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACRO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_OP_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ORD_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_RLE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_SECT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_TAG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_UT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIRTUALITY_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIS_name
unsigned
int
val_in
const
char
s_out
END
FILE
New
February
On
success
returns
DW_DLV_OK
and
creates
an
array
of
Dwarf_Signed
values
from
the
block
of
sleb
numbers
This
interface
supercedes
dwarf_uncompress_integer_block
No
ugly
cast
needed
to
know
if
dwarf_uncompress_integer_block_a
succeeds
or
not
int
dwarf_uncompress_integer_block_a
Dwarf_Debug
dbg
Dwarf_Unsigned
input_length_in_bytes
void
input_block
Dwarf_Unsigned
value_count
Dwarf_Signed
value_array
Dwarf_Error
error
Decode
an
array
of
signed
leb
integers
so
of
course
the
array
is
not
composed
of
fixed
length
values
but
is
instead
a
sequence
of
sleb
values
Returns
a
DW_DLV_BADADDR
on
error
Otherwise
returns
a
pointer
to
an
array
of
integers
The
signed
argument
must
be
non
zero
the
decode
assumes
sleb
integers
in
the
input
data
at
this
time
Size
of
integer
units
must
be
bits
each
at
this
time
Number
of
bytes
in
block
is
a
byte
count
not
array
count
Returns
number
of
units
in
output
block
ie
number
of
elements
of
the
array
that
the
return
value
points
to
thru
the
argument
void
dwarf_uncompress_integer_block
Dwarf_Debug
dbg
Dwarf_Bool
signed
true
or
unsigned
Dwarf_Small
size
of
integer
units
void
input
data
Dwarf_Unsigned
number
of
bytes
in
input
Dwarf_Unsigned
number
of
units
in
output
block
Dwarf_Error
error
Call
this
passing
in
return
value
from
dwarf_uncompress_integer_block
to
free
the
space
the
decompression
allocated
void
dwarf_dealloc_uncompressed_block
Dwarf_Debug
void
extern
int
dwarf_get_FORM_CLASS_name
enum
Dwarf_Form_Class
fc
const
char
s_out
Convert
local
offset
into
global
offset
int
dwarf_convert_to_global_offset
Dwarf_Attribute
attr
Dwarf_Off
offset
Dwarf_Off
ret_offset
Dwarf_Error
error
Get
both
offsets
local
and
global
int
dwarf_die_offsets
Dwarf_Die
die
Dwarf_Off
global_offset
Dwarf_Off
local_offset
Dwarf_Error
error
Giving
a
section
name
get
its
size
and
address
int
dwarf_get_section_info_by_name
Dwarf_Debug
dbg
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
Giving
a
section
index
get
its
size
and
address
int
dwarf_get_section_info_by_index
Dwarf_Debug
dbg
int
section_index
const
char
section_name
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
Get
section
count
of
object
file
sections
int
dwarf_get_section_count
Dwarf_Debug
dbg
Get
the
version
and
offset
size
of
a
CU
context
This
is
useful
as
a
precursor
to
calling
dwarf_get_form_class
at
times
int
dwarf_get_version_of_die
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Half
offset_size
int
dwarf_discr_list
Dwarf_Debug
dbg
Dwarf_Small
blockpointer
Dwarf_Unsigned
blocklen
Dwarf_Dsc_Head
dsc_head_out
Dwarf_Unsigned
dsc_array_length_out
Dwarf_Error
error
NEW
September
Allows
easy
access
to
DW_AT_discr_list
entry
Callers
must
know
which
is
the
appropriate
one
of
the
following
two
interfaces
though
both
will
work
int
dwarf_discr_entry_u
Dwarf_Dsc_Head
dsc
Dwarf_Unsigned
entrynum
Dwarf_Half
out_type
Dwarf_Unsigned
out_discr_low
Dwarf_Unsigned
out_discr_high
Dwarf_Error
error
NEW
September
Allows
easy
access
to
DW_AT_discr_list
entry
int
dwarf_discr_entry_s
Dwarf_Dsc_Head
dsc
Dwarf_Unsigned
entrynum
Dwarf_Half
out_type
Dwarf_Signed
out_discr_low
Dwarf_Signed
out_discr_high
Dwarf_Error
error
New
May
So
users
can
find
out
what
groups
dwo
or
COMDAT
are
in
the
object
and
how
much
to
allocate
so
one
can
get
the
group
section
map
data
int
dwarf_sec_group_sizes
Dwarf_Debug
dbg
Dwarf_Unsigned
section_count_out
Dwarf_Unsigned
group_count_out
Dwarf_Unsigned
selected_group_out
Dwarf_Unsigned
map_entry_count_out
Dwarf_Error
error
New
May
Reveals
the
map
between
group
numbers
and
section
numbers
Caller
must
allocate
the
arrays
with
space
for
map_entry_count
values
and
this
function
fills
in
the
array
entries
Output
ordered
by
group
number
and
section
number
int
dwarf_sec_group_map
Dwarf_Debug
dbg
Dwarf_Unsigned
map_entry_count
Dwarf_Unsigned
group_numbers_array
Dwarf_Unsigned
sec_numbers_array
const
char
sec_names_array
Dwarf_Error
error
dwarf_get_endian_copy_function
new
December
void
dwarf_get_endian_copy_function
Dwarf_Debug
dbg
void
const
void
src
unsigned
long
srclen
These
make
the
LEB
encoding
routines
visible
to
libdwarf
callers
Added
November
int
dwarf_encode_leb128
Dwarf_Unsigned
val
int
nbytes
char
space
int
splen
int
dwarf_encode_signed_leb128
Dwarf_Signed
val
int
nbytes
char
space
int
splen
Same
for
LEB
decoding
routines
caller
sets
endptr
to
an
address
one
past
the
last
valid
address
the
library
should
be
allowed
to
access
int
dwarf_decode_leb128
char
leb
Dwarf_Unsigned
leblen
Dwarf_Unsigned
outval
char
endptr
int
dwarf_decode_signed_leb128
char
leb
Dwarf_Unsigned
leblen
Dwarf_Signed
outval
char
endptr
Record
some
application
command
line
options
in
libdwarf
This
is
not
arc
argv
processing
just
precooked
setting
of
a
flag
in
libdwarf
based
on
something
the
application
wants
check_verbose_mode
of
TRUE
means
do
more
checking
and
sometimes
print
errors
from
libdwarf
Not
restricted
to
a
single
Dwarf_Debug
it
applies
to
the
libdwarf
the
executable
is
using
typedef
struct
Dwarf_Cmdline_Options_s
Dwarf_Bool
check_verbose_mode
Dwarf_Cmdline_Options
extern
Dwarf_Cmdline_Options
dwarf_cmdline_options
Set
libdwarf
to
reflect
some
application
command
line
options
void
dwarf_record_cmdline_options
Dwarf_Cmdline_Options
options
ifndef
DW_FTYPE_UNKNOWN
define
DW_FTYPE_UNKNOWN
define
DW_FTYPE_ELF
Unix
Linux
etc
define
DW_FTYPE_MACH_O
MacOS
define
DW_FTYPE_PE
Windows
define
DW_FTYPE_ARCHIVE
unix
archive
endif
DW_FTYPE_UNKNOWN
ifndef
DW_ENDIAN_UNKNOWN
define
DW_ENDIAN_UNKNOWN
define
DW_ENDIAN_BIG
define
DW_ENDIAN_LITTLE
endif
DW_ENDIAN_UNKNOWN
Defined
March
Allows
a
caller
to
avoid
most
tracking
by
the
de_alloc_tree
hash
table
if
called
with
v
of
zero
Returns
the
value
the
flag
was
before
this
call
int
dwarf_set_de_alloc_flag
int
v
int
dwarf_object_detector_path_b
const
char
path
char
outpath_buffer
unsigned
long
outpathlen
char
gl_pathnames
unsigned
gl_pathcount
unsigned
int
ftype
unsigned
int
endian
unsigned
int
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
Solely
looks
for
dSYM
int
dwarf_object_detector_path_dSYM
const
char
path
char
outpath
unsigned
long
outpath_len
char
gl_pathnames
unsigned
gl_pathcount
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
unsigned
char
pathsource
int
errcode
define
DW_PATHSOURCE_unspecified
define
DW_PATHSOURCE_basic
define
DW_PATHSOURCE_dsym
MacOS
dSYM
define
DW_PATHSOURCE_debuglink
GNU
debuglink
Returns
the
pathsource
value
set
up
at
init
time
int
dwarf_get_path_source_type
Dwarf_Debug
dbg
unsigned
char
path_source
Dwarf_Error
error
int
dwarf_object_detector_fd
int
fd
unsigned
int
ftype
unsigned
int
endian
unsigned
int
offsetsize
Dwarf_Unsigned
filesize
int
errcode
ifdef
__cplusplus
endif
endif
_LIBDWARF_H
Copyright
David
Anderson
This
trivial
set
of
defines
is
hereby
placed
in
the
public
domain
for
all
to
use
To
enable
printing
with
printf
regardless
of
the
actual
underlying
data
type
we
define
the
DW_PR_xxx
macros
To
ensure
uses
of
DW_PR_DUx
or
DW_PR_DSx
look
the
way
you
want
ensure
the
DW_PR_XZEROS
define
as
you
want
it
ifndef
LIBDWARF_PRIVATE_H
define
LIBDWARF_PRIVATE_H
define
DW_PR_XZEROS
ifdef
_WIN32
define
DW_PR_DUx
I64x
define
DW_PR_DSx
I64x
define
DW_PR_DUu
I64u
define
DW_PR_DSd
I64d
else
define
DW_PR_DUx
llx
define
DW_PR_DSx
llx
define
DW_PR_DUu
llu
define
DW_PR_DSd
lld
endif
DW_PR
defines
ifdef
HAVE_UNUSED_ATTRIBUTE
define
UNUSEDARG
__attribute__
unused
else
define
UNUSEDARG
endif
ifndef
TRUE
define
TRUE
endif
TRUE
ifndef
FALSE
define
FALSE
endif
FALSE
define
DWARF_HALF_SIZE
endif
LIBDWARF_PRIVATE_H
This
date
string
is
hereby
put
into
the
public
domain
Copyrighting
this
is
crazy
It
s
just
a
date
string
and
is
modified
from
time
to
time
define
DW_VERSION_DATE_STR
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
malloc_check
h
A
simple
libdwarf
aware
malloc
checker
define
WANT_LIBBDWARF_MALLOC_CHECK
and
rebuild
libdwarf
do
make
a
checking
for
alloc
mistakes
libdwarf
NOT
recommended
for
production
use
When
defined
also
add
malloc_check
c
to
the
list
of
files
in
Makefile
undef
WANT_LIBBDWARF_MALLOC_CHECK
define
WANT_LIBBDWARF_MALLOC_CHECK
ifdef
WANT_LIBBDWARF_MALLOC_CHECK
void
dwarf_malloc_check_alloc_data
void
addr
unsigned
char
code
void
dwarf_malloc_check_dealloc_data
void
addr
unsigned
char
code
called
at
exit
of
app
void
dwarf_malloc_check_complete
char
wheremsg
else
WANT_LIBBDWARF_MALLOC_CHECK
define
dwarf_malloc_check_alloc_data
a
b
nothing
define
dwarf_malloc_check_dealloc_data
a
b
nothing
define
dwarf_malloc_check_complete
a
nothing
endif
WANT_LIBBDWARF_MALLOC_CHECK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
Lesser
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
Lesser
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
MEMCPY_SWAP_H
define
MEMCPY_SWAP_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
void
_dwarf_memcpy_swap_bytes
void
s1
const
void
s2
unsigned
long
len
It
s
inconvenient
to
use
memcpy
directly
as
it
uses
size_t
and
that
requires
stddef
h
void
_dwarf_memcpy_noswap_bytes
void
s1
const
void
s2
unsigned
long
len
ifdef
__cplusplus
endif
__cplusplus
endif
MEMCPY_SWAP_H
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
If
memory
full
we
do
not
exit
we
just
keep
going
as
if
all
were
well
include
globals
h
include
stdio
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
addrmap
h
include
dwarf_tsearch
h
static
struct
Addr_Map_Entry
addr_map_create_entry
Dwarf_Unsigned
k
char
name
struct
Addr_Map_Entry
mp
struct
Addr_Map_Entry
malloc
sizeof
struct
Addr_Map_Entry
if
mp
return
mp
mp_key
k
if
name
mp
mp_name
char
strdup
name
else
mp
mp_name
return
mp
static
void
addr_map_free_func
void
mx
struct
Addr_Map_Entry
m
mx
if
m
return
free
m
mp_name
m
mp_name
free
m
return
static
int
addr_map_compare_func
const
void
l
const
void
r
const
struct
Addr_Map_Entry
ml
l
const
struct
Addr_Map_Entry
mr
r
if
ml
mp_key
mr
mp_key
return
if
ml
mp_key
mr
mp_key
return
return
struct
Addr_Map_Entry
addr_map_insert
Dwarf_Unsigned
addr
char
name
void
tree1
void
retval
struct
Addr_Map_Entry
re
struct
Addr_Map_Entry
e
e
addr_map_create_entry
addr
name
tsearch
records
e
s
contents
unless
e
is
already
present
We
must
not
free
it
till
destroy
time
if
it
got
added
to
tree1
retval
dwarf_tsearch
e
tree1
addr_map_compare_func
if
retval
re
struct
Addr_Map_Entry
retval
if
re
e
We
returned
an
existing
record
e
not
needed
addr_map_free_func
e
else
Record
e
got
added
to
tree1
do
not
free
record
e
return
re
struct
Addr_Map_Entry
addr_map_find
Dwarf_Unsigned
addr
void
tree1
void
retval
struct
Addr_Map_Entry
re
struct
Addr_Map_Entry
e
e
addr_map_create_entry
addr
NULL
retval
dwarf_tfind
e
tree1
addr_map_compare_func
if
retval
re
struct
Addr_Map_Entry
retval
The
one
we
created
here
must
be
deleted
it
is
dead
We
look
at
the
returned
one
instead
addr_map_free_func
e
return
re
void
addr_map_destroy
void
map
tdestroy
is
not
part
of
Posix
it
is
a
GNU
libc
function
if
map
dwarf_tdestroy
map
addr_map_free_func
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
define
DW_TSHASHTYPE
long
this
type
not
needed
include
dwarf_tsearch
h
include
naming
h
include
attr_form
h
include
dwarfdump
af
table
h
const
Three_Key_Entry
threekeyzero
if
static
void
print_3key_record
int
num
Three_Key_Entry
e
printf
d
x
x
x
st
d
d
ct
lu
n
num
e
key1
e
key2
e
key3
e
std_or_exten
e
from_tables
unsigned
long
e
count
endif
int
make_3key
Dwarf_Half
k1
Dwarf_Half
k2
Dwarf_Half
k3
Dwarf_Small
std_or_exten
Dwarf_Small
from_preset
Dwarf_Unsigned
count
Three_Key_Entry
out
Three_Key_Entry
e
Three_Key_Entry
malloc
sizeof
Three_Key_Entry
if
e
return
DW_DLV_ERROR
out
of
memory
e
key1
k1
e
key2
k2
e
key3
k3
e
std_or_exten
std_or_exten
e
from_tables
from_preset
e
count
count
out
e
return
DW_DLV_OK
void
free_func_3key_entry
void
keystructptr
Three_Key_Entry
e
keystructptr
free
e
int
std_compare_3key_entry
const
void
l_in
const
void
r_in
const
Three_Key_Entry
l
l_in
const
Three_Key_Entry
r
r_in
if
l
key1
r
key1
return
if
l
key1
r
key1
return
if
l
key2
r
key2
return
if
l
key2
r
key2
return
if
l
key3
r
key3
return
if
l
key3
r
key3
return
return
static
Dwarf_Unsigned
counting_global
static
void
count_3key_entry
const
void
vptr
UNUSEDARG
DW_VISIT
x
int
level
UNUSEDARG
if
x
dwarf_preorder
x
dwarf_leaf
counting_global
Tree
argument
expected
is
threekey_attr_form_base
for
example
Dwarf_Unsigned
three_key_entry_count
void
base
Dwarf_Unsigned
count
counting_global
dwarf_twalk
base
count_3key_entry
count
counting_global
counting_global
return
count
tree
argument
expected
is
for
example
static
int
insert_new_tab_entry
void
tree
struct
af_table_s
tab
int
errnum
Three_Key_Entry
e
Three_Key_Entry
re
void
ret
int
res
res
make_3key
tab
attr
tab
formclass
tab
section
is
from
preset
data
count
is
zero
during
preset
if
res
DW_DLV_OK
errnum
DW_DLE_ALLOC_FAIL
return
res
ret
dwarf_tsearch
e
tree
std_compare_3key_entry
if
ret
errnum
DW_DLE_ALLOC_FAIL
return
res
re
Three_Key_Entry
ret
if
re
e
Normal
Added
return
DW_DLV_OK
A
full
duplicate
in
the
table
Oops
Not
a
great
choice
of
error
code
errnum
DW_DLE_ATTR_FORM_BAD
return
DW_DLV_ERROR
This
is
for
dwarfdump
to
call
at
runtime
Returns
DW_DLV_OK
on
success
int
build_attr_form_base_tree
int
errnum
struct
af_table_s
tab
int
res
void
tree
if
threekey_attr_form_base
Do
not
init
again
if
a
tied
file
return
DW_DLV_OK
for
tab
tab
if
tab
attr
tab
formclass
tab
section
Done
break
res
insert_new_tab_entry
tree
tab
errnum
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
The
standard
main
tree
for
attr_form
data
Starting
out
as
a
simple
global
variable
In
general
pass
for
example
to
tsearch
calls
void
threekey_attr_form_base
void
destroy_attr_form_trees
void
if
threekey_attr_form_base
return
dwarf_tdestroy
threekey_attr_form_base
free_func_3key_entry
threekey_attr_form_base
SKIP_AF_CHECK
defined
means
this
is
in
scripts
ddbuild
sh
and
this
checking
makes
no
sense
and
will
not
compile
ifndef
SKIP_AF_CHECK
static
Dwarf_Bool
legal_attr_formclass_combination
Dwarf_Half
attr
Dwarf_Half
fc
Three_Key_Entry
e
Three_Key_Entry
re
void
ret
int
res
res
make_3key
attr
fc
if
res
DW_DLV_OK
Hiding
some
sort
of
botch
malloc
issue
return
TRUE
ret
dwarf_tfind
e
std_compare_3key_entry
if
ret
Surprising
combo
free
e
return
FALSE
re
Three_Key_Entry
ret
if
glflags
gf_suppress_check_extensions_tables
free
e
return
TRUE
if
re
std_or_exten
AF_STD
free
e
return
TRUE
free
e
return
FALSE
static
void
check_attr_formclass_combination
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Half
attrnum
Dwarf_Half
fc
int
pd_dwarf_names_print_on_error
int
die_stack_indent_level
const
char
tagname
AT
invalid
const
char
formclassname
FORM_CLASS
invalid
DWARF_CHECK_COUNT
attr_formclass_result
if
legal_attr_formclass_combination
attrnum
fc
OK
else
Report
errors
only
if
tag
attr
check
is
on
if
glflags
gf_check_tag_attr
tagname
get_AT_name
attrnum
pd_dwarf_names_print_on_error
tag_specific_globals_setup
dbg
tag
die_stack_indent_level
formclassname
get_FORM_CLASS_name
fc
pd_dwarf_names_print_on_error
DWARF_CHECK_ERROR3
attr_formclass_result
tagname
formclassname
check
the
attr
formclass
combination
endif
SKIP_AF_CHECK
void
record_attr_form_use
ifndef
SKIP_AF_CHECK
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Half
attr
Dwarf_Half
fclass
Dwarf_Half
form
int
pd_dwarf_names_print_on_error
int
die_stack_indent_level
else
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Half
tag
UNUSEDARG
Dwarf_Half
attr
Dwarf_Half
fclass
Dwarf_Half
form
int
pd_dwarf_names_print_on_error
UNUSEDARG
int
die_stack_indent_level
UNUSEDARG
endif
SKIP_AF_CHECK
Three_Key_Entry
e
Three_Key_Entry
re
void
ret
Dwarf_Small
std_or_exten
AF_STD
int
res
if
attr
DW_AT_lo_user
std_or_exten
AF_EXTEN
else
if
form
DW_FORM_addrx4
There
is
no
lo_user
code
for
FORMs
they
really
are
limited
std_or_exten
AF_EXTEN
ifndef
SKIP_AF_CHECK
check_attr_formclass_combination
dbg
tag
attr
fclass
pd_dwarf_names_print_on_error
die_stack_indent_level
endif
SKIP_AF_CHECK
res
make_3key
attr
fclass
form
std_or_exten
if
res
DW_DLV_OK
Could
print
something
return
ret
dwarf_tsearch
e
std_compare_3key_entry
if
ret
free_func_3key_entry
e
Could
print
something
return
re
Three_Key_Entry
ret
if
re
e
Brand
new
entry
Done
local
malloc
is
in
the
tree
return
Was
already
entered
re
count
Clean
out
the
local
malloc
free_func_3key_entry
e
return
static
Dwarf_Unsigned
recordcount
static
Dwarf_Unsigned
recordmax
static
Three_Key_Entry
tkarray
static
void
extract_3key_entry
const
void
vptr
DW_VISIT
x
int
level
UNUSEDARG
if
x
dwarf_preorder
x
dwarf_leaf
Three_Key_Entry
m
Three_Key_Entry
vptr
if
recordcount
recordmax
Should
never
happen
return
tkarray
recordcount
m
recordcount
static
int
qsortformclass
const
void
e1in
const
void
e2in
Three_Key_Entry
e1
Three_Key_Entry
e1in
Three_Key_Entry
e2
Three_Key_Entry
e2in
if
e1
key2
e2
key2
return
if
e1
key2
e2
key2
return
return
static
int
qsortform
const
void
e1in
const
void
e2in
Three_Key_Entry
e1
Three_Key_Entry
e1in
Three_Key_Entry
e2
Three_Key_Entry
e2in
if
e1
key3
e2
key3
return
if
e1
key3
e2
key3
return
return
static
int
qsortcountattr
const
void
e1in
const
void
e2in
Three_Key_Entry
e1
Three_Key_Entry
e1in
Three_Key_Entry
e2
Three_Key_Entry
e2in
if
e1
count
e2
count
return
if
e1
count
e2
count
return
if
e1
key1
e2
key1
return
if
e1
key1
e2
key1
return
if
e1
key3
e2
key3
return
if
e1
key3
e2
key3
return
if
e1
key2
e2
key2
return
if
e1
key2
e2
key2
return
return
void
print_attr_form_usage
int
pd_dwarf_names_print_on_error
Three_Key_Entry
tk_l
Dwarf_Unsigned
i
float
total
unsigned
curform
Dwarf_Unsigned
formtotal
unsigned
curattr
Dwarf_Unsigned
attrtotal
Dwarf_Unsigned
j
float
pct
Dwarf_Bool
startnoted
FALSE
const
char
localformat
Dwarf_Unsigned
localsum
recordmax
three_key_entry_count
threekey_attr_form_base
if
recordmax
return
tk_l
Three_Key_Entry
calloc
recordmax
sizeof
Three_Key_Entry
tkarray
tk_l
if
tk_l
printf
ERROR
unable
to
malloc
attr
form
array
for
a
summary
report
n
glflags
gf_count_major_errors
return
Reset
the
file
global
recordcount
dwarf_twalk
threekey_attr_form_base
extract_3key_entry
if
recordcount
recordmax
printf
ERROR
unable
to
fill
in
attr
form
array
for
a
summary
report
count
lu
walk
lu
n
unsigned
long
recordcount
unsigned
long
recordmax
glflags
gf_count_major_errors
free
tk_l
tkarray
return
for
i
i
recordmax
i
Three_Key_Entry
tke
tk_l
i
if
tke
key3
Skip
table
building
data
continue
total
float
tke
count
qsort
tk_l
recordmax
sizeof
Three_Key_Entry
qsortcountattr
printf
n
ATTRIBUTES
AND
FORMS
USAGE
n
printf
Full
record
count
DW_PR_DUu
n
recordmax
printf
Total
number
of
objectfile
attributes
n
total
printf
found
rate
n
localformat
DW_PR_DUu
n
localsum
for
i
i
recordmax
i
Three_Key_Entry
tke
tk_l
i
if
tke
key3
Skip
table
building
data
continue
pct
float
tke
count
total
printf
localformat
unsigned
i
get_AT_name
tke
key1
pd_dwarf_names_print_on_error
get_FORM_name
tke
key3
pd_dwarf_names_print_on_error
tke
count
pct
localsum
tke
count
printf
localformat
unsigned
recordmax
Sum
found
localsum
qsort
tk_l
recordmax
sizeof
Three_Key_Entry
qsortformclass
j
Re
using
the
following
two
curform
formtotal
startnoted
FALSE
printf
n
COUNT
BY
FORMCLASS
n
printf
found
rate
n
localsum
localformat
DW_PR_DUu
n
for
i
i
recordmax
i
Three_Key_Entry
tke
tk_l
i
if
tke
key3
Skip
table
building
data
continue
if
startnoted
curform
tke
key2
formtotal
tke
count
startnoted
TRUE
continue
if
curform
tke
key2
pct
float
formtotal
total
printf
localformat
unsigned
j
get_FORM_CLASS_name
curform
pd_dwarf_names_print_on_error
formtotal
pct
localsum
formtotal
curform
tke
key2
formtotal
tke
count
j
continue
formtotal
tke
count
if
formtotal
pct
float
formtotal
total
printf
localformat
unsigned
j
get_FORM_CLASS_name
curform
pd_dwarf_names_print_on_error
formtotal
pct
localsum
formtotal
printf
localformat
unsigned
j
Sum
found
localsum
Re
using
the
following
two
curform
formtotal
startnoted
FALSE
qsort
tk_l
recordmax
sizeof
Three_Key_Entry
qsortform
j
printf
n
COUNT
BY
FORM
n
printf
found
rate
n
localformat
DW_PR_DUu
n
localsum
for
i
i
recordmax
i
Three_Key_Entry
tke
tk_l
i
if
tke
key3
Skip
table
building
data
continue
if
startnoted
curform
tke
key3
formtotal
tke
count
startnoted
TRUE
continue
if
curform
tke
key3
pct
float
formtotal
total
printf
localformat
unsigned
j
get_FORM_name
curform
pd_dwarf_names_print_on_error
formtotal
pct
localsum
formtotal
curform
tke
key3
formtotal
tke
count
j
continue
formtotal
tke
count
if
formtotal
pct
float
formtotal
total
printf
localformat
unsigned
j
get_FORM_name
curform
pd_dwarf_names_print_on_error
formtotal
pct
localsum
formtotal
printf
localformat
unsigned
j
Sum
found
localsum
j
curattr
attrtotal
startnoted
FALSE
printf
n
COUNT
BY
ATTRIBUTE
n
printf
found
rate
n
localsum
localformat
DW_PR_DUu
n
for
i
i
recordmax
i
Three_Key_Entry
tke
tk_l
i
if
tke
key3
Skip
table
building
data
continue
if
startnoted
curattr
tke
key1
attrtotal
tke
count
startnoted
TRUE
continue
if
curattr
tke
key1
pct
float
attrtotal
total
printf
localformat
unsigned
j
get_AT_name
curattr
pd_dwarf_names_print_on_error
attrtotal
pct
localsum
attrtotal
curattr
tke
key1
attrtotal
tke
count
j
continue
formtotal
tke
count
if
attrtotal
pct
float
attrtotal
total
printf
localformat
unsigned
j
get_AT_name
curattr
pd_dwarf_names_print_on_error
attrtotal
pct
localsum
attrtotal
printf
localformat
unsigned
j
Sum
found
localsum
free
tk_l
tkarray
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
stdio
h
include
stdarg
h
For
va_start
va_arg
va_list
include
errno
h
For
errno
declaration
ifdef
HAVE_UNISTD_H
include
unistd
h
endif
HAVE_UNISTD_
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
exit
declaration
etc
endif
HAVE_STDLIB_H
include
dwarf
h
include
libdwarf
h
include
common
h
include
esb
h
include
tag_common
h
include
dwgetopt
h
define
DW_TSHASHTYPE
long
we
are
not
using
hash
tree
include
dwarf_tsearch
h
include
attr_form
h
include
libdwarf_version
h
Dwarf_Bool
ellipsis
FALSE
So
we
can
use
dwarf_names
c
Expected
input
format
DW_AT_something
a
number
as
seen
here
name
of
a
form
class
enum
entry
DW_AT_something_else
a
number
as
seen
here
name
of
a
form
class
enum
entry
We
generate
a
text
list
of
numbers
as
a
C
header
file
The
array
there
is
used
include
dwarf_tsearch
h
by
dwarfdump
at
runtime
if
attr
form
checking
is
requested
The
file
is
named
dwarfump
dwarfdump
af
table
h
and
is
intended
to
be
included
in
exactly
one
place
in
dwarfdump
source
The
list
is
N
entries
N
is
not
limited
of
attribute
formclass
std1
extended2
flag
followed
by
a
space
and
the
and
then
names
For
example
DW_AT_location
DW_FORM_CLASS_REFERENCE
Std
with
the
names
in
a
C
comment
block
which
we
do
not
show
quite
right
here
See
dwarfdump
dwarfdump
af
table
h
The
Standard
vs
Extended
table
indication
is
a
rough
indication
dwarfdump
will
know
what
are
extension
ATtributes
and
extension
FORMs
by
the
valuing
being
at
or
above
the
formal
AT
DW_AT_lo_user
and
the
FORM
being
above
ie
the
highest
defined
by
any
DWARF
standard
lacking
a
DW_FORM_lo_user
value
Lines
beggining
with
a
character
are
ignored
by
the
code
in
dwarfdump
reading
this
output
Any
lines
commented
with
C
comments
are
stripped
by
the
initial
C
pre
processor
invocation
define
AF_STANDARD
define
AF_EXTENDED
static
const
char
usage
Usage
attr_form_build
options
i
input
table
path
o
output
table
path
s
Generate
standard
attr
formclass
table
e
Generate
extended
attr
formclass
table
common
extensions
const
char
program_name
char
input_name
char
output_name
int
standard_flag
FALSE
int
extended_flag
FALSE
process
arguments
static
void
process_args
int
argc
char
argv
int
c
Dwarf_Bool
usage_error
FALSE
program_name
argv
while
c
dwgetopt
argc
argv
i
o
se
EOF
switch
c
case
i
input_name
dwoptarg
break
case
o
output_name
dwoptarg
break
case
e
extended_flag
TRUE
break
case
s
standard_flag
TRUE
break
default
usage_error
TRUE
break
if
usage_error
dwoptind
dwoptind
argc
print_usage_message
argv
usage
exit
FAILED
void
attr_check_dups
void
check_for_dup_attr
unsigned
attr
Three_Key_Entry
e
Three_Key_Entry
re
int
kres
void
ret
kres
make_3key
attr
if
kres
DW_DLV_OK
printf
FAIL
malloc
in
check_for_dup_attr
line
d
n
__LINE__
exit
if
ret
dwarf_tfind
e
std_compare_3key_entry
if
ret
printf
FAIL
as
attribute
x
is
duplicated
n
attr
exit
endif
ret
dwarf_tsearch
e
std_compare_3key_entry
if
ret
printf
FAIL
malloc
in
check_for_dup_attr
line
d
n
__LINE__
exit
re
Three_Key_Entry
ret
if
re
e
printf
FAIL
as
attribute
x
is
duplicated
n
attr
If
we
did
not
exit
we
would
free
e
here
exit
int
main
int
argc
char
argv
unsigned
int
num
int
input_eof
unsigned
current_row
FILE
fileInp
FILE
fileOut
print_version_details
argv
FALSE
print_args
argc
argv
process_args
argc
argv
if
input_name
fprintf
stderr
Input
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileInp
fopen
input_name
r
if
fileInp
fprintf
stderr
Invalid
input
filename
could
not
open
s
n
input_name
print_usage_message
argv
usage
exit
FAILED
if
output_name
fprintf
stderr
Output
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileOut
fopen
output_name
a
if
fileOut
fprintf
stderr
Invalid
output
filename
could
not
open
s
n
output_name
print_usage_message
argv
usage
exit
FAILED
if
standard_flag
extended_flag
standard_flag
extended_flag
fprintf
stderr
Invalid
table
type
n
fprintf
stderr
Choose
e
or
s
n
print_usage_message
argv
usage
exit
FAILED
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Empty
input
file
if
num
MAGIC_TOKEN_VALUE
bad_line_input
Expected
if
standard_flag
fprintf
fileOut
Generated
table
do
not
edit
n
fprintf
fileOut
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
fileOut
n
fprintf
fileOut
s
n
ifndef
DWARFDUMP_AF_TABLE_H
fprintf
fileOut
s
n
define
DWARFDUMP_AF_TABLE_H
fprintf
fileOut
n
fprintf
fileOut
s
n
ifdef
__cplusplus
fprintf
fileOut
s
n
extern
C
fprintf
fileOut
s
n
endif
__cplusplus
fprintf
fileOut
struct
af_table_s
n
fprintf
fileOut
Dwarf_Half
attr
n
fprintf
fileOut
Dwarf_Half
formclass
n
fprintf
fileOut
unsigned
char
section
n
fprintf
fileOut
attr_formclass_table
n
while
feof
stdin
unsigned
int
attr
input_eof
read_value
fileInp
if
IS_EOF
input_eof
Reached
normal
eof
break
check_for_dup_attr
attr
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
while
num
MAGIC_TOKEN_VALUE
int
res
const
char
name
fprintf
fileOut
d
attr
num
standard_flag?
AF_STANDARD
AF_EXTENDED
res
dwarf_get_AT_name
attr
if
res
DW_DLV_OK
printf
Unknown
attribute
number
of
x
Giving
up
n
num
exit
fprintf
fileOut
s
name
res
dwarf_get_FORM_CLASS_name
num
if
res
DW_DLV_OK
printf
Unknown
form
class
number
of
x
Giving
up
n
num
exit
fprintf
fileOut
s
name
fprintf
fileOut
s
n
standard_flag?
Std
Ext
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
current_row
if
extended_flag
fprintf
fileOut
n
fprintf
fileOut
end
af_table
extended
n
fprintf
fileOut
s
n
ifdef
__cplusplus
fprintf
fileOut
s
n
extern
C
fprintf
fileOut
s
n
endif
__cplusplus
fprintf
fileOut
s
n
endif
DWARFDUMP_AF_TABLE_H
else
fprintf
fileOut
end
af_table
standard
n
dwarf_tdestroy
attr_check_dups
free_func_3key_entry
attr_check_dups
fclose
fileInp
fclose
fileOut
return
A
fake
so
we
can
use
dwarf_names
c
void
print_error
Dwarf_Debug
dbg
UNUSEDARG
const
char
msg
UNUSEDARG
int
res
UNUSEDARG
Dwarf_Error
localerr
UNUSEDARG
Copyright
c
David
Anderson
All
rights
reserved
This
software
file
is
hereby
placed
in
the
public
domain
For
use
by
anyone
for
any
purpose
This
uses
this
condensed
table
to
make
a
simple
fast
access
C
table
Build
and
run
with
cc
I
libdwarf
buildopscounttab
c
dwarf_names
c
o
buildop
buildop
opscounttab
c
include
stdio
h
include
dwarf
h
include
dwarf_names
h
include
opscounttab
h
struct
ops_table_s
unsigned
char
ot_first
unsigned
char
ot_last
signed
char
ot_opcount
Must
match
libdwarf
h
macros
define
DW_DLV_OK
define
DW_DLV_ERROR
struct
ops_table_s
optabsource
DW_OP_addr
DW_OP_deref
DW_OP_const1u
DW_OP_consts
DW_OP_dup
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_xor
DW_OP_bra
DW_OP_eq
DW_OP_ne
DW_OP_skip
DW_OP_lit0
DW_OP_lit31
DW_OP_reg0
DW_OP_reg31
DW_OP_breg0
DW_OP_breg31
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_xderef_size
DW_OP_nop
DW_OP_push_object_address
DW_OP_call2
DW_OP_call_ref
DW_OP_form_tls_address
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_xderef_type
DW_OP_convert
DW_OP_reinterpret
DW_OP_GNU_push_tls_address
DW_OP_GNU_uninit
DW_OP_GNU_encoded_addr
DW_OP_GNU_implicit_pointer
DW_OP_GNU_entry_value
DW_OP_GNU_const_type
DW_OP_GNU_regval_type
DW_OP_GNU_deref_type
DW_OP_GNU_convert
DW_OP_GNU_variable_value
int
main
struct
ops_table_s
op
int
inindex
int
outindex
int
f
int
l
int
c
int
res
int
lastop
printf
Generated
expression
ops
table
n
printf
do
not
edit
n
printf
include
opscounttab
h
n
printf
n
printf
struct
dwarf_opscounttab_s
dwarf_opscounttab
n
for
inindex
const
char
opn
op
inindex
f
op
ot_first
if
f
break
if
lastop
f
lastop
printf
FAILED
buildopscounttab
on
OP
out
of
sequence
f
x
lastop
x
n
unsigned
f
unsigned
lastop
return
effectively
exit
l
op
ot_last
c
op
ot_opcount
while
f
outindex
printf
d
n
unused
outindex
outindex
if
l
res
dwarf_get_OP_name
f
if
res
DW_DLV_OK
printf
FAILED
buildopscounttab
on
OP
x
n
f
return
effectively
exit
lastop
f
printf
d
n
opn
f
c
outindex
else
int
j
f
for
j
l
j
res
dwarf_get_OP_name
j
if
res
DW_DLV_OK
printf
FAILED
buildopscounttab
on
OP
x
n
f
return
effectively
exit
printf
d
n
opn
j
c
outindex
lastop
j
while
outindex
DWOPS_ARRAY_SIZE
printf
d
n
unused
outindex
outindex
printf
n
return
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
These
simple
list
processing
functions
are
in
support
of
checking
DWARF
for
compiler
errors
of
various
sorts
include
globals
h
It
includes
config
h
include
assert
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
esb
h
Private
function
static
void
DumpFullBucketGroup
Bucket_Group
pBucketGroup
static
int
FindDataIndexInBucket
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
static
void
PrintBucketData
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
static
void
ProcessBucketGroup
Bucket_Group
pBucketGroup
void
pFunction
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
Bucket_Group
AllocateBucketGroup
int
kind
Bucket_Group
pBucketGroup
Bucket_Group
calloc
sizeof
Bucket_Group
pBucketGroup
kind
kind
return
pBucketGroup
void
ReleaseBucketGroup
Bucket_Group
pBucketGroup
Bucket
pBucket
Bucket
pNext
assert
pBucketGroup
for
pBucket
pBucketGroup
pHead
pBucket
pNext
pBucket
pNext
free
pBucket
pBucket
pNext
pBucketGroup
pHead
NULL
pBucketGroup
pTail
NULL
free
pBucketGroup
void
ResetBucketGroup
Bucket_Group
pBucketGroup
Bucket
pBucket
assert
pBucketGroup
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
pBucket
pNext
pBucket
nEntries
ResetSentinelBucketGroup
pBucketGroup
Reset
sentinels
in
a
Bucket
Group
void
ResetSentinelBucketGroup
Bucket_Group
pBucketGroup
Sanity
checks
assert
pBucketGroup
pBucketGroup
pFirst
NULL
pBucketGroup
pLast
NULL
void
PrintBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Bool
bFull
if
pBucketGroup
if
bFull
DumpFullBucketGroup
pBucketGroup
else
if
pBucketGroup
pFirst
pBucketGroup
pLast
printf
nBegin
Traversing
First
DW_PR_DUx
Last
DW_PR_DUx
n
pBucketGroup
pFirst
key
pBucketGroup
pLast
key
ProcessBucketGroup
pBucketGroup
PrintBucketData
static
void
PrintBucketData
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
int
nCount
assert
pBucketGroup
assert
pBucketData
nCount
FindDataIndexInBucket
pBucketGroup
pBucketData
printf
Key
DW_PR_DUx
Base
DW_PR_DUx
Low
DW_PR_DUx
High
DW_PR_DUx
Flag
d
Name
s
n
nCount
pBucketData
key
pBucketData
base
pBucketData
low
pBucketData
high
pBucketData
bFlag
pBucketData
name
static
void
DumpFullBucketGroup
Bucket_Group
pBucketGroup
int
nBucketNo
int
nIndex
int
nCount
Bucket
pBucket
Bucket_Data
pBucketData
assert
pBucketGroup
printf
nBucket
Group
at
DW_PR_DUx
lower
DW_PR_DUx
upper
DW_PR_DUx
n
Dwarf_Unsigned
uintptr_t
pBucketGroup
Dwarf_Unsigned
pBucketGroup
lower
Dwarf_Unsigned
pBucketGroup
upper
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
printf
LowPC
HighPC
records
for
bucket
d
at
DW_PR_DUx
n
nBucketNo
Dwarf_Unsigned
uintptr_t
pBucket
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
printf
Key
DW_PR_DUx
Base
DW_PR_DUx
Low
DW_PR_DUx
High
DW_PR_DUx
Flag
d
Name
s
n
nCount
pBucketData
key
pBucketData
base
pBucketData
low
pBucketData
high
pBucketData
bFlag
pBucketData
name
Insert
entry
into
Bucket
Group
We
make
no
check
for
duplicate
information
void
AddEntryIntoBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
Dwarf_Addr
base
Dwarf_Addr
low
Dwarf_Addr
high
const
char
name
Dwarf_Bool
bFlag
Bucket
pBucket
Bucket_Data
data
data
bFlag
bFlag
data
name
name
data
key
key
data
base
base
data
low
low
data
high
high
assert
pBucketGroup
if
pBucketGroup
pHead
Allocate
first
bucket
pBucket
Bucket
calloc
sizeof
Bucket
pBucketGroup
pHead
pBucket
pBucketGroup
pTail
pBucket
pBucket
nEntries
pBucket
Entries
data
return
pBucket
pBucketGroup
pTail
Check
if
we
have
a
previous
allocated
set
of
buckets
have
been
cleared
if
pBucket
nEntries
if
pBucket
nEntries
BUCKET_SIZE
pBucket
Entries
pBucket
nEntries
data
else
Allocate
new
bucket
pBucket
Bucket
calloc
sizeof
Bucket
pBucketGroup
pTail
pNext
pBucket
pBucketGroup
pTail
pBucket
pBucket
nEntries
pBucket
Entries
data
else
We
have
an
allocated
bucket
with
zero
entries
search
for
the
first
available
bucket
to
be
used
as
the
current
insertion
point
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
pBucket
pNext
if
pBucket
nEntries
BUCKET_SIZE
pBucket
Entries
pBucket
nEntries
data
break
For
Groups
where
entries
are
individually
deleted
this
does
that
work
Dwarf_Bool
DeleteKeyInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
int
nIndex
Bucket
pBucket
Bucket_Data
pBucketData
Sanity
checks
assert
pBucketGroup
For
now
do
a
linear
search
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
pBucketData
key
key
Bucket_Data
data
FALSE
NULL
int
nStart
for
nStart
nIndex
nStart
pBucket
nEntries
nStart
pBucket
Entries
nIndex
pBucket
Entries
nStart
nIndex
pBucket
Entries
nIndex
data
pBucket
nEntries
return
TRUE
return
FALSE
Search
to
see
if
the
address
is
in
the
range
between
low
and
high
addresses
in
some
Bucked
Data
record
This
matches
if
high
is
exact
match
which
usually
means
one
past
true
high
Dwarf_Bool
FindAddressInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
address
int
nIndex
Bucket
pBucket
Bucket_Data
pBucketData
assert
pBucketGroup
For
now
do
a
linear
search
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
address
pBucketData
low
address
pBucketData
high
return
TRUE
return
FALSE
Search
an
entry
Bucket
Data
in
the
Bucket
Set
Bucket_Data
FindDataInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
int
mid
int
low
int
high
Bucket
pBucket
Bucket_Data
pBucketData
assert
pBucketGroup
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
pBucket
pNext
Get
lower
and
upper
references
if
pBucket
nEntries
low
high
pBucket
nEntries
while
low
high
mid
low
high
low
if
pBucket
Entries
mid
key
key
low
mid
else
high
mid
if
low
pBucket
nEntries
pBucket
Entries
low
key
key
pBucketData
Entries
low
Update
sentinels
to
allow
traversing
the
table
if
pBucketGroup
pFirst
pBucketGroup
pFirst
pBucketData
pBucketGroup
pLast
pBucketData
return
pBucketData
return
Bucket_Data
NULL
Find
the
Bucket
that
contains
a
given
Bucket
Data
and
return
its
local
index
Else
return
static
int
FindDataIndexInBucket
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
Bucket
pBucket
Bucket_Data
pLower
Bucket_Data
pUpper
Sanity
checks
assert
pBucketGroup
assert
pBucketData
Use
sentinels
if
any
if
pBucketGroup
pFirst
pBucketGroup
pLast
pBucketData
pBucketGroup
pFirst
pBucketData
pBucketGroup
pLast
Find
bucket
that
contains
the
first
sentinel
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
pLower
Entries
pUpper
Entries
pBucket
nEntries
Check
if
the
first
sentinel
is
in
this
bucket
if
pBucketGroup
pFirst
pLower
pBucketGroup
pFirst
pUpper
We
have
found
the
bucket
return
the
index
return
pBucketData
pBucketGroup
pFirst
else
Find
bucket
that
contains
the
entry
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
pLower
Entries
pUpper
Entries
pBucket
nEntries
Check
if
the
first
sentinel
is
in
this
bucket
if
pBucketData
pLower
pBucketData
pUpper
We
have
found
the
bucket
return
the
index
return
pBucketData
pLower
Invalid
data
just
return
index
indicating
not
found
return
Search
an
entry
Bucket
Data
in
the
Bucket
Group
The
key
is
an
offset
a
DIE
offset
within
Visited
info
Bucket_Data
FindKeyInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
int
nIndex
Bucket
pBucket
Bucket_Data
pBucketData
Sanity
checks
assert
pBucketGroup
For
now
do
a
linear
search
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
pBucketData
key
key
return
pBucketData
return
Bucket_Data
NULL
Search
an
entry
Bucket
Data
in
the
Bucket
Set
by
name
Used
to
find
link
once
section
names
Bucket_Data
FindNameInBucketGroup
Bucket_Group
pBucketGroup
char
name
int
nIndex
Bucket
pBucket
Bucket_Data
pBucketData
assert
pBucketGroup
For
now
do
a
linear
search
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
strcmp
pBucketData
name
name
return
pBucketData
return
Bucket_Data
NULL
Check
if
an
address
valid
or
not
That
is
check
if
it
is
in
the
lower
upper
range
of
a
bucket
It
checks
and
so
the
lower
end
and
one
past
on
the
upper
end
matches
Dwarf_Bool
IsValidInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
address
Bucket
pBucket
Bucket_Data
pBucketData
int
nIndex
assert
pBucketGroup
Check
the
address
is
within
the
allowed
limits
if
address
pBucketGroup
lower
address
pBucketGroup
upper
pBucket
pBucketGroup
pHead
for
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
address
pBucketData
low
address
pBucketData
high
return
TRUE
return
FALSE
Reset
limits
for
values
in
the
Bucket
Set
void
ResetLimitsBucketSet
Bucket_Group
pBucketGroup
assert
pBucketGroup
pBucketGroup
lower
pBucketGroup
upper
Limits
are
set
only
for
ranges
so
only
in
pRangesInfo
But
is
used
for
ranges
and
location
lists
The
default
is
set
from
object
data
virt
addr
size
in
object
file
but
that
does
not
work
sensibly
in
PE
object
files
void
SetLimitsBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
lower
Dwarf_Addr
upper
assert
pBucketGroup
if
lower
upper
pBucketGroup
lower
lower
pBucketGroup
upper
upper
Traverse
Bucket
Set
and
execute
a
supplied
function
static
void
ProcessBucketGroup
Bucket_Group
pBucketGroup
void
pFunction
Bucket_Group
pBucketGroup
Bucket_Data
pBucketData
int
nIndex
int
nStart
Bucket
pBucket
Bucket_Data
pBucketData
Bucket_Data
pLower
Bucket_Data
pUpper
Dwarf_Bool
bFound
FALSE
Sanity
checks
assert
pBucketGroup
No
sentinels
present
do
nothing
if
pBucketGroup
pFirst
pBucketGroup
pLast
return
Find
bucket
that
contains
the
first
sentinel
for
pBucket
pBucketGroup
pHead
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
pLower
Entries
pUpper
Entries
pBucket
nEntries
Check
if
the
first
sentinel
is
in
this
bucket
if
pBucketGroup
pFirst
pLower
pBucketGroup
pFirst
pUpper
Low
sentinel
is
in
this
bucket
bFound
TRUE
break
Invalid
sentinel
do
nothing
if
bFound
return
Calculate
index
for
first
sentinel
nStart
pBucketGroup
pFirst
pLower
Start
traversing
from
found
bucket
for
pBucket
pBucket
nEntries
pBucket
pBucket
pNext
for
nIndex
nStart
nIndex
pBucket
nEntries
nIndex
pBucketData
Entries
nIndex
if
pBucketData
pBucketGroup
pLast
return
Call
the
user
supplied
function
if
pFunction
pFunction
pBucketGroup
pBucketData
For
next
bucket
start
with
first
entry
nStart
Check
if
a
given
lopc
hipc
are
valid
for
a
linkonce
We
pass
in
the
linkonce
instead
of
referencing
the
global
pLinkonceInfo
as
that
means
searches
for
pLinkonceInfo
find
all
the
uses
making
understanding
of
the
code
a
tiny
bit
easier
The
section
name
created
is
supposed
to
be
the
appropriate
linkonce
section
name
Dwarf_Bool
IsValidInLinkonce
Bucket_Group
pLo
const
char
name
Dwarf_Addr
lopc
Dwarf_Addr
hipc
define
SECTION_NAME_LEN
Guessing
a
sensible
length
static
char
section_name
SECTION_NAME_LEN
Bucket_Data
pBucketData
Since
text
is
quite
uniformly
just
this
name
no
need
to
get
it
from
elsewhere
though
it
will
not
work
for
non
elf
const
char
lo_text
text
Build
the
name
that
represents
the
linkonce
section
text
This
is
not
defined
in
DWARF
so
not
correct
for
all
compilers
struct
esb_s
sn
esb_constructor_fixed
section_name
sizeof
section_name
esb_append
lo_text
esb_append
name
pBucketData
FindNameInBucketGroup
pLo
esb_get_string
esb_destructor
if
pBucketData
if
lopc
pBucketData
low
lopc
pBucketData
high
if
hipc
pBucketData
low
hipc
pBucketData
high
return
TRUE
return
FALSE
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
dwconf
h
include
dwgetopt
h
include
common
h
include
makename
h
include
uri
h
include
esb
h
For
flexible
string
buffer
include
sanitized
h
include
tag_common
h
include
section_bitmaps
h
include
command_options
h
include
compiler_info
h
static
const
char
remove_quotes_pair
const
char
text
static
char
special_program_name
char
n
static
void
suppress_check_dwarf
void
extern
char
dwoptarg
These
configure
items
are
for
the
frame
data
We
re
flexible
in
the
path
to
dwarfdump
conf
The
HOME
strings
here
are
transformed
in
dwconf
c
to
reference
the
environment
variable
As
of
August
CONFPREFIX
is
always
set
as
it
comes
from
autoconf
prefix
aka
which
defaults
to
usr
local
The
install
puts
the
conf
file
in
CONFPREFIX
dwarfdump
static
char
config_file_defaults
dwarfdump
conf
dwarfdump
conf
HOME
dwarfdump
conf
HOME
dwarfdump
conf
See
Makefile
am
dwarfdump_CFLAGS
This
prefix
is
the
prefix
option
defaults
to
usr
local
and
Makefile
am
adds
share
dwarfdump
We
need
levels
of
macro
to
get
the
name
turned
into
the
string
we
want
define
STR2
s
s
define
STR
s
STR2
s
STR
CONFPREFIX
dwarfdump
conf
usr
share
dwarfdump
dwarfdump
conf
static
const
char
config_file_abi
Do
printing
of
most
sections
Do
not
do
detailed
checking
static
void
do_all
void
glflags
gf_frame_flag
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
debug_types
glflags
gf_line_flag
TRUE
glflags
gf_no_follow_debuglink
FALSE
glflags
gf_global_debuglink_paths
glflags
gf_global_debuglink_count
glflags
gf_pubnames_flag
TRUE
glflags
gf_macinfo_flag
TRUE
glflags
gf_macro_flag
TRUE
glflags
gf_aranges_flag
TRUE
Do
not
do
glflags
gf_loc_flag
TRUE
glflags
gf_abbrev_flag
TRUE
glflags
gf_ranges_flag
TRUE
because
nothing
in
the
DWARF
spec
guarantees
the
sections
are
free
of
random
bytes
in
areas
not
referenced
by
debug_info
though
for
DWARF5
debug_loclists
is
free
of
random
bytes
See
print_raw_loclists
glflags
gf_string_flag
TRUE
Do
not
do
glflags
gf_reloc_flag
TRUE
as
print_relocs
makes
no
sense
for
non
elf
dwarfdump
users
glflags
gf_static_func_flag
TRUE
SGI
only
glflags
gf_static_var_flag
TRUE
SGI
only
glflags
gf_pubtypes_flag
TRUE
both
SGI
typenames
and
dwarf_pubtypes
glflags
gf_weakname_flag
TRUE
SGI
only
glflags
gf_gnu_debuglink_flag
FALSE
glflags
gf_debug_names_flag
TRUE
glflags
gf_debug_sup_flag
TRUE
static
int
get_number_value
char
v_in
long
int
v_out
long
int
v
size_t
len
strlen
v_in
char
endptr
if
len
return
DW_DLV_ERROR
v
strtol
v_in
if
endptr
v_in
return
DW_DLV_NO_ENTRY
if
endptr
return
DW_DLV_ERROR
v_out
v
return
DW_DLV_OK
static
void
suppress_print_dwarf
void
glflags
gf_do_print_dwarf
FALSE
glflags
gf_do_check_dwarf
TRUE
Remove
matching
leading
trailing
quotes
Does
not
alter
the
passed
in
string
If
quotes
removed
does
a
makename
on
a
modified
string
static
const
char
remove_quotes_pair
const
char
text
static
char
single_quote
static
char
double_quote
char
quote
const
char
p
text
int
len
strlen
text
if
len
return
p
Compare
first
character
with
or
if
p
single_quote
quote
single_quote
else
if
p
double_quote
quote
double_quote
else
return
p
if
p
len
quote
char
altered
calloc
len
const
char
str2
strcpy
altered
p
altered
len
str2
makename
altered
free
altered
return
str2
return
p
By
trimming
a
dwarfdump
O
down
to
dwarfdump
keeping
any
prefix
or
suffix
we
can
avoid
a
sed
command
in
regressiontests
DWARFTEST
sh
and
save
minutes
run
time
of
a
regression
test
The
effect
is
when
nothing
has
changed
in
the
normal
output
that
the
program_name
matches
too
Because
we
don
t
want
a
different
name
of
dwarfdump
to
cause
a
mismatch
static
char
special_program_name
char
n
char
mp
dwarfdump
O
char
revstr
dwarfdump
char
cp
n
size_t
mslen
strlen
mp
for
cp
cp
if
cp
mp
if
strncmp
cp
mp
mslen
esb_append
glflags
newprogname
revstr
cp
mslen
else
esb_appendn
glflags
newprogname
cp
else
esb_appendn
glflags
newprogname
cp
return
esb_get_string
glflags
newprogname
static
void
suppress_check_dwarf
void
glflags
gf_do_print_dwarf
TRUE
if
glflags
gf_do_check_dwarf
printf
Warning
check
flag
turned
off
checking
and
printing
are
separate
n
glflags
gf_do_check_dwarf
FALSE
set_checks_off
static
struct
esb_s
uri_esb_data
void
uri_data_constructor
void
esb_constructor
void
uri_data_destructor
void
esb_destructor
The
strings
whose
pointers
are
returned
here
from
makename
are
never
destructed
but
that
is
ok
since
there
are
only
about
created
at
most
const
char
do_uri_translation
const
char
s
const
char
context
struct
esb_s
str
char
finalstr
if
glflags
gf_uri_options_translation
return
makename
s
esb_constructor
translate_from_uri
s
if
glflags
gf_do_print_uri_in_input
if
strcmp
s
esb_get_string
printf
Uri
Translation
on
option
s
n
context
printf
s
n
s
printf
s
n
esb_get_string
finalstr
makename
esb_get_string
esb_destructor
return
finalstr
Support
for
short
option
and
long
option
names
options
These
functions
implement
the
individual
options
They
are
called
from
short
names
and
long
names
options
Implementation
code
is
shared
for
both
types
of
formats
Handlers
for
the
short
long
names
options
static
void
arg_check_abbrev
void
static
void
arg_check_all
void
static
void
arg_check_aranges
void
static
void
arg_check_attr_dup
void
static
void
arg_check_attr_encodings
void
static
void
arg_check_attr_names
void
static
void
arg_check_constants
void
static
void
arg_check_files_lines
void
static
void
arg_check_forward_refs
void
static
void
arg_check_frame_basic
void
static
void
arg_check_frame_extended
void
static
void
arg_check_frame_info
void
static
void
arg_check_gaps
void
static
void
arg_check_loc
void
static
void
arg_check_macros
void
static
void
arg_check_pubnames
void
static
void
arg_check_ranges
void
static
void
arg_check_self_refs
void
static
void
arg_check_show
void
static
void
arg_check_silent
void
static
void
arg_check_summary
void
static
void
arg_check_tag_attr
void
static
void
arg_check_tag_tag
void
static
void
arg_check_type
void
static
void
arg_check_unique
void
ifdef
HAVE_USAGE_TAG_ATTR
static
void
arg_check_usage
void
static
void
arg_check_usage_extended
void
endif
HAVE_USAGE_TAG_ATTR
static
void
arg_elf
void
static
void
arg_elf_abbrev
void
static
void
arg_elf_aranges
void
static
void
arg_elf_default
void
static
void
arg_elf_fission
void
static
void
arg_elf_frames
void
static
void
arg_elf_header
void
static
void
arg_elf_info
void
static
void
arg_elf_line
void
static
void
arg_elf_loc
void
static
void
arg_elf_macinfo
void
static
void
arg_elf_pubnames
void
static
void
arg_elf_pubtypes
void
static
void
arg_elf_ranges
void
static
void
arg_elf_strings
void
static
void
arg_elf_text
void
static
void
arg_file_abi
void
static
void
arg_file_line5
void
static
void
arg_file_name
void
static
void
arg_file_output
void
static
void
arg_file_tied
void
static
void
arg_file_use_no_libelf
void
static
void
arg_format_attr_name
void
static
void
arg_format_dense
void
static
void
arg_format_ellipsis
void
static
void
arg_format_expr_ops_joined
void
static
void
arg_format_extensions
void
static
void
arg_format_global_offsets
void
static
void
arg_format_loc
void
static
void
arg_format_registers
void
static
void
arg_format_suppress_data
void
static
void
arg_format_suppress_group
void
static
void
arg_format_suppress_lookup
void
static
void
arg_format_suppress_offsets
void
static
void
arg_format_suppress_sanitize
void
static
void
arg_format_suppress_uri
void
static
void
arg_format_suppress_uri_msg
void
static
void
arg_format_file
void
static
void
arg_format_gcc
void
static
void
arg_format_groupnumber
void
static
void
arg_format_limit
void
static
void
arg_format_producer
void
static
void
arg_format_snc
void
static
void
arg_print_all
void
static
void
arg_print_abbrev
void
static
void
arg_print_aranges
void
static
void
arg_print_debug_frame
void
static
void
arg_print_debug_names
void
static
void
arg_print_gnu_debuglink
void
static
void
arg_print_debug_gnu
void
static
void
arg_print_debug_sup
void
static
void
arg_print_fission
void
static
void
arg_print_gnu_frame
void
static
void
arg_print_info
void
static
void
arg_print_lines
void
static
void
arg_print_lines_short
void
static
void
arg_print_loc
void
static
void
arg_print_macinfo
void
static
void
arg_print_pubnames
void
static
void
arg_print_producers
void
static
void
arg_print_ranges
void
static
void
arg_print_raw_loclists
void
static
void
arg_print_raw_rnglists
void
static
void
arg_print_static
void
static
void
arg_print_static_func
void
static
void
arg_print_static_var
void
static
void
arg_print_str_offsets
void
static
void
arg_print_strings
void
static
void
arg_print_types
void
static
void
arg_print_weaknames
void
static
void
arg_reloc
void
static
void
arg_reloc_abbrev
void
static
void
arg_reloc_aranges
void
static
void
arg_reloc_frames
void
static
void
arg_reloc_info
void
static
void
arg_reloc_line
void
static
void
arg_reloc_loc
void
static
void
arg_reloc_pubnames
void
static
void
arg_reloc_ranges
void
static
void
arg_no_follow_debuglink
void
static
void
arg_add_debuglink_path
void
static
void
arg_debuglink_path_invalid
void
static
void
arg_search_any
void
static
void
arg_search_any_count
void
static
void
arg_search_match
void
static
void
arg_search_match_count
void
ifdef
HAVE_REGEX
static
void
arg_search_regex
void
static
void
arg_search_regex_count
void
endif
HAVE_REGEX
static
void
arg_search_count
void
static
void
arg_search_invalid
void
static
void
arg_search_print_children
void
static
void
arg_search_print_parent
void
static
void
arg_search_print_tree
void
static
void
arg_help
void
static
void
arg_trace
void
static
void
arg_verbose
void
static
void
arg_version
void
static
void
arg_show_dwarfdump_conf
void
static
void
arg_c_multiple_selection
void
static
void
arg_E_multiple_selection
void
static
void
arg_h_multiple_selection
void
static
void
arg_l_multiple_selection
void
static
void
arg_k_multiple_selection
void
static
void
arg_kx_multiple_selection
void
ifdef
HAVE_USAGE_TAG_ATTR
static
void
arg_ku_multiple_selection
void
endif
HAVE_USAGE_TAG_ATTR
static
void
arg_o_multiple_selection
void
static
void
arg_O_multiple_selection
void
static
void
arg_S_multiple_selection
void
static
void
arg_t_multiple_selection
void
static
void
arg_W_multiple_selection
void
static
void
arg_x_multiple_selection
void
static
void
arg_not_supported
void
static
void
arg_x_invalid
void
Extracted
from
process_args
as
they
are
used
by
option
handlers
static
Dwarf_Bool
arg_usage_error
FALSE
static
int
arg_option
static
const
char
usage_debug_text
Usage
DwarfDump
debug_options
options
t
tprint
this
information
t
t
tDump
RangesInfo
Table
t
t
tDump
Location
debug_loc
Info
t
t
tDump
Ranges
debug_ranges
Info
t
t
tDump
Linkonce
Table
t
t
tDump
Visited
Info
static
const
char
usage_long_text
Usage
DwarfDump
options
object
file
Print
Debug
Sections
b
print
abbrev
Print
abbrev
section
a
print
all
Print
all
debug_
sections
r
print
aranges
Print
aranges
section
F
print
eh
frame
Print
gnu
eh_frame
section
I
print
fission
Print
fission
sections
gdb_index
debug_cu_index
debug_tu_index
gnu
debuglink
note
gnu
build
id
print
gnu
debuglink
Print
gnu_debuglink
note
gnu
build
id
sections
print
debug
gnu
Print
debug_gnu_pubtypes
and
debug_gnu_pubnames
sections
print
debug
names
Print
debug_names
section
print
debug
sup
Print
debug_sup
section
i
print
info
Print
info
section
l
print
lines
Print
line
section
ls
print
lines
short
Print
line
section
but
do
not
print
pc
address
c
print
loc
Print
loc
section
m
print
macinfo
Print
DWARF5
style
debug_macro
section
and
DWARF2
debug_macinfo
section
P
print
producers
Print
list
of
compile
units
per
producer
p
print
pubnames
Print
pubnames
section
N
print
ranges
Print
ranges
section
print
raw
rnglists
Print
entire
debug_rnglists
section
print
raw
loclists
Print
entire
debug_loclists
section
ta
print
static
Print
both
static
sections
tf
print
static
func
Print
static
func
section
tv
print
static
var
Print
static
var
section
s
print
strings
Print
string
section
print
str
offsets
Print
the
debug_str_offsets
section
y
print
type
Print
pubtypes
section
w
print
weakname
Print
weakname
section
Print
Elf
Relocation
Data
libelf
not
present
use
GNU
readelf
or
readelfobj
to
see
relocations
Print
Elf
Section
Headers
libelf
not
present
use
GNU
readelf
or
readelfobj
to
see
elf
file
details
Check
DWARF
Integrity
kb
check
abbrev
Check
abbreviations
ka
check
all
Do
all
checks
kM
check
aranges
Check
ranges
list
debug_aranges
kD
check
attr
dup
Check
duplicated
attributes
kE
check
attr
encodings
Examine
attributes
encodings
kn
check
attr
names
Examine
names
in
attributes
kc
check
constants
Examine
DWARF
constants
kF
check
files
lines
Examine
integrity
of
files
lines
attributes
kR
check
forward
refs
Check
forward
references
to
DIEs
declarations
kx
check
frame
basic
Basic
frames
check
eh_frame
debug_frame
kxe
check
frame
extended
Extensive
frames
check
eh_frame
debug_frame
kf
check
frame
info
Examine
frame
information
use
with
f
or
F
kg
check
gaps
Check
debug
info
gaps
kl
check
loc
Check
location
list
debug_loc
kw
check
macros
Check
macros
ke
check
pubnames
Examine
attributes
of
pubnames
km
check
ranges
Check
ranges
list
debug_ranges
kS
check
self
refs
Check
self
references
to
DIEs
kd
check
show
Show
check
results
ks
check
silent
Perform
checks
in
silent
mode
ki
check
summary
Display
summary
for
all
compilers
kr
check
tag
attr
Examine
tag
attr
relation
kt
check
tag
tag
Examine
tag
tag
relations
Unless
C
option
given
certain
common
tag
attr
and
tag
tag
extensions
are
assumed
to
be
ok
not
reported
ky
check
type
Examine
type
info
kG
check
unique
Print
only
unique
errors
ifdef
HAVE_USAGE_TAG_ATTR
ku
check
usage
Print
tag
tree
tag
attr
usage
basic
format
kuf
check
usage
extended
Modifies
ku
to
add
summary
detail
endif
HAVE_USAGE_TAG_ATTR
Print
Output
Qualifiers
M
format
attr
name
Print
the
form
name
for
each
attribute
d
format
dense
One
line
per
entry
info
section
e
format
ellipsis
Short
names
for
tags
attrs
etc
G
format
global
offsets
Show
global
die
offsets
g
format
loc
Was
loclist
support
Do
not
use
format
expr
ops
joined
Print
each
group
of
DWARF
DW_OPs
on
one
line
rather
than
one
per
line
R
format
registers
Print
frame
register
names
as
r33
etc
and
allow
up
to
registers
using
a
generic
register
set
Q
format
suppress
data
Suppress
printing
section
data
x
noprintsectiongroups
format
suppress
group
Do
not
print
section
groups
n
format
suppress
lookup
Suppress
frame
information
function
name
lookup
when
printing
frame
information
from
multi
gigabyte
object
files
this
option
may
save
significant
time
D
format
suppress
offsets
Do
not
show
offsets
x
nosanitizestrings
format
suppress
sanitize
Arbitrary
string
characters
come
thru
printf
U
format
suppress
uri
Suppress
uri
translate
q
format
suppress
uri
msg
Suppress
uri
did
translate
notification
C
format
extensions
Print
with
ki
warnings
for
some
common
DWARF
extensions
by
default
extensions
accepted
as
standard
Print
Output
Limiters
u
file
format
file
file
Print
only
specified
file
CU
name
x
groupnumber
n
format
group
number
n
Groupnumber
to
print
H
num
format
limit
num
Limit
output
to
the
first
num
major
units
Stop
after
num
compilation
units
c
str
format
producer
str
Check
only
specific
compiler
objects
str
is
described
by
DW_AT_producer
c
check
only
compiler
objects
with
in
the
CU
name
cs
format
snc
Check
only
SNC
compiler
objects
cg
format
gcc
Check
only
gcc
compiler
objects
File
Specifications
x
abi
abi
file
abi
abi
Name
abi
in
dwarfdump
conf
x
name
path
file
name
path
Name
dwarfdump
conf
x
line5
val
file
line5
val
Table
DWARF5
new
interfaces
where
val
is
std
or
s2l
O
file
path
file
output
path
Name
the
output
file
x
tied
path
file
tied
path
Name
the
Split
Dwarf
skeleton
object
file
file
use
no
libelf
Use
non
libelf
to
read
objects
as
much
as
possible
GNU
debuglink
options
no
follow
debuglink
Do
not
follow
GNU
debuglink
just
use
the
file
directly
so
debuglink
global
paths
are
ignored
add
debuglink_path
text
Add
the
path
to
the
list
of
global
paths
debuglink
searches
Search
text
in
attributes
S
any
text
search
any
text
Search
any
text
Svany
text
search
any
count
text
print
number
of
occurrences
S
match
text
search
match
text
Search
matching
text
Svmatch
text
search
match
count
text
print
number
of
occurrences
ifdef
HAVE_REGEX
S
regex
text
search
regex
text
Use
regular
expression
matching
Svregex
text
search
regex
count
text
print
number
of
occurrences
endif
HAVE_REGEX
only
one
S
option
allowed
any
and
regex
only
usable
if
the
functions
required
are
found
at
configure
time
Wc
search
print
children
Print
children
tree
wide
format
with
S
Wp
search
print
parent
Print
parent
tree
wide
format
with
S
W
search
print
tree
Print
parent
children
tree
wide
format
with
S
Help
Version
h
help
Print
this
dwarfdump
help
message
v
verbose
Show
more
information
vv
verbose
more
Show
even
more
information
V
version
Print
version
information
show
dwarfdump
conf
Show
what
dwarfdump
conf
is
being
used
enum
longopts_vals
OPT_BEGIN
Check
DWARF
Integrity
OPT_CHECK_ABBREV
kb
check
abbrev
OPT_CHECK_ALL
ka
check
all
OPT_CHECK_ARANGES
kM
check
aranges
OPT_CHECK_ATTR_DUP
kD
check
attr
dup
OPT_CHECK_ATTR_ENCODINGS
kE
check
attr
encodings
OPT_CHECK_ATTR_NAMES
kn
check
attr
names
OPT_CHECK_CONSTANTS
kc
check
constants
OPT_CHECK_FILES_LINES
kF
check
files
lines
OPT_CHECK_FORWARD_REFS
kR
check
forward
refs
OPT_CHECK_FRAME_BASIC
kx
check
frame
basic
OPT_CHECK_FRAME_EXTENDED
kxe
check
frame
extended
OPT_CHECK_FRAME_INFO
kf
check
frame
info
OPT_CHECK_GAPS
kg
check
gaps
OPT_CHECK_LOC
kl
check
loc
OPT_CHECK_MACROS
kw
check
macros
OPT_CHECK_PUBNAMES
ke
check
pubnames
OPT_CHECK_RANGES
km
check
ranges
OPT_CHECK_SELF_REFS
kS
check
self
refs
OPT_CHECK_SHOW
kd
check
show
OPT_CHECK_SILENT
ks
check
silent
OPT_CHECK_SUMMARY
ki
check
summary
OPT_CHECK_TAG_ATTR
kr
check
tag
attr
OPT_CHECK_TAG_TAG
kt
check
tag
tag
OPT_CHECK_TYPE
ky
check
type
OPT_CHECK_UNIQUE
kG
check
unique
ifdef
HAVE_USAGE_TAG_ATTR
OPT_CHECK_USAGE
ku
check
usage
OPT_CHECK_USAGE_EXTENDED
kuf
check
usage
extended
endif
HAVE_USAGE_TAG_ATTR
Print
ELF
sections
header
OPT_ELF
E
elf
OPT_ELF_ABBREV
Ea
elf
abbrev
OPT_ELF_ARANGES
Er
elf
aranges
OPT_ELF_DEFAULT
Ed
elf
default
OPT_ELF_FISSION
EI
elf
fission
OPT_ELF_FRAMES
Ef
elf
frames
OPT_ELF_HEADER
Eh
elf
header
OPT_ELF_INFO
Ei
elf
info
OPT_ELF_LINE
El
elf
line
OPT_ELF_LOC
Eo
elf
loc
OPT_ELF_MACINFO
Em
elf
macinfo
OPT_ELF_PUBNAMES
Ep
elf
pubnames
OPT_ELF_PUBTYPES
Et
elf
pubtypes
OPT_ELF_RANGES
ER
elf
ranges
OPT_ELF_STRINGS
Es
elf
strings
OPT_ELF_TEXT
Ex
elf
text
File
Specifications
OPT_FILE_ABI
x
abi
abi
file
abi
abi
OPT_FILE_LINE5
x
line5
val
file
line5
val
OPT_FILE_NAME
x
name
path
file
name
path
OPT_FILE_OUTPUT
O
file
path
file
output
path
OPT_FILE_TIED
x
tied
path
file
tied
path
OPT_FILE_USE_NO_LIBELF
file
use
no
libelf
path
Print
Output
Qualifiers
OPT_FORMAT_ATTR_NAME
M
format
attr
name
OPT_FORMAT_DENSE
d
format
dense
OPT_FORMAT_ELLIPSIS
e
format
ellipsis
OPT_FORMAT_EXPR_OPS_JOINED
format
expr
ops
joined
OPT_FORMAT_EXTENSIONS
C
format
extensions
OPT_FORMAT_GLOBAL_OFFSETS
G
format
global
offsets
OPT_FORMAT_LOC
g
format
loc
OPT_FORMAT_REGISTERS
R
format
registers
OPT_FORMAT_SUPPRESS_DATA
Q
format
suppress
data
OPT_FORMAT_SUPPRESS_GROUP
x
format
suppress
group
OPT_FORMAT_SUPPRESS_LOOKUP
n
format
suppress
lookup
OPT_FORMAT_SUPPRESS_OFFSETS
D
format
suppress
offsets
OPT_FORMAT_SUPPRESS_SANITIZE
x
no
sanitize
strings
format
suppress
sanitize
OPT_FORMAT_SUPPRESS_URI
U
format
suppress
uri
OPT_FORMAT_SUPPRESS_URI_MSG
q
format
suppress
uri
msg
Print
Output
Limiters
OPT_FORMAT_FILE
u
file
format
file
file
OPT_FORMAT_GCC
cg
format
gcc
OPT_FORMAT_GROUP_NUMBER
x
n
format
group
number
n
OPT_FORMAT_LIMIT
H
num
format
limit
num
OPT_FORMAT_PRODUCER
c
str
format
producer
str
OPT_FORMAT_SNC
cs
format
snc
Print
Debug
Sections
OPT_PRINT_ABBREV
b
print
abbrev
OPT_PRINT_ALL
a
print
all
OPT_PRINT_ARANGES
r
print
aranges
OPT_PRINT_DEBUG_NAMES
print
debug
names
OPT_PRINT_GNU_DEBUGLINK
print
gnu
debuglink
OPT_PRINT_DEBUG_GNU
print
debug
gnu
OPT_PRINT_DEBUG_SUP
print
debug
sup
OPT_PRINT_EH_FRAME
F
print
eh
frame
OPT_PRINT_FISSION
I
print
fission
OPT_PRINT_FRAME
f
print
frame
OPT_PRINT_INFO
i
print
info
OPT_PRINT_LINES
l
print
lines
OPT_PRINT_LINES_SHORT
ls
print
lines
short
OPT_PRINT_LOC
c
print
loc
OPT_PRINT_MACINFO
m
print
macinfo
OPT_PRINT_PRODUCERS
P
print
producers
OPT_PRINT_PUBNAMES
p
print
pubnames
OPT_PRINT_RANGES
N
print
ranges
OPT_PRINT_RAW_LOCLISTS
print
raw
loclists
OPT_PRINT_RAW_RNGLISTS
print
raw
rnglists
OPT_PRINT_STATIC
ta
print
static
OPT_PRINT_STATIC_FUNC
tf
print
static
func
OPT_PRINT_STATIC_VAR
tv
print
static
var
OPT_PRINT_STRINGS
s
print
strings
OPT_PRINT_STR_OFFSETS
print
str
offsets
OPT_PRINT_TYPE
y
print
type
OPT_PRINT_WEAKNAME
w
print
weakname
Print
Relocations
Info
OPT_RELOC
o
reloc
OPT_RELOC_ABBREV
oa
reloc
abbrev
OPT_RELOC_ARANGES
or
reloc
aranges
OPT_RELOC_FRAMES
of
reloc
frames
OPT_RELOC_INFO
oi
reloc
info
OPT_RELOC_LINE
ol
reloc
line
OPT_RELOC_LOC
oo
reloc
loc
OPT_RELOC_PUBNAMES
op
reloc
pubnames
OPT_RELOC_RANGES
oR
reloc
ranges
debuglink
options
OPT_NO_FOLLOW_DEBUGLINK
no
follow
debuglink
OPT_ADD_DEBUGLINK_PATH
add
debuglink
path
text
Search
text
in
attributes
OPT_SEARCH_ANY
S
any
text
search
any
text
OPT_SEARCH_ANY_COUNT
Svany
text
search
any
count
text
OPT_SEARCH_MATCH
S
match
text
search
match
text
OPT_SEARCH_MATCH_COUNT
Svmatch
text
search
match
count
text
OPT_SEARCH_PRINT_CHILDREN
Wc
search
print
children
OPT_SEARCH_PRINT_PARENT
Wp
search
print
parent
OPT_SEARCH_PRINT_TREE
W
search
print
tree
ifdef
HAVE_REGEX
OPT_SEARCH_REGEX
S
regex
text
search
regex
text
OPT_SEARCH_REGEX_COUNT
Svregex
text
search
regex
count
text
endif
HAVE_REGEX
Help
Version
OPT_HELP
h
help
OPT_VERBOSE
v
verbose
OPT_VERBOSE_MORE
vv
verbose
more
OPT_VERSION
V
version
OPT_SHOW_DWARFDUMP_CONF
show
dwarfdump
conf
Trace
OPT_TRACE
trace
num
allocation
statistics
OPT_ALLOC_PRINT_SUMS
print
alloc
sums
OPT_ALLOC_TREE_OFF
suppress
de
alloc
tree
OPT_END
static
struct
dwoption
longopts
Check
DWARF
Integrity
check
abbrev
dwno_argument
OPT_CHECK_ABBREV
check
all
dwno_argument
OPT_CHECK_ALL
check
aranges
dwno_argument
OPT_CHECK_ARANGES
check
attr
dup
dwno_argument
OPT_CHECK_ATTR_DUP
check
attr
encodings
dwno_argument
OPT_CHECK_ATTR_ENCODINGS
check
attr
names
dwno_argument
OPT_CHECK_ATTR_NAMES
check
constants
dwno_argument
OPT_CHECK_CONSTANTS
check
files
lines
dwno_argument
OPT_CHECK_FILES_LINES
check
forward
refs
dwno_argument
OPT_CHECK_FORWARD_REFS
check
frame
basic
dwno_argument
OPT_CHECK_FRAME_BASIC
check
frame
extended
dwno_argument
OPT_CHECK_FRAME_EXTENDED
check
frame
info
dwno_argument
OPT_CHECK_FRAME_INFO
check
gaps
dwno_argument
OPT_CHECK_GAPS
check
loc
dwno_argument
OPT_CHECK_LOC
check
macros
dwno_argument
OPT_CHECK_MACROS
check
pubnames
dwno_argument
OPT_CHECK_PUBNAMES
check
ranges
dwno_argument
OPT_CHECK_RANGES
check
self
refs
dwno_argument
OPT_CHECK_SELF_REFS
check
show
dwno_argument
OPT_CHECK_SHOW
check
silent
dwno_argument
OPT_CHECK_SILENT
check
summary
dwno_argument
OPT_CHECK_SUMMARY
check
tag
attr
dwno_argument
OPT_CHECK_TAG_ATTR
check
tag
tag
dwno_argument
OPT_CHECK_TAG_TAG
check
type
dwno_argument
OPT_CHECK_TYPE
check
unique
dwno_argument
OPT_CHECK_UNIQUE
ifdef
HAVE_USAGE_TAG_ATTR
check
usage
dwno_argument
OPT_CHECK_USAGE
check
usage
extended
dwno_argument
OPT_CHECK_USAGE_EXTENDED
endif
HAVE_USAGE_TAG_ATTR
Print
ELF
sections
header
elf
dwno_argument
OPT_ELF
elf
abbrev
dwno_argument
OPT_ELF_ABBREV
elf
aranges
dwno_argument
OPT_ELF_ARANGES
elf
default
dwno_argument
OPT_ELF_DEFAULT
elf
fission
dwno_argument
OPT_ELF_FISSION
elf
frames
dwno_argument
OPT_ELF_FRAMES
elf
header
dwno_argument
OPT_ELF_HEADER
elf
info
dwno_argument
OPT_ELF_INFO
elf
line
dwno_argument
OPT_ELF_LINE
elf
loc
dwno_argument
OPT_ELF_LOC
elf
macinfo
dwno_argument
OPT_ELF_MACINFO
elf
pubnames
dwno_argument
OPT_ELF_PUBNAMES
elf
pubtypes
dwno_argument
OPT_ELF_PUBTYPES
elf
ranges
dwno_argument
OPT_ELF_RANGES
elf
strings
dwno_argument
OPT_ELF_STRINGS
elf
text
dwno_argument
OPT_ELF_TEXT
File
Specifications
file
abi
dwrequired_argument
OPT_FILE_ABI
file
line5
dwrequired_argument
OPT_FILE_LINE5
file
name
dwrequired_argument
OPT_FILE_NAME
file
output
dwrequired_argument
OPT_FILE_OUTPUT
file
tied
dwrequired_argument
OPT_FILE_TIED
file
use
no
libelf
dwno_argument
OPT_FILE_USE_NO_LIBELF
Print
Output
Qualifiers
format
attr
name
dwno_argument
OPT_FORMAT_ATTR_NAME
format
dense
dwno_argument
OPT_FORMAT_DENSE
format
ellipsis
dwno_argument
OPT_FORMAT_ELLIPSIS
format
expr
ops
joined
dwno_argument
OPT_FORMAT_EXPR_OPS_JOINED
format
extensions
dwno_argument
OPT_FORMAT_EXTENSIONS
format
global
offsets
dwno_argument
OPT_FORMAT_GLOBAL_OFFSETS
format
loc
dwno_argument
OPT_FORMAT_LOC
format
registers
dwno_argument
OPT_FORMAT_REGISTERS
format
suppress
data
dwno_argument
OPT_FORMAT_SUPPRESS_DATA
format
suppress
group
dwno_argument
OPT_FORMAT_SUPPRESS_GROUP
format
suppress
lookup
dwno_argument
OPT_FORMAT_SUPPRESS_LOOKUP
format
suppress
offsets
dwno_argument
OPT_FORMAT_SUPPRESS_OFFSETS
format
suppress
sanitize
dwno_argument
OPT_FORMAT_SUPPRESS_SANITIZE
format
suppress
uri
dwno_argument
OPT_FORMAT_SUPPRESS_URI
format
suppress
uri
msg
dwno_argument
OPT_FORMAT_SUPPRESS_URI_MSG
Print
Output
Limiters
format
file
dwrequired_argument
OPT_FORMAT_FILE
format
gcc
dwno_argument
OPT_FORMAT_GCC
format
group
number
dwrequired_argument
OPT_FORMAT_GROUP_NUMBER
format
limit
dwrequired_argument
OPT_FORMAT_LIMIT
format
producer
dwrequired_argument
OPT_FORMAT_PRODUCER
format
snc
dwno_argument
OPT_FORMAT_SNC
Print
Debug
Sections
print
abbrev
dwno_argument
OPT_PRINT_ABBREV
print
all
dwno_argument
OPT_PRINT_ALL
print
aranges
dwno_argument
OPT_PRINT_ARANGES
print
debug
names
dwno_argument
OPT_PRINT_DEBUG_NAMES
print
gnu
debuglink
dwno_argument
OPT_PRINT_GNU_DEBUGLINK
print
debug
gnu
dwno_argument
OPT_PRINT_DEBUG_GNU
print
debug
sup
dwno_argument
OPT_PRINT_DEBUG_SUP
print
eh
frame
dwno_argument
OPT_PRINT_EH_FRAME
print
fission
dwno_argument
OPT_PRINT_FISSION
print
frame
dwno_argument
OPT_PRINT_FRAME
print
info
dwno_argument
OPT_PRINT_INFO
print
lines
dwno_argument
OPT_PRINT_LINES
print
lines
short
dwno_argument
OPT_PRINT_LINES_SHORT
print
loc
dwno_argument
OPT_PRINT_LOC
print
macinfo
dwno_argument
OPT_PRINT_MACINFO
print
producers
dwno_argument
OPT_PRINT_PRODUCERS
print
pubnames
dwno_argument
OPT_PRINT_PUBNAMES
print
ranges
dwno_argument
OPT_PRINT_RANGES
print
raw
loclists
dwno_argument
OPT_PRINT_RAW_LOCLISTS
print
raw
rnglists
dwno_argument
OPT_PRINT_RAW_RNGLISTS
print
static
dwno_argument
OPT_PRINT_STATIC
print
static
func
dwno_argument
OPT_PRINT_STATIC_FUNC
print
static
var
dwno_argument
OPT_PRINT_STATIC_VAR
print
strings
dwno_argument
OPT_PRINT_STRINGS
print
str
offsets
dwno_argument
OPT_PRINT_STR_OFFSETS
print
type
dwno_argument
OPT_PRINT_TYPE
print
weakname
dwno_argument
OPT_PRINT_WEAKNAME
Print
Relocations
Info
reloc
dwno_argument
OPT_RELOC
reloc
abbrev
dwno_argument
OPT_RELOC_ABBREV
reloc
aranges
dwno_argument
OPT_RELOC_ARANGES
reloc
frames
dwno_argument
OPT_RELOC_FRAMES
reloc
info
dwno_argument
OPT_RELOC_INFO
reloc
line
dwno_argument
OPT_RELOC_LINE
reloc
loc
dwno_argument
OPT_RELOC_LOC
reloc
pubnames
dwno_argument
OPT_RELOC_PUBNAMES
reloc
ranges
dwno_argument
OPT_RELOC_RANGES
GNU
debuglink
options
no
follow
debuglink
dwno_argument
OPT_NO_FOLLOW_DEBUGLINK
add
debuglink
path
dwrequired_argument
OPT_ADD_DEBUGLINK_PATH
Search
text
in
attributes
search
any
dwrequired_argument
OPT_SEARCH_ANY
search
any
count
dwrequired_argument
OPT_SEARCH_ANY_COUNT
search
match
dwrequired_argument
OPT_SEARCH_MATCH
search
match
count
dwrequired_argument
OPT_SEARCH_MATCH_COUNT
search
print
children
dwno_argument
OPT_SEARCH_PRINT_CHILDREN
search
print
parent
dwno_argument
OPT_SEARCH_PRINT_PARENT
search
print
tree
dwno_argument
OPT_SEARCH_PRINT_TREE
ifdef
HAVE_REGEX
search
regex
dwrequired_argument
OPT_SEARCH_REGEX
search
regex
count
dwrequired_argument
OPT_SEARCH_REGEX_COUNT
endif
HAVE_REGEX
Help
Version
help
dwno_argument
OPT_HELP
verbose
dwno_argument
OPT_VERBOSE
verbose
more
dwno_argument
OPT_VERBOSE_MORE
version
dwno_argument
OPT_VERSION
show
dwarfdump
conf
dwno_argument
OPT_SHOW_DWARFDUMP_CONF
Trace
trace
dwrequired_argument
OPT_TRACE
alloc
sums
print
alloc
sums
dwno_argument
OPT_ALLOC_PRINT_SUMS
suppress
de
alloc
tree
dwno_argument
OPT_ALLOC_TREE_OFF
Handlers
for
the
command
line
options
Option
print
debug
names
void
arg_print_debug_names
void
glflags
gf_debug_names_flag
TRUE
Option
print
gnu
debuglink
void
arg_print_gnu_debuglink
void
glflags
gf_gnu_debuglink_flag
TRUE
Option
print
debug
gnu
void
arg_print_debug_gnu
void
glflags
gf_debug_gnu_flag
TRUE
Option
print
debug
sup
void
arg_print_debug_sup
void
glflags
gf_debug_sup_flag
TRUE
Option
print
str
offsets
void
arg_print_str_offsets
void
glflags
gf_print_str_offsets
TRUE
void
arg_trace
void
int
nTraceLevel
atoi
dwoptarg
if
nTraceLevel
nTraceLevel
MAX_TRACE_LEVEL
glflags
nTrace
nTraceLevel
Display
dwarfdump
debug
options
if
dump_options
print_usage_message
glflags
program_name
usage_debug_text
exit
OKAY
Option
a
void
arg_print_all
void
suppress_check_dwarf
do_all
Option
b
void
arg_print_abbrev
void
glflags
gf_abbrev_flag
TRUE
suppress_check_dwarf
Option
c
void
arg_c_multiple_selection
void
Specify
compiler
name
if
dwoptarg
switch
dwoptarg
case
s
arg_format_snc
break
case
g
arg_format_gcc
break
default
arg_format_producer
break
else
arg_print_loc
Option
c
with
no
other
letters
See
just
above
void
arg_print_loc
void
printf
The
c
option
to
print
debug_loc
unsafely
is
ignored
n
glflags
gf_loc_flag
TRUE
suppress_check_dwarf
Option
cs
void
arg_format_snc
void
cs
Check
SNC
compiler
glflags
gf_check_snc_compiler
TRUE
glflags
gf_check_all_compilers
FALSE
Option
cg
format
gcc
void
arg_format_gcc
void
cg
Check
GCC
compiler
glflags
gf_check_gcc_compiler
TRUE
glflags
gf_check_all_compilers
FALSE
Option
c
producer
void
arg_format_producer
void
Assume
a
compiler
version
to
check
most
likely
a
substring
of
a
compiler
name
if
record_producer
dwoptarg
fprintf
stderr
Compiler
table
max
d
exceeded
limiting
the
tracked
compilers
to
d
n
COMPILER_TABLE_MAX
COMPILER_TABLE_MAX
Option
format
expr
ops
joined
restoring
pre
December
expression
block
printing
void
arg_format_expr_ops_joined
void
glflags
gf_expr_ops_joined
TRUE
Option
C
void
arg_format_extensions
void
glflags
gf_suppress_check_extensions_tables
TRUE
Option
d
void
arg_format_dense
void
glflags
gf_do_print_dwarf
TRUE
This
is
sort
of
useless
unless
printing
but
harmless
so
we
do
not
insist
we
are
printing
with
suppress_check_dwarf
glflags
dense
TRUE
Option
D
void
arg_format_suppress_offsets
void
Do
not
emit
offset
in
output
glflags
gf_display_offsets
FALSE
Option
e
void
arg_format_ellipsis
void
suppress_check_dwarf
glflags
ellipsis
TRUE
Option
E
void
arg_E_multiple_selection
void
Object
Header
information
but
maybe
really
print
Selected
printing
of
section
info
if
dwoptarg
switch
dwoptarg
case
a
arg_elf_abbrev
break
case
d
arg_elf_default
break
case
f
arg_elf_frames
break
case
h
arg_elf_header
break
case
i
arg_elf_info
break
case
I
arg_elf_fission
break
case
l
arg_elf_line
break
case
m
arg_elf_macinfo
break
case
o
arg_elf_loc
break
case
p
arg_elf_pubnames
break
case
r
arg_elf_aranges
break
case
R
arg_elf_ranges
break
case
s
arg_elf_strings
break
case
t
arg_elf_pubtypes
break
case
x
arg_elf_text
break
default
arg_usage_error
TRUE
break
else
arg_elf
Option
E
void
arg_elf
void
Display
header
and
all
sections
info
glflags
gf_header_flag
TRUE
set_all_sections_on
Option
Ea
void
arg_elf_abbrev
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_ABBREV
Option
Ed
void
arg_elf_default
void
case
d
use
the
default
section
set
glflags
gf_header_flag
TRUE
set_all_section_defaults
Option
Ef
void
arg_elf_frames
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_FRAME
Option
Eh
void
arg_elf_header
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_HEADER
Option
Ei
void
arg_elf_info
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_INFO
enable_section_map_entry
DW_HDR_DEBUG_TYPES
Option
EI
void
arg_elf_fission
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_GDB_INDEX
enable_section_map_entry
DW_HDR_DEBUG_CU_INDEX
enable_section_map_entry
DW_HDR_DEBUG_TU_INDEX
enable_section_map_entry
DW_HDR_DEBUG_NAMES
Option
El
void
arg_elf_line
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_LINE
Option
Em
void
arg_elf_macinfo
void
For
both
old
macinfo
and
dwarf5
macro
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_MACINFO
Option
Eo
void
arg_elf_loc
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_LOC
Option
Ep
void
arg_elf_pubnames
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_PUBNAMES
Option
Er
void
arg_elf_aranges
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_ARANGES
Option
ER
void
arg_elf_ranges
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_RANGES
enable_section_map_entry
DW_HDR_DEBUG_RNGLISTS
Option
Es
void
arg_elf_strings
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_STR
Option
Et
void
arg_elf_pubtypes
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_DEBUG_PUBTYPES
Option
Ex
void
arg_elf_text
void
glflags
gf_header_flag
TRUE
enable_section_map_entry
DW_HDR_TEXT
Option
f
void
arg_print_debug_frame
void
glflags
gf_frame_flag
TRUE
suppress_check_dwarf
Option
F
void
arg_print_gnu_frame
void
glflags
gf_eh_frame_flag
TRUE
suppress_check_dwarf
Option
g
void
arg_format_loc
void
info_flag
TRUE
removed
from
g
Nov
Entirely
removed
the
effect
of
the
g
glflags
gf_use_old_dwarf_loclist
FALSE
suppress_check_dwarf
Option
G
void
arg_format_global_offsets
void
glflags
gf_show_global_offsets
TRUE
Option
h
void
arg_h_multiple_selection
void
if
dwoptarg
arg_usage_error
TRUE
else
arg_help
Option
h
void
arg_help
void
print_usage_message
glflags
program_name
usage_long_text
exit
OKAY
Option
H
void
arg_format_limit
void
int
break_val
atoi
dwoptarg
if
break_val
glflags
break_after_n_units
break_val
Option
i
void
arg_print_info
void
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
suppress_check_dwarf
Option
I
void
arg_print_fission
void
glflags
gf_gdbindex_flag
TRUE
glflags
gf_gnu_debuglink_flag
TRUE
suppress_check_dwarf
Option
k
void
arg_k_multiple_selection
void
switch
dwoptarg
case
a
arg_check_all
break
case
b
arg_check_abbrev
break
case
c
arg_check_constants
break
case
d
arg_check_show
break
case
D
arg_check_attr_dup
break
case
e
arg_check_pubnames
break
case
E
arg_check_attr_encodings
break
case
f
arg_check_frame_info
break
case
F
arg_check_files_lines
break
case
g
arg_check_gaps
break
case
G
arg_check_unique
break
case
i
arg_check_summary
break
case
l
arg_check_loc
break
case
m
arg_check_ranges
break
case
M
arg_check_aranges
break
case
n
arg_check_attr_names
break
case
r
arg_check_tag_attr
break
case
R
arg_check_forward_refs
break
case
s
arg_check_silent
break
case
S
arg_check_self_refs
break
case
t
arg_check_tag_tag
break
ifdef
HAVE_USAGE_TAG_ATTR
case
u
arg_ku_multiple_selection
break
endif
HAVE_USAGE_TAG_ATTR
case
w
arg_check_macros
break
case
x
arg_kx_multiple_selection
break
case
y
arg_check_type
break
default
arg_usage_error
TRUE
break
Option
ka
void
arg_check_all
void
suppress_print_dwarf
glflags
gf_check_pubname_attr
TRUE
glflags
gf_check_tag_attr
TRUE
glflags
gf_check_tag_tree
TRUE
glflags
gf_check_type_offset
TRUE
glflags
gf_gnu_debuglink_flag
FALSE
glflags
gf_check_names
TRUE
glflags
gf_pubnames_flag
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
glflags
gf_gdbindex_flag
TRUE
glflags
gf_check_decl_file
TRUE
glflags
gf_check_macros
TRUE
glflags
gf_check_frames
TRUE
glflags
gf_check_frames_extended
FALSE
glflags
gf_check_locations
TRUE
glflags
gf_frame_flag
TRUE
glflags
gf_eh_frame_flag
TRUE
glflags
gf_check_ranges
TRUE
glflags
gf_check_lines
TRUE
glflags
gf_check_fdes
TRUE
glflags
gf_check_harmless
TRUE
glflags
gf_check_aranges
TRUE
glflags
gf_aranges_flag
TRUE
Aranges
section
glflags
gf_check_abbreviations
TRUE
glflags
gf_check_dwarf_constants
TRUE
glflags
gf_check_di_gaps
TRUE
glflags
gf_check_forward_decl
TRUE
glflags
gf_check_self_references
TRUE
glflags
gf_check_attr_encoding
TRUE
glflags
gf_print_usage_tag_attr
TRUE
glflags
gf_check_duplicated_attributes
TRUE
Option
kb
check
abbrev
void
arg_check_abbrev
void
Abbreviations
suppress_print_dwarf
glflags
gf_check_abbreviations
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
For
some
checks
is
worth
trying
the
plain
debug_abbrev
section
on
its
own
glflags
gf_abbrev_flag
TRUE
Option
kc
check
constants
void
arg_check_constants
void
DWARF
constants
suppress_print_dwarf
glflags
gf_check_dwarf_constants
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kd
check
show
void
arg_check_show
void
Display
check
results
suppress_print_dwarf
glflags
gf_check_show_results
TRUE
Option
kD
check
attr
dup
void
arg_check_attr_dup
void
Check
duplicated
attributes
suppress_print_dwarf
glflags
gf_check_duplicated_attributes
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
For
some
checks
is
worth
trying
the
plain
debug_abbrev
section
on
its
own
glflags
gf_abbrev_flag
TRUE
Option
ke
check
pubnames
void
arg_check_pubnames
void
suppress_print_dwarf
glflags
gf_check_pubname_attr
TRUE
glflags
gf_pubnames_flag
TRUE
glflags
gf_check_harmless
TRUE
glflags
gf_check_fdes
TRUE
Option
kE
check
attr
encodings
void
arg_check_attr_encodings
void
Attributes
encoding
usage
suppress_print_dwarf
glflags
gf_check_attr_encoding
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kf
check
frame
info
void
arg_check_frame_info
void
suppress_print_dwarf
glflags
gf_check_harmless
TRUE
glflags
gf_check_fdes
TRUE
Option
kF
check
files
lines
void
arg_check_files_lines
void
files
lines
suppress_print_dwarf
glflags
gf_check_decl_file
TRUE
glflags
gf_check_lines
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kg
void
arg_check_gaps
void
Check
debug
info
gaps
suppress_print_dwarf
glflags
gf_check_di_gaps
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kG
void
arg_check_unique
void
Print
just
global
unique
errors
suppress_print_dwarf
glflags
gf_print_unique_errors
TRUE
Option
ki
void
arg_check_summary
void
Summary
for
each
compiler
suppress_print_dwarf
glflags
gf_print_summary_all
TRUE
Option
kl
void
arg_check_loc
void
Locations
list
suppress_print_dwarf
glflags
gf_check_locations
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
glflags
gf_loc_flag
TRUE
Option
km
void
arg_check_ranges
void
Ranges
suppress_print_dwarf
glflags
gf_check_ranges
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kM
void
arg_check_aranges
void
Aranges
suppress_print_dwarf
glflags
gf_check_aranges
TRUE
glflags
gf_aranges_flag
TRUE
Option
kn
void
arg_check_attr_names
void
invalid
names
suppress_print_dwarf
glflags
gf_check_names
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kr
void
arg_check_tag_attr
void
suppress_print_dwarf
glflags
gf_check_tag_attr
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
glflags
gf_check_harmless
TRUE
Option
kR
void
arg_check_forward_refs
void
forward
declarations
in
DW_AT_specification
suppress_print_dwarf
glflags
gf_check_forward_decl
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
ks
void
arg_check_silent
void
Check
verbose
mode
suppress_print_dwarf
glflags
gf_check_verbose_mode
FALSE
Option
kS
void
arg_check_self_refs
void
self
references
in
DW_AT_specification
DW_AT_type
DW_AT_abstract_origin
suppress_print_dwarf
glflags
gf_check_self_references
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kt
void
arg_check_tag_tag
void
suppress_print_dwarf
glflags
gf_check_tag_tree
TRUE
glflags
gf_check_harmless
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
ifdef
HAVE_USAGE_TAG_ATTR
Option
ku
void
arg_ku_multiple_selection
void
Tag
Tree
and
Tag
Attr
usage
if
dwoptarg
switch
dwoptarg
case
f
arg_check_usage_extended
break
default
arg_usage_error
TRUE
break
else
arg_check_usage
Option
ku
check
usage
void
arg_check_usage
void
suppress_print_dwarf
glflags
gf_print_usage_tag_attr
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
Option
kuf
check
usage
extended
a
modifier
to
ku
or
kr
to
add
details
to
the
summary
report
void
arg_check_usage_extended
void
arg_check_usage
kuf
Full
report
glflags
gf_print_usage_tag_attr_full
TRUE
endif
HAVE_USAGE_TAG_ATTR
Option
kw
check
macros
void
arg_check_macros
void
suppress_print_dwarf
glflags
gf_check_macros
TRUE
glflags
gf_macro_flag
TRUE
glflags
gf_macinfo_flag
TRUE
Option
kx
void
arg_kx_multiple_selection
void
Frames
check
if
dwoptarg
switch
dwoptarg
case
e
arg_check_frame_extended
break
default
arg_usage_error
TRUE
break
else
arg_check_frame_basic
Option
kx
check
frame
basic
void
arg_check_frame_basic
void
suppress_print_dwarf
glflags
gf_check_frames
TRUE
glflags
gf_frame_flag
TRUE
glflags
gf_eh_frame_flag
TRUE
Option
kxe
check
frame
extended
void
arg_check_frame_extended
void
arg_check_frame_basic
xe
Extended
frames
check
glflags
gf_check_frames
FALSE
glflags
gf_check_frames_extended
TRUE
Option
ky
void
arg_check_type
void
suppress_print_dwarf
glflags
gf_check_type_offset
TRUE
glflags
gf_check_harmless
TRUE
glflags
gf_check_decl_file
TRUE
glflags
gf_info_flag
TRUE
glflags
gf_pubtypes_flag
TRUE
glflags
gf_check_ranges
TRUE
glflags
gf_check_aranges
TRUE
Option
l
void
arg_l_multiple_selection
void
if
dwoptarg
switch
dwoptarg
case
s
arg_print_lines_short
break
default
arg_usage_error
TRUE
break
else
arg_print_lines
Option
l
void
arg_print_lines
void
Enable
to
suppress
offsets
printing
glflags
gf_line_flag
TRUE
suppress_check_dwarf
Option
ls
void
arg_print_lines_short
void
ls
suppress
pc
addresses
glflags
gf_line_print_pc
FALSE
arg_print_lines
Option
m
void
arg_print_macinfo
void
glflags
gf_macinfo_flag
TRUE
DWARF2
glflags
gf_macro_flag
TRUE
DWARF5
suppress_check_dwarf
Option
M
void
arg_format_attr_name
void
glflags
show_form_used
TRUE
Option
n
void
arg_format_suppress_lookup
void
glflags
gf_suppress_nested_name_search
TRUE
Option
N
void
arg_print_ranges
void
glflags
gf_ranges_flag
TRUE
suppress_check_dwarf
Option
print
raw
rnglists
void
arg_print_raw_rnglists
void
glflags
gf_print_raw_rnglists
TRUE
suppress_check_dwarf
Option
print
raw
loclists
void
arg_print_raw_loclists
void
glflags
gf_print_raw_loclists
TRUE
suppress_check_dwarf
Option
o
void
arg_o_multiple_selection
void
if
dwoptarg
switch
dwoptarg
case
a
arg_reloc_abbrev
break
case
i
arg_reloc_info
break
case
l
arg_reloc_line
break
case
p
arg_reloc_pubnames
break
case
r
arg_reloc_aranges
break
case
f
arg_reloc_frames
break
case
o
arg_reloc_loc
break
case
R
arg_reloc_ranges
break
default
arg_usage_error
TRUE
break
else
arg_reloc
Option
o
void
arg_reloc
void
glflags
gf_reloc_flag
TRUE
set_all_reloc_sections_on
Option
oa
void
arg_reloc_abbrev
void
Case
a
has
no
effect
no
relocations
can
point
out
of
the
abbrev
section
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_ABBREV
Option
of
void
arg_reloc_frames
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_FRAME
Option
oi
void
arg_reloc_info
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_INFO
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_TYPES
Option
ol
void
arg_reloc_line
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_LINE
Option
oo
void
arg_reloc_loc
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_LOC
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_LOCLISTS
Option
op
void
arg_reloc_pubnames
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_PUBNAMES
Option
or
void
arg_reloc_aranges
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_ARANGES
Option
oR
void
arg_reloc_ranges
void
glflags
gf_reloc_flag
TRUE
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_RANGES
enable_reloc_map_entry
DW_SECTION_REL_DEBUG_RNGLISTS
Option
O
void
arg_O_multiple_selection
void
Output
filename
O
file
filename
if
strncmp
dwoptarg
file
dwoptarg
arg_file_output
else
arg_usage_error
TRUE
Option
O
file
void
arg_file_output
void
const
char
ctx
arg_option
OPT_BEGIN
file
output
O
file
const
char
path
do_uri_translation
dwoptarg
ctx
if
strlen
path
glflags
output_file
path
else
arg_usage_error
TRUE
Option
p
void
arg_print_pubnames
void
glflags
gf_pubnames_flag
TRUE
suppress_check_dwarf
Option
P
void
arg_print_producers
void
List
of
CUs
per
compiler
glflags
gf_producer_children_flag
TRUE
Option
q
void
arg_format_suppress_uri_msg
void
Suppress
uri
did
translate
notification
glflags
gf_do_print_uri_in_input
FALSE
Option
Q
void
arg_format_suppress_data
void
Q
suppresses
section
data
printing
glflags
gf_do_print_dwarf
FALSE
Option
r
void
arg_print_aranges
void
glflags
gf_aranges_flag
TRUE
suppress_check_dwarf
Option
R
void
arg_format_registers
void
glflags
gf_generic_1200_regs
TRUE
Option
s
void
arg_print_strings
void
glflags
gf_string_flag
TRUE
suppress_check_dwarf
Option
S
void
arg_S_multiple_selection
void
v
option
to
print
number
of
occurrences
S
v
match|any|regex
text
if
dwoptarg
v
dwoptarg
arg_search_count
if
strncmp
dwoptarg
match
dwoptarg
arg_search_match
else
if
strncmp
dwoptarg
any
dwoptarg
arg_search_any
ifdef
HAVE_REGEX
else
if
strncmp
dwoptarg
regex
dwoptarg
arg_search_regex
endif
HAVE_REGEX
else
arg_search_invalid
Option
no
follow
debuglink
void
arg_no_follow_debuglink
void
glflags
gf_no_follow_debuglink
TRUE
static
int
insert_debuglink_path
char
p
char
newarray
unsigned
int
curcount
glflags
gf_global_debuglink_count
unsigned
newcount
curcount
unsigned
u
char
pstr
newarray
char
malloc
newcount
sizeof
char
if
newarray
fprintf
stderr
ERROR
Unable
to
malloc
space
for
debuglink
paths
malloc
u
pointers
failed
n
newcount
fprintf
stderr
Global
debuglink
path
ignored
s
n
sanitized
p
return
DW_DLV_ERROR
pstr
strdup
p
if
pstr
fprintf
stderr
ERROR
Unable
to
malloc
space
for
debuglink
path
count
stays
at
u
n
curcount
fprintf
stderr
Global
debuglink
path
ignored
s
n
sanitized
p
free
newarray
return
DW_DLV_ERROR
for
u
u
curcount
u
newarray
u
glflags
gf_global_debuglink_paths
u
newarray
curcount
pstr
free
glflags
gf_global_debuglink_paths
glflags
gf_global_debuglink_paths
newarray
glflags
gf_global_debuglink_count
newcount
return
DW_DLV_OK
Option
add
debuglink
path
text
void
arg_add_debuglink_path
void
int
res
if
strncmp
dwoptarg
add
debuglink
path
dwoptarg
if
strlen
dwoptarg
dosomething
debuglink
FIXME
res
insert_debuglink_path
dwoptarg
if
res
DW_DLV_OK
return
arg_debuglink_path_invalid
Option
S
any
void
arg_search_any
void
const
char
tempstr
const
char
ctx
arg_option
OPT_BEGIN
search
any
S
any
S
any
text
glflags
gf_search_is_on
TRUE
glflags
search_any_text
makename
dwoptarg
tempstr
remove_quotes_pair
glflags
search_any_text
glflags
search_any_text
do_uri_translation
tempstr
ctx
if
strlen
glflags
search_any_text
arg_search_invalid
Option
Sv
any
void
arg_search_any_count
void
arg_search_count
arg_search_any
Option
S
match
void
arg_search_match
void
const
char
tempstr
const
char
ctx
arg_option
OPT_BEGIN
search
match
S
match
S
match
text
glflags
gf_search_is_on
TRUE
glflags
search_match_text
makename
dwoptarg
tempstr
remove_quotes_pair
glflags
search_match_text
glflags
search_match_text
do_uri_translation
tempstr
ctx
if
strlen
glflags
search_match_text
arg_search_invalid
Option
Sv
match
void
arg_search_match_count
void
arg_search_count
arg_search_match
ifdef
HAVE_REGEX
Option
S
regex
void
arg_search_regex
void
const
char
tempstr
const
char
ctx
arg_option
OPT_BEGIN
search
regex
S
regex
S
regex
regular
expression
glflags
gf_search_is_on
TRUE
glflags
search_regex_text
makename
dwoptarg
tempstr
remove_quotes_pair
glflags
search_regex_text
glflags
search_regex_text
do_uri_translation
tempstr
ctx
if
strlen
glflags
search_regex_text
if
regcomp
glflags
search_re
glflags
search_regex_text
REG_EXTENDED
fprintf
stderr
regcomp
unable
to
compile
search
regular
expression
s
n
glflags
search_regex_text
else
arg_search_invalid
Option
Sv
regex
void
arg_search_regex_count
void
arg_search_count
arg_search_regex
endif
HAVE_REGEX
Option
Sv
void
arg_search_count
void
glflags
gf_search_print_results
TRUE
Option
t
void
arg_t_multiple_selection
void
switch
dwoptarg
case
a
arg_print_static
break
case
f
arg_print_static_func
break
case
v
arg_print_static_var
break
default
arg_usage_error
TRUE
break
Option
ta
void
arg_print_static
void
all
glflags
gf_static_func_flag
TRUE
glflags
gf_static_var_flag
TRUE
suppress_check_dwarf
Option
tf
void
arg_print_static_func
void
debug_static_func
glflags
gf_static_func_flag
TRUE
suppress_check_dwarf
Option
tv
void
arg_print_static_var
void
debug_static_var
glflags
gf_static_var_flag
TRUE
suppress_check_dwarf
Option
u
void
arg_format_file
void
const
char
ctx
arg_option
OPT_BEGIN
format
file
u
cu
name
compile
unit
const
char
tstr
glflags
gf_cu_name_flag
TRUE
tstr
do_uri_translation
dwoptarg
ctx
esb_append
glflags
cu_name
tstr
Option
U
void
arg_format_suppress_uri
void
glflags
gf_uri_options_translation
FALSE
Option
v
verbose
void
arg_verbose
void
glflags
verbose
Option
show
dwarfdump
conf
void
arg_show_dwarfdump_conf
void
glflags
gf_show_dwarfdump_conf
Option
V
void
arg_version
void
Display
dwarfdump
compilation
date
and
time
print_version_details
glflags
program_fullname
TRUE
exit
OKAY
Option
w
void
arg_print_weaknames
void
debug_weaknames
glflags
gf_weakname_flag
TRUE
suppress_check_dwarf
Option
W
void
arg_W_multiple_selection
void
if
dwoptarg
switch
dwoptarg
case
c
arg_search_print_children
break
case
p
arg_search_print_parent
break
default
arg_usage_error
TRUE
break
else
arg_search_print_tree
Option
W
void
arg_search_print_tree
void
Search
results
in
wide
format
glflags
gf_search_wide_format
TRUE
W
Display
parent
and
children
tree
glflags
gf_display_children_tree
TRUE
glflags
gf_display_parent_tree
TRUE
Option
Wc
void
arg_search_print_children
void
Wc
Display
children
tree
arg_search_print_tree
glflags
gf_display_children_tree
TRUE
glflags
gf_display_parent_tree
FALSE
Option
Wp
void
arg_search_print_parent
void
Wp
Display
parent
tree
arg_search_print_tree
glflags
gf_display_children_tree
FALSE
glflags
gf_display_parent_tree
TRUE
Option
x
void
arg_x_multiple_selection
void
if
strncmp
dwoptarg
name
dwoptarg
arg_file_name
else
if
strncmp
dwoptarg
abi
dwoptarg
arg_file_abi
else
if
strncmp
dwoptarg
groupnumber
dwoptarg
arg_format_groupnumber
else
if
strncmp
dwoptarg
tied
dwoptarg
arg_file_tied
else
if
strncmp
dwoptarg
line5
dwoptarg
arg_file_line5
else
if
strcmp
dwoptarg
nosanitizestrings
arg_format_suppress_sanitize
else
if
strcmp
dwoptarg
noprintsectiongroups
arg_format_suppress_group
else
arg_x_invalid
Option
x
abi
static
void
arg_file_abi
void
const
char
ctx
arg_option
OPT_BEGIN
file
abi
x
abi
x
abi
abi
meaning
select
abi
from
dwarfdump
conf
file
Must
always
select
abi
to
use
dwarfdump
conf
const
char
abi
do_uri_translation
dwoptarg
ctx
if
strlen
abi
config_file_abi
abi
else
arg_x_invalid
Option
x
groupnumber
static
void
arg_format_groupnumber
void
By
default
prints
the
lowest
groupnumber
in
the
object
Default
is
x
groupnumber
For
group
standard
base
dwarfdata
x
groupnumber
For
group
DWARF5
dwo
sections
and
dwp
data
x
groupnumber
long
int
gnum
int
res
get_number_value
dwoptarg
if
res
DW_DLV_OK
glflags
group_number
gnum
else
arg_x_invalid
Option
x
line5
file
line5
v
static
void
arg_file_line5
void
if
strcmp
dwoptarg
std
glflags
gf_line_flag_selection
singledw5
else
if
strcmp
dwoptarg
s2l
glflags
gf_line_flag_selection
s2l
else
if
strcmp
dwoptarg
orig
drop
orig
glflags
gf_line_flag_selection
singledw5
else
if
strcmp
dwoptarg
orig2l
drop
orig2l
glflags
gf_line_flag_selection
s2l
else
arg_x_invalid
Option
x
name
static
void
arg_file_name
void
const
char
ctx
arg_option
OPT_BEGIN
file
name
x
name
x
name
path
meaning
name
dwarfdump
conf
file
const
char
path
do_uri_translation
dwoptarg
ctx
if
strlen
path
esb_empty_string
glflags
config_file_path
esb_append
glflags
config_file_path
path
else
arg_x_invalid
Option
x
noprintsectiongroups
static
void
arg_format_suppress_group
void
glflags
gf_section_groups_flag
FALSE
Option
x
nosanitizestrings
format
suppress
sanitize
static
void
arg_format_suppress_sanitize
void
glflags
gf_no_sanitize_strings
TRUE
Option
x
tied
static
void
arg_file_tied
void
const
char
ctx
arg_option
OPT_BEGIN
file
tied
x
tied
const
char
tiedpath
do_uri_translation
dwoptarg
ctx
if
strlen
tiedpath
esb_empty_string
glflags
config_file_tiedpath
esb_append
glflags
config_file_tiedpath
tiedpath
else
arg_x_invalid
Option
file
use
no
libelf
static
void
arg_file_use_no_libelf
void
glflags
gf_file_use_no_libelf
TRUE
y
static
void
arg_print_types
void
debug_pubtypes
Also
for
SGI
only
and
obsolete
debug_typenames
suppress_check_dwarf
glflags
gf_pubtypes_flag
TRUE
Option
not
supported
static
void
arg_not_supported
void
fprintf
stderr
c
is
no
longer
supported
ignored
n
arg_option
Error
message
for
add
debuglink
path
path
static
void
arg_debuglink_path_invalid
void
fprintf
stderr
add
debuglink
path
text
n
fprintf
stderr
is
allowed
not
s
n
dwoptarg
arg_usage_error
TRUE
Error
message
for
invalid
S
option
static
void
arg_search_invalid
void
fprintf
stderr
S
any
text
or
S
match
text
or
S
regex
text
n
fprintf
stderr
is
allowed
not
S
s
n
dwoptarg
arg_usage_error
TRUE
Error
message
for
invalid
x
option
static
void
arg_x_invalid
void
fprintf
stderr
x
name
path
to
conf
n
fprintf
stderr
and
n
fprintf
stderr
x
abi
abi
in
conf
n
fprintf
stderr
and
n
fprintf
stderr
x
tied
tied
file
path
n
fprintf
stderr
and
n
fprintf
stderr
x
line5
std
s2l
orig
orig2l
n
fprintf
stderr
and
n
fprintf
stderr
x
nosanitizestrings
n
fprintf
stderr
are
legal
not
x
s
n
dwoptarg
arg_usage_error
TRUE
Process
the
command
line
arguments
and
set
the
appropriate
options
All
the
options
are
within
the
global
flags
structure
static
void
set_command_options
int
argc
char
argv
int
longindex
j
unused
while
arg_option
dwgetopt_long
argc
argv
abc
CdDeE
fFgGhH
iIk
l
mMnNo
O
pPqQrRsS
t
u
UvVwW
x
yz
longopts
EOF
switch
arg_option
case
arg_trace
break
case
a
arg_print_all
break
case
b
arg_print_abbrev
break
case
c
arg_c_multiple_selection
break
case
C
arg_format_extensions
break
case
d
arg_format_dense
break
case
D
arg_format_suppress_offsets
break
case
e
arg_format_ellipsis
break
case
E
arg_E_multiple_selection
break
case
f
arg_print_debug_frame
break
case
F
arg_print_gnu_frame
break
case
g
arg_format_loc
break
case
G
arg_format_global_offsets
break
case
h
arg_h_multiple_selection
break
case
H
arg_format_limit
break
case
i
arg_print_info
break
case
I
arg_print_fission
break
case
k
arg_k_multiple_selection
break
case
l
arg_l_multiple_selection
break
case
m
arg_print_macinfo
break
case
M
arg_format_attr_name
break
case
n
arg_format_suppress_lookup
break
case
N
arg_print_ranges
break
case
o
arg_o_multiple_selection
break
case
O
arg_O_multiple_selection
break
case
p
arg_print_pubnames
break
case
P
arg_print_producers
break
case
q
arg_format_suppress_uri_msg
break
case
Q
arg_format_suppress_data
break
case
r
arg_print_aranges
break
case
R
arg_format_registers
break
case
s
arg_print_strings
break
case
S
arg_S_multiple_selection
break
case
t
arg_t_multiple_selection
break
case
u
arg_format_file
break
case
U
arg_format_suppress_uri
break
case
v
arg_verbose
break
case
V
arg_version
break
case
w
arg_print_weaknames
break
case
W
arg_W_multiple_selection
break
case
x
arg_x_multiple_selection
break
case
y
arg_print_types
break
case
z
arg_not_supported
break
Check
DWARF
Integrity
case
OPT_CHECK_ABBREV
arg_check_abbrev
break
case
OPT_CHECK_ALL
arg_check_all
break
case
OPT_CHECK_ARANGES
arg_check_aranges
break
case
OPT_CHECK_ATTR_DUP
arg_check_attr_dup
break
case
OPT_CHECK_ATTR_ENCODINGS
arg_check_attr_encodings
break
case
OPT_CHECK_ATTR_NAMES
arg_check_attr_names
break
case
OPT_CHECK_CONSTANTS
arg_check_constants
break
case
OPT_CHECK_FILES_LINES
arg_check_files_lines
break
case
OPT_CHECK_FORWARD_REFS
arg_check_forward_refs
break
case
OPT_CHECK_FRAME_BASIC
arg_check_frame_basic
break
case
OPT_CHECK_FRAME_EXTENDED
arg_check_frame_extended
break
case
OPT_CHECK_FRAME_INFO
arg_check_frame_info
break
case
OPT_CHECK_GAPS
arg_check_gaps
break
case
OPT_CHECK_LOC
arg_check_loc
break
case
OPT_CHECK_MACROS
arg_check_macros
break
case
OPT_CHECK_PUBNAMES
arg_check_pubnames
break
case
OPT_CHECK_RANGES
arg_check_ranges
break
case
OPT_CHECK_SELF_REFS
arg_check_self_refs
break
case
OPT_CHECK_SHOW
arg_check_show
break
case
OPT_CHECK_SILENT
arg_check_silent
break
case
OPT_CHECK_SUMMARY
arg_check_summary
break
case
OPT_CHECK_TAG_ATTR
arg_check_tag_attr
break
case
OPT_CHECK_TAG_TAG
arg_check_tag_tag
break
case
OPT_CHECK_TYPE
arg_check_type
break
case
OPT_CHECK_UNIQUE
arg_check_unique
break
ifdef
HAVE_USAGE_TAG_ATTR
case
OPT_CHECK_USAGE
arg_check_usage
break
case
OPT_CHECK_USAGE_EXTENDED
arg_check_usage_extended
break
endif
HAVE_USAGE_TAG_ATTR
Print
ELF
sections
header
case
OPT_ELF
arg_elf
break
case
OPT_ELF_ABBREV
arg_elf_abbrev
break
case
OPT_ELF_ARANGES
arg_elf_aranges
break
case
OPT_ELF_DEFAULT
arg_elf_default
break
case
OPT_ELF_FISSION
arg_elf_fission
break
case
OPT_ELF_FRAMES
arg_elf_frames
break
case
OPT_ELF_HEADER
arg_elf_header
break
case
OPT_ELF_INFO
arg_elf_info
break
case
OPT_ELF_LINE
arg_elf_line
break
case
OPT_ELF_LOC
arg_elf_loc
break
case
OPT_ELF_MACINFO
arg_elf_macinfo
break
case
OPT_ELF_PUBNAMES
arg_elf_pubnames
break
case
OPT_ELF_PUBTYPES
arg_elf_pubtypes
break
case
OPT_ELF_RANGES
arg_elf_ranges
break
case
OPT_ELF_STRINGS
arg_elf_strings
break
case
OPT_ELF_TEXT
arg_elf_text
break
File
Specifications
case
OPT_FILE_ABI
arg_file_abi
break
case
OPT_FILE_LINE5
arg_file_line5
break
case
OPT_FILE_NAME
arg_file_name
break
case
OPT_FILE_OUTPUT
arg_file_output
break
case
OPT_FILE_TIED
arg_file_tied
break
case
OPT_FILE_USE_NO_LIBELF
arg_file_use_no_libelf
break
Print
Output
Qualifiers
case
OPT_FORMAT_ATTR_NAME
arg_format_attr_name
break
case
OPT_FORMAT_DENSE
arg_format_dense
break
case
OPT_FORMAT_ELLIPSIS
arg_format_ellipsis
break
case
OPT_FORMAT_EXPR_OPS_JOINED
arg_format_expr_ops_joined
break
case
OPT_FORMAT_EXTENSIONS
arg_format_extensions
break
case
OPT_FORMAT_GLOBAL_OFFSETS
arg_format_global_offsets
break
case
OPT_FORMAT_LOC
arg_format_loc
break
case
OPT_FORMAT_REGISTERS
arg_format_registers
break
case
OPT_FORMAT_SUPPRESS_DATA
arg_format_suppress_data
break
case
OPT_FORMAT_SUPPRESS_GROUP
arg_format_suppress_group
break
case
OPT_FORMAT_SUPPRESS_OFFSETS
arg_format_suppress_offsets
break
case
OPT_FORMAT_SUPPRESS_LOOKUP
arg_format_suppress_lookup
break
case
OPT_FORMAT_SUPPRESS_SANITIZE
arg_format_suppress_sanitize
break
case
OPT_FORMAT_SUPPRESS_URI
arg_format_suppress_uri
break
case
OPT_FORMAT_SUPPRESS_URI_MSG
arg_format_suppress_uri_msg
break
Print
Output
Limiters
case
OPT_FORMAT_FILE
arg_format_file
break
case
OPT_FORMAT_GCC
arg_format_gcc
break
case
OPT_FORMAT_GROUP_NUMBER
arg_format_groupnumber
break
case
OPT_FORMAT_LIMIT
arg_format_limit
break
case
OPT_FORMAT_PRODUCER
arg_format_producer
break
case
OPT_FORMAT_SNC
arg_format_snc
break
Print
Debug
Sections
case
OPT_PRINT_ABBREV
arg_print_abbrev
break
case
OPT_PRINT_ALL
arg_print_all
break
case
OPT_PRINT_ARANGES
arg_print_aranges
break
case
OPT_PRINT_DEBUG_NAMES
arg_print_debug_names
break
case
OPT_PRINT_GNU_DEBUGLINK
arg_print_gnu_debuglink
break
case
OPT_PRINT_DEBUG_GNU
arg_print_debug_gnu
break
case
OPT_PRINT_DEBUG_SUP
arg_print_debug_sup
break
case
OPT_PRINT_EH_FRAME
arg_print_gnu_frame
break
case
OPT_PRINT_FISSION
arg_print_fission
break
case
OPT_PRINT_FRAME
arg_print_debug_frame
break
case
OPT_PRINT_INFO
arg_print_info
break
case
OPT_PRINT_LINES
arg_print_lines
break
case
OPT_PRINT_LINES_SHORT
arg_print_lines_short
break
case
OPT_PRINT_LOC
arg_print_loc
break
case
OPT_PRINT_MACINFO
arg_print_macinfo
break
case
OPT_PRINT_PRODUCERS
arg_print_producers
break
case
OPT_PRINT_PUBNAMES
arg_print_pubnames
break
case
OPT_PRINT_RANGES
arg_print_ranges
break
case
OPT_PRINT_RAW_LOCLISTS
arg_print_raw_loclists
break
case
OPT_PRINT_RAW_RNGLISTS
arg_print_raw_rnglists
break
case
OPT_PRINT_STATIC
arg_print_static
break
case
OPT_PRINT_STATIC_FUNC
arg_print_static_func
break
case
OPT_PRINT_STATIC_VAR
arg_print_static_var
break
case
OPT_PRINT_STRINGS
arg_print_strings
break
case
OPT_PRINT_STR_OFFSETS
arg_print_str_offsets
break
case
OPT_PRINT_TYPE
arg_print_types
break
case
OPT_PRINT_WEAKNAME
arg_print_weaknames
break
Print
Relocations
Info
only
with
libelf
case
OPT_RELOC
arg_reloc
break
case
OPT_RELOC_ABBREV
arg_reloc_abbrev
break
case
OPT_RELOC_ARANGES
arg_reloc_aranges
break
case
OPT_RELOC_FRAMES
arg_reloc_frames
break
case
OPT_RELOC_INFO
arg_reloc_info
break
case
OPT_RELOC_LINE
arg_reloc_line
break
case
OPT_RELOC_LOC
arg_reloc_loc
break
case
OPT_RELOC_PUBNAMES
arg_reloc_pubnames
break
case
OPT_RELOC_RANGES
arg_reloc_ranges
break
debuglink
attributes
case
OPT_NO_FOLLOW_DEBUGLINK
arg_no_follow_debuglink
break
case
OPT_ADD_DEBUGLINK_PATH
arg_add_debuglink_path
break
Search
text
in
attributes
case
OPT_SEARCH_ANY
arg_search_any
break
case
OPT_SEARCH_ANY_COUNT
arg_search_any_count
break
case
OPT_SEARCH_MATCH
arg_search_match
break
case
OPT_SEARCH_MATCH_COUNT
arg_search_match_count
break
case
OPT_SEARCH_PRINT_CHILDREN
arg_search_print_children
break
case
OPT_SEARCH_PRINT_PARENT
arg_search_print_parent
break
case
OPT_SEARCH_PRINT_TREE
arg_search_print_tree
break
ifdef
HAVE_REGEX
case
OPT_SEARCH_REGEX
arg_search_regex
break
case
OPT_SEARCH_REGEX_COUNT
arg_search_regex_count
break
endif
HAVE_REGEX
Help
Version
case
OPT_HELP
arg_help
break
case
OPT_VERBOSE
arg_verbose
break
case
OPT_VERBOSE_MORE
arg_verbose
break
case
OPT_VERSION
arg_version
break
case
OPT_SHOW_DWARFDUMP_CONF
arg_show_dwarfdump_conf
break
Trace
case
OPT_TRACE
arg_trace
break
case
OPT_ALLOC_PRINT_SUMS
glflags
gf_print_alloc_sums
TRUE
break
case
OPT_ALLOC_TREE_OFF
Suppress
nearly
all
libdwarf
de_alloc_tree
record
keeping
dwarf_set_de_alloc_flag
FALSE
break
default
arg_usage_error
TRUE
break
This
is
a
hack
allowing
us
to
pretend
that
dwarfdump
print
alloc
sums
suppress
de
alloc
tree
foo
o
has
no
arguments
Because
the
args
here
really
are
special
for
use
by
dwarfdump
developers
and
even
with
these
special
args
we
want
do_all
to
be
called
by
process_args
below
if
there
are
no
normal
or
args
And
of
course
v
verbose
are
special
too
So
regression
testing
can
behave
identically
with
or
without
the
specials
Function
new
March
static
const
char
simplestdargs
v
vv
vvv
vvvv
vvvvv
vvvvvv
verbose
show
dwarfdump
conf
verbose
more
print
alloc
sums
suppress
de
alloc
tree
static
int
lacking_normal_args
int
argct
char
args
char
curarg
int
i
for
i
i
argct
i
int
k
int
simple
FALSE
curarg
args
i
if
curarg
Standard
case
return
TRUE
for
k
simplestdargs
k
k
if
strcmp
curarg
simplestdargs
k
simple
TRUE
break
if
simple
continue
Not
one
of
the
specials
a
normal
argument
so
we
have
some
real
args
return
FALSE
Never
found
any
non
simple
argument
let
regular
arg
processing
deal
with
it
return
TRUE
process
arguments
and
return
object
filename
const
char
process_args
int
argc
char
argv
glflags
program_name
special_program_name
argv
glflags
program_fullname
argv
suppress_check_dwarf
if
argv
lacking_normal_args
argc
argv
The
default
setting
of
what
to
print
or
do
do_all
glflags
gf_section_groups_flag
TRUE
Process
the
arguments
and
set
the
appropriate
options
set_command_options
argc
argv
if
config_file_abi
glflags
gf_generic_1200_regs
printf
Specifying
both
R
and
x
abi
is
not
allowed
Use
one
or
the
other
x
abi
ignored
n
config_file_abi
even
with
no
abi
we
look
as
there
may
be
a
dwarfdump
option
there
we
know
about
int
res
res
find_conf_file_and_read_config
esb_get_string
glflags
config_file_path
config_file_abi
config_file_defaults
glflags
config_file_data
if
res
FOUND_ERROR
if
glflags
gf_do_print_dwarf
glflags
gf_do_check_dwarf
printf
Frame
not
configured
due
to
configure
error
s
n
printf
Since
no
print
or
check
options
provided
dwarfdump
may
now
silently
exit
n
else
printf
Frame
not
configured
due
to
configure
error
s
using
generic
registers
n
Frame
section
access
suppressed
n
glflags
gf_eh_frame_flag
FALSE
glflags
gf_frame_flag
FALSE
else
if
res
FOUND_DONE
res
FOUND_OPTION
if
glflags
gf_generic_1200_regs
init_generic_config_1200_regs
glflags
config_file_data
else
FOUND_ABI_START
nothing
to
do
if
arg_usage_error
printf
s
option
error
n
glflags
program_name
printf
To
see
the
options
list
s
h
n
glflags
program_name
exit
FAILED
if
dwoptind
argc
printf
Multiple
apparent
object
file
names
provided
to
s
n
glflags
program_name
printf
Only
a
single
object
name
is
allowed
n
printf
To
see
the
options
list
s
h
n
glflags
program_name
exit
FAILED
if
dwoptind
argc
printf
No
object
file
name
provided
to
s
n
glflags
program_name
printf
To
see
the
options
list
s
h
n
glflags
program_name
exit
FAILED
FIXME
it
seems
silly
to
be
printing
section
names
where
the
section
does
not
exist
in
the
object
file
However
we
continue
the
long
standard
practice
of
printing
such
by
default
in
most
cases
For
now
if
glflags
group_number
DW_GROUPNUMBER_DWO
For
split
dwarf
DWO
some
sections
make
no
sense
This
prevents
printing
of
meaningless
headers
where
no
data
can
exist
glflags
gf_pubnames_flag
FALSE
glflags
gf_eh_frame_flag
FALSE
glflags
gf_frame_flag
FALSE
glflags
gf_macinfo_flag
FALSE
glflags
gf_aranges_flag
FALSE
glflags
gf_ranges_flag
FALSE
glflags
gf_static_func_flag
FALSE
glflags
gf_static_var_flag
FALSE
glflags
gf_weakname_flag
FALSE
if
glflags
group_number
DW_GROUPNUMBER_BASE
These
no
longer
apply
no
one
uses
glflags
gf_static_func_flag
FALSE
glflags
gf_static_var_flag
FALSE
glflags
gf_weakname_flag
FALSE
glflags
gf_pubnames_flag
FALSE
if
glflags
gf_do_check_dwarf
Reduce
verbosity
when
checking
checking
means
checking
only
glflags
verbose
return
do_uri_translation
argv
dwoptind
file
to
process
Copyright
C
SN
Systems
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
These
do
little
except
on
Windows
include
config
h
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
common
h
include
defined_types
h
include
sanitized
h
include
libdwarf_version
h
for
DW_VERSION_DATE_STR
include
stdio
h
include
libdwarf_private
h
ifndef
BUILD_STANDARD_SOURCE
Must
match
libdwarf
h
in
declaration
const
char
dwarf_package_version
void
endif
BUILD_STANDARD_SOURCE
define
RELEASE_DATE
PACKAGE_VERSION
is
from
config
h
The
Linux
Unix
version
does
not
want
a
version
string
to
print
unless
V
is
on
the
command
line
void
print_version_details
const
char
name
UNUSEDARG
int
alwaysprint
ifdef
_WIN32
UNUSEDARG
we
don
t
use
this
arg
with
Windows
endif
ifdef
_WIN32
ifdef
_DEBUG
char
acType
Debug
else
char
acType
Release
endif
_DEBUG
ifdef
_WIN64
char
bits
else
char
bits
endif
_WIN64
printf
s
s
s
s
Win
s
s
n
sanitized
name
__DATE__
__TIME__
acType
bits
PACKAGE_VERSION
else
_WIN32
if
alwaysprint
ifdef
BUILD_STANDARD_SOURCE
Used
by
scripts
buildstandardsource
sh
printf
s
n
DW_VERSION_DATE_STR
else
const
char
pv
dwarf_package_version
printf
s
Package
Version
s
n
DW_VERSION_DATE_STR
pv
endif
endif
_WIN32
void
print_args
int
argc
UNUSEDARG
char
argv
UNUSEDARG
ifdef
_WIN32
int
index
printf
Arguments
for
index
index
argc
index
printf
s
sanitized
argv
index
printf
n
endif
_WIN32
Going
to
stdout
as
of
April
dwarfdump
only
calls
if
requested
by
user
void
print_usage_message
const
char
program_name_in
UNUSEDARG
const
char
text
unsigned
i
for
i
text
i
i
printf
s
n
text
i
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
makename
h
include
sanitized
h
include
command_options
h
include
compiler_info
h
Record
compilers
whose
CU
names
have
been
seen
Full
CU
names
recorded
here
though
only
a
portion
of
the
name
may
have
been
checked
to
cause
the
compiler
data
to
be
entered
here
The
detected
targeted
arrays
leave
index
unused
There
is
no
particularly
good
reason
for
this
current_compiler
starts
at
and
is
legitimately
through
COMPILER_TABLE_MAX
compilers_targeted_count
and
compilers_detected_count
are
the
actual
count
so
loops
use
things
like
for
i
i
compilers_detected_count
for
example
static
Compiler
compilers_detected
COMPILER_TABLE_MAX
static
int
compilers_detected_count
compilers_targeted
is
a
list
of
indications
of
compilers
on
which
we
wish
error
checking
and
the
counts
of
checks
made
and
errors
found
We
do
substring
comparisons
so
the
compilers_targeted
name
might
be
simply
a
compiler
version
number
or
a
short
substring
of
a
CU
producer
name
The
guarantees
we
do
not
overstep
the
array
static
Compiler
compilers_targeted
COMPILER_TABLE_MAX
static
int
compilers_targeted_count
static
int
current_compiler
Indicates
if
the
current
CU
is
a
target
static
Dwarf_Bool
current_cu_is_checked_compiler
TRUE
static
int
hasprefix
const
char
sample
const
char
prefix
unsigned
prelen
strlen
prefix
if
strncmp
sample
prefix
prelen
return
TRUE
return
FALSE
static
void
PRINT_CHECK_RESULT
char
str
Compiler
pCompiler
Dwarf_Check_Categories
category
Dwarf_Check_Result
result
pCompiler
results
category
printf
n
str
result
checks
result
errors
Print
checks
and
errors
for
a
specific
compiler
static
void
print_specific_checks_results
Compiler
pCompiler
printf
nDWARF
CHECK
RESULT
n
printf
item
checks
errors
n
if
glflags
gf_check_pubname_attr
PRINT_CHECK_RESULT
pubname_attr
pCompiler
pubname_attr_result
if
glflags
gf_check_tag_attr
PRINT_CHECK_RESULT
attr_tag
pCompiler
attr_tag_result
PRINT_CHECK_RESULT
attr_formclass
pCompiler
attr_formclass_result
if
glflags
gf_check_tag_tree
PRINT_CHECK_RESULT
tag_tree
pCompiler
tag_tree_result
if
glflags
gf_check_type_offset
PRINT_CHECK_RESULT
type_offset
pCompiler
type_offset_result
if
glflags
gf_check_decl_file
PRINT_CHECK_RESULT
decl_file
pCompiler
decl_file_result
if
glflags
gf_check_ranges
PRINT_CHECK_RESULT
ranges
pCompiler
ranges_result
if
glflags
gf_check_lines
PRINT_CHECK_RESULT
line_table
pCompiler
lines_result
if
glflags
gf_check_fdes
PRINT_CHECK_RESULT
fde_table
pCompiler
fde_duplication
if
glflags
gf_check_aranges
PRINT_CHECK_RESULT
aranges
pCompiler
aranges_result
if
glflags
gf_check_names
PRINT_CHECK_RESULT
names
pCompiler
names_result
if
glflags
gf_check_frames
PRINT_CHECK_RESULT
frames
pCompiler
frames_result
if
glflags
gf_check_locations
PRINT_CHECK_RESULT
locations
pCompiler
locations_result
if
glflags
gf_check_harmless
PRINT_CHECK_RESULT
harmless_errors
pCompiler
harmless_result
if
glflags
gf_check_abbreviations
PRINT_CHECK_RESULT
abbreviations
pCompiler
abbreviations_result
if
glflags
gf_check_dwarf_constants
PRINT_CHECK_RESULT
dwarf_constants
pCompiler
dwarf_constants_result
if
glflags
gf_check_di_gaps
PRINT_CHECK_RESULT
debug_info_gaps
pCompiler
di_gaps_result
if
glflags
gf_check_forward_decl
PRINT_CHECK_RESULT
forward_declarations
pCompiler
forward_decl_result
if
glflags
gf_check_self_references
PRINT_CHECK_RESULT
self_references
pCompiler
self_references_result
Display
attributes
encoding
results
if
glflags
gf_check_attr_encoding
PRINT_CHECK_RESULT
attr_encoding
pCompiler
attr_encoding_result
Duplicated
attributes
if
glflags
gf_check_duplicated_attributes
PRINT_CHECK_RESULT
duplicated_attributes
pCompiler
duplicated_attributes_result
PRINT_CHECK_RESULT
Summarize
pCompiler
total_check_result
fflush
stdout
Add
a
CU
name
to
the
current
compiler
entry
specified
by
the
current_compiler
the
name
is
added
to
the
compilers_detected
table
and
is
printed
if
the
P
or
print
producers
option
is
specified
in
the
command
line
void
add_cu_name_compiler_target
char
name
a_name_chain
cu_last
a_name_chain
nc
Compiler
pCompiler
if
current_compiler
fprintf
stderr
Current
compiler
set
to
d
cannot
add
Compilation
unit
name
Giving
up
current_compiler
exit
FAILED
pCompiler
current_compiler
cu_last
pCompiler
cu_last
Record
current
cu
name
nc
a_name_chain
malloc
sizeof
a_name_chain
nc
item
makename
name
nc
next
NULL
if
cu_last
cu_last
next
nc
else
pCompiler
cu_list
nc
pCompiler
cu_last
nc
Reset
a
compiler
entry
so
all
fields
are
properly
set
void
reset_compiler_entry
Compiler
compiler
memset
compiler
sizeof
Compiler
Record
which
compiler
was
used
or
notice
we
saw
it
before
and
set
a
couple
variables
as
a
side
effect
which
are
used
all
over
in
this
one
source
file
current_cu_is_checked_compiler
used
in
checking_this_compiler
current_compiler
The
compiler
producer
name
is
from
DW_AT_producer
void
update_compiler_target
const
char
producer_name
Dwarf_Bool
cFound
FALSE
int
index
safe_strcpy
glflags
CU_producer
sizeof
glflags
CU_producer
producer_name
strlen
producer_name
current_cu_is_checked_compiler
FALSE
This
list
of
compilers
is
just
a
start
GCC
id
GNU
SNC
id
SN
Systems
Find
a
compiler
version
to
check
if
compilers_targeted_count
for
index
index
compilers_targeted_count
index
if
is_strstrnocase
glflags
CU_producer
compilers_targeted
index
name
compilers_targeted
index
verified
TRUE
current_cu_is_checked_compiler
TRUE
break
else
Internally
the
strings
do
not
include
quotes
Dwarf_Bool
snc_compiler
hasprefix
glflags
CU_producer
SN
TRUE
FALSE
Dwarf_Bool
gcc_compiler
hasprefix
glflags
CU_producer
GNU
TRUE
FALSE
current_cu_is_checked_compiler
glflags
gf_check_all_compilers
snc_compiler
glflags
gf_check_snc_compiler
gcc_compiler
glflags
gf_check_gcc_compiler
Check
for
already
detected
compiler
for
index
index
compilers_detected_count
index
const
char
name
compilers_detected
index
name
if
if
_WIN32
stricmp
name
glflags
CU_producer
else
strcmp
name
glflags
CU_producer
endif
_WIN32
Set
current
compiler
index
current_compiler
index
cFound
TRUE
break
else
if
cFound
Record
a
new
detected
compiler
name
if
compilers_detected_count
COMPILER_TABLE_MAX
Compiler
pCompiler
char
cmp
makename
glflags
CU_producer
Set
current
compiler
index
first
compiler
at
position
current_compiler
compilers_detected_count
pCompiler
current_compiler
reset_compiler_entry
pCompiler
pCompiler
name
cmp
void
clean_up_compilers_detected
void
memset
COMPILER_TABLE_MAX
sizeof
Compiler
compilers_detected_count
Are
we
checking
for
errors
from
the
compiler
of
the
current
compilation
unit?
Dwarf_Bool
checking_this_compiler
void
This
flag
has
been
update
by
update_compiler_target
and
indicates
if
the
current
CU
is
in
a
targeted
compiler
specified
by
the
user
Default
value
is
TRUE
which
means
test
all
compilers
until
a
CU
is
detected
return
current_cu_is_checked_compiler
static
int
qsort_compare_compiler
const
void
elem1
const
void
elem2
Compiler
cmp1
Compiler
elem1
Compiler
cmp2
Compiler
elem2
int
cnt1
cmp1
results
total_check_result
errors
int
cnt2
cmp2
results
total_check_result
errors
if
cnt1
cnt2
return
else
if
cnt1
cnt2
return
When
error
counts
match
sort
on
name
int
v
strcmp
cmp2
name
cmp1
name
return
v
Print
a
summary
of
checks
and
errors
void
print_checks_results
void
int
index
Compiler
pCompilers
Compiler
pCompiler
Sort
based
on
errors
detected
the
first
entry
is
reserved
and
unused
count
started
at
pCompilers
if
compilers_detected_count
qsort
void
pCompilers
compilers_detected_count
sizeof
Compiler
qsort_compare_compiler
Print
list
of
CUs
for
each
compiler
detected
if
glflags
gf_producer_children_flag
a_name_chain
nc
a_name_chain
nc_next
int
count
int
total
printf
n
CU
NAMES
PER
COMPILER
n
for
index
index
compilers_detected_count
index
pCompiler
index
printf
n
s
index
sanitized
pCompiler
name
count
for
nc
pCompiler
cu_list
nc
nc
nc_next
printf
n
s
count
sanitized
nc
item
nc_next
nc
next
free
nc
total
count
printf
n
printf
nDetected
d
CU
names
n
total
Print
error
report
only
if
errors
have
been
detected
Print
error
report
if
the
kd
option
if
glflags
gf_do_check_dwarf
glflags
check_error
glflags
gf_check_show_results
int
count
int
compilers_not_detected
int
compilers_verified
Find
out
how
many
compilers
have
been
verified
for
index
index
compilers_detected_count
index
if
compilers_detected
index
verified
compilers_verified
Find
out
how
many
compilers
have
been
not
detected
for
index
index
compilers_targeted_count
index
if
compilers_targeted
index
verified
compilers_not_detected
Print
compilers
detected
list
printf
n
d
Compilers
detected
n
compilers_detected_count
for
index
index
compilers_detected_count
index
pCompiler
index
printf
s
n
index
sanitized
pCompiler
name
Print
compiler
list
specified
by
the
user
with
the
c
str
that
were
not
detected
if
compilers_not_detected
count
printf
n
d
Compilers
not
detected
n
compilers_not_detected
for
index
index
compilers_targeted_count
index
if
compilers_targeted
index
verified
printf
s
n
count
sanitized
compilers_targeted
index
name
count
printf
n
d
Compilers
verified
n
compilers_verified
for
index
index
compilers_detected_count
index
pCompiler
index
if
pCompiler
verified
printf
errors
s
n
count
pCompiler
results
total_check_result
errors
sanitized
pCompiler
name
Print
summary
if
we
have
verified
compilers
or
if
the
kd
option
used
if
compilers_verified
glflags
gf_check_show_results
Print
compilers
detected
summary
if
glflags
gf_print_summary_all
count
printf
n
ERRORS
PER
COMPILER
n
for
index
index
compilers_detected_count
index
pCompiler
index
if
pCompiler
verified
printf
n
s
count
sanitized
pCompiler
name
print_specific_checks_results
pCompiler
Print
general
summary
all
compilers
checked
printf
n
TOTAL
ERRORS
FOR
ALL
COMPILERS
n
print_specific_checks_results
fflush
stdout
void
DWARF_CHECK_COUNT
Dwarf_Check_Categories
category
int
inc
Compiler
c
c
c
results
category
checks
inc
c
results
total_check_result
checks
inc
if
current_compiler
current_compiler
COMPILER_TABLE_MAX
c
current_compiler
c
results
category
checks
inc
c
results
total_check_result
checks
inc
c
verified
TRUE
void
DWARF_ERROR_COUNT
Dwarf_Check_Categories
category
int
inc
Compiler
c
c
c
results
category
errors
inc
c
results
total_check_result
errors
inc
if
current_compiler
current_compiler
COMPILER_TABLE_MAX
c
current_compiler
c
results
category
errors
inc
c
results
total_check_result
errors
inc
Dwarf_Bool
record_producer
char
name
Dwarf_Bool
recorded
FALSE
if
compilers_targeted_count
COMPILER_TABLE_MAX
Compiler
pCompiler
const
char
cmp
cmp
do_uri_translation
name
c
compiler
name
First
compiler
at
position
compilers_targeted_count
pCompiler
compilers_targeted_count
reset_compiler_entry
pCompiler
pCompiler
name
cmp
glflags
gf_check_all_compilers
FALSE
recorded
TRUE
return
recorded
Generated
routines
do
not
edit
Generated
sourcedate
BEGIN
FILE
include
dwarf
h
include
libdwarf
h
ARGSUSED
int
dwarf_get_TAG_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_TAG_array_type
s_out
DW_TAG_array_type
return
DW_DLV_OK
case
DW_TAG_class_type
s_out
DW_TAG_class_type
return
DW_DLV_OK
case
DW_TAG_entry_point
s_out
DW_TAG_entry_point
return
DW_DLV_OK
case
DW_TAG_enumeration_type
s_out
DW_TAG_enumeration_type
return
DW_DLV_OK
case
DW_TAG_formal_parameter
s_out
DW_TAG_formal_parameter
return
DW_DLV_OK
case
DW_TAG_imported_declaration
s_out
DW_TAG_imported_declaration
return
DW_DLV_OK
case
DW_TAG_label
s_out
DW_TAG_label
return
DW_DLV_OK
case
DW_TAG_lexical_block
s_out
DW_TAG_lexical_block
return
DW_DLV_OK
case
DW_TAG_member
s_out
DW_TAG_member
return
DW_DLV_OK
case
DW_TAG_pointer_type
s_out
DW_TAG_pointer_type
return
DW_DLV_OK
case
DW_TAG_reference_type
s_out
DW_TAG_reference_type
return
DW_DLV_OK
case
DW_TAG_compile_unit
s_out
DW_TAG_compile_unit
return
DW_DLV_OK
case
DW_TAG_string_type
s_out
DW_TAG_string_type
return
DW_DLV_OK
case
DW_TAG_structure_type
s_out
DW_TAG_structure_type
return
DW_DLV_OK
case
DW_TAG_subroutine_type
s_out
DW_TAG_subroutine_type
return
DW_DLV_OK
case
DW_TAG_typedef
s_out
DW_TAG_typedef
return
DW_DLV_OK
case
DW_TAG_union_type
s_out
DW_TAG_union_type
return
DW_DLV_OK
case
DW_TAG_unspecified_parameters
s_out
DW_TAG_unspecified_parameters
return
DW_DLV_OK
case
DW_TAG_variant
s_out
DW_TAG_variant
return
DW_DLV_OK
case
DW_TAG_common_block
s_out
DW_TAG_common_block
return
DW_DLV_OK
case
DW_TAG_common_inclusion
s_out
DW_TAG_common_inclusion
return
DW_DLV_OK
case
DW_TAG_inheritance
s_out
DW_TAG_inheritance
return
DW_DLV_OK
case
DW_TAG_inlined_subroutine
s_out
DW_TAG_inlined_subroutine
return
DW_DLV_OK
case
DW_TAG_module
s_out
DW_TAG_module
return
DW_DLV_OK
case
DW_TAG_ptr_to_member_type
s_out
DW_TAG_ptr_to_member_type
return
DW_DLV_OK
case
DW_TAG_set_type
s_out
DW_TAG_set_type
return
DW_DLV_OK
case
DW_TAG_subrange_type
s_out
DW_TAG_subrange_type
return
DW_DLV_OK
case
DW_TAG_with_stmt
s_out
DW_TAG_with_stmt
return
DW_DLV_OK
case
DW_TAG_access_declaration
s_out
DW_TAG_access_declaration
return
DW_DLV_OK
case
DW_TAG_base_type
s_out
DW_TAG_base_type
return
DW_DLV_OK
case
DW_TAG_catch_block
s_out
DW_TAG_catch_block
return
DW_DLV_OK
case
DW_TAG_const_type
s_out
DW_TAG_const_type
return
DW_DLV_OK
case
DW_TAG_constant
s_out
DW_TAG_constant
return
DW_DLV_OK
case
DW_TAG_enumerator
s_out
DW_TAG_enumerator
return
DW_DLV_OK
case
DW_TAG_file_type
s_out
DW_TAG_file_type
return
DW_DLV_OK
case
DW_TAG_friend
s_out
DW_TAG_friend
return
DW_DLV_OK
case
DW_TAG_namelist
s_out
DW_TAG_namelist
return
DW_DLV_OK
case
DW_TAG_namelist_item
s_out
DW_TAG_namelist_item
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_namelist_items
case
DW_TAG_packed_type
s_out
DW_TAG_packed_type
return
DW_DLV_OK
case
DW_TAG_subprogram
s_out
DW_TAG_subprogram
return
DW_DLV_OK
case
DW_TAG_template_type_parameter
s_out
DW_TAG_template_type_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_template_type_param
case
DW_TAG_template_value_parameter
s_out
DW_TAG_template_value_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_template_value_param
case
DW_TAG_thrown_type
s_out
DW_TAG_thrown_type
return
DW_DLV_OK
case
DW_TAG_try_block
s_out
DW_TAG_try_block
return
DW_DLV_OK
case
DW_TAG_variant_part
s_out
DW_TAG_variant_part
return
DW_DLV_OK
case
DW_TAG_variable
s_out
DW_TAG_variable
return
DW_DLV_OK
case
DW_TAG_volatile_type
s_out
DW_TAG_volatile_type
return
DW_DLV_OK
case
DW_TAG_dwarf_procedure
s_out
DW_TAG_dwarf_procedure
return
DW_DLV_OK
case
DW_TAG_restrict_type
s_out
DW_TAG_restrict_type
return
DW_DLV_OK
case
DW_TAG_interface_type
s_out
DW_TAG_interface_type
return
DW_DLV_OK
case
DW_TAG_namespace
s_out
DW_TAG_namespace
return
DW_DLV_OK
case
DW_TAG_imported_module
s_out
DW_TAG_imported_module
return
DW_DLV_OK
case
DW_TAG_unspecified_type
s_out
DW_TAG_unspecified_type
return
DW_DLV_OK
case
DW_TAG_partial_unit
s_out
DW_TAG_partial_unit
return
DW_DLV_OK
case
DW_TAG_imported_unit
s_out
DW_TAG_imported_unit
return
DW_DLV_OK
case
DW_TAG_mutable_type
s_out
DW_TAG_mutable_type
return
DW_DLV_OK
case
DW_TAG_condition
s_out
DW_TAG_condition
return
DW_DLV_OK
case
DW_TAG_shared_type
s_out
DW_TAG_shared_type
return
DW_DLV_OK
case
DW_TAG_type_unit
s_out
DW_TAG_type_unit
return
DW_DLV_OK
case
DW_TAG_rvalue_reference_type
s_out
DW_TAG_rvalue_reference_type
return
DW_DLV_OK
case
DW_TAG_template_alias
s_out
DW_TAG_template_alias
return
DW_DLV_OK
case
DW_TAG_coarray_type
s_out
DW_TAG_coarray_type
return
DW_DLV_OK
case
DW_TAG_generic_subrange
s_out
DW_TAG_generic_subrange
return
DW_DLV_OK
case
DW_TAG_dynamic_type
s_out
DW_TAG_dynamic_type
return
DW_DLV_OK
case
DW_TAG_atomic_type
s_out
DW_TAG_atomic_type
return
DW_DLV_OK
case
DW_TAG_call_site
s_out
DW_TAG_call_site
return
DW_DLV_OK
case
DW_TAG_call_site_parameter
s_out
DW_TAG_call_site_parameter
return
DW_DLV_OK
case
DW_TAG_skeleton_unit
s_out
DW_TAG_skeleton_unit
return
DW_DLV_OK
case
DW_TAG_immutable_type
s_out
DW_TAG_immutable_type
return
DW_DLV_OK
case
DW_TAG_lo_user
s_out
DW_TAG_lo_user
return
DW_DLV_OK
case
DW_TAG_MIPS_loop
s_out
DW_TAG_MIPS_loop
return
DW_DLV_OK
case
DW_TAG_HP_array_descriptor
s_out
DW_TAG_HP_array_descriptor
return
DW_DLV_OK
case
DW_TAG_format_label
s_out
DW_TAG_format_label
return
DW_DLV_OK
case
DW_TAG_function_template
s_out
DW_TAG_function_template
return
DW_DLV_OK
case
DW_TAG_class_template
s_out
DW_TAG_class_template
return
DW_DLV_OK
case
DW_TAG_GNU_BINCL
s_out
DW_TAG_GNU_BINCL
return
DW_DLV_OK
case
DW_TAG_GNU_EINCL
s_out
DW_TAG_GNU_EINCL
return
DW_DLV_OK
case
DW_TAG_GNU_template_template_parameter
s_out
DW_TAG_GNU_template_template_parameter
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_TAG_GNU_template_template_param
case
DW_TAG_GNU_template_parameter_pack
s_out
DW_TAG_GNU_template_parameter_pack
return
DW_DLV_OK
case
DW_TAG_GNU_formal_parameter_pack
s_out
DW_TAG_GNU_formal_parameter_pack
return
DW_DLV_OK
case
DW_TAG_GNU_call_site
s_out
DW_TAG_GNU_call_site
return
DW_DLV_OK
case
DW_TAG_GNU_call_site_parameter
s_out
DW_TAG_GNU_call_site_parameter
return
DW_DLV_OK
case
DW_TAG_SUN_function_template
s_out
DW_TAG_SUN_function_template
return
DW_DLV_OK
case
DW_TAG_SUN_class_template
s_out
DW_TAG_SUN_class_template
return
DW_DLV_OK
case
DW_TAG_SUN_struct_template
s_out
DW_TAG_SUN_struct_template
return
DW_DLV_OK
case
DW_TAG_SUN_union_template
s_out
DW_TAG_SUN_union_template
return
DW_DLV_OK
case
DW_TAG_SUN_indirect_inheritance
s_out
DW_TAG_SUN_indirect_inheritance
return
DW_DLV_OK
case
DW_TAG_SUN_codeflags
s_out
DW_TAG_SUN_codeflags
return
DW_DLV_OK
case
DW_TAG_SUN_memop_info
s_out
DW_TAG_SUN_memop_info
return
DW_DLV_OK
case
DW_TAG_SUN_omp_child_func
s_out
DW_TAG_SUN_omp_child_func
return
DW_DLV_OK
case
DW_TAG_SUN_rtti_descriptor
s_out
DW_TAG_SUN_rtti_descriptor
return
DW_DLV_OK
case
DW_TAG_SUN_dtor_info
s_out
DW_TAG_SUN_dtor_info
return
DW_DLV_OK
case
DW_TAG_SUN_dtor
s_out
DW_TAG_SUN_dtor
return
DW_DLV_OK
case
DW_TAG_SUN_f90_interface
s_out
DW_TAG_SUN_f90_interface
return
DW_DLV_OK
case
DW_TAG_SUN_fortran_vax_structure
s_out
DW_TAG_SUN_fortran_vax_structure
return
DW_DLV_OK
case
DW_TAG_SUN_hi
s_out
DW_TAG_SUN_hi
return
DW_DLV_OK
case
DW_TAG_ALTIUM_circ_type
s_out
DW_TAG_ALTIUM_circ_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_mwa_circ_type
s_out
DW_TAG_ALTIUM_mwa_circ_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_rev_carry_type
s_out
DW_TAG_ALTIUM_rev_carry_type
return
DW_DLV_OK
case
DW_TAG_ALTIUM_rom
s_out
DW_TAG_ALTIUM_rom
return
DW_DLV_OK
case
DW_TAG_ghs_namespace
s_out
DW_TAG_ghs_namespace
return
DW_DLV_OK
case
DW_TAG_ghs_using_namespace
s_out
DW_TAG_ghs_using_namespace
return
DW_DLV_OK
case
DW_TAG_ghs_using_declaration
s_out
DW_TAG_ghs_using_declaration
return
DW_DLV_OK
case
DW_TAG_ghs_template_templ_param
s_out
DW_TAG_ghs_template_templ_param
return
DW_DLV_OK
case
DW_TAG_upc_shared_type
s_out
DW_TAG_upc_shared_type
return
DW_DLV_OK
case
DW_TAG_upc_strict_type
s_out
DW_TAG_upc_strict_type
return
DW_DLV_OK
case
DW_TAG_upc_relaxed_type
s_out
DW_TAG_upc_relaxed_type
return
DW_DLV_OK
case
DW_TAG_PGI_kanji_type
s_out
DW_TAG_PGI_kanji_type
return
DW_DLV_OK
case
DW_TAG_PGI_interface_block
s_out
DW_TAG_PGI_interface_block
return
DW_DLV_OK
case
DW_TAG_BORLAND_property
s_out
DW_TAG_BORLAND_property
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_string
s_out
DW_TAG_BORLAND_Delphi_string
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_dynamic_array
s_out
DW_TAG_BORLAND_Delphi_dynamic_array
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_set
s_out
DW_TAG_BORLAND_Delphi_set
return
DW_DLV_OK
case
DW_TAG_BORLAND_Delphi_variant
s_out
DW_TAG_BORLAND_Delphi_variant
return
DW_DLV_OK
case
DW_TAG_hi_user
s_out
DW_TAG_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_children_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_children_no
s_out
DW_children_no
return
DW_DLV_OK
case
DW_children_yes
s_out
DW_children_yes
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_FORM_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_FORM_addr
s_out
DW_FORM_addr
return
DW_DLV_OK
case
DW_FORM_block2
s_out
DW_FORM_block2
return
DW_DLV_OK
case
DW_FORM_block4
s_out
DW_FORM_block4
return
DW_DLV_OK
case
DW_FORM_data2
s_out
DW_FORM_data2
return
DW_DLV_OK
case
DW_FORM_data4
s_out
DW_FORM_data4
return
DW_DLV_OK
case
DW_FORM_data8
s_out
DW_FORM_data8
return
DW_DLV_OK
case
DW_FORM_string
s_out
DW_FORM_string
return
DW_DLV_OK
case
DW_FORM_block
s_out
DW_FORM_block
return
DW_DLV_OK
case
DW_FORM_block1
s_out
DW_FORM_block1
return
DW_DLV_OK
case
DW_FORM_data1
s_out
DW_FORM_data1
return
DW_DLV_OK
case
DW_FORM_flag
s_out
DW_FORM_flag
return
DW_DLV_OK
case
DW_FORM_sdata
s_out
DW_FORM_sdata
return
DW_DLV_OK
case
DW_FORM_strp
s_out
DW_FORM_strp
return
DW_DLV_OK
case
DW_FORM_udata
s_out
DW_FORM_udata
return
DW_DLV_OK
case
DW_FORM_ref_addr
s_out
DW_FORM_ref_addr
return
DW_DLV_OK
case
DW_FORM_ref1
s_out
DW_FORM_ref1
return
DW_DLV_OK
case
DW_FORM_ref2
s_out
DW_FORM_ref2
return
DW_DLV_OK
case
DW_FORM_ref4
s_out
DW_FORM_ref4
return
DW_DLV_OK
case
DW_FORM_ref8
s_out
DW_FORM_ref8
return
DW_DLV_OK
case
DW_FORM_ref_udata
s_out
DW_FORM_ref_udata
return
DW_DLV_OK
case
DW_FORM_indirect
s_out
DW_FORM_indirect
return
DW_DLV_OK
case
DW_FORM_sec_offset
s_out
DW_FORM_sec_offset
return
DW_DLV_OK
case
DW_FORM_exprloc
s_out
DW_FORM_exprloc
return
DW_DLV_OK
case
DW_FORM_flag_present
s_out
DW_FORM_flag_present
return
DW_DLV_OK
case
DW_FORM_strx
s_out
DW_FORM_strx
return
DW_DLV_OK
case
DW_FORM_addrx
s_out
DW_FORM_addrx
return
DW_DLV_OK
case
DW_FORM_ref_sup4
s_out
DW_FORM_ref_sup4
return
DW_DLV_OK
case
DW_FORM_strp_sup
s_out
DW_FORM_strp_sup
return
DW_DLV_OK
case
DW_FORM_data16
s_out
DW_FORM_data16
return
DW_DLV_OK
case
DW_FORM_line_strp
s_out
DW_FORM_line_strp
return
DW_DLV_OK
case
DW_FORM_ref_sig8
s_out
DW_FORM_ref_sig8
return
DW_DLV_OK
case
DW_FORM_implicit_const
s_out
DW_FORM_implicit_const
return
DW_DLV_OK
case
DW_FORM_loclistx
s_out
DW_FORM_loclistx
return
DW_DLV_OK
case
DW_FORM_rnglistx
s_out
DW_FORM_rnglistx
return
DW_DLV_OK
case
DW_FORM_ref_sup8
s_out
DW_FORM_ref_sup8
return
DW_DLV_OK
case
DW_FORM_strx1
s_out
DW_FORM_strx1
return
DW_DLV_OK
case
DW_FORM_strx2
s_out
DW_FORM_strx2
return
DW_DLV_OK
case
DW_FORM_strx3
s_out
DW_FORM_strx3
return
DW_DLV_OK
case
DW_FORM_strx4
s_out
DW_FORM_strx4
return
DW_DLV_OK
case
DW_FORM_addrx1
s_out
DW_FORM_addrx1
return
DW_DLV_OK
case
DW_FORM_addrx2
s_out
DW_FORM_addrx2
return
DW_DLV_OK
case
DW_FORM_addrx3
s_out
DW_FORM_addrx3
return
DW_DLV_OK
case
DW_FORM_addrx4
s_out
DW_FORM_addrx4
return
DW_DLV_OK
case
DW_FORM_GNU_addr_index
s_out
DW_FORM_GNU_addr_index
return
DW_DLV_OK
case
DW_FORM_GNU_str_index
s_out
DW_FORM_GNU_str_index
return
DW_DLV_OK
case
DW_FORM_GNU_ref_alt
s_out
DW_FORM_GNU_ref_alt
return
DW_DLV_OK
case
DW_FORM_GNU_strp_alt
s_out
DW_FORM_GNU_strp_alt
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_AT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_AT_sibling
s_out
DW_AT_sibling
return
DW_DLV_OK
case
DW_AT_location
s_out
DW_AT_location
return
DW_DLV_OK
case
DW_AT_name
s_out
DW_AT_name
return
DW_DLV_OK
case
DW_AT_ordering
s_out
DW_AT_ordering
return
DW_DLV_OK
case
DW_AT_subscr_data
s_out
DW_AT_subscr_data
return
DW_DLV_OK
case
DW_AT_byte_size
s_out
DW_AT_byte_size
return
DW_DLV_OK
case
DW_AT_bit_offset
s_out
DW_AT_bit_offset
return
DW_DLV_OK
case
DW_AT_bit_size
s_out
DW_AT_bit_size
return
DW_DLV_OK
case
DW_AT_element_list
s_out
DW_AT_element_list
return
DW_DLV_OK
case
DW_AT_stmt_list
s_out
DW_AT_stmt_list
return
DW_DLV_OK
case
DW_AT_low_pc
s_out
DW_AT_low_pc
return
DW_DLV_OK
case
DW_AT_high_pc
s_out
DW_AT_high_pc
return
DW_DLV_OK
case
DW_AT_language
s_out
DW_AT_language
return
DW_DLV_OK
case
DW_AT_member
s_out
DW_AT_member
return
DW_DLV_OK
case
DW_AT_discr
s_out
DW_AT_discr
return
DW_DLV_OK
case
DW_AT_discr_value
s_out
DW_AT_discr_value
return
DW_DLV_OK
case
DW_AT_visibility
s_out
DW_AT_visibility
return
DW_DLV_OK
case
DW_AT_import
s_out
DW_AT_import
return
DW_DLV_OK
case
DW_AT_string_length
s_out
DW_AT_string_length
return
DW_DLV_OK
case
DW_AT_common_reference
s_out
DW_AT_common_reference
return
DW_DLV_OK
case
DW_AT_comp_dir
s_out
DW_AT_comp_dir
return
DW_DLV_OK
case
DW_AT_const_value
s_out
DW_AT_const_value
return
DW_DLV_OK
case
DW_AT_containing_type
s_out
DW_AT_containing_type
return
DW_DLV_OK
case
DW_AT_default_value
s_out
DW_AT_default_value
return
DW_DLV_OK
case
DW_AT_inline
s_out
DW_AT_inline
return
DW_DLV_OK
case
DW_AT_is_optional
s_out
DW_AT_is_optional
return
DW_DLV_OK
case
DW_AT_lower_bound
s_out
DW_AT_lower_bound
return
DW_DLV_OK
case
DW_AT_producer
s_out
DW_AT_producer
return
DW_DLV_OK
case
DW_AT_prototyped
s_out
DW_AT_prototyped
return
DW_DLV_OK
case
DW_AT_return_addr
s_out
DW_AT_return_addr
return
DW_DLV_OK
case
DW_AT_start_scope
s_out
DW_AT_start_scope
return
DW_DLV_OK
case
DW_AT_bit_stride
s_out
DW_AT_bit_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_stride_size
case
DW_AT_upper_bound
s_out
DW_AT_upper_bound
return
DW_DLV_OK
case
DW_AT_abstract_origin
s_out
DW_AT_abstract_origin
return
DW_DLV_OK
case
DW_AT_accessibility
s_out
DW_AT_accessibility
return
DW_DLV_OK
case
DW_AT_address_class
s_out
DW_AT_address_class
return
DW_DLV_OK
case
DW_AT_artificial
s_out
DW_AT_artificial
return
DW_DLV_OK
case
DW_AT_base_types
s_out
DW_AT_base_types
return
DW_DLV_OK
case
DW_AT_calling_convention
s_out
DW_AT_calling_convention
return
DW_DLV_OK
case
DW_AT_count
s_out
DW_AT_count
return
DW_DLV_OK
case
DW_AT_data_member_location
s_out
DW_AT_data_member_location
return
DW_DLV_OK
case
DW_AT_decl_column
s_out
DW_AT_decl_column
return
DW_DLV_OK
case
DW_AT_decl_file
s_out
DW_AT_decl_file
return
DW_DLV_OK
case
DW_AT_decl_line
s_out
DW_AT_decl_line
return
DW_DLV_OK
case
DW_AT_declaration
s_out
DW_AT_declaration
return
DW_DLV_OK
case
DW_AT_discr_list
s_out
DW_AT_discr_list
return
DW_DLV_OK
case
DW_AT_encoding
s_out
DW_AT_encoding
return
DW_DLV_OK
case
DW_AT_external
s_out
DW_AT_external
return
DW_DLV_OK
case
DW_AT_frame_base
s_out
DW_AT_frame_base
return
DW_DLV_OK
case
DW_AT_friend
s_out
DW_AT_friend
return
DW_DLV_OK
case
DW_AT_identifier_case
s_out
DW_AT_identifier_case
return
DW_DLV_OK
case
DW_AT_macro_info
s_out
DW_AT_macro_info
return
DW_DLV_OK
case
DW_AT_namelist_item
s_out
DW_AT_namelist_item
return
DW_DLV_OK
case
DW_AT_priority
s_out
DW_AT_priority
return
DW_DLV_OK
case
DW_AT_segment
s_out
DW_AT_segment
return
DW_DLV_OK
case
DW_AT_specification
s_out
DW_AT_specification
return
DW_DLV_OK
case
DW_AT_static_link
s_out
DW_AT_static_link
return
DW_DLV_OK
case
DW_AT_type
s_out
DW_AT_type
return
DW_DLV_OK
case
DW_AT_use_location
s_out
DW_AT_use_location
return
DW_DLV_OK
case
DW_AT_variable_parameter
s_out
DW_AT_variable_parameter
return
DW_DLV_OK
case
DW_AT_virtuality
s_out
DW_AT_virtuality
return
DW_DLV_OK
case
DW_AT_vtable_elem_location
s_out
DW_AT_vtable_elem_location
return
DW_DLV_OK
case
DW_AT_allocated
s_out
DW_AT_allocated
return
DW_DLV_OK
case
DW_AT_associated
s_out
DW_AT_associated
return
DW_DLV_OK
case
DW_AT_data_location
s_out
DW_AT_data_location
return
DW_DLV_OK
case
DW_AT_byte_stride
s_out
DW_AT_byte_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_stride
case
DW_AT_entry_pc
s_out
DW_AT_entry_pc
return
DW_DLV_OK
case
DW_AT_use_UTF8
s_out
DW_AT_use_UTF8
return
DW_DLV_OK
case
DW_AT_extension
s_out
DW_AT_extension
return
DW_DLV_OK
case
DW_AT_ranges
s_out
DW_AT_ranges
return
DW_DLV_OK
case
DW_AT_trampoline
s_out
DW_AT_trampoline
return
DW_DLV_OK
case
DW_AT_call_column
s_out
DW_AT_call_column
return
DW_DLV_OK
case
DW_AT_call_file
s_out
DW_AT_call_file
return
DW_DLV_OK
case
DW_AT_call_line
s_out
DW_AT_call_line
return
DW_DLV_OK
case
DW_AT_description
s_out
DW_AT_description
return
DW_DLV_OK
case
DW_AT_binary_scale
s_out
DW_AT_binary_scale
return
DW_DLV_OK
case
DW_AT_decimal_scale
s_out
DW_AT_decimal_scale
return
DW_DLV_OK
case
DW_AT_small
s_out
DW_AT_small
return
DW_DLV_OK
case
DW_AT_decimal_sign
s_out
DW_AT_decimal_sign
return
DW_DLV_OK
case
DW_AT_digit_count
s_out
DW_AT_digit_count
return
DW_DLV_OK
case
DW_AT_picture_string
s_out
DW_AT_picture_string
return
DW_DLV_OK
case
DW_AT_mutable
s_out
DW_AT_mutable
return
DW_DLV_OK
case
DW_AT_threads_scaled
s_out
DW_AT_threads_scaled
return
DW_DLV_OK
case
DW_AT_explicit
s_out
DW_AT_explicit
return
DW_DLV_OK
case
DW_AT_object_pointer
s_out
DW_AT_object_pointer
return
DW_DLV_OK
case
DW_AT_endianity
s_out
DW_AT_endianity
return
DW_DLV_OK
case
DW_AT_elemental
s_out
DW_AT_elemental
return
DW_DLV_OK
case
DW_AT_pure
s_out
DW_AT_pure
return
DW_DLV_OK
case
DW_AT_recursive
s_out
DW_AT_recursive
return
DW_DLV_OK
case
DW_AT_signature
s_out
DW_AT_signature
return
DW_DLV_OK
case
DW_AT_main_subprogram
s_out
DW_AT_main_subprogram
return
DW_DLV_OK
case
DW_AT_data_bit_offset
s_out
DW_AT_data_bit_offset
return
DW_DLV_OK
case
DW_AT_const_expr
s_out
DW_AT_const_expr
return
DW_DLV_OK
case
DW_AT_enum_class
s_out
DW_AT_enum_class
return
DW_DLV_OK
case
DW_AT_linkage_name
s_out
DW_AT_linkage_name
return
DW_DLV_OK
case
DW_AT_string_length_bit_size
s_out
DW_AT_string_length_bit_size
return
DW_DLV_OK
case
DW_AT_string_length_byte_size
s_out
DW_AT_string_length_byte_size
return
DW_DLV_OK
case
DW_AT_rank
s_out
DW_AT_rank
return
DW_DLV_OK
case
DW_AT_str_offsets_base
s_out
DW_AT_str_offsets_base
return
DW_DLV_OK
case
DW_AT_addr_base
s_out
DW_AT_addr_base
return
DW_DLV_OK
case
DW_AT_rnglists_base
s_out
DW_AT_rnglists_base
return
DW_DLV_OK
case
DW_AT_dwo_id
s_out
DW_AT_dwo_id
return
DW_DLV_OK
case
DW_AT_dwo_name
s_out
DW_AT_dwo_name
return
DW_DLV_OK
case
DW_AT_reference
s_out
DW_AT_reference
return
DW_DLV_OK
case
DW_AT_rvalue_reference
s_out
DW_AT_rvalue_reference
return
DW_DLV_OK
case
DW_AT_macros
s_out
DW_AT_macros
return
DW_DLV_OK
case
DW_AT_call_all_calls
s_out
DW_AT_call_all_calls
return
DW_DLV_OK
case
DW_AT_call_all_source_calls
s_out
DW_AT_call_all_source_calls
return
DW_DLV_OK
case
DW_AT_call_all_tail_calls
s_out
DW_AT_call_all_tail_calls
return
DW_DLV_OK
case
DW_AT_call_return_pc
s_out
DW_AT_call_return_pc
return
DW_DLV_OK
case
DW_AT_call_value
s_out
DW_AT_call_value
return
DW_DLV_OK
case
DW_AT_call_origin
s_out
DW_AT_call_origin
return
DW_DLV_OK
case
DW_AT_call_parameter
s_out
DW_AT_call_parameter
return
DW_DLV_OK
case
DW_AT_call_pc
s_out
DW_AT_call_pc
return
DW_DLV_OK
case
DW_AT_call_tail_call
s_out
DW_AT_call_tail_call
return
DW_DLV_OK
case
DW_AT_call_target
s_out
DW_AT_call_target
return
DW_DLV_OK
case
DW_AT_call_target_clobbered
s_out
DW_AT_call_target_clobbered
return
DW_DLV_OK
case
DW_AT_call_data_location
s_out
DW_AT_call_data_location
return
DW_DLV_OK
case
DW_AT_call_data_value
s_out
DW_AT_call_data_value
return
DW_DLV_OK
case
DW_AT_noreturn
s_out
DW_AT_noreturn
return
DW_DLV_OK
case
DW_AT_alignment
s_out
DW_AT_alignment
return
DW_DLV_OK
case
DW_AT_export_symbols
s_out
DW_AT_export_symbols
return
DW_DLV_OK
case
DW_AT_deleted
s_out
DW_AT_deleted
return
DW_DLV_OK
case
DW_AT_defaulted
s_out
DW_AT_defaulted
return
DW_DLV_OK
case
DW_AT_loclists_base
s_out
DW_AT_loclists_base
return
DW_DLV_OK
case
DW_AT_ghs_namespace_alias
s_out
DW_AT_ghs_namespace_alias
return
DW_DLV_OK
case
DW_AT_ghs_using_namespace
s_out
DW_AT_ghs_using_namespace
return
DW_DLV_OK
case
DW_AT_ghs_using_declaration
s_out
DW_AT_ghs_using_declaration
return
DW_DLV_OK
case
DW_AT_HP_block_index
s_out
DW_AT_HP_block_index
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_lo_user
case
DW_AT_MIPS_fde
s_out
DW_AT_MIPS_fde
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_unmodifiable
Skipping
alternate
spelling
of
value
DW_AT_CPQ_discontig_ranges
case
DW_AT_MIPS_loop_begin
s_out
DW_AT_MIPS_loop_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_semantic_events
case
DW_AT_MIPS_tail_loop_begin
s_out
DW_AT_MIPS_tail_loop_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_split_lifetimes_var
case
DW_AT_MIPS_epilog_begin
s_out
DW_AT_MIPS_epilog_begin
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_CPQ_split_lifetimes_rtn
case
DW_AT_MIPS_loop_unroll_factor
s_out
DW_AT_MIPS_loop_unroll_factor
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_prologue
Skipping
alternate
spelling
of
value
DW_AT_CPQ_prologue_length
case
DW_AT_MIPS_software_pipeline_depth
s_out
DW_AT_MIPS_software_pipeline_depth
return
DW_DLV_OK
case
DW_AT_MIPS_linkage_name
s_out
DW_AT_MIPS_linkage_name
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_ghs_mangled
case
DW_AT_MIPS_stride
s_out
DW_AT_MIPS_stride
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_epilogue
case
DW_AT_MIPS_abstract_name
s_out
DW_AT_MIPS_abstract_name
return
DW_DLV_OK
case
DW_AT_MIPS_clone_origin
s_out
DW_AT_MIPS_clone_origin
return
DW_DLV_OK
case
DW_AT_MIPS_has_inlines
s_out
DW_AT_MIPS_has_inlines
return
DW_DLV_OK
case
DW_AT_MIPS_stride_byte
s_out
DW_AT_MIPS_stride_byte
return
DW_DLV_OK
case
DW_AT_MIPS_stride_elem
s_out
DW_AT_MIPS_stride_elem
return
DW_DLV_OK
case
DW_AT_MIPS_ptr_dopetype
s_out
DW_AT_MIPS_ptr_dopetype
return
DW_DLV_OK
case
DW_AT_MIPS_allocatable_dopetype
s_out
DW_AT_MIPS_allocatable_dopetype
return
DW_DLV_OK
case
DW_AT_MIPS_assumed_shape_dopetype
s_out
DW_AT_MIPS_assumed_shape_dopetype
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_actuals_stmt_list
case
DW_AT_MIPS_assumed_size
s_out
DW_AT_MIPS_assumed_size
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_HP_proc_per_section
case
DW_AT_HP_raw_data_ptr
s_out
DW_AT_HP_raw_data_ptr
return
DW_DLV_OK
case
DW_AT_HP_pass_by_reference
s_out
DW_AT_HP_pass_by_reference
return
DW_DLV_OK
case
DW_AT_HP_opt_level
s_out
DW_AT_HP_opt_level
return
DW_DLV_OK
case
DW_AT_HP_prof_version_id
s_out
DW_AT_HP_prof_version_id
return
DW_DLV_OK
case
DW_AT_HP_opt_flags
s_out
DW_AT_HP_opt_flags
return
DW_DLV_OK
case
DW_AT_HP_cold_region_low_pc
s_out
DW_AT_HP_cold_region_low_pc
return
DW_DLV_OK
case
DW_AT_HP_cold_region_high_pc
s_out
DW_AT_HP_cold_region_high_pc
return
DW_DLV_OK
case
DW_AT_HP_all_variables_modifiable
s_out
DW_AT_HP_all_variables_modifiable
return
DW_DLV_OK
case
DW_AT_HP_linkage_name
s_out
DW_AT_HP_linkage_name
return
DW_DLV_OK
case
DW_AT_HP_prof_flags
s_out
DW_AT_HP_prof_flags
return
DW_DLV_OK
case
DW_AT_HP_unit_name
s_out
DW_AT_HP_unit_name
return
DW_DLV_OK
case
DW_AT_HP_unit_size
s_out
DW_AT_HP_unit_size
return
DW_DLV_OK
case
DW_AT_HP_widened_byte_size
s_out
DW_AT_HP_widened_byte_size
return
DW_DLV_OK
case
DW_AT_HP_definition_points
s_out
DW_AT_HP_definition_points
return
DW_DLV_OK
case
DW_AT_HP_default_location
s_out
DW_AT_HP_default_location
return
DW_DLV_OK
case
DW_AT_INTEL_other_endian
s_out
DW_AT_INTEL_other_endian
return
DW_DLV_OK
case
DW_AT_HP_is_result_param
s_out
DW_AT_HP_is_result_param
return
DW_DLV_OK
case
DW_AT_ghs_rsm
s_out
DW_AT_ghs_rsm
return
DW_DLV_OK
case
DW_AT_ghs_frsm
s_out
DW_AT_ghs_frsm
return
DW_DLV_OK
case
DW_AT_ghs_frames
s_out
DW_AT_ghs_frames
return
DW_DLV_OK
case
DW_AT_ghs_rso
s_out
DW_AT_ghs_rso
return
DW_DLV_OK
case
DW_AT_ghs_subcpu
s_out
DW_AT_ghs_subcpu
return
DW_DLV_OK
case
DW_AT_ghs_lbrace_line
s_out
DW_AT_ghs_lbrace_line
return
DW_DLV_OK
case
DW_AT_sf_names
s_out
DW_AT_sf_names
return
DW_DLV_OK
case
DW_AT_src_info
s_out
DW_AT_src_info
return
DW_DLV_OK
case
DW_AT_mac_info
s_out
DW_AT_mac_info
return
DW_DLV_OK
case
DW_AT_src_coords
s_out
DW_AT_src_coords
return
DW_DLV_OK
case
DW_AT_body_begin
s_out
DW_AT_body_begin
return
DW_DLV_OK
case
DW_AT_body_end
s_out
DW_AT_body_end
return
DW_DLV_OK
case
DW_AT_GNU_vector
s_out
DW_AT_GNU_vector
return
DW_DLV_OK
case
DW_AT_GNU_guarded_by
s_out
DW_AT_GNU_guarded_by
return
DW_DLV_OK
case
DW_AT_GNU_pt_guarded_by
s_out
DW_AT_GNU_pt_guarded_by
return
DW_DLV_OK
case
DW_AT_GNU_guarded
s_out
DW_AT_GNU_guarded
return
DW_DLV_OK
case
DW_AT_GNU_pt_guarded
s_out
DW_AT_GNU_pt_guarded
return
DW_DLV_OK
case
DW_AT_GNU_locks_excluded
s_out
DW_AT_GNU_locks_excluded
return
DW_DLV_OK
case
DW_AT_GNU_exclusive_locks_required
s_out
DW_AT_GNU_exclusive_locks_required
return
DW_DLV_OK
case
DW_AT_GNU_shared_locks_required
s_out
DW_AT_GNU_shared_locks_required
return
DW_DLV_OK
case
DW_AT_GNU_odr_signature
s_out
DW_AT_GNU_odr_signature
return
DW_DLV_OK
case
DW_AT_GNU_template_name
s_out
DW_AT_GNU_template_name
return
DW_DLV_OK
case
DW_AT_GNU_call_site_value
s_out
DW_AT_GNU_call_site_value
return
DW_DLV_OK
case
DW_AT_GNU_call_site_data_value
s_out
DW_AT_GNU_call_site_data_value
return
DW_DLV_OK
case
DW_AT_GNU_call_site_target
s_out
DW_AT_GNU_call_site_target
return
DW_DLV_OK
case
DW_AT_GNU_call_site_target_clobbered
s_out
DW_AT_GNU_call_site_target_clobbered
return
DW_DLV_OK
case
DW_AT_GNU_tail_call
s_out
DW_AT_GNU_tail_call
return
DW_DLV_OK
case
DW_AT_GNU_all_tail_call_sites
s_out
DW_AT_GNU_all_tail_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_all_call_sites
s_out
DW_AT_GNU_all_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_all_source_call_sites
s_out
DW_AT_GNU_all_source_call_sites
return
DW_DLV_OK
case
DW_AT_GNU_macros
s_out
DW_AT_GNU_macros
return
DW_DLV_OK
case
DW_AT_GNU_deleted
s_out
DW_AT_GNU_deleted
return
DW_DLV_OK
case
DW_AT_GNU_dwo_name
s_out
DW_AT_GNU_dwo_name
return
DW_DLV_OK
case
DW_AT_GNU_dwo_id
s_out
DW_AT_GNU_dwo_id
return
DW_DLV_OK
case
DW_AT_GNU_ranges_base
s_out
DW_AT_GNU_ranges_base
return
DW_DLV_OK
case
DW_AT_GNU_addr_base
s_out
DW_AT_GNU_addr_base
return
DW_DLV_OK
case
DW_AT_GNU_pubnames
s_out
DW_AT_GNU_pubnames
return
DW_DLV_OK
case
DW_AT_GNU_pubtypes
s_out
DW_AT_GNU_pubtypes
return
DW_DLV_OK
case
DW_AT_GNU_discriminator
s_out
DW_AT_GNU_discriminator
return
DW_DLV_OK
case
DW_AT_GNU_locviews
s_out
DW_AT_GNU_locviews
return
DW_DLV_OK
case
DW_AT_GNU_entry_view
s_out
DW_AT_GNU_entry_view
return
DW_DLV_OK
case
DW_AT_SUN_template
s_out
DW_AT_SUN_template
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_VMS_rtnbeg_pd_address
case
DW_AT_SUN_alignment
s_out
DW_AT_SUN_alignment
return
DW_DLV_OK
case
DW_AT_SUN_vtable
s_out
DW_AT_SUN_vtable
return
DW_DLV_OK
case
DW_AT_SUN_count_guarantee
s_out
DW_AT_SUN_count_guarantee
return
DW_DLV_OK
case
DW_AT_SUN_command_line
s_out
DW_AT_SUN_command_line
return
DW_DLV_OK
case
DW_AT_SUN_vbase
s_out
DW_AT_SUN_vbase
return
DW_DLV_OK
case
DW_AT_SUN_compile_options
s_out
DW_AT_SUN_compile_options
return
DW_DLV_OK
case
DW_AT_SUN_language
s_out
DW_AT_SUN_language
return
DW_DLV_OK
case
DW_AT_SUN_browser_file
s_out
DW_AT_SUN_browser_file
return
DW_DLV_OK
case
DW_AT_SUN_vtable_abi
s_out
DW_AT_SUN_vtable_abi
return
DW_DLV_OK
case
DW_AT_SUN_func_offsets
s_out
DW_AT_SUN_func_offsets
return
DW_DLV_OK
case
DW_AT_SUN_cf_kind
s_out
DW_AT_SUN_cf_kind
return
DW_DLV_OK
case
DW_AT_SUN_vtable_index
s_out
DW_AT_SUN_vtable_index
return
DW_DLV_OK
case
DW_AT_SUN_omp_tpriv_addr
s_out
DW_AT_SUN_omp_tpriv_addr
return
DW_DLV_OK
case
DW_AT_SUN_omp_child_func
s_out
DW_AT_SUN_omp_child_func
return
DW_DLV_OK
case
DW_AT_SUN_func_offset
s_out
DW_AT_SUN_func_offset
return
DW_DLV_OK
case
DW_AT_SUN_memop_type_ref
s_out
DW_AT_SUN_memop_type_ref
return
DW_DLV_OK
case
DW_AT_SUN_profile_id
s_out
DW_AT_SUN_profile_id
return
DW_DLV_OK
case
DW_AT_SUN_memop_signature
s_out
DW_AT_SUN_memop_signature
return
DW_DLV_OK
case
DW_AT_SUN_obj_dir
s_out
DW_AT_SUN_obj_dir
return
DW_DLV_OK
case
DW_AT_SUN_obj_file
s_out
DW_AT_SUN_obj_file
return
DW_DLV_OK
case
DW_AT_SUN_original_name
s_out
DW_AT_SUN_original_name
return
DW_DLV_OK
case
DW_AT_SUN_hwcprof_signature
s_out
DW_AT_SUN_hwcprof_signature
return
DW_DLV_OK
case
DW_AT_SUN_amd64_parmdump
s_out
DW_AT_SUN_amd64_parmdump
return
DW_DLV_OK
case
DW_AT_SUN_part_link_name
s_out
DW_AT_SUN_part_link_name
return
DW_DLV_OK
case
DW_AT_SUN_link_name
s_out
DW_AT_SUN_link_name
return
DW_DLV_OK
case
DW_AT_SUN_pass_with_const
s_out
DW_AT_SUN_pass_with_const
return
DW_DLV_OK
case
DW_AT_SUN_return_with_const
s_out
DW_AT_SUN_return_with_const
return
DW_DLV_OK
case
DW_AT_SUN_import_by_name
s_out
DW_AT_SUN_import_by_name
return
DW_DLV_OK
case
DW_AT_SUN_f90_pointer
s_out
DW_AT_SUN_f90_pointer
return
DW_DLV_OK
case
DW_AT_SUN_pass_by_ref
s_out
DW_AT_SUN_pass_by_ref
return
DW_DLV_OK
case
DW_AT_SUN_f90_allocatable
s_out
DW_AT_SUN_f90_allocatable
return
DW_DLV_OK
case
DW_AT_SUN_f90_assumed_shape_array
s_out
DW_AT_SUN_f90_assumed_shape_array
return
DW_DLV_OK
case
DW_AT_SUN_c_vla
s_out
DW_AT_SUN_c_vla
return
DW_DLV_OK
case
DW_AT_SUN_return_value_ptr
s_out
DW_AT_SUN_return_value_ptr
return
DW_DLV_OK
case
DW_AT_SUN_dtor_start
s_out
DW_AT_SUN_dtor_start
return
DW_DLV_OK
case
DW_AT_SUN_dtor_length
s_out
DW_AT_SUN_dtor_length
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_initial
s_out
DW_AT_SUN_dtor_state_initial
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_final
s_out
DW_AT_SUN_dtor_state_final
return
DW_DLV_OK
case
DW_AT_SUN_dtor_state_deltas
s_out
DW_AT_SUN_dtor_state_deltas
return
DW_DLV_OK
case
DW_AT_SUN_import_by_lname
s_out
DW_AT_SUN_import_by_lname
return
DW_DLV_OK
case
DW_AT_SUN_f90_use_only
s_out
DW_AT_SUN_f90_use_only
return
DW_DLV_OK
case
DW_AT_SUN_namelist_spec
s_out
DW_AT_SUN_namelist_spec
return
DW_DLV_OK
case
DW_AT_SUN_is_omp_child_func
s_out
DW_AT_SUN_is_omp_child_func
return
DW_DLV_OK
case
DW_AT_SUN_fortran_main_alias
s_out
DW_AT_SUN_fortran_main_alias
return
DW_DLV_OK
case
DW_AT_SUN_fortran_based
s_out
DW_AT_SUN_fortran_based
return
DW_DLV_OK
case
DW_AT_ALTIUM_loclist
s_out
DW_AT_ALTIUM_loclist
return
DW_DLV_OK
case
DW_AT_use_GNAT_descriptive_type
s_out
DW_AT_use_GNAT_descriptive_type
return
DW_DLV_OK
case
DW_AT_GNAT_descriptive_type
s_out
DW_AT_GNAT_descriptive_type
return
DW_DLV_OK
case
DW_AT_GNU_numerator
s_out
DW_AT_GNU_numerator
return
DW_DLV_OK
case
DW_AT_GNU_denominator
s_out
DW_AT_GNU_denominator
return
DW_DLV_OK
case
DW_AT_GNU_bias
s_out
DW_AT_GNU_bias
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_GNU_bias
case
DW_AT_go_kind
s_out
DW_AT_go_kind
return
DW_DLV_OK
case
DW_AT_go_key
s_out
DW_AT_go_key
return
DW_DLV_OK
case
DW_AT_go_elem
s_out
DW_AT_go_elem
return
DW_DLV_OK
case
DW_AT_go_embedded_field
s_out
DW_AT_go_embedded_field
return
DW_DLV_OK
case
DW_AT_go_runtime_type
s_out
DW_AT_go_runtime_type
return
DW_DLV_OK
case
DW_AT_upc_threads_scaled
s_out
DW_AT_upc_threads_scaled
return
DW_DLV_OK
case
DW_AT_IBM_wsa_addr
s_out
DW_AT_IBM_wsa_addr
return
DW_DLV_OK
case
DW_AT_IBM_home_location
s_out
DW_AT_IBM_home_location
return
DW_DLV_OK
case
DW_AT_IBM_alt_srcview
s_out
DW_AT_IBM_alt_srcview
return
DW_DLV_OK
case
DW_AT_PGI_lbase
s_out
DW_AT_PGI_lbase
return
DW_DLV_OK
case
DW_AT_PGI_soffset
s_out
DW_AT_PGI_soffset
return
DW_DLV_OK
case
DW_AT_PGI_lstride
s_out
DW_AT_PGI_lstride
return
DW_DLV_OK
case
DW_AT_BORLAND_property_read
s_out
DW_AT_BORLAND_property_read
return
DW_DLV_OK
case
DW_AT_BORLAND_property_write
s_out
DW_AT_BORLAND_property_write
return
DW_DLV_OK
case
DW_AT_BORLAND_property_implements
s_out
DW_AT_BORLAND_property_implements
return
DW_DLV_OK
case
DW_AT_BORLAND_property_index
s_out
DW_AT_BORLAND_property_index
return
DW_DLV_OK
case
DW_AT_BORLAND_property_default
s_out
DW_AT_BORLAND_property_default
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_unit
s_out
DW_AT_BORLAND_Delphi_unit
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_class
s_out
DW_AT_BORLAND_Delphi_class
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_record
s_out
DW_AT_BORLAND_Delphi_record
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_metaclass
s_out
DW_AT_BORLAND_Delphi_metaclass
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_constructor
s_out
DW_AT_BORLAND_Delphi_constructor
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_destructor
s_out
DW_AT_BORLAND_Delphi_destructor
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_anonymous_method
s_out
DW_AT_BORLAND_Delphi_anonymous_method
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_interface
s_out
DW_AT_BORLAND_Delphi_interface
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_ABI
s_out
DW_AT_BORLAND_Delphi_ABI
return
DW_DLV_OK
case
DW_AT_BORLAND_Delphi_frameptr
s_out
DW_AT_BORLAND_Delphi_frameptr
return
DW_DLV_OK
case
DW_AT_BORLAND_closure
s_out
DW_AT_BORLAND_closure
return
DW_DLV_OK
case
DW_AT_LLVM_include_path
s_out
DW_AT_LLVM_include_path
return
DW_DLV_OK
case
DW_AT_LLVM_config_macros
s_out
DW_AT_LLVM_config_macros
return
DW_DLV_OK
case
DW_AT_LLVM_sysroot
s_out
DW_AT_LLVM_sysroot
return
DW_DLV_OK
case
DW_AT_LLVM_tag_offset
s_out
DW_AT_LLVM_tag_offset
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_AT_LLVM_apinotes
case
DW_AT_APPLE_optimized
s_out
DW_AT_APPLE_optimized
return
DW_DLV_OK
case
DW_AT_APPLE_flags
s_out
DW_AT_APPLE_flags
return
DW_DLV_OK
case
DW_AT_APPLE_isa
s_out
DW_AT_APPLE_isa
return
DW_DLV_OK
case
DW_AT_APPLE_block
s_out
DW_AT_APPLE_block
return
DW_DLV_OK
case
DW_AT_APPLE_major_runtime_vers
s_out
DW_AT_APPLE_major_runtime_vers
return
DW_DLV_OK
case
DW_AT_APPLE_runtime_class
s_out
DW_AT_APPLE_runtime_class
return
DW_DLV_OK
case
DW_AT_APPLE_omit_frame_ptr
s_out
DW_AT_APPLE_omit_frame_ptr
return
DW_DLV_OK
case
DW_AT_APPLE_property_name
s_out
DW_AT_APPLE_property_name
return
DW_DLV_OK
case
DW_AT_APPLE_property_getter
s_out
DW_AT_APPLE_property_getter
return
DW_DLV_OK
case
DW_AT_APPLE_property_setter
s_out
DW_AT_APPLE_property_setter
return
DW_DLV_OK
case
DW_AT_APPLE_property_attribute
s_out
DW_AT_APPLE_property_attribute
return
DW_DLV_OK
case
DW_AT_APPLE_objc_complete_type
s_out
DW_AT_APPLE_objc_complete_type
return
DW_DLV_OK
case
DW_AT_APPLE_property
s_out
DW_AT_APPLE_property
return
DW_DLV_OK
case
DW_AT_APPLE_objc_direct
s_out
DW_AT_APPLE_objc_direct
return
DW_DLV_OK
case
DW_AT_APPLE_sdk
s_out
DW_AT_APPLE_sdk
return
DW_DLV_OK
case
DW_AT_hi_user
s_out
DW_AT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_OP_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_OP_addr
s_out
DW_OP_addr
return
DW_DLV_OK
case
DW_OP_deref
s_out
DW_OP_deref
return
DW_DLV_OK
case
DW_OP_const1u
s_out
DW_OP_const1u
return
DW_DLV_OK
case
DW_OP_const1s
s_out
DW_OP_const1s
return
DW_DLV_OK
case
DW_OP_const2u
s_out
DW_OP_const2u
return
DW_DLV_OK
case
DW_OP_const2s
s_out
DW_OP_const2s
return
DW_DLV_OK
case
DW_OP_const4u
s_out
DW_OP_const4u
return
DW_DLV_OK
case
DW_OP_const4s
s_out
DW_OP_const4s
return
DW_DLV_OK
case
DW_OP_const8u
s_out
DW_OP_const8u
return
DW_DLV_OK
case
DW_OP_const8s
s_out
DW_OP_const8s
return
DW_DLV_OK
case
DW_OP_constu
s_out
DW_OP_constu
return
DW_DLV_OK
case
DW_OP_consts
s_out
DW_OP_consts
return
DW_DLV_OK
case
DW_OP_dup
s_out
DW_OP_dup
return
DW_DLV_OK
case
DW_OP_drop
s_out
DW_OP_drop
return
DW_DLV_OK
case
DW_OP_over
s_out
DW_OP_over
return
DW_DLV_OK
case
DW_OP_pick
s_out
DW_OP_pick
return
DW_DLV_OK
case
DW_OP_swap
s_out
DW_OP_swap
return
DW_DLV_OK
case
DW_OP_rot
s_out
DW_OP_rot
return
DW_DLV_OK
case
DW_OP_xderef
s_out
DW_OP_xderef
return
DW_DLV_OK
case
DW_OP_abs
s_out
DW_OP_abs
return
DW_DLV_OK
case
DW_OP_and
s_out
DW_OP_and
return
DW_DLV_OK
case
DW_OP_div
s_out
DW_OP_div
return
DW_DLV_OK
case
DW_OP_minus
s_out
DW_OP_minus
return
DW_DLV_OK
case
DW_OP_mod
s_out
DW_OP_mod
return
DW_DLV_OK
case
DW_OP_mul
s_out
DW_OP_mul
return
DW_DLV_OK
case
DW_OP_neg
s_out
DW_OP_neg
return
DW_DLV_OK
case
DW_OP_not
s_out
DW_OP_not
return
DW_DLV_OK
case
DW_OP_or
s_out
DW_OP_or
return
DW_DLV_OK
case
DW_OP_plus
s_out
DW_OP_plus
return
DW_DLV_OK
case
DW_OP_plus_uconst
s_out
DW_OP_plus_uconst
return
DW_DLV_OK
case
DW_OP_shl
s_out
DW_OP_shl
return
DW_DLV_OK
case
DW_OP_shr
s_out
DW_OP_shr
return
DW_DLV_OK
case
DW_OP_shra
s_out
DW_OP_shra
return
DW_DLV_OK
case
DW_OP_xor
s_out
DW_OP_xor
return
DW_DLV_OK
case
DW_OP_bra
s_out
DW_OP_bra
return
DW_DLV_OK
case
DW_OP_eq
s_out
DW_OP_eq
return
DW_DLV_OK
case
DW_OP_ge
s_out
DW_OP_ge
return
DW_DLV_OK
case
DW_OP_gt
s_out
DW_OP_gt
return
DW_DLV_OK
case
DW_OP_le
s_out
DW_OP_le
return
DW_DLV_OK
case
DW_OP_lt
s_out
DW_OP_lt
return
DW_DLV_OK
case
DW_OP_ne
s_out
DW_OP_ne
return
DW_DLV_OK
case
DW_OP_skip
s_out
DW_OP_skip
return
DW_DLV_OK
case
DW_OP_lit0
s_out
DW_OP_lit0
return
DW_DLV_OK
case
DW_OP_lit1
s_out
DW_OP_lit1
return
DW_DLV_OK
case
DW_OP_lit2
s_out
DW_OP_lit2
return
DW_DLV_OK
case
DW_OP_lit3
s_out
DW_OP_lit3
return
DW_DLV_OK
case
DW_OP_lit4
s_out
DW_OP_lit4
return
DW_DLV_OK
case
DW_OP_lit5
s_out
DW_OP_lit5
return
DW_DLV_OK
case
DW_OP_lit6
s_out
DW_OP_lit6
return
DW_DLV_OK
case
DW_OP_lit7
s_out
DW_OP_lit7
return
DW_DLV_OK
case
DW_OP_lit8
s_out
DW_OP_lit8
return
DW_DLV_OK
case
DW_OP_lit9
s_out
DW_OP_lit9
return
DW_DLV_OK
case
DW_OP_lit10
s_out
DW_OP_lit10
return
DW_DLV_OK
case
DW_OP_lit11
s_out
DW_OP_lit11
return
DW_DLV_OK
case
DW_OP_lit12
s_out
DW_OP_lit12
return
DW_DLV_OK
case
DW_OP_lit13
s_out
DW_OP_lit13
return
DW_DLV_OK
case
DW_OP_lit14
s_out
DW_OP_lit14
return
DW_DLV_OK
case
DW_OP_lit15
s_out
DW_OP_lit15
return
DW_DLV_OK
case
DW_OP_lit16
s_out
DW_OP_lit16
return
DW_DLV_OK
case
DW_OP_lit17
s_out
DW_OP_lit17
return
DW_DLV_OK
case
DW_OP_lit18
s_out
DW_OP_lit18
return
DW_DLV_OK
case
DW_OP_lit19
s_out
DW_OP_lit19
return
DW_DLV_OK
case
DW_OP_lit20
s_out
DW_OP_lit20
return
DW_DLV_OK
case
DW_OP_lit21
s_out
DW_OP_lit21
return
DW_DLV_OK
case
DW_OP_lit22
s_out
DW_OP_lit22
return
DW_DLV_OK
case
DW_OP_lit23
s_out
DW_OP_lit23
return
DW_DLV_OK
case
DW_OP_lit24
s_out
DW_OP_lit24
return
DW_DLV_OK
case
DW_OP_lit25
s_out
DW_OP_lit25
return
DW_DLV_OK
case
DW_OP_lit26
s_out
DW_OP_lit26
return
DW_DLV_OK
case
DW_OP_lit27
s_out
DW_OP_lit27
return
DW_DLV_OK
case
DW_OP_lit28
s_out
DW_OP_lit28
return
DW_DLV_OK
case
DW_OP_lit29
s_out
DW_OP_lit29
return
DW_DLV_OK
case
DW_OP_lit30
s_out
DW_OP_lit30
return
DW_DLV_OK
case
DW_OP_lit31
s_out
DW_OP_lit31
return
DW_DLV_OK
case
DW_OP_reg0
s_out
DW_OP_reg0
return
DW_DLV_OK
case
DW_OP_reg1
s_out
DW_OP_reg1
return
DW_DLV_OK
case
DW_OP_reg2
s_out
DW_OP_reg2
return
DW_DLV_OK
case
DW_OP_reg3
s_out
DW_OP_reg3
return
DW_DLV_OK
case
DW_OP_reg4
s_out
DW_OP_reg4
return
DW_DLV_OK
case
DW_OP_reg5
s_out
DW_OP_reg5
return
DW_DLV_OK
case
DW_OP_reg6
s_out
DW_OP_reg6
return
DW_DLV_OK
case
DW_OP_reg7
s_out
DW_OP_reg7
return
DW_DLV_OK
case
DW_OP_reg8
s_out
DW_OP_reg8
return
DW_DLV_OK
case
DW_OP_reg9
s_out
DW_OP_reg9
return
DW_DLV_OK
case
DW_OP_reg10
s_out
DW_OP_reg10
return
DW_DLV_OK
case
DW_OP_reg11
s_out
DW_OP_reg11
return
DW_DLV_OK
case
DW_OP_reg12
s_out
DW_OP_reg12
return
DW_DLV_OK
case
DW_OP_reg13
s_out
DW_OP_reg13
return
DW_DLV_OK
case
DW_OP_reg14
s_out
DW_OP_reg14
return
DW_DLV_OK
case
DW_OP_reg15
s_out
DW_OP_reg15
return
DW_DLV_OK
case
DW_OP_reg16
s_out
DW_OP_reg16
return
DW_DLV_OK
case
DW_OP_reg17
s_out
DW_OP_reg17
return
DW_DLV_OK
case
DW_OP_reg18
s_out
DW_OP_reg18
return
DW_DLV_OK
case
DW_OP_reg19
s_out
DW_OP_reg19
return
DW_DLV_OK
case
DW_OP_reg20
s_out
DW_OP_reg20
return
DW_DLV_OK
case
DW_OP_reg21
s_out
DW_OP_reg21
return
DW_DLV_OK
case
DW_OP_reg22
s_out
DW_OP_reg22
return
DW_DLV_OK
case
DW_OP_reg23
s_out
DW_OP_reg23
return
DW_DLV_OK
case
DW_OP_reg24
s_out
DW_OP_reg24
return
DW_DLV_OK
case
DW_OP_reg25
s_out
DW_OP_reg25
return
DW_DLV_OK
case
DW_OP_reg26
s_out
DW_OP_reg26
return
DW_DLV_OK
case
DW_OP_reg27
s_out
DW_OP_reg27
return
DW_DLV_OK
case
DW_OP_reg28
s_out
DW_OP_reg28
return
DW_DLV_OK
case
DW_OP_reg29
s_out
DW_OP_reg29
return
DW_DLV_OK
case
DW_OP_reg30
s_out
DW_OP_reg30
return
DW_DLV_OK
case
DW_OP_reg31
s_out
DW_OP_reg31
return
DW_DLV_OK
case
DW_OP_breg0
s_out
DW_OP_breg0
return
DW_DLV_OK
case
DW_OP_breg1
s_out
DW_OP_breg1
return
DW_DLV_OK
case
DW_OP_breg2
s_out
DW_OP_breg2
return
DW_DLV_OK
case
DW_OP_breg3
s_out
DW_OP_breg3
return
DW_DLV_OK
case
DW_OP_breg4
s_out
DW_OP_breg4
return
DW_DLV_OK
case
DW_OP_breg5
s_out
DW_OP_breg5
return
DW_DLV_OK
case
DW_OP_breg6
s_out
DW_OP_breg6
return
DW_DLV_OK
case
DW_OP_breg7
s_out
DW_OP_breg7
return
DW_DLV_OK
case
DW_OP_breg8
s_out
DW_OP_breg8
return
DW_DLV_OK
case
DW_OP_breg9
s_out
DW_OP_breg9
return
DW_DLV_OK
case
DW_OP_breg10
s_out
DW_OP_breg10
return
DW_DLV_OK
case
DW_OP_breg11
s_out
DW_OP_breg11
return
DW_DLV_OK
case
DW_OP_breg12
s_out
DW_OP_breg12
return
DW_DLV_OK
case
DW_OP_breg13
s_out
DW_OP_breg13
return
DW_DLV_OK
case
DW_OP_breg14
s_out
DW_OP_breg14
return
DW_DLV_OK
case
DW_OP_breg15
s_out
DW_OP_breg15
return
DW_DLV_OK
case
DW_OP_breg16
s_out
DW_OP_breg16
return
DW_DLV_OK
case
DW_OP_breg17
s_out
DW_OP_breg17
return
DW_DLV_OK
case
DW_OP_breg18
s_out
DW_OP_breg18
return
DW_DLV_OK
case
DW_OP_breg19
s_out
DW_OP_breg19
return
DW_DLV_OK
case
DW_OP_breg20
s_out
DW_OP_breg20
return
DW_DLV_OK
case
DW_OP_breg21
s_out
DW_OP_breg21
return
DW_DLV_OK
case
DW_OP_breg22
s_out
DW_OP_breg22
return
DW_DLV_OK
case
DW_OP_breg23
s_out
DW_OP_breg23
return
DW_DLV_OK
case
DW_OP_breg24
s_out
DW_OP_breg24
return
DW_DLV_OK
case
DW_OP_breg25
s_out
DW_OP_breg25
return
DW_DLV_OK
case
DW_OP_breg26
s_out
DW_OP_breg26
return
DW_DLV_OK
case
DW_OP_breg27
s_out
DW_OP_breg27
return
DW_DLV_OK
case
DW_OP_breg28
s_out
DW_OP_breg28
return
DW_DLV_OK
case
DW_OP_breg29
s_out
DW_OP_breg29
return
DW_DLV_OK
case
DW_OP_breg30
s_out
DW_OP_breg30
return
DW_DLV_OK
case
DW_OP_breg31
s_out
DW_OP_breg31
return
DW_DLV_OK
case
DW_OP_regx
s_out
DW_OP_regx
return
DW_DLV_OK
case
DW_OP_fbreg
s_out
DW_OP_fbreg
return
DW_DLV_OK
case
DW_OP_bregx
s_out
DW_OP_bregx
return
DW_DLV_OK
case
DW_OP_piece
s_out
DW_OP_piece
return
DW_DLV_OK
case
DW_OP_deref_size
s_out
DW_OP_deref_size
return
DW_DLV_OK
case
DW_OP_xderef_size
s_out
DW_OP_xderef_size
return
DW_DLV_OK
case
DW_OP_nop
s_out
DW_OP_nop
return
DW_DLV_OK
case
DW_OP_push_object_address
s_out
DW_OP_push_object_address
return
DW_DLV_OK
case
DW_OP_call2
s_out
DW_OP_call2
return
DW_DLV_OK
case
DW_OP_call4
s_out
DW_OP_call4
return
DW_DLV_OK
case
DW_OP_call_ref
s_out
DW_OP_call_ref
return
DW_DLV_OK
case
DW_OP_form_tls_address
s_out
DW_OP_form_tls_address
return
DW_DLV_OK
case
DW_OP_call_frame_cfa
s_out
DW_OP_call_frame_cfa
return
DW_DLV_OK
case
DW_OP_bit_piece
s_out
DW_OP_bit_piece
return
DW_DLV_OK
case
DW_OP_implicit_value
s_out
DW_OP_implicit_value
return
DW_DLV_OK
case
DW_OP_stack_value
s_out
DW_OP_stack_value
return
DW_DLV_OK
case
DW_OP_implicit_pointer
s_out
DW_OP_implicit_pointer
return
DW_DLV_OK
case
DW_OP_addrx
s_out
DW_OP_addrx
return
DW_DLV_OK
case
DW_OP_constx
s_out
DW_OP_constx
return
DW_DLV_OK
case
DW_OP_entry_value
s_out
DW_OP_entry_value
return
DW_DLV_OK
case
DW_OP_const_type
s_out
DW_OP_const_type
return
DW_DLV_OK
case
DW_OP_regval_type
s_out
DW_OP_regval_type
return
DW_DLV_OK
case
DW_OP_deref_type
s_out
DW_OP_deref_type
return
DW_DLV_OK
case
DW_OP_xderef_type
s_out
DW_OP_xderef_type
return
DW_DLV_OK
case
DW_OP_convert
s_out
DW_OP_convert
return
DW_DLV_OK
case
DW_OP_reinterpret
s_out
DW_OP_reinterpret
return
DW_DLV_OK
case
DW_OP_GNU_push_tls_address
s_out
DW_OP_GNU_push_tls_address
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_OP_lo_user
Skipping
alternate
spelling
of
value
DW_OP_HP_unknown
case
DW_OP_HP_is_value
s_out
DW_OP_HP_is_value
return
DW_DLV_OK
case
DW_OP_HP_fltconst4
s_out
DW_OP_HP_fltconst4
return
DW_DLV_OK
case
DW_OP_HP_fltconst8
s_out
DW_OP_HP_fltconst8
return
DW_DLV_OK
case
DW_OP_HP_mod_range
s_out
DW_OP_HP_mod_range
return
DW_DLV_OK
case
DW_OP_HP_unmod_range
s_out
DW_OP_HP_unmod_range
return
DW_DLV_OK
case
DW_OP_HP_tls
s_out
DW_OP_HP_tls
return
DW_DLV_OK
case
DW_OP_INTEL_bit_piece
s_out
DW_OP_INTEL_bit_piece
return
DW_DLV_OK
case
DW_OP_WASM_location
s_out
DW_OP_WASM_location
return
DW_DLV_OK
case
DW_OP_WASM_location_int
s_out
DW_OP_WASM_location_int
return
DW_DLV_OK
case
DW_OP_GNU_uninit
s_out
DW_OP_GNU_uninit
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_OP_APPLE_uninit
case
DW_OP_GNU_encoded_addr
s_out
DW_OP_GNU_encoded_addr
return
DW_DLV_OK
case
DW_OP_GNU_implicit_pointer
s_out
DW_OP_GNU_implicit_pointer
return
DW_DLV_OK
case
DW_OP_GNU_entry_value
s_out
DW_OP_GNU_entry_value
return
DW_DLV_OK
case
DW_OP_GNU_const_type
s_out
DW_OP_GNU_const_type
return
DW_DLV_OK
case
DW_OP_GNU_regval_type
s_out
DW_OP_GNU_regval_type
return
DW_DLV_OK
case
DW_OP_GNU_deref_type
s_out
DW_OP_GNU_deref_type
return
DW_DLV_OK
case
DW_OP_GNU_convert
s_out
DW_OP_GNU_convert
return
DW_DLV_OK
case
DW_OP_PGI_omp_thread_num
s_out
DW_OP_PGI_omp_thread_num
return
DW_DLV_OK
case
DW_OP_GNU_reinterpret
s_out
DW_OP_GNU_reinterpret
return
DW_DLV_OK
case
DW_OP_GNU_parameter_ref
s_out
DW_OP_GNU_parameter_ref
return
DW_DLV_OK
case
DW_OP_GNU_addr_index
s_out
DW_OP_GNU_addr_index
return
DW_DLV_OK
case
DW_OP_GNU_const_index
s_out
DW_OP_GNU_const_index
return
DW_DLV_OK
case
DW_OP_GNU_variable_value
s_out
DW_OP_GNU_variable_value
return
DW_DLV_OK
case
DW_OP_hi_user
s_out
DW_OP_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ATE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ATE_address
s_out
DW_ATE_address
return
DW_DLV_OK
case
DW_ATE_boolean
s_out
DW_ATE_boolean
return
DW_DLV_OK
case
DW_ATE_complex_float
s_out
DW_ATE_complex_float
return
DW_DLV_OK
case
DW_ATE_float
s_out
DW_ATE_float
return
DW_DLV_OK
case
DW_ATE_signed
s_out
DW_ATE_signed
return
DW_DLV_OK
case
DW_ATE_signed_char
s_out
DW_ATE_signed_char
return
DW_DLV_OK
case
DW_ATE_unsigned
s_out
DW_ATE_unsigned
return
DW_DLV_OK
case
DW_ATE_unsigned_char
s_out
DW_ATE_unsigned_char
return
DW_DLV_OK
case
DW_ATE_imaginary_float
s_out
DW_ATE_imaginary_float
return
DW_DLV_OK
case
DW_ATE_packed_decimal
s_out
DW_ATE_packed_decimal
return
DW_DLV_OK
case
DW_ATE_numeric_string
s_out
DW_ATE_numeric_string
return
DW_DLV_OK
case
DW_ATE_edited
s_out
DW_ATE_edited
return
DW_DLV_OK
case
DW_ATE_signed_fixed
s_out
DW_ATE_signed_fixed
return
DW_DLV_OK
case
DW_ATE_unsigned_fixed
s_out
DW_ATE_unsigned_fixed
return
DW_DLV_OK
case
DW_ATE_decimal_float
s_out
DW_ATE_decimal_float
return
DW_DLV_OK
case
DW_ATE_UTF
s_out
DW_ATE_UTF
return
DW_DLV_OK
case
DW_ATE_UCS
s_out
DW_ATE_UCS
return
DW_DLV_OK
case
DW_ATE_ASCII
s_out
DW_ATE_ASCII
return
DW_DLV_OK
case
DW_ATE_ALTIUM_fract
s_out
DW_ATE_ALTIUM_fract
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_ATE_lo_user
Skipping
alternate
spelling
of
value
DW_ATE_HP_float80
case
DW_ATE_ALTIUM_accum
s_out
DW_ATE_ALTIUM_accum
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_ATE_HP_complex_float80
case
DW_ATE_HP_float128
s_out
DW_ATE_HP_float128
return
DW_DLV_OK
case
DW_ATE_HP_complex_float128
s_out
DW_ATE_HP_complex_float128
return
DW_DLV_OK
case
DW_ATE_HP_floathpintel
s_out
DW_ATE_HP_floathpintel
return
DW_DLV_OK
case
DW_ATE_HP_imaginary_float80
s_out
DW_ATE_HP_imaginary_float80
return
DW_DLV_OK
case
DW_ATE_HP_imaginary_float128
s_out
DW_ATE_HP_imaginary_float128
return
DW_DLV_OK
case
DW_ATE_SUN_interval_float
s_out
DW_ATE_SUN_interval_float
return
DW_DLV_OK
case
DW_ATE_SUN_imaginary_float
s_out
DW_ATE_SUN_imaginary_float
return
DW_DLV_OK
case
DW_ATE_hi_user
s_out
DW_ATE_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DEFAULTED_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DEFAULTED_no
s_out
DW_DEFAULTED_no
return
DW_DLV_OK
case
DW_DEFAULTED_in_class
s_out
DW_DEFAULTED_in_class
return
DW_DLV_OK
case
DW_DEFAULTED_out_of_class
s_out
DW_DEFAULTED_out_of_class
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_IDX_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_IDX_compile_unit
s_out
DW_IDX_compile_unit
return
DW_DLV_OK
case
DW_IDX_type_unit
s_out
DW_IDX_type_unit
return
DW_DLV_OK
case
DW_IDX_die_offset
s_out
DW_IDX_die_offset
return
DW_DLV_OK
case
DW_IDX_parent
s_out
DW_IDX_parent
return
DW_DLV_OK
case
DW_IDX_type_hash
s_out
DW_IDX_type_hash
return
DW_DLV_OK
case
DW_IDX_hi_user
s_out
DW_IDX_hi_user
return
DW_DLV_OK
case
DW_IDX_lo_user
s_out
DW_IDX_lo_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LLEX_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LLEX_end_of_list_entry
s_out
DW_LLEX_end_of_list_entry
return
DW_DLV_OK
case
DW_LLEX_base_address_selection_entry
s_out
DW_LLEX_base_address_selection_entry
return
DW_DLV_OK
case
DW_LLEX_start_end_entry
s_out
DW_LLEX_start_end_entry
return
DW_DLV_OK
case
DW_LLEX_start_length_entry
s_out
DW_LLEX_start_length_entry
return
DW_DLV_OK
case
DW_LLEX_offset_pair_entry
s_out
DW_LLEX_offset_pair_entry
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LLE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LLE_end_of_list
s_out
DW_LLE_end_of_list
return
DW_DLV_OK
case
DW_LLE_base_addressx
s_out
DW_LLE_base_addressx
return
DW_DLV_OK
case
DW_LLE_startx_endx
s_out
DW_LLE_startx_endx
return
DW_DLV_OK
case
DW_LLE_startx_length
s_out
DW_LLE_startx_length
return
DW_DLV_OK
case
DW_LLE_offset_pair
s_out
DW_LLE_offset_pair
return
DW_DLV_OK
case
DW_LLE_default_location
s_out
DW_LLE_default_location
return
DW_DLV_OK
case
DW_LLE_base_address
s_out
DW_LLE_base_address
return
DW_DLV_OK
case
DW_LLE_start_end
s_out
DW_LLE_start_end
return
DW_DLV_OK
case
DW_LLE_start_length
s_out
DW_LLE_start_length
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_RLE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_RLE_end_of_list
s_out
DW_RLE_end_of_list
return
DW_DLV_OK
case
DW_RLE_base_addressx
s_out
DW_RLE_base_addressx
return
DW_DLV_OK
case
DW_RLE_startx_endx
s_out
DW_RLE_startx_endx
return
DW_DLV_OK
case
DW_RLE_startx_length
s_out
DW_RLE_startx_length
return
DW_DLV_OK
case
DW_RLE_offset_pair
s_out
DW_RLE_offset_pair
return
DW_DLV_OK
case
DW_RLE_base_address
s_out
DW_RLE_base_address
return
DW_DLV_OK
case
DW_RLE_start_end
s_out
DW_RLE_start_end
return
DW_DLV_OK
case
DW_RLE_start_length
s_out
DW_RLE_start_length
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_GNUIVIS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_GNUIVIS_global
s_out
DW_GNUIVIS_global
return
DW_DLV_OK
case
DW_GNUIVIS_static
s_out
DW_GNUIVIS_static
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_GNUIKIND_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_GNUIKIND_none
s_out
DW_GNUIKIND_none
return
DW_DLV_OK
case
DW_GNUIKIND_type
s_out
DW_GNUIKIND_type
return
DW_DLV_OK
case
DW_GNUIKIND_variable
s_out
DW_GNUIKIND_variable
return
DW_DLV_OK
case
DW_GNUIKIND_function
s_out
DW_GNUIKIND_function
return
DW_DLV_OK
case
DW_GNUIKIND_other
s_out
DW_GNUIKIND_other
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_UT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_UT_compile
s_out
DW_UT_compile
return
DW_DLV_OK
case
DW_UT_type
s_out
DW_UT_type
return
DW_DLV_OK
case
DW_UT_partial
s_out
DW_UT_partial
return
DW_DLV_OK
case
DW_UT_skeleton
s_out
DW_UT_skeleton
return
DW_DLV_OK
case
DW_UT_split_compile
s_out
DW_UT_split_compile
return
DW_DLV_OK
case
DW_UT_split_type
s_out
DW_UT_split_type
return
DW_DLV_OK
case
DW_UT_lo_user
s_out
DW_UT_lo_user
return
DW_DLV_OK
case
DW_UT_hi_user
s_out
DW_UT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_SECT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_SECT_INFO
s_out
DW_SECT_INFO
return
DW_DLV_OK
case
DW_SECT_TYPES
s_out
DW_SECT_TYPES
return
DW_DLV_OK
case
DW_SECT_ABBREV
s_out
DW_SECT_ABBREV
return
DW_DLV_OK
case
DW_SECT_LINE
s_out
DW_SECT_LINE
return
DW_DLV_OK
case
DW_SECT_LOCLISTS
s_out
DW_SECT_LOCLISTS
return
DW_DLV_OK
case
DW_SECT_STR_OFFSETS
s_out
DW_SECT_STR_OFFSETS
return
DW_DLV_OK
case
DW_SECT_MACRO
s_out
DW_SECT_MACRO
return
DW_DLV_OK
case
DW_SECT_RNGLISTS
s_out
DW_SECT_RNGLISTS
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DS_unsigned
s_out
DW_DS_unsigned
return
DW_DLV_OK
case
DW_DS_leading_overpunch
s_out
DW_DS_leading_overpunch
return
DW_DLV_OK
case
DW_DS_trailing_overpunch
s_out
DW_DS_trailing_overpunch
return
DW_DLV_OK
case
DW_DS_leading_separate
s_out
DW_DS_leading_separate
return
DW_DLV_OK
case
DW_DS_trailing_separate
s_out
DW_DS_trailing_separate
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_END_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_END_default
s_out
DW_END_default
return
DW_DLV_OK
case
DW_END_big
s_out
DW_END_big
return
DW_DLV_OK
case
DW_END_little
s_out
DW_END_little
return
DW_DLV_OK
case
DW_END_lo_user
s_out
DW_END_lo_user
return
DW_DLV_OK
case
DW_END_hi_user
s_out
DW_END_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ATCF_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ATCF_lo_user
s_out
DW_ATCF_lo_user
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_bitfield
s_out
DW_ATCF_SUN_mop_bitfield
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_spill
s_out
DW_ATCF_SUN_mop_spill
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_scopy
s_out
DW_ATCF_SUN_mop_scopy
return
DW_DLV_OK
case
DW_ATCF_SUN_func_start
s_out
DW_ATCF_SUN_func_start
return
DW_DLV_OK
case
DW_ATCF_SUN_end_ctors
s_out
DW_ATCF_SUN_end_ctors
return
DW_DLV_OK
case
DW_ATCF_SUN_branch_target
s_out
DW_ATCF_SUN_branch_target
return
DW_DLV_OK
case
DW_ATCF_SUN_mop_stack_probe
s_out
DW_ATCF_SUN_mop_stack_probe
return
DW_DLV_OK
case
DW_ATCF_SUN_func_epilog
s_out
DW_ATCF_SUN_func_epilog
return
DW_DLV_OK
case
DW_ATCF_hi_user
s_out
DW_ATCF_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ACCESS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ACCESS_public
s_out
DW_ACCESS_public
return
DW_DLV_OK
case
DW_ACCESS_protected
s_out
DW_ACCESS_protected
return
DW_DLV_OK
case
DW_ACCESS_private
s_out
DW_ACCESS_private
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_VIS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_VIS_local
s_out
DW_VIS_local
return
DW_DLV_OK
case
DW_VIS_exported
s_out
DW_VIS_exported
return
DW_DLV_OK
case
DW_VIS_qualified
s_out
DW_VIS_qualified
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_VIRTUALITY_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_VIRTUALITY_none
s_out
DW_VIRTUALITY_none
return
DW_DLV_OK
case
DW_VIRTUALITY_virtual
s_out
DW_VIRTUALITY_virtual
return
DW_DLV_OK
case
DW_VIRTUALITY_pure_virtual
s_out
DW_VIRTUALITY_pure_virtual
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LANG_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LANG_C89
s_out
DW_LANG_C89
return
DW_DLV_OK
case
DW_LANG_C
s_out
DW_LANG_C
return
DW_DLV_OK
case
DW_LANG_Ada83
s_out
DW_LANG_Ada83
return
DW_DLV_OK
case
DW_LANG_C_plus_plus
s_out
DW_LANG_C_plus_plus
return
DW_DLV_OK
case
DW_LANG_Cobol74
s_out
DW_LANG_Cobol74
return
DW_DLV_OK
case
DW_LANG_Cobol85
s_out
DW_LANG_Cobol85
return
DW_DLV_OK
case
DW_LANG_Fortran77
s_out
DW_LANG_Fortran77
return
DW_DLV_OK
case
DW_LANG_Fortran90
s_out
DW_LANG_Fortran90
return
DW_DLV_OK
case
DW_LANG_Pascal83
s_out
DW_LANG_Pascal83
return
DW_DLV_OK
case
DW_LANG_Modula2
s_out
DW_LANG_Modula2
return
DW_DLV_OK
case
DW_LANG_Java
s_out
DW_LANG_Java
return
DW_DLV_OK
case
DW_LANG_C99
s_out
DW_LANG_C99
return
DW_DLV_OK
case
DW_LANG_Ada95
s_out
DW_LANG_Ada95
return
DW_DLV_OK
case
DW_LANG_Fortran95
s_out
DW_LANG_Fortran95
return
DW_DLV_OK
case
DW_LANG_PLI
s_out
DW_LANG_PLI
return
DW_DLV_OK
case
DW_LANG_ObjC
s_out
DW_LANG_ObjC
return
DW_DLV_OK
case
DW_LANG_ObjC_plus_plus
s_out
DW_LANG_ObjC_plus_plus
return
DW_DLV_OK
case
DW_LANG_UPC
s_out
DW_LANG_UPC
return
DW_DLV_OK
case
DW_LANG_D
s_out
DW_LANG_D
return
DW_DLV_OK
case
DW_LANG_Python
s_out
DW_LANG_Python
return
DW_DLV_OK
case
DW_LANG_OpenCL
s_out
DW_LANG_OpenCL
return
DW_DLV_OK
case
DW_LANG_Go
s_out
DW_LANG_Go
return
DW_DLV_OK
case
DW_LANG_Modula3
s_out
DW_LANG_Modula3
return
DW_DLV_OK
case
DW_LANG_Haskel
s_out
DW_LANG_Haskel
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_03
s_out
DW_LANG_C_plus_plus_03
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_11
s_out
DW_LANG_C_plus_plus_11
return
DW_DLV_OK
case
DW_LANG_OCaml
s_out
DW_LANG_OCaml
return
DW_DLV_OK
case
DW_LANG_Rust
s_out
DW_LANG_Rust
return
DW_DLV_OK
case
DW_LANG_C11
s_out
DW_LANG_C11
return
DW_DLV_OK
case
DW_LANG_Swift
s_out
DW_LANG_Swift
return
DW_DLV_OK
case
DW_LANG_Julia
s_out
DW_LANG_Julia
return
DW_DLV_OK
case
DW_LANG_Dylan
s_out
DW_LANG_Dylan
return
DW_DLV_OK
case
DW_LANG_C_plus_plus_14
s_out
DW_LANG_C_plus_plus_14
return
DW_DLV_OK
case
DW_LANG_Fortran03
s_out
DW_LANG_Fortran03
return
DW_DLV_OK
case
DW_LANG_Fortran08
s_out
DW_LANG_Fortran08
return
DW_DLV_OK
case
DW_LANG_RenderScript
s_out
DW_LANG_RenderScript
return
DW_DLV_OK
case
DW_LANG_BLISS
s_out
DW_LANG_BLISS
return
DW_DLV_OK
case
DW_LANG_lo_user
s_out
DW_LANG_lo_user
return
DW_DLV_OK
case
DW_LANG_Mips_Assembler
s_out
DW_LANG_Mips_Assembler
return
DW_DLV_OK
case
DW_LANG_Upc
s_out
DW_LANG_Upc
return
DW_DLV_OK
case
DW_LANG_SUN_Assembler
s_out
DW_LANG_SUN_Assembler
return
DW_DLV_OK
case
DW_LANG_ALTIUM_Assembler
s_out
DW_LANG_ALTIUM_Assembler
return
DW_DLV_OK
case
DW_LANG_hi_user
s_out
DW_LANG_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ID_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ID_case_sensitive
s_out
DW_ID_case_sensitive
return
DW_DLV_OK
case
DW_ID_up_case
s_out
DW_ID_up_case
return
DW_DLV_OK
case
DW_ID_down_case
s_out
DW_ID_down_case
return
DW_DLV_OK
case
DW_ID_case_insensitive
s_out
DW_ID_case_insensitive
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CC_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CC_normal
s_out
DW_CC_normal
return
DW_DLV_OK
case
DW_CC_program
s_out
DW_CC_program
return
DW_DLV_OK
case
DW_CC_nocall
s_out
DW_CC_nocall
return
DW_DLV_OK
case
DW_CC_pass_by_reference
s_out
DW_CC_pass_by_reference
return
DW_DLV_OK
case
DW_CC_pass_by_value
s_out
DW_CC_pass_by_value
return
DW_DLV_OK
case
DW_CC_lo_user
s_out
DW_CC_lo_user
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CC_GNU_renesas_sh
case
DW_CC_GNU_borland_fastcall_i386
s_out
DW_CC_GNU_borland_fastcall_i386
return
DW_DLV_OK
case
DW_CC_ALTIUM_interrupt
s_out
DW_CC_ALTIUM_interrupt
return
DW_DLV_OK
case
DW_CC_ALTIUM_near_system_stack
s_out
DW_CC_ALTIUM_near_system_stack
return
DW_DLV_OK
case
DW_CC_ALTIUM_near_user_stack
s_out
DW_CC_ALTIUM_near_user_stack
return
DW_DLV_OK
case
DW_CC_ALTIUM_huge_user_stack
s_out
DW_CC_ALTIUM_huge_user_stack
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_safecall
s_out
DW_CC_GNU_BORLAND_safecall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_stdcall
s_out
DW_CC_GNU_BORLAND_stdcall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_pascal
s_out
DW_CC_GNU_BORLAND_pascal
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_msfastcall
s_out
DW_CC_GNU_BORLAND_msfastcall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_msreturn
s_out
DW_CC_GNU_BORLAND_msreturn
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_thiscall
s_out
DW_CC_GNU_BORLAND_thiscall
return
DW_DLV_OK
case
DW_CC_GNU_BORLAND_fastcall
s_out
DW_CC_GNU_BORLAND_fastcall
return
DW_DLV_OK
case
DW_CC_LLVM_vectorcall
s_out
DW_CC_LLVM_vectorcall
return
DW_DLV_OK
case
DW_CC_LLVM_Win64
s_out
DW_CC_LLVM_Win64
return
DW_DLV_OK
case
DW_CC_LLVM_X86_64SysV
s_out
DW_CC_LLVM_X86_64SysV
return
DW_DLV_OK
case
DW_CC_LLVM_AAPCS
s_out
DW_CC_LLVM_AAPCS
return
DW_DLV_OK
case
DW_CC_LLVM_AAPCS_VFP
s_out
DW_CC_LLVM_AAPCS_VFP
return
DW_DLV_OK
case
DW_CC_LLVM_IntelOclBicc
s_out
DW_CC_LLVM_IntelOclBicc
return
DW_DLV_OK
case
DW_CC_LLVM_SpirFunction
s_out
DW_CC_LLVM_SpirFunction
return
DW_DLV_OK
case
DW_CC_LLVM_OpenCLKernel
s_out
DW_CC_LLVM_OpenCLKernel
return
DW_DLV_OK
case
DW_CC_LLVM_Swift
s_out
DW_CC_LLVM_Swift
return
DW_DLV_OK
case
DW_CC_LLVM_PreserveMost
s_out
DW_CC_LLVM_PreserveMost
return
DW_DLV_OK
case
DW_CC_LLVM_PreserveAll
s_out
DW_CC_LLVM_PreserveAll
return
DW_DLV_OK
case
DW_CC_LLVM_X86RegCall
s_out
DW_CC_LLVM_X86RegCall
return
DW_DLV_OK
case
DW_CC_GDB_IBM_OpenCL
s_out
DW_CC_GDB_IBM_OpenCL
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CC_hi_user
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_INL_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_INL_not_inlined
s_out
DW_INL_not_inlined
return
DW_DLV_OK
case
DW_INL_inlined
s_out
DW_INL_inlined
return
DW_DLV_OK
case
DW_INL_declared_not_inlined
s_out
DW_INL_declared_not_inlined
return
DW_DLV_OK
case
DW_INL_declared_inlined
s_out
DW_INL_declared_inlined
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ORD_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ORD_row_major
s_out
DW_ORD_row_major
return
DW_DLV_OK
case
DW_ORD_col_major
s_out
DW_ORD_col_major
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_DSC_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_DSC_label
s_out
DW_DSC_label
return
DW_DLV_OK
case
DW_DSC_range
s_out
DW_DSC_range
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNCT_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNCT_path
s_out
DW_LNCT_path
return
DW_DLV_OK
case
DW_LNCT_directory_index
s_out
DW_LNCT_directory_index
return
DW_DLV_OK
case
DW_LNCT_timestamp
s_out
DW_LNCT_timestamp
return
DW_DLV_OK
case
DW_LNCT_size
s_out
DW_LNCT_size
return
DW_DLV_OK
case
DW_LNCT_MD5
s_out
DW_LNCT_MD5
return
DW_DLV_OK
case
DW_LNCT_GNU_subprogram_name
s_out
DW_LNCT_GNU_subprogram_name
return
DW_DLV_OK
case
DW_LNCT_GNU_decl_file
s_out
DW_LNCT_GNU_decl_file
return
DW_DLV_OK
case
DW_LNCT_GNU_decl_line
s_out
DW_LNCT_GNU_decl_line
return
DW_DLV_OK
case
DW_LNCT_lo_user
s_out
DW_LNCT_lo_user
return
DW_DLV_OK
case
DW_LNCT_LLVM_source
s_out
DW_LNCT_LLVM_source
return
DW_DLV_OK
case
DW_LNCT_hi_user
s_out
DW_LNCT_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNS_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNS_copy
s_out
DW_LNS_copy
return
DW_DLV_OK
case
DW_LNS_advance_pc
s_out
DW_LNS_advance_pc
return
DW_DLV_OK
case
DW_LNS_advance_line
s_out
DW_LNS_advance_line
return
DW_DLV_OK
case
DW_LNS_set_file
s_out
DW_LNS_set_file
return
DW_DLV_OK
case
DW_LNS_set_column
s_out
DW_LNS_set_column
return
DW_DLV_OK
case
DW_LNS_negate_stmt
s_out
DW_LNS_negate_stmt
return
DW_DLV_OK
case
DW_LNS_set_basic_block
s_out
DW_LNS_set_basic_block
return
DW_DLV_OK
case
DW_LNS_const_add_pc
s_out
DW_LNS_const_add_pc
return
DW_DLV_OK
case
DW_LNS_fixed_advance_pc
s_out
DW_LNS_fixed_advance_pc
return
DW_DLV_OK
case
DW_LNS_set_prologue_end
s_out
DW_LNS_set_prologue_end
return
DW_DLV_OK
case
DW_LNS_set_epilogue_begin
s_out
DW_LNS_set_epilogue_begin
return
DW_DLV_OK
case
DW_LNS_set_isa
s_out
DW_LNS_set_isa
return
DW_DLV_OK
case
DW_LNS_set_address_from_logical
s_out
DW_LNS_set_address_from_logical
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_LNS_set_subprogram
case
DW_LNS_inlined_call
s_out
DW_LNS_inlined_call
return
DW_DLV_OK
case
DW_LNS_pop_context
s_out
DW_LNS_pop_context
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_LNE_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_LNE_end_sequence
s_out
DW_LNE_end_sequence
return
DW_DLV_OK
case
DW_LNE_set_address
s_out
DW_LNE_set_address
return
DW_DLV_OK
case
DW_LNE_define_file
s_out
DW_LNE_define_file
return
DW_DLV_OK
case
DW_LNE_set_discriminator
s_out
DW_LNE_set_discriminator
return
DW_DLV_OK
case
DW_LNE_HP_negate_is_UV_update
s_out
DW_LNE_HP_negate_is_UV_update
return
DW_DLV_OK
case
DW_LNE_HP_push_context
s_out
DW_LNE_HP_push_context
return
DW_DLV_OK
case
DW_LNE_HP_pop_context
s_out
DW_LNE_HP_pop_context
return
DW_DLV_OK
case
DW_LNE_HP_set_file_line_column
s_out
DW_LNE_HP_set_file_line_column
return
DW_DLV_OK
case
DW_LNE_HP_set_routine_name
s_out
DW_LNE_HP_set_routine_name
return
DW_DLV_OK
case
DW_LNE_HP_set_sequence
s_out
DW_LNE_HP_set_sequence
return
DW_DLV_OK
case
DW_LNE_HP_negate_post_semantics
s_out
DW_LNE_HP_negate_post_semantics
return
DW_DLV_OK
case
DW_LNE_HP_negate_function_exit
s_out
DW_LNE_HP_negate_function_exit
return
DW_DLV_OK
case
DW_LNE_HP_negate_front_end_logical
s_out
DW_LNE_HP_negate_front_end_logical
return
DW_DLV_OK
case
DW_LNE_HP_define_proc
s_out
DW_LNE_HP_define_proc
return
DW_DLV_OK
case
DW_LNE_HP_source_file_correlation
s_out
DW_LNE_HP_source_file_correlation
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_LNE_lo_user
case
DW_LNE_hi_user
s_out
DW_LNE_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ISA_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ISA_UNKNOWN
s_out
DW_ISA_UNKNOWN
return
DW_DLV_OK
case
DW_ISA_ARM_thumb
s_out
DW_ISA_ARM_thumb
return
DW_DLV_OK
case
DW_ISA_ARM_arm
s_out
DW_ISA_ARM_arm
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_MACRO_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_MACRO_define
s_out
DW_MACRO_define
return
DW_DLV_OK
case
DW_MACRO_undef
s_out
DW_MACRO_undef
return
DW_DLV_OK
case
DW_MACRO_start_file
s_out
DW_MACRO_start_file
return
DW_DLV_OK
case
DW_MACRO_end_file
s_out
DW_MACRO_end_file
return
DW_DLV_OK
case
DW_MACRO_define_strp
s_out
DW_MACRO_define_strp
return
DW_DLV_OK
case
DW_MACRO_undef_strp
s_out
DW_MACRO_undef_strp
return
DW_DLV_OK
case
DW_MACRO_import
s_out
DW_MACRO_import
return
DW_DLV_OK
case
DW_MACRO_define_sup
s_out
DW_MACRO_define_sup
return
DW_DLV_OK
case
DW_MACRO_undef_sup
s_out
DW_MACRO_undef_sup
return
DW_DLV_OK
case
DW_MACRO_import_sup
s_out
DW_MACRO_import_sup
return
DW_DLV_OK
case
DW_MACRO_define_strx
s_out
DW_MACRO_define_strx
return
DW_DLV_OK
case
DW_MACRO_undef_strx
s_out
DW_MACRO_undef_strx
return
DW_DLV_OK
case
DW_MACRO_lo_user
s_out
DW_MACRO_lo_user
return
DW_DLV_OK
case
DW_MACRO_hi_user
s_out
DW_MACRO_hi_user
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_MACINFO_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_MACINFO_define
s_out
DW_MACINFO_define
return
DW_DLV_OK
case
DW_MACINFO_undef
s_out
DW_MACINFO_undef
return
DW_DLV_OK
case
DW_MACINFO_start_file
s_out
DW_MACINFO_start_file
return
DW_DLV_OK
case
DW_MACINFO_end_file
s_out
DW_MACINFO_end_file
return
DW_DLV_OK
case
DW_MACINFO_vendor_ext
s_out
DW_MACINFO_vendor_ext
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CFA_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CFA_extended
s_out
DW_CFA_extended
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_nop
case
DW_CFA_set_loc
s_out
DW_CFA_set_loc
return
DW_DLV_OK
case
DW_CFA_advance_loc1
s_out
DW_CFA_advance_loc1
return
DW_DLV_OK
case
DW_CFA_advance_loc2
s_out
DW_CFA_advance_loc2
return
DW_DLV_OK
case
DW_CFA_advance_loc4
s_out
DW_CFA_advance_loc4
return
DW_DLV_OK
case
DW_CFA_offset_extended
s_out
DW_CFA_offset_extended
return
DW_DLV_OK
case
DW_CFA_restore_extended
s_out
DW_CFA_restore_extended
return
DW_DLV_OK
case
DW_CFA_undefined
s_out
DW_CFA_undefined
return
DW_DLV_OK
case
DW_CFA_same_value
s_out
DW_CFA_same_value
return
DW_DLV_OK
case
DW_CFA_register
s_out
DW_CFA_register
return
DW_DLV_OK
case
DW_CFA_remember_state
s_out
DW_CFA_remember_state
return
DW_DLV_OK
case
DW_CFA_restore_state
s_out
DW_CFA_restore_state
return
DW_DLV_OK
case
DW_CFA_def_cfa
s_out
DW_CFA_def_cfa
return
DW_DLV_OK
case
DW_CFA_def_cfa_register
s_out
DW_CFA_def_cfa_register
return
DW_DLV_OK
case
DW_CFA_def_cfa_offset
s_out
DW_CFA_def_cfa_offset
return
DW_DLV_OK
case
DW_CFA_def_cfa_expression
s_out
DW_CFA_def_cfa_expression
return
DW_DLV_OK
case
DW_CFA_expression
s_out
DW_CFA_expression
return
DW_DLV_OK
case
DW_CFA_offset_extended_sf
s_out
DW_CFA_offset_extended_sf
return
DW_DLV_OK
case
DW_CFA_def_cfa_sf
s_out
DW_CFA_def_cfa_sf
return
DW_DLV_OK
case
DW_CFA_def_cfa_offset_sf
s_out
DW_CFA_def_cfa_offset_sf
return
DW_DLV_OK
case
DW_CFA_val_offset
s_out
DW_CFA_val_offset
return
DW_DLV_OK
case
DW_CFA_val_offset_sf
s_out
DW_CFA_val_offset_sf
return
DW_DLV_OK
case
DW_CFA_val_expression
s_out
DW_CFA_val_expression
return
DW_DLV_OK
case
DW_CFA_lo_user
s_out
DW_CFA_lo_user
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_low_user
case
DW_CFA_MIPS_advance_loc8
s_out
DW_CFA_MIPS_advance_loc8
return
DW_DLV_OK
case
DW_CFA_GNU_window_save
s_out
DW_CFA_GNU_window_save
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_CFA_AARCH64_negate_ra_state
case
DW_CFA_GNU_args_size
s_out
DW_CFA_GNU_args_size
return
DW_DLV_OK
case
DW_CFA_GNU_negative_offset_extended
s_out
DW_CFA_GNU_negative_offset_extended
return
DW_DLV_OK
case
DW_CFA_METAWARE_info
s_out
DW_CFA_METAWARE_info
return
DW_DLV_OK
case
DW_CFA_high_user
s_out
DW_CFA_high_user
return
DW_DLV_OK
case
DW_CFA_advance_loc
s_out
DW_CFA_advance_loc
return
DW_DLV_OK
case
DW_CFA_offset
s_out
DW_CFA_offset
return
DW_DLV_OK
case
DW_CFA_restore
s_out
DW_CFA_restore
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_EH_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_EH_PE_absptr
s_out
DW_EH_PE_absptr
return
DW_DLV_OK
case
DW_EH_PE_uleb128
s_out
DW_EH_PE_uleb128
return
DW_DLV_OK
case
DW_EH_PE_udata2
s_out
DW_EH_PE_udata2
return
DW_DLV_OK
case
DW_EH_PE_udata4
s_out
DW_EH_PE_udata4
return
DW_DLV_OK
case
DW_EH_PE_udata8
s_out
DW_EH_PE_udata8
return
DW_DLV_OK
case
DW_EH_PE_sleb128
s_out
DW_EH_PE_sleb128
return
DW_DLV_OK
case
DW_EH_PE_sdata2
s_out
DW_EH_PE_sdata2
return
DW_DLV_OK
case
DW_EH_PE_sdata4
s_out
DW_EH_PE_sdata4
return
DW_DLV_OK
case
DW_EH_PE_sdata8
s_out
DW_EH_PE_sdata8
return
DW_DLV_OK
case
DW_EH_PE_pcrel
s_out
DW_EH_PE_pcrel
return
DW_DLV_OK
case
DW_EH_PE_textrel
s_out
DW_EH_PE_textrel
return
DW_DLV_OK
case
DW_EH_PE_datarel
s_out
DW_EH_PE_datarel
return
DW_DLV_OK
case
DW_EH_PE_funcrel
s_out
DW_EH_PE_funcrel
return
DW_DLV_OK
case
DW_EH_PE_aligned
s_out
DW_EH_PE_aligned
return
DW_DLV_OK
case
DW_EH_PE_omit
s_out
DW_EH_PE_omit
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_FRAME_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_FRAME_CFA_COL
s_out
DW_FRAME_CFA_COL
return
DW_DLV_OK
Skipping
alternate
spelling
of
value
DW_FRAME_LAST_REG_NUM
Skipping
alternate
spelling
of
value
DW_FRAME_RA_COL
Skipping
alternate
spelling
of
value
DW_FRAME_STATIC_LINK
case
DW_FRAME_REG1
s_out
DW_FRAME_REG1
return
DW_DLV_OK
case
DW_FRAME_REG2
s_out
DW_FRAME_REG2
return
DW_DLV_OK
case
DW_FRAME_REG3
s_out
DW_FRAME_REG3
return
DW_DLV_OK
case
DW_FRAME_REG4
s_out
DW_FRAME_REG4
return
DW_DLV_OK
case
DW_FRAME_REG5
s_out
DW_FRAME_REG5
return
DW_DLV_OK
case
DW_FRAME_REG6
s_out
DW_FRAME_REG6
return
DW_DLV_OK
case
DW_FRAME_REG7
s_out
DW_FRAME_REG7
return
DW_DLV_OK
case
DW_FRAME_REG8
s_out
DW_FRAME_REG8
return
DW_DLV_OK
case
DW_FRAME_REG9
s_out
DW_FRAME_REG9
return
DW_DLV_OK
case
DW_FRAME_REG10
s_out
DW_FRAME_REG10
return
DW_DLV_OK
case
DW_FRAME_REG11
s_out
DW_FRAME_REG11
return
DW_DLV_OK
case
DW_FRAME_REG12
s_out
DW_FRAME_REG12
return
DW_DLV_OK
case
DW_FRAME_REG13
s_out
DW_FRAME_REG13
return
DW_DLV_OK
case
DW_FRAME_REG14
s_out
DW_FRAME_REG14
return
DW_DLV_OK
case
DW_FRAME_REG15
s_out
DW_FRAME_REG15
return
DW_DLV_OK
case
DW_FRAME_REG16
s_out
DW_FRAME_REG16
return
DW_DLV_OK
case
DW_FRAME_REG17
s_out
DW_FRAME_REG17
return
DW_DLV_OK
case
DW_FRAME_REG18
s_out
DW_FRAME_REG18
return
DW_DLV_OK
case
DW_FRAME_REG19
s_out
DW_FRAME_REG19
return
DW_DLV_OK
case
DW_FRAME_REG20
s_out
DW_FRAME_REG20
return
DW_DLV_OK
case
DW_FRAME_REG21
s_out
DW_FRAME_REG21
return
DW_DLV_OK
case
DW_FRAME_REG22
s_out
DW_FRAME_REG22
return
DW_DLV_OK
case
DW_FRAME_REG23
s_out
DW_FRAME_REG23
return
DW_DLV_OK
case
DW_FRAME_REG24
s_out
DW_FRAME_REG24
return
DW_DLV_OK
case
DW_FRAME_REG25
s_out
DW_FRAME_REG25
return
DW_DLV_OK
case
DW_FRAME_REG26
s_out
DW_FRAME_REG26
return
DW_DLV_OK
case
DW_FRAME_REG27
s_out
DW_FRAME_REG27
return
DW_DLV_OK
case
DW_FRAME_REG28
s_out
DW_FRAME_REG28
return
DW_DLV_OK
case
DW_FRAME_REG29
s_out
DW_FRAME_REG29
return
DW_DLV_OK
case
DW_FRAME_REG30
s_out
DW_FRAME_REG30
return
DW_DLV_OK
case
DW_FRAME_REG31
s_out
DW_FRAME_REG31
return
DW_DLV_OK
case
DW_FRAME_FREG0
s_out
DW_FRAME_FREG0
return
DW_DLV_OK
case
DW_FRAME_FREG1
s_out
DW_FRAME_FREG1
return
DW_DLV_OK
case
DW_FRAME_FREG2
s_out
DW_FRAME_FREG2
return
DW_DLV_OK
case
DW_FRAME_FREG3
s_out
DW_FRAME_FREG3
return
DW_DLV_OK
case
DW_FRAME_FREG4
s_out
DW_FRAME_FREG4
return
DW_DLV_OK
case
DW_FRAME_FREG5
s_out
DW_FRAME_FREG5
return
DW_DLV_OK
case
DW_FRAME_FREG6
s_out
DW_FRAME_FREG6
return
DW_DLV_OK
case
DW_FRAME_FREG7
s_out
DW_FRAME_FREG7
return
DW_DLV_OK
case
DW_FRAME_FREG8
s_out
DW_FRAME_FREG8
return
DW_DLV_OK
case
DW_FRAME_FREG9
s_out
DW_FRAME_FREG9
return
DW_DLV_OK
case
DW_FRAME_FREG10
s_out
DW_FRAME_FREG10
return
DW_DLV_OK
case
DW_FRAME_FREG11
s_out
DW_FRAME_FREG11
return
DW_DLV_OK
case
DW_FRAME_FREG12
s_out
DW_FRAME_FREG12
return
DW_DLV_OK
case
DW_FRAME_FREG13
s_out
DW_FRAME_FREG13
return
DW_DLV_OK
case
DW_FRAME_FREG14
s_out
DW_FRAME_FREG14
return
DW_DLV_OK
case
DW_FRAME_FREG15
s_out
DW_FRAME_FREG15
return
DW_DLV_OK
case
DW_FRAME_FREG16
s_out
DW_FRAME_FREG16
return
DW_DLV_OK
case
DW_FRAME_FREG17
s_out
DW_FRAME_FREG17
return
DW_DLV_OK
case
DW_FRAME_FREG18
s_out
DW_FRAME_FREG18
return
DW_DLV_OK
case
DW_FRAME_FREG19
s_out
DW_FRAME_FREG19
return
DW_DLV_OK
case
DW_FRAME_FREG20
s_out
DW_FRAME_FREG20
return
DW_DLV_OK
case
DW_FRAME_FREG21
s_out
DW_FRAME_FREG21
return
DW_DLV_OK
case
DW_FRAME_FREG22
s_out
DW_FRAME_FREG22
return
DW_DLV_OK
case
DW_FRAME_FREG23
s_out
DW_FRAME_FREG23
return
DW_DLV_OK
case
DW_FRAME_FREG24
s_out
DW_FRAME_FREG24
return
DW_DLV_OK
case
DW_FRAME_FREG25
s_out
DW_FRAME_FREG25
return
DW_DLV_OK
case
DW_FRAME_FREG26
s_out
DW_FRAME_FREG26
return
DW_DLV_OK
case
DW_FRAME_FREG27
s_out
DW_FRAME_FREG27
return
DW_DLV_OK
case
DW_FRAME_FREG28
s_out
DW_FRAME_FREG28
return
DW_DLV_OK
case
DW_FRAME_FREG29
s_out
DW_FRAME_FREG29
return
DW_DLV_OK
case
DW_FRAME_FREG30
s_out
DW_FRAME_FREG30
return
DW_DLV_OK
case
DW_FRAME_FREG31
s_out
DW_FRAME_FREG31
return
DW_DLV_OK
case
DW_FRAME_FREG32
s_out
DW_FRAME_FREG32
return
DW_DLV_OK
case
DW_FRAME_FREG33
s_out
DW_FRAME_FREG33
return
DW_DLV_OK
case
DW_FRAME_FREG34
s_out
DW_FRAME_FREG34
return
DW_DLV_OK
case
DW_FRAME_FREG35
s_out
DW_FRAME_FREG35
return
DW_DLV_OK
case
DW_FRAME_FREG36
s_out
DW_FRAME_FREG36
return
DW_DLV_OK
case
DW_FRAME_FREG37
s_out
DW_FRAME_FREG37
return
DW_DLV_OK
case
DW_FRAME_FREG38
s_out
DW_FRAME_FREG38
return
DW_DLV_OK
case
DW_FRAME_FREG39
s_out
DW_FRAME_FREG39
return
DW_DLV_OK
case
DW_FRAME_FREG40
s_out
DW_FRAME_FREG40
return
DW_DLV_OK
case
DW_FRAME_FREG41
s_out
DW_FRAME_FREG41
return
DW_DLV_OK
case
DW_FRAME_FREG42
s_out
DW_FRAME_FREG42
return
DW_DLV_OK
case
DW_FRAME_FREG43
s_out
DW_FRAME_FREG43
return
DW_DLV_OK
case
DW_FRAME_FREG44
s_out
DW_FRAME_FREG44
return
DW_DLV_OK
case
DW_FRAME_FREG45
s_out
DW_FRAME_FREG45
return
DW_DLV_OK
case
DW_FRAME_FREG46
s_out
DW_FRAME_FREG46
return
DW_DLV_OK
case
DW_FRAME_FREG47
s_out
DW_FRAME_FREG47
return
DW_DLV_OK
case
DW_FRAME_FREG48
s_out
DW_FRAME_FREG48
return
DW_DLV_OK
case
DW_FRAME_FREG49
s_out
DW_FRAME_FREG49
return
DW_DLV_OK
case
DW_FRAME_FREG50
s_out
DW_FRAME_FREG50
return
DW_DLV_OK
case
DW_FRAME_FREG51
s_out
DW_FRAME_FREG51
return
DW_DLV_OK
case
DW_FRAME_FREG52
s_out
DW_FRAME_FREG52
return
DW_DLV_OK
case
DW_FRAME_FREG53
s_out
DW_FRAME_FREG53
return
DW_DLV_OK
case
DW_FRAME_FREG54
s_out
DW_FRAME_FREG54
return
DW_DLV_OK
case
DW_FRAME_FREG55
s_out
DW_FRAME_FREG55
return
DW_DLV_OK
case
DW_FRAME_FREG56
s_out
DW_FRAME_FREG56
return
DW_DLV_OK
case
DW_FRAME_FREG57
s_out
DW_FRAME_FREG57
return
DW_DLV_OK
case
DW_FRAME_FREG58
s_out
DW_FRAME_FREG58
return
DW_DLV_OK
case
DW_FRAME_FREG59
s_out
DW_FRAME_FREG59
return
DW_DLV_OK
case
DW_FRAME_FREG60
s_out
DW_FRAME_FREG60
return
DW_DLV_OK
case
DW_FRAME_FREG61
s_out
DW_FRAME_FREG61
return
DW_DLV_OK
case
DW_FRAME_FREG62
s_out
DW_FRAME_FREG62
return
DW_DLV_OK
case
DW_FRAME_FREG63
s_out
DW_FRAME_FREG63
return
DW_DLV_OK
case
DW_FRAME_FREG64
s_out
DW_FRAME_FREG64
return
DW_DLV_OK
case
DW_FRAME_FREG65
s_out
DW_FRAME_FREG65
return
DW_DLV_OK
case
DW_FRAME_FREG66
s_out
DW_FRAME_FREG66
return
DW_DLV_OK
case
DW_FRAME_FREG67
s_out
DW_FRAME_FREG67
return
DW_DLV_OK
case
DW_FRAME_FREG68
s_out
DW_FRAME_FREG68
return
DW_DLV_OK
case
DW_FRAME_FREG69
s_out
DW_FRAME_FREG69
return
DW_DLV_OK
case
DW_FRAME_FREG70
s_out
DW_FRAME_FREG70
return
DW_DLV_OK
case
DW_FRAME_FREG71
s_out
DW_FRAME_FREG71
return
DW_DLV_OK
case
DW_FRAME_FREG72
s_out
DW_FRAME_FREG72
return
DW_DLV_OK
case
DW_FRAME_FREG73
s_out
DW_FRAME_FREG73
return
DW_DLV_OK
case
DW_FRAME_FREG74
s_out
DW_FRAME_FREG74
return
DW_DLV_OK
case
DW_FRAME_FREG75
s_out
DW_FRAME_FREG75
return
DW_DLV_OK
case
DW_FRAME_FREG76
s_out
DW_FRAME_FREG76
return
DW_DLV_OK
case
DW_FRAME_HIGHEST_NORMAL_REGISTER
s_out
DW_FRAME_HIGHEST_NORMAL_REGISTER
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_CHILDREN_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_CHILDREN_no
s_out
DW_CHILDREN_no
return
DW_DLV_OK
case
DW_CHILDREN_yes
s_out
DW_CHILDREN_yes
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
ARGSUSED
int
dwarf_get_ADDR_name
unsigned
int
val
const
char
s_out
switch
val
case
DW_ADDR_none
s_out
DW_ADDR_none
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
END
FILE
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
The
interfaces
follow
tsearch
See
the
Single
Unix
Specification
but
the
implementation
is
written
without
reference
to
the
source
of
any
version
of
tsearch
See
http
www
prevanders
net
tsearch
html
for
information
and
an
example
of
use
Based
on
Knuth
chapter
And
based
on
chapter
Balanced
Trees
sometimes
call
AVL
trees
Algorithm
A
and
the
sketch
on
deletion
The
wikipedia
page
on
AVL
trees
is
also
quite
useful
A
Key
equation
is
bal
factor
node
k
height
left
subtree
height
right
subtree
We
don
t
know
the
absolute
height
but
we
do
know
the
balance
factor
of
the
pointed
to
subtrees
or
And
we
always
know
if
we
are
adding
or
deleting
a
node
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
config
h
include
libdwarf_private
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
free
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
stdio
h
for
printf
This
must
match
the
types
and
print
options
found
in
libdwarf
h
define
Dwarf_Unsigned
unsigned
long
long
include
dwarf_tsearch
h
define
IMPLEMENTD15
ifdef
DW_CHECK_CONSISTENCY
struct
ts_entry
void
dwarf_check_balance
struct
ts_entry
head
int
finalprefix
endif
head
is
a
special
link
rlink
points
to
root
node
head
llink
is
a
tree
depth
value
Using
a
pointer
root
head
rlink
The
keypointer
and
balance
fields
of
the
head
node
are
not
used
Might
be
sensible
to
use
the
head
balance
field
as
a
tree
depth
instead
of
using
llink
struct
ts_entry
Keyptr
points
to
a
pointer
to
a
record
the
user
saved
the
user
record
contains
the
user
s
key
itself
and
perhaps
more
We
will
request
free
so
const
void
is
not
quite
right
void
keyptr
int
balance
Knuth
algorithm
A
struct
ts_entry
llink
struct
ts_entry
rlink
static
void
printlevel
int
level
int
len
int
targetlen
level
int
shownlen
char
number
This
is
a
safe
sprintf
No
need
for
esb
here
len
sprintf
number
d
level
printf
s
number
shownlen
len
while
shownlen
targetlen
putchar
shownlen
Not
needed
for
this
set
of
functions
void
dwarf_initialize_search_hash
void
treeptr
DW_TSHASHTYPE
hashfunc
const
void
key
UNUSEDARG
unsigned
long
size_estimate
UNUSEDARG
return
treeptr
For
debugging
mainly
We
print
the
tree
with
the
head
node
unnumbered
and
the
root
node
called
level
In
Knuth
algorithms
where
we
have
p
k
when
k
is
zero
k
refers
to
the
head
node
Handy
as
then
the
root
node
is
not
special
at
all
But
here
it
just
looks
better
as
shown
perhaps
The
ordering
here
is
so
that
if
you
turned
an
output
page
with
the
left
side
at
the
top
then
the
tree
sort
of
just
shows
up
nicely
in
what
most
think
of
as
a
normal
way
static
void
tdump_inner
struct
ts_entry
t
char
keyprint
const
void
const
char
descr
int
level
const
char
keyv
if
t
return
tdump_inner
t
rlink
keyprint
right
level
printlevel
level
if
t
keyptr
keyv
keyprint
t
keyptr
printf
DW_PR_DUx
keyptr
DW_PR_DUx
s
s
bal
l
DW_PR_DUx
r
DW_PR_DUx
s
n
Dwarf_Unsigned
uintptr_t
t
Dwarf_Unsigned
uintptr_t
t
keyptr
t
keyptr?
key
null
keyv
t
balance
Dwarf_Unsigned
uintptr_t
t
llink
Dwarf_Unsigned
uintptr_t
t
rlink
descr
tdump_inner
t
llink
keyprint
left
level
ifdef
DW_CHECK_CONSISTENCY
Checking
that
a
tree
or
sub
tree
is
in
balance
Only
meaningful
for
balanced
trees
Returns
the
depth
int
dwarf_check_balance_inner
struct
ts_entry
t
int
level
int
maxdepth
int
founderror
const
char
prefix
int
l
int
r
if
level
maxdepth
printf
s
Likely
internal
erroneous
link
loop
got
to
depth
d
n
prefix
level
exit
if
t
return
if
t
llink
t
rlink
if
t
balance
printf
s
Balance
at
DW_PR_DUx
should
be
is
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
t
balance
founderror
return
l
dwarf_check_balance_inner
t
llink
level
maxdepth
founderror
prefix
r
dwarf_check_balance_inner
t
rlink
level
maxdepth
founderror
prefix
if
l
r
t
balance
printf
s
Balance
at
DW_PR_DUx
d
should
be
is
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
t
balance
founderror
return
l
if
l
r
if
l
r
printf
s
depth
mismatch
at
DW_PR_DUx
l
d
r
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
l
r
founderror
if
t
balance
printf
s
Balance
at
DW_PR_DUx
should
be
is
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
t
balance
founderror
return
l
if
r
l
if
r
l
printf
s
depth
mismatch
at
DW_PR_DUx
r
d
l
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
r
l
founderror
if
t
balance
printf
s
Balance
at
DW_PR_DUx
should
be
is
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
t
balance
founderror
else
if
t
balance
printf
s
Balance
at
DW_PR_DUx
should
be
is
d
n
prefix
Dwarf_Unsigned
uintptr_t
t
t
balance
founderror
return
r
void
dwarf_check_balance
struct
ts_entry
head
int
finalprefix
const
char
prefix
int
maxdepth
size_t
headdepth
int
errcount
int
depth
struct
ts_entry
root
if
finalprefix
prefix
BalanceError
else
prefix
BalanceWarn
if
head
printf
s
check
balance
null
tree
ptr
n
prefix
return
root
head
rlink
headdepth
head
llink
struct
ts_entry
if
root
printf
s
check
balance
null
tree
ptr
n
prefix
return
maxdepth
headdepth
Counting
in
levels
not
level
number
of
top
level
headdepth
depth
dwarf_check_balance_inner
root
depth
maxdepth
prefix
if
depth
headdepth
printf
s
Head
node
says
depth
lu
it
is
really
d
n
prefix
unsigned
long
headdepth
depth
errcount
if
errcount
printf
s
error
count
d
n
prefix
errcount
return
endif
Dumping
the
tree
to
stdout
void
dwarf_tdump
const
void
headp_in
char
keyprint
const
void
const
char
msg
const
struct
ts_entry
head
const
struct
ts_entry
headp_in
struct
ts_entry
root
size_t
headdepth
if
head
printf
dumptree
null
tree
ptr
s
n
msg
return
headdepth
head
llink
struct
ts_entry
printf
dumptree
head
ptr
DW_PR_DUx
tree
depth
d
s
n
Dwarf_Unsigned
uintptr_t
head
int
headdepth
msg
root
head
rlink
if
root
printf
Empty
tree
n
return
tdump_inner
root
keyprint
top
static
void
setlink
struct
ts_entry
t
int
a
struct
ts_entry
x
if
a
t
llink
x
else
t
rlink
x
static
struct
ts_entry
getlink
struct
ts_entry
t
int
a
if
a
return
t
llink
return
t
rlink
static
struct
ts_entry
allocate_ts_entry
const
void
key
struct
ts_entry
e
struct
ts_entry
malloc
sizeof
struct
ts_entry
if
e
return
NULL
We
will
eventually
ask
it
be
freed
so
being
const
void
in
is
not
quite
right
e
keyptr
void
key
e
balance
e
llink
e
rlink
return
e
Knuth
step
T5
the
insert
static
struct
ts_entry
tsearch_insert_k
const
void
key
int
kc
struct
ts_entry
p
struct
ts_entry
q
allocate_ts_entry
key
if
q
out
of
memory
return
NULL
setlink
p
kc
q
Non
NULL
means
inserted
return
q
Knuth
step
T5
static
struct
ts_entry
tsearch_inner_do_insert
const
void
key
int
kc
int
inserted
struct
ts_entry
p
struct
ts_entry
q
q
tsearch_insert_k
key
kc
p
if
q
inserted
return
q
Algorithm
A
of
Knuth
balanced
tree
key
is
pointer
to
a
user
data
area
containing
the
key
and
possibly
more
We
could
recurse
on
this
routine
but
instead
we
iterate
like
Knuth
does
but
using
for
instead
of
go
to
static
struct
ts_entry
tsearch_inner
const
void
key
struct
ts_entry
head
int
compar
const
void
const
void
int
inserted
struct
ts_entry
nullme
UNUSEDARG
int
comparres
UNUSEDARG
t
points
to
parent
of
p
struct
ts_entry
t
head
p
moves
down
tree
p
starts
as
root
struct
ts_entry
p
head
rlink
s
points
where
rebalancing
may
be
needed
struct
ts_entry
s
p
struct
ts_entry
r
struct
ts_entry
q
int
a
int
kc
for
A2
kc
compar
key
p
keyptr
if
kc
A3
and
A4
handled
here
q
getlink
p
kc
if
q
Does
step
A5
q
tsearch_inner_do_insert
key
kc
inserted
p
if
q
Out
of
memory
return
q
break
to
A5
if
q
balance
t
p
s
q
p
q
continue
K
KEY
P
in
Knuth
kc
we
found
the
entry
we
search
for
return
p
A5
work
already
done
A6
Balance
factors
on
nodes
betwen
S
and
Q
need
to
be
changed
from
zero
to
int
kc2
compar
key
s
keyptr
if
kc2
a
else
a
r
p
getlink
s
a
while
p
q
int
kc3
compar
key
p
keyptr
if
kc3
p
balance
p
p
llink
else
if
kc3
p
balance
p
p
rlink
else
ASSERT
p
q
break
A7
if
s
balance
Tree
has
grown
higher
s
balance
a
Counting
in
pointers
not
integers
Ugh
head
llink
head
llink
return
q
if
s
balance
a
Tree
is
more
balanced
s
balance
return
q
if
s
balance
a
Rebalance
if
r
balance
a
single
rotation
step
A8
p
r
setlink
s
a
getlink
r
a
setlink
r
a
s
s
balance
r
balance
else
if
r
balance
a
double
rotation
step
A9
p
getlink
r
a
setlink
r
a
getlink
p
a
setlink
p
a
r
setlink
s
a
getlink
p
a
setlink
p
a
s
if
p
balance
a
s
balance
a
r
balance
else
if
p
balance
s
balance
r
balance
else
if
p
balance
a
s
balance
r
balance
a
p
balance
else
fprintf
stderr
Impossible
balanced
tree
situation
n
Impossible
Cannot
be
here
exit
else
fprintf
stderr
Impossible
balanced
tree
situation
n
Impossible
Cannot
be
here
exit
A10
if
s
t
rlink
t
rlink
p
else
t
llink
p
ifdef
DW_CHECK_CONSISTENCY
dwarf_check_balance
head
endif
return
q
Search
and
if
missing
insert
void
dwarf_tsearch
const
void
key
void
headin
int
compar
const
void
const
void
struct
ts_entry
headp
struct
ts_entry
headin
struct
ts_entry
head
struct
ts_entry
r
int
inserted
kcomparv
should
be
ignored
int
kcomparv
nullme
won
t
be
set
struct
ts_entry
nullme
if
headp
return
NULL
head
headp
if
head
struct
ts_entry
root
head
allocate_ts_entry
if
head
return
NULL
root
allocate_ts_entry
key
if
root
free
head
return
NULL
head
rlink
root
head
llink
is
used
for
the
depth
as
a
count
head
points
to
the
special
head
node
headin
head
return
void
root
keyptr
r
tsearch_inner
key
head
compar
if
r
return
NULL
return
void
r
keyptr
Search
without
insert
void
dwarf_tfind
const
void
key
void
const
rootp
int
compar
const
void
const
void
struct
ts_entry
const
phead
struct
ts_entry
const
rootp
struct
ts_entry
head
struct
ts_entry
p
if
phead
return
NULL
head
phead
if
head
return
NULL
p
head
rlink
while
p
int
kc
compar
key
p
keyptr
if
kc
return
void
p
keyptr
p
getlink
p
kc
return
NULL
Used
for
an
array
of
records
used
in
the
deletion
code
k
for
the
special
head
node
which
is
never
matched
by
input
k
etc
struct
pkrecord
struct
ts_entry
pk
int
ak
Is
or
Here
we
rearrange
the
tree
so
the
node
p
to
be
deleted
is
a
node
with
a
null
left
link
With
that
done
we
can
fix
pkarray
and
then
we
can
use
the
pkarray
to
rebalance
It
s
a
bit
long
so
we
refactor
out
the
code
from
where
it
is
called
The
rearrangement
is
Algorithm
in
Knuth
PRECONDITION
p
p
rlink
pp
non
null
RETURNS
new
high
index
of
pkarray
static
unsigned
rearrange_tree_so_p_llink_null
struct
pkrecord
pkarray
unsigned
k
struct
ts_entry
head
UNUSEDARG
struct
ts_entry
r
struct
ts_entry
p
int
pak
UNUSEDARG
struct
ts_entry
pp
UNUSEDARG
int
ppak
struct
ts_entry
s
unsigned
k2
indexing
pkarray
int
pbalance
p
balance
Step
D3
Since
we
are
going
to
modify
the
tree
by
movement
of
a
node
down
the
tree
a
ways
we
need
to
build
pkarray
with
the
not
yet
found
new
next
node
in
pkarray
k
not
p
The
deletion
will
be
of
p
but
by
then
p
will
be
moved
in
the
tree
so
it
has
a
null
left
link
P
s
possibly
non
null
right
link
k2
k
k2
r
p
rlink
pkarray
k2
pk
r
pkarray
k2
ak
s
r
llink
Move
down
and
left
to
get
a
null
llink
while
s
llink
k2
r
s
s
r
llink
pkarray
k2
pk
r
pkarray
k2
ak
Now
we
move
S
up
in
place
in
the
tree
of
the
node
P
we
will
delete
and
p
replaces
s
Finally
winding
up
with
a
newly
shaped
balanced
tree
struct
ts_entry
tmp
int
sbalance
s
balance
s
llink
p
llink
r
llink
p
p
llink
tmp
p
rlink
p
rlink
s
rlink
s
rlink
tmp
setlink
pp
ppak
s
s
balance
pbalance
p
balance
sbalance
Now
the
tree
is
rearranged
and
still
in
balance
Replace
the
previous
k
position
entry
with
S
We
trace
the
right
link
off
of
the
moved
S
node
pkarray
k
pk
s
pkarray
k
ak
r
llink
p
rlink
Now
p
is
out
of
the
tree
and
we
start
the
rebalance
at
r
pkarray
Index
k2
Step
D4
free
p
return
k2
Returns
deleted
node
parent
unless
the
head
changed
Returns
NULL
if
wanted
node
not
found
or
the
tree
is
now
empty
or
the
head
node
changed
Sets
did_delete
if
it
found
and
deleted
a
node
Sets
tree_empty
if
there
are
no
more
user
nodes
present
static
struct
ts_entry
tdelete_inner
const
void
key
struct
ts_entry
head
int
compar
const
void
const
void
int
tree_empty
int
did_delete
struct
ts_entry
p
struct
ts_entry
pp
struct
pkrecord
pkarray
size_t
depth
head
llink
struct
ts_entry
unsigned
k
Allocate
extra
head
is
on
the
stack
we
create
here
and
the
depth
might
increase
depth
depth
pkarray
calloc
sizeof
struct
pkrecord
depth
if
pkarray
Malloc
fails
we
could
abort
return
NULL
k
pkarray
k
pk
head
pkarray
k
ak
p
head
rlink
while
p
int
kc
k
kc
compar
key
p
keyptr
pkarray
k
pk
p
pkarray
k
ak
kc
if
kc
break
p
getlink
p
kc
if
p
Node
to
delete
never
found
free
pkarray
return
NULL
struct
ts_entry
t
struct
ts_entry
r
int
pak
int
ppak
p
pkarray
k
pk
pak
pkarray
k
ak
pp
pkarray
k
pk
ppak
pkarray
k
ak
Found
a
match
p
to
be
deleted
t
p
did_delete
if
t
rlink
if
k
t
llink
tree_empty
upper
level
will
fix
up
head
node
free
t
free
pkarray
return
NULL
t
llink
might
be
NULL
setlink
pp
ppak
t
llink
ASSERT
t
llink
NULL
or
t
llink
has
no
children
balance
zero
and
balance
of
t
llink
not
changing
k
Step
D4
free
t
goto
balance
ifdef
IMPLEMENTD15
Step
D1
if
t
llink
setlink
pp
ppak
t
rlink
we
change
the
left
link
off
ak
k
Step
D4
free
t
goto
balance
endif
IMPLEMENTD15
Step
D2
r
t
rlink
if
r
llink
We
decrease
the
height
of
the
right
tree
r
llink
t
llink
setlink
pp
ppak
r
pkarray
k
pk
r
pkarray
k
ak
The
following
essential
line
not
mentioned
in
Knuth
AFAICT
r
balance
t
balance
Step
D4
free
t
goto
balance
Step
D3
we
rearrange
the
tree
and
pkarray
so
the
balance
step
can
work
step
D2
is
insufficient
so
not
done
k
rearrange_tree_so_p_llink_null
pkarray
k
head
r
p
pak
pp
ppak
goto
balance
Now
use
pkarray
decide
if
rebalancing
needed
and
if
needed
to
rebalance
k
here
matches
l
in
Knuth
balance
unsigned
k2
k
We
do
not
want
a
test
in
the
for
itself
for
k2
struct
ts_entry
pk
int
ak
int
bk
if
k2
decreased
in
height
head
llink
goto
cleanup
pk
pkarray
k2
pk
if
pk
Nothing
here
to
work
with
Move
up
continue
ak
pkarray
k2
ak
bk
pk
balance
if
bk
ak
pk
balance
continue
if
bk
pk
balance
ak
goto
cleanup
ASSERT
bk
ak
We
will
use
bk
adel
here
just
below
Rebalancing
required
Here
we
use
and
in
to
adjust
the
nodes
Rebalance
We
use
s
for
what
is
called
A
in
Knuth
Case
Case
page
r
For
what
is
called
B
So
the
link
movement
logic
looks
similar
to
the
tsearch
insert
case
struct
ts_entry
r
struct
ts_entry
s
struct
ts_entry
pa
int
pak
int
adel
ak
s
pk
r
getlink
s
adel
pa
pkarray
k2
pk
pak
pkarray
k2
ak
if
r
balance
adel
case
setlink
s
adel
getlink
r
adel
setlink
r
adel
s
A10
in
tsearch
setlink
pa
pak
r
s
balance
r
balance
continue
else
if
r
balance
adel
case
x
plays
the
role
of
p
in
step
A9
struct
ts_entry
x
getlink
r
adel
setlink
r
adel
getlink
x
adel
setlink
x
adel
r
setlink
s
adel
getlink
x
adel
setlink
x
adel
s
A10
in
tsearch
setlink
pa
pak
x
if
x
balance
adel
s
balance
adel
r
balance
else
if
x
balance
s
balance
r
balance
else
if
x
balance
adel
s
balance
r
balance
adel
x
balance
continue
else
r
balance
case
we
do
a
single
rotation
and
we
are
done
setlink
s
adel
getlink
r
adel
setlink
r
adel
s
setlink
pa
pak
r
r
balance
adel
s
balance
r
balance
goto
cleanup
cleanup
free
pkarray
ifdef
DW_CHECK_CONSISTENCY
dwarf_check_balance
head
endif
return
pp
void
dwarf_tdelete
const
void
key
void
rootp
int
compar
const
void
const
void
struct
ts_entry
phead
struct
ts_entry
rootp
struct
ts_entry
head
If
a
leaf
is
found
we
have
to
null
a
parent
link
or
the
root
struct
ts_entry
parentp
int
tree_empty
int
did_delete
if
phead
return
NULL
head
phead
if
head
return
NULL
if
head
rlink
return
NULL
parentp
tdelete_inner
key
head
compar
if
tree_empty
head
rlink
head
llink
free
head
phead
return
NULL
ASSERT
head
rlink
non
null
if
did_delete
if
parentp
parentp
head
rlink
return
void
parentp
keyptr
Not
deleted
return
NULL
static
void
dwarf_twalk_inner
struct
ts_entry
p
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
unsigned
level
if
p
llink
p
rlink
action
const
void
p
keyptr
dwarf_leaf
level
return
action
const
void
p
keyptr
dwarf_preorder
level
if
p
llink
dwarf_twalk_inner
p
llink
action
level
action
const
void
p
keyptr
dwarf_postorder
level
if
p
rlink
dwarf_twalk_inner
p
rlink
action
level
action
const
void
p
keyptr
dwarf_endorder
level
void
dwarf_twalk
const
void
rootp
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
const
struct
ts_entry
head
const
struct
ts_entry
rootp
struct
ts_entry
root
if
head
return
root
head
rlink
if
root
return
Get
to
actual
tree
dwarf_twalk_inner
root
action
static
void
dwarf_tdestroy_inner
struct
ts_entry
p
void
free_node
void
nodep
int
depth
if
p
llink
dwarf_tdestroy_inner
p
llink
free_node
depth
p
llink
if
p
rlink
dwarf_tdestroy_inner
p
rlink
free_node
depth
p
rlink
free_node
void
p
keyptr
free
p
Walk
the
tree
freeing
all
space
in
the
tree
and
calling
the
user
s
callback
function
on
each
node
It
is
up
to
the
caller
to
zero
out
anything
pointing
to
head
ie
that
has
the
value
rootp
holds
after
this
returns
void
dwarf_tdestroy
void
rootp
void
free_node
void
nodep
struct
ts_entry
head
struct
ts_entry
rootp
struct
ts_entry
root
if
head
return
root
head
rlink
if
root
dwarf_tdestroy_inner
root
free_node
free
head
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
for
open
ifdef
SYS_TYPES_H
include
sys
types
h
endif
SYS_TYPES_H
ifdef
SYS_STAT_H
include
sys
stat
h
endif
SYS_STAT_H
include
fcntl
h
include
limits
h
ifdef
_WIN32
include
io
h
for
dup2
elif
defined
HAVE_UNISTD_H
include
unistd
h
for
dup2
endif
_WIN32
include
makename
h
include
macrocheck
h
include
dwconf
h
include
dwconf_using_functions
h
include
common
h
include
helpertree
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
tag_common
h
include
addrmap
h
include
attr_form
h
include
print_debug_gnu
h
include
naming
h
for
get_FORM_name
include
libdwarf_version
h
for
DW_VERSION_DATE_STR
include
command_options
h
include
compiler_info
h
ifndef
O_RDONLY
This
is
for
a
Windows
environment
define
O_RDONLY
_O_RDONLY
endif
ifdef
_O_BINARY
This
is
for
a
Windows
environment
define
O_BINARY
_O_BINARY
else
ifndef
O_BINARY
define
O_BINARY
So
it
does
nothing
in
Linux
Unix
endif
endif
O_BINARY
ifdef
HAVE_ELF_OPEN
extern
int
elf_open
const
char
name
int
mode
endif
HAVE_ELF_OPEN
define
BYTES_PER_INSTRUCTION
The
type
of
Bucket
define
KIND_RANGES_INFO
define
KIND_SECTIONS_INFO
define
KIND_VISITED_INFO
Build
section
information
void
build_linkonce_info
Dwarf_Debug
dbg
struct
glflags_s
glflags
Functions
used
to
manage
the
unique
errors
table
static
void
allocate_unique_errors_table
void
static
void
release_unique_errors_table
void
ifdef
TESTING
static
void
dump_unique_errors_table
void
endif
static
Dwarf_Bool
add_to_unique_errors_table
char
error_text
static
struct
esb_s
esb_short_cu_name
static
struct
esb_s
esb_long_cu_name
static
struct
esb_s
dwarf_error_line
static
int
global_basefd
static
int
global_tiedfd
static
struct
esb_s
global_file_name
static
struct
esb_s
global_tied_file_name
static
int
process_one_file
const
char
file_name
const
char
tied_file_name
char
tempbuf
unsigned
int
tempbuflen
struct
dwconf_s
conf
static
int
print_gnu_debuglink
Dwarf_Debug
dbg
Dwarf_Error
err
static
int
open_a_file
const
char
name
Set
to
a
file
number
that
cannot
be
legal
int
fd
if
HAVE_ELF_OPEN
It
is
not
possible
to
share
file
handles
between
applications
or
DLLs
Each
application
has
its
own
file
handle
table
For
two
applications
to
use
the
same
file
using
a
DLL
they
must
both
open
the
file
individually
Let
the
libelf
dll
open
and
close
the
file
fd
elf_open
name
O_RDONLY
O_BINARY
else
fd
open
name
O_RDONLY
O_BINARY
endif
return
fd
static
void
close_a_file
int
f
if
f
close
f
static
void
global_destructors
void
makename_destructor
uri_data_destructor
esb_destructor
esb_destructor
esb_destructor
esb_destructor
glflags
newprogname
esb_destructor
esb_destructor
free_all_dwconf
glflags
config_file_data
sanitized_string_destructor
ranges_esb_string_destructor
Global
flags
initialization
and
esb
buffers
destruction
reset_global_flags
close_a_file
global_basefd
close_a_file
global_tiedfd
ifdef
_WIN32
Close
the
null
device
used
during
formatting
printing
esb_close_null_device
endif
_WIN32
if
glflags
gf_global_debuglink_paths
unsigned
int
i
for
i
glflags
gf_global_debuglink_count
i
free
glflags
gf_global_debuglink_paths
i
glflags
gf_global_debuglink_paths
i
free
glflags
gf_global_debuglink_paths
glflags
gf_global_debuglink_paths
glflags
gf_global_debuglink_count
static
void
check_for_notes
void
long
int
ect
glflags
gf_count_macronotes
const
char
w
was
const
char
e
MACRONOTE
if
ect
return
if
ect
w
were
e
MACRONOTEs
printf
There
s
ld
DWARF
s
reported
see
MACRONOTE
above
n
w
ect
e
static
void
check_for_major_errors
void
long
int
ect
glflags
gf_count_major_errors
const
char
w
was
const
char
e
error
if
ect
return
if
ect
w
were
e
errors
printf
There
s
ld
DWARF
s
reported
see
ERROR
above
n
w
ect
e
static
void
flag_data_pre_allocation
void
memset
glflags
section_high_offsets_global
sizeof
glflags
section_high_offsets_global
If
we
are
checking
debug_line
debug_ranges
debug_aranges
or
debug_loc
build
the
tables
containing
the
pairs
LowPC
and
HighPC
It
is
safer
and
not
expensive
to
build
all
of
these
at
once
so
mistakes
in
options
do
not
lead
to
coredumps
like
ka
p
did
once
if
glflags
gf_check_decl_file
glflags
gf_check_ranges
glflags
gf_check_locations
glflags
gf_do_check_dwarf
glflags
gf_check_self_references
glflags
pRangesInfo
AllocateBucketGroup
KIND_RANGES_INFO
glflags
pLinkonceInfo
AllocateBucketGroup
KIND_SECTIONS_INFO
glflags
pVisitedInfo
AllocateBucketGroup
KIND_VISITED_INFO
Create
the
unique
error
table
if
glflags
gf_print_unique_errors
allocate_unique_errors_table
Allocate
range
array
to
be
used
by
all
CUs
if
glflags
gf_check_ranges
allocate_range_array_info
static
void
flag_data_post_cleanup
void
if
glflags
pRangesInfo
ReleaseBucketGroup
glflags
pRangesInfo
glflags
pRangesInfo
if
glflags
pLinkonceInfo
ReleaseBucketGroup
glflags
pLinkonceInfo
glflags
pLinkonceInfo
if
glflags
pVisitedInfo
ReleaseBucketGroup
glflags
pVisitedInfo
glflags
pVisitedInfo
Release
range
array
to
be
used
by
all
CUs
if
glflags
gf_check_ranges
release_range_array_info
Delete
the
unique
error
set
if
glflags
gf_print_unique_errors
release_unique_errors_table
clean_up_compilers_detected
destruct_abbrev_array
void
_dwarf_alloc_tree_counts
Dwarf_Unsigned
allocount
Dwarf_Unsigned
allosum
Dwarf_Unsigned
treecount
Dwarf_Unsigned
treesum
Dwarf_Unsigned
earlydealloccount
Dwarf_Unsigned
earlydeallocsize
Dwarf_Unsigned
unused1
Dwarf_Unsigned
unused2
Dwarf_Unsigned
unused3
This
intended
for
dwarfdump
testing
only
by
the
developers
It
s
quite
odd
really
See
regressiontests
scripts
analyzedwalloc
py
But
handy
for
some
performance
analysis
static
void
print_libdwarf_alloc_values
const
char
file_name
int
argc
char
argv
Dwarf_Unsigned
alloct
Dwarf_Unsigned
allosum
Dwarf_Unsigned
treect
Dwarf_Unsigned
treesum
Dwarf_Unsigned
earlydelct
Dwarf_Unsigned
earlydelsum
FILE
out
int
i
_dwarf_alloc_tree_counts
out
fopen
libdwallocs
a
if
out
return
fprintf
out
s
file_name
for
i
argc
i
fprintf
out
s
argv
i
fprintf
out
n
fprintf
out
DW_PR_DSd
alloct
fprintf
out
DW_PR_DSd
allosum
fprintf
out
DW_PR_DSd
treect
fprintf
out
DW_PR_DSd
treesum
fprintf
out
DW_PR_DSd
earlydelct
fprintf
out
DW_PR_DSd
earlydelsum
fprintf
out
n
fclose
out
Iterate
through
dwarf
and
print
all
info
int
main
int
argc
char
argv
const
char
file_name
unsigned
ftype
unsigned
endian
unsigned
offsetsize
Dwarf_Unsigned
filesize
int
errcode
char
temp_path_buf
unsigned
temp_path_buf_len
int
res
path_source
will
be
DW_PATHSOURCE_basic
unsigned
char
path_source
DW_PATHSOURCE_unspecified
ifdef
_WIN32
Open
the
null
device
used
during
formatting
printing
if
esb_open_null_device
fprintf
stderr
dwarfdump
Unable
to
open
null
device
n
exit
FAILED
endif
_WIN32
Global
flags
initialization
and
esb
buffers
construction
init_global_flags
set_checks_off
uri_data_constructor
esb_constructor
esb_constructor
esb_constructor
ifdef
_WIN32
Often
we
redirect
the
output
to
a
file
but
we
have
found
issues
due
to
the
buffering
associated
with
stdout
Some
issues
were
fixed
just
by
the
use
of
fflush
but
the
main
issued
remained
The
stdout
stream
is
buffered
so
will
only
display
what
s
in
the
buffer
after
it
reaches
a
newline
or
when
it
s
told
to
We
have
a
few
options
to
print
immediately
Print
to
stderr
instead
using
fprintf
Print
to
stdout
and
flush
stdout
whenever
we
need
it
to
using
fflush
We
can
also
disable
buffering
on
stdout
by
using
setbuf
setbuf
stdout
NULL
Make
stdout
unbuffered
this
seems
to
work
for
all
cases
The
problem
is
no
longer
present
Now
for
practical
purposes
there
is
no
stderr
output
all
is
stdout
September
Calling
setbuf
with
NULL
argument
it
turns
off
all
buffering
for
the
specified
stream
Then
writing
to
and
or
reading
from
the
stream
will
be
exactly
as
directed
by
the
program
But
if
dwarfdump
is
used
over
a
network
drive
it
shows
a
dramatic
slowdown
when
sending
the
output
to
a
file
An
operation
that
takes
couple
of
seconds
it
was
taking
few
hours
setbuf
stdout
NULL
Redirect
stderr
to
stdout
dup2
fileno
stdout
fileno
stderr
endif
_WIN32
print_version_details
argv
FALSE
file_name
process_args
argc
argv
print_args
argc
argv
Redirect
stdout
and
stderr
to
an
specific
file
if
glflags
output_file
if
NULL
freopen
glflags
output_file
w
stdout
fprintf
stderr
dwarfdump
Unable
to
redirect
output
to
s
n
glflags
output_file
global_destructors
exit
FAILED
dup2
fileno
stdout
fileno
stderr
Record
version
and
arguments
in
the
output
file
print_version_details
argv
FALSE
print_args
argc
argv
Allow
the
user
to
hide
some
warnings
by
using
command
line
options
Dwarf_Cmdline_Options
wcmd
The
struct
has
just
one
field
wcmd
check_verbose_mode
glflags
gf_check_verbose_mode
dwarf_record_cmdline_options
wcmd
BEGIN
FINDING
NAMES
AND
OPENING
FDs
The
etc
is
more
than
suffices
for
the
expansion
that
a
MacOS
dsym
or
a
GNU
debuglink
might
need
we
hope
temp_path_buf_len
strlen
file_name
temp_path_buf
malloc
temp_path_buf_len
if
temp_path_buf
fprintf
stderr
s
ERROR
Unable
to
malloc
lu
bytes
for
possible
path
string
s
n
glflags
program_name
unsigned
long
temp_path_buf_len
file_name
return
FAILED
temp_path_buf
This
data
scan
is
to
find
Elf
objects
and
unknown
objects
early
If
the
user
asks
for
libelf
with
certain
options
that
will
rule
out
handling
GNU_debuglink
on
that
object
This
does
not
concern
itself
with
dSYM
or
debuglink
at
all
res
dwarf_object_detector_path_b
file_name
if
res
DW_DLV_OK
fprintf
stderr
s
ERROR
Can
t
open
s
n
glflags
program_name
sanitized
file_name
global_destructors
free
temp_path_buf
return
FAILED
esb_append
file_name
temp_path_buf
global_basefd
open_a_file
esb_get_string
if
global_basefd
fprintf
stderr
s
ERROR
can
t
open
s
n
glflags
program_name
esb_get_string
global_destructors
free
temp_path_buf
return
FAILED
if
esb_string_len
glflags
config_file_tiedpath
unsigned
tftype
unsigned
tendian
unsigned
toffsetsize
Dwarf_Unsigned
tfilesize
const
char
tied_file_name
path_source
will
be
DW_PATHSOURCE_basic
unsigned
char
tpath_source
temp_path_buf
tied_file_name
esb_get_string
glflags
config_file_tiedpath
A
genuine
tiedpath
cannot
be
dsym
or
debuglink
res
dwarf_object_detector_path_b
tied_file_name
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
char
errmsg
dwarf_errmsg_by_number
errcode
fprintf
stderr
s
ERROR
can
t
open
tied
file
s
s
n
glflags
program_name
sanitized
tied_file_name
errmsg
else
fprintf
stderr
s
ERROR
tied
file
not
an
object
file
s
n
glflags
program_name
sanitized
tied_file_name
global_destructors
free
temp_path_buf
return
FAILED
if
ftype
tftype
endian
tendian
offsetsize
toffsetsize
fprintf
stderr
s
ERROR
tied
file
s
and
main
file
s
not
the
same
kind
of
object
n
glflags
program_name
sanitized
tied_file_name
esb_get_string
free
temp_path_buf
global_destructors
return
FAILED
esb_append
tied_file_name
global_tiedfd
open_a_file
esb_get_string
if
global_tiedfd
fprintf
stderr
s
ERROR
can
t
open
tied
file
s
n
glflags
program_name
sanitized
esb_get_string
global_destructors
free
temp_path_buf
return
FAILED
end
FINDING
NAMES
AND
OPENING
FDs
temp_path_buf
BEGIN
PROCESSING
OBJECT
FILES
BY
TYPE
if
ftype
DW_FTYPE_ELF
glflags
gf_reloc_flag
glflags
gf_header_flag
ftype
DW_FTYPE_ARCHIVE
fprintf
stderr
Can
t
process
s
archives
and
printing
elf
headers
not
supported
in
this
dwarfdump
disable
libelf
build
n
file_name
else
if
ftype
DW_FTYPE_ELF
ftype
DW_FTYPE_MACH_O
ftype
DW_FTYPE_PE
flag_data_pre_allocation
close_a_file
global_basefd
global_basefd
close_a_file
global_tiedfd
global_tiedfd
process_one_file
esb_get_string
esb_get_string
temp_path_buf
temp_path_buf_len
glflags
config_file_data
flag_data_post_cleanup
else
fprintf
stderr
Can
t
process
s
unhandled
format
n
file_name
free
temp_path_buf
temp_path_buf
temp_path_buf_len
if
glflags
gf_print_alloc_sums
print_libdwarf_alloc_values
file_name
argc
argv
END
PROCESSING
OBJECT
FILES
BY
TYPE
These
cleanups
only
necessary
once
all
objects
processed
ifdef
HAVE_REGEX
if
glflags
search_regex_text
regfree
glflags
search_re
endif
In
case
of
a
serious
DWARF
error
we
try
to
get
here
we
try
not
to
exit
by
using
print_error
check_for_major_errors
check_for_notes
flag_data_post_cleanup
global_destructors
free
temp_path_buf
As
the
tool
have
reached
this
point
it
means
there
are
no
internal
errors
and
we
should
return
an
OKAY
condition
regardless
if
the
file
being
processed
has
minor
errors
return
OKAY
void
print_any_harmless_errors
Dwarf_Debug
dbg
define
LOCAL_PTR_ARY_COUNT
We
do
not
need
to
initialize
the
local
array
libdwarf
does
it
const
char
buf
LOCAL_PTR_ARY_COUNT
unsigned
totalcount
unsigned
i
unsigned
printcount
int
res
dwarf_get_harmless_error_list
dbg
LOCAL_PTR_ARY_COUNT
buf
if
res
DW_DLV_NO_ENTRY
return
if
totalcount
printf
n
HARMLESS
ERROR
COUNT
u
n
totalcount
for
i
buf
i
i
printcount
DWARF_CHECK_COUNT
harmless_result
DWARF_CHECK_ERROR
harmless_result
buf
i
if
totalcount
printcount
harmless_result
checks
totalcount
printcount
DWARF_CHECK_COUNT
harmless_result
totalcount
printcount
harmless_result
errors
totalcount
printcount
DWARF_ERROR_COUNT
harmless_result
totalcount
printcount
Print
a
summary
of
search
results
static
void
print_search_results
void
const
char
search_type
const
char
search_text
if
glflags
search_any_text
search_type
any
search_text
glflags
search_any_text
else
if
glflags
search_match_text
search_type
match
search_text
glflags
search_match_text
else
search_type
regex
search_text
glflags
search_regex_text
fflush
stdout
fflush
stderr
printf
nSearch
type
s
n
search_type
printf
Pattern
searched
s
n
search_text
printf
Occurrences
Found
d
n
glflags
search_occurrences
fflush
stdout
This
is
for
dwarf_print_lines
static
void
printf_callback_for_libdwarf
void
userdata
UNUSEDARG
const
char
data
printf
s
sanitized
data
int
get_address_size_and_max
Dwarf_Debug
dbg
Dwarf_Half
size
Dwarf_Addr
max
Dwarf_Error
aerr
int
dres
Dwarf_Half
lsize
Get
address
size
and
largest
representable
address
dres
dwarf_get_address_size
dbg
aerr
if
dres
DW_DLV_OK
return
dres
if
max
max
lsize
if
size
size
lsize
return
DW_DLV_OK
dbg
is
often
null
when
dbgtied
was
passed
in
static
void
dbgsetup
Dwarf_Debug
dbg
struct
dwconf_s
setup_config_file_data
if
dbg
return
dwarf_set_frame_rule_initial_value
dbg
setup_config_file_data
cf_initial_rule_value
dwarf_set_frame_rule_table_size
dbg
setup_config_file_data
cf_table_entry_count
dwarf_set_frame_cfa_value
dbg
setup_config_file_data
cf_cfa_reg
dwarf_set_frame_same_value
dbg
setup_config_file_data
cf_same_val
dwarf_set_frame_undefined_value
dbg
setup_config_file_data
cf_undefined_val
if
setup_config_file_data
cf_address_size
dwarf_set_default_address_size
dbg
setup_config_file_data
cf_address_size
dwarf_set_harmless_error_list_size
dbg
Callable
at
any
time
Sets
section
sizes
with
the
sizes
known
as
of
the
call
Repeat
whenever
about
to
reference
a
size
that
might
not
have
been
set
as
of
the
last
call
static
void
set_global_section_sizes
Dwarf_Debug
dbg
dwarf_get_section_max_offsets_d
dbg
section_high_offsets_global
debug_info_size
section_high_offsets_global
debug_abbrev_size
section_high_offsets_global
debug_line_size
section_high_offsets_global
debug_loc_size
section_high_offsets_global
debug_aranges_size
section_high_offsets_global
debug_macinfo_size
section_high_offsets_global
debug_pubnames_size
section_high_offsets_global
debug_str_size
section_high_offsets_global
debug_frame_size
section_high_offsets_global
debug_ranges_size
section_high_offsets_global
debug_pubtypes_size
section_high_offsets_global
debug_types_size
section_high_offsets_global
debug_macro_size
section_high_offsets_global
debug_str_offsets_size
section_high_offsets_global
debug_sup_size
section_high_offsets_global
debug_cu_index_size
section_high_offsets_global
debug_tu_index_size
section_high_offsets_global
debug_names_size
section_high_offsets_global
debug_loclists_size
section_high_offsets_global
debug_rnglists_size
Set
limits
for
Ranges
Information
The
linker
may
put
parts
of
the
text
code
in
additional
sections
such
as
init
fini
__libc_freeres_fn
rodata
__libc_subfreeres
__libc_atexit
too
define
LIKELYNAMESMAX
static
const
char
likely_ns
LIKELYNAMESMAX
text
is
first
as
it
is
often
the
only
thing
See
below
init
text
fini
define
ORIGLKLYTEXTINDEX
struct
likely_names_s
const
char
name
int
origindex
Dwarf_Unsigned
low
Dwarf_Unsigned
size
Dwarf_Unsigned
end
static
struct
likely_names_s
likely_names
LIKELYNAMESMAX
if
FOR
DEBUG
ONLY
static
void
printlnrec
const
char
msg
struct
likely_names_s
ln
int
line
char
fn
printf
s
name
s
origindx
d
low
lx
size
lx
end
lx
line
d
s
n
msg
ln
name
ln
origindex
unsigned
long
ln
low
unsigned
long
ln
size
unsigned
long
ln
end
line
fn
endif
static
int
likelycmp
const
void
l_in
const
void
r_in
struct
likely_names_s
l
struct
likely_names_s
l_in
struct
likely_names_s
r
struct
likely_names_s
r_in
if
l
low
r
low
return
if
l
low
r
low
return
if
l
end
r
end
return
if
l
end
r
end
return
return
This
is
a
bit
slow
but
happens
only
once
for
a
dbg
It
is
not
as
much
help
as
I
expected
in
avoiding
line
table
content
CHECK
warnings
because
so
far
those
come
from
init
csu
code
and
the
DWARF
has
no
subprogram
information
nor
any
high
low
pc
information
at
all
static
int
calculate_likely_limits_of_code
Dwarf_Debug
dbg
Dwarf_Unsigned
lower
Dwarf_Unsigned
size
struct
likely_names_s
ln
int
ct
Dwarf_Unsigned
baselow
Dwarf_Unsigned
basesize
Dwarf_Unsigned
baseend
int
lnindex
int
lncount
memset
likely_names
sizeof
likely_names
for
ct
ct
LIKELYNAMESMAX
ct
Dwarf_Unsigned
clow
Dwarf_Unsigned
csize
int
res
Dwarf_Error
err
const
char
name
likely_ns
ct
ln
likely_names
lnindex
res
dwarf_get_section_info_by_name
dbg
name
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
err
if
ct
ORIGLKLYTEXTINDEX
return
DW_DLV_NO_ENTRY
continue
if
res
DW_DLV_NO_ENTRY
if
ct
ORIGLKLYTEXTINDEX
return
DW_DLV_NO_ENTRY
continue
ln
name
name
ln
low
clow
ln
size
csize
ln
end
csize
clow
ln
origindex
ct
if
ct
ORIGLKLYTEXTINDEX
basesize
csize
baselow
clow
baseend
csize
clow
lnindex
if
lnindex
return
DW_DLV_NO_ENTRY
if
lnindex
lower
baselow
size
basesize
return
DW_DLV_OK
lncount
lnindex
qsort
likely_names
lncount
sizeof
struct
likely_names_s
likelycmp
ln
likely_names
baselow
ln
low
basesize
ln
size
baseend
ln
end
for
lnindex
lnindex
lncount
lnindex
ln
likely_names
lnindex
if
ln
end
baseend
baseend
ln
end
basesize
baseend
baselow
lower
baselow
size
basesize
return
DW_DLV_OK
Given
a
file
which
is
an
object
type
we
think
we
can
read
process
the
dwarf
data
static
int
process_one_file
const
char
file_name
const
char
tied_file_name
char
temp_path_buf
unsigned
int
temp_path_buf_len
struct
dwconf_s
l_config_file_data
Dwarf_Debug
dbg
Dwarf_Debug
dbgtied
int
dres
struct
Dwarf_Printf_Callback_Info_s
printfcallbackdata
Dwarf_Half
elf_address_size
Target
pointer
size
Dwarf_Error
onef_err
const
char
title
unsigned
char
path_source
int
localerrno
If
using
a
tied
file
group
number
should
be
DW_GROUPNUMBER_DWO
but
in
a
dwp
or
separate
split
dwarf
object
then
will
find
the
dwo
data
automatically
This
will
go
for
the
real
main
file
whether
an
underlying
dSYM
or
via
debuglink
or
if
those
find
nothing
then
the
original
char
tb
temp_path_buf
unsigned
tblen
temp_path_buf_len
title
dwarf_init_path_dl
fails
exit
dwarfdump
if
glflags
gf_no_follow_debuglink
tb
tblen
dres
dwarf_init_path_dl
file_name
tb
tblen
glflags
group_number
NULL
NULL
glflags
gf_global_debuglink_paths
glflags
gf_global_debuglink_count
if
dres
DW_DLV_NO_ENTRY
if
glflags
group_number
printf
No
DWARF
information
present
in
s
for
section
group
d
n
file_name
glflags
group_number
else
printf
No
DWARF
information
present
in
s
n
file_name
return
dres
if
dres
DW_DLV_ERROR
Prints
error
cleans
up
Dwarf_Error
data
Never
returns
print_error_and_continue
dbg
title
dres
onef_err
DROP_ERROR_INSTANCE
dbg
dres
onef_err
return
DW_DLV_ERROR
if
path_source
DW_PATHSOURCE_dsym
printf
Filename
by
dSYM
is
s
n
sanitized
temp_path_buf
else
if
path_source
DW_PATHSOURCE_debuglink
printf
Filename
by
debuglink
is
s
n
sanitized
temp_path_buf
glflags
gf_gnu_debuglink_flag
TRUE
if
tied_file_name
strlen
tied_file_name
The
tied
file
we
define
as
group
BASE
Cannot
follow
debuglink
or
dSYM
is
a
tied
file
dres
dwarf_init_path
tied_file_name
ignore
dSYM
debuglink
DW_GROUPNUMBER_BASE
path_source
DW_PATHSOURCE_basic
if
dres
DW_DLV_NO_ENTRY
printf
No
DWARF
information
present
in
tied
file
s
n
tied_file_name
return
dres
if
dres
DW_DLV_ERROR
Prints
error
cleans
up
Dwarf_Error
data
Never
returns
print_error
dbg
dwarf_init_path
on
tied_file
dres
onef_err
memset
sizeof
printfcallbackdata
printfcallbackdata
dp_fptr
printf_callback_for_libdwarf
dwarf_register_printf_callback
dbg
if
dbgtied
dwarf_register_printf_callback
dbgtied
memset
sizeof
printfcallbackdata
dbgsetup
dbg
l_config_file_data
dbgsetup
dbgtied
l_config_file_data
dres
get_address_size_and_max
dbg
if
dres
DW_DLV_OK
print_error
dbg
Unable
to
read
address
size
so
unable
to
continue
dres
onef_err
if
glflags
gf_check_tag_attr
glflags
gf_print_usage_tag_attr
dres
build_attr_form_base_tree
if
dres
DW_DLV_OK
simple_err_return_msg_either_action
dres
ERROR
Failed
to
initialize
attribute
form
tables
properly
Ok
for
dbgtied
to
be
NULL
dres
dwarf_set_tied_dbg
dbg
dbgtied
if
dres
DW_DLV_OK
print_error
dbg
dwarf_set_tied_dbg
failed
dres
onef_err
Get
text
and
debug_ranges
info
if
in
check
mode
if
glflags
gf_do_check_dwarf
Dwarf_Addr
lower
Dwarf_Addr
upper
Dwarf_Unsigned
size
Dwarf_Debug
dbg_with_code
dbg
int
res
if
dbgtied
Assuming
tied
is
exectuable
main
is
dwo
dwp
dbg_with_code
dbgtied
res
calculate_likely_limits_of_code
dbg_with_code
upper
lower
size
Set
limits
for
Ranges
Information
Some
objects
have
CUs
for
startup
code
and
the
expanded
range
here
turns
out
not
to
actually
help
if
res
DW_DLV_OK
glflags
pRangesInfo
SetLimitsBucketGroup
glflags
pRangesInfo
lower
upper
AddEntryIntoBucketGroup
glflags
pRangesInfo
lower
lower
upper
text
TRUE
Build
section
information
linkonce
is
an
SNR
thing
we
build_linkonce_info
dbg
if
glflags
gf_section_groups_flag
int
res
Dwarf_Error
err
res
print_section_groups_data
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
section
groups
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
If
groupnum
this
turns
off
some
of
the
gf_flags
here
so
we
don
t
print
section
names
of
things
we
do
not
want
to
print
update_section_flags_per_groups
dbg
reset_overall_CU_error_data
if
glflags
gf_info_flag
glflags
gf_line_flag
glflags
gf_types_flag
glflags
gf_check_macros
glflags
gf_macinfo_flag
glflags
gf_macro_flag
glflags
gf_cu_name_flag
glflags
gf_search_is_on
glflags
gf_producer_children_flag
Dwarf_Error
err
int
res
reset_overall_CU_error_data
res
print_infos
dbg
TRUE
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
debug_info
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
reset_overall_CU_error_data
res
print_infos
dbg
FALSE
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
debug_types
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
set_global_section_sizes
dbg
The
statistics
are
for
ALL
of
the
DWARF5
and
DWARF4
with
debug_macro
across
all
CUs
if
macro_check_tree
debug_macro_size
is
to
check
the
section
end
print_macrocheck_statistics
DWARF5
debug_macro
DWARF5
TRUE
glflags
section_high_offsets_global
debug_macro_size
if
glflags
gf_check_macros
if
macinfo_check_tree
debug_macinfo_size
is
to
check
the
section
end
print_macrocheck_statistics
DWARF2
debug_macinfo
DWARF5
FALSE
glflags
section_high_offsets_global
debug_macinfo_size
clear_macrocheck_statistics
clear_macrocheck_statistics
if
glflags
gf_gdbindex_flag
int
res
Dwarf_Error
err
reset_overall_CU_error_data
By
definition
if
gdb_index
is
present
then
cu
and
tu
will
not
be
And
vice
versa
res
print_gdb_index
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
gdb
index
section
had
a
problem
res
err
res
print_debugfission_index
dbg
cu
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
debugfission
cu
section
had
a
problem
res
err
res
print_debugfission_index
dbg
tu
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
debugfission
tu
section
had
a
problem
res
err
if
glflags
gf_pubnames_flag
int
res
Dwarf_Error
err
reset_overall_CU_error_data
res
print_pubnames
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
pubnames
data
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_abbrev_flag
Dwarf_Error
err
int
res
reset_overall_CU_error_data
res
print_abbrevs
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
debug_abbrev
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_string_flag
Dwarf_Error
err
int
res
reset_overall_CU_error_data
res
print_strings
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
debug_str
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_aranges_flag
Dwarf_Error
err
int
res
reset_overall_CU_error_data
res
print_aranges
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
aranges
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_ranges_flag
int
res
Dwarf_Error
err
reset_overall_CU_error_data
res
print_ranges
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
ranges
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_print_raw_loclists
int
res
Dwarf_Error
err
reset_overall_CU_error_data
res
print_raw_all_loclists
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
raw
debug_loclists
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_print_raw_rnglists
int
res
Dwarf_Error
err
reset_overall_CU_error_data
res
print_raw_all_rnglists
dbg
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
printing
the
raw
debug_rnglists
section
had
a
problem
res
err
DROP_ERROR_INSTANCE
dbg
res
err
if
glflags
gf_frame_flag
glflags
gf_eh_frame_flag
int
sres
Dwarf_Error
err
int
want_eh
These
three
shared
eh_frame
and
debug_frame
as
they
are
about
the
DIEs
not
about
frames
Dwarf_Die
cu_die_for_print_frames
void
map_lowpc_to_name
void
lowpcSet
reset_overall_CU_error_data
if
glflags
gf_frame_flag
want_eh
sres
print_frames
dbg
want_eh
l_config_file_data
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
standard
frame
data
had
a
problem
sres
err
DROP_ERROR_INSTANCE
dbg
sres
err
if
glflags
gf_eh_frame_flag
want_eh
sres
print_frames
dbg
want_eh
l_config_file_data
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
eh
frame
data
had
a
problem
sres
err
DROP_ERROR_INSTANCE
dbg
sres
err
addr_map_destroy
lowpcSet
addr_map_destroy
map_lowpc_to_name
if
cu_die_for_print_frames
dwarf_dealloc_die
cu_die_for_print_frames
if
glflags
gf_static_func_flag
int
sres
Dwarf_Error
err
reset_overall_CU_error_data
sres
print_static_funcs
dbg
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
SGI
static
funcs
had
a
problem
sres
err
DROP_ERROR_INSTANCE
dbg
sres
err
if
glflags
gf_static_var_flag
int
sres
Dwarf_Error
err
reset_overall_CU_error_data
sres
print_static_vars
dbg
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
SGI
static
vars
had
a
problem
sres
err
DROP_ERROR_INSTANCE
dbg
sres
err
DWARF_PUBTYPES
is
the
standard
typenames
dwarf
section
SGI_TYPENAME
is
the
same
concept
but
is
SGI
specific
it
was
defined
years
before
dwarf
pubtypes
if
glflags
gf_pubtypes_flag
Dwarf_Error
err
int
tres
reset_overall_CU_error_data
tres
print_types
dbg
DWARF_PUBTYPES
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
pubtypes
had
a
problem
tres
err
DROP_ERROR_INSTANCE
dbg
tres
err
reset_overall_CU_error_data
tres
print_types
dbg
SGI_TYPENAME
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
printing
SGI
typenames
had
a
problem
tres
err
DROP_ERROR_INSTANCE
dbg
tres
err
if
glflags
gf_weakname_flag
Dwarf_Error
err
int
res3
reset_overall_CU_error_data
res3
print_weaknames
dbg
if
res3
DW_DLV_ERROR
print_error_and_continue
dbg
printing
weaknames
had
a
problem
res3
err
DROP_ERROR_INSTANCE
dbg
res3
err
if
glflags
gf_reloc_flag
Harmless
though
likely
not
needed
here
reset_overall_CU_error_data
if
glflags
gf_debug_names_flag
int
nres
Dwarf_Error
err
reset_overall_CU_error_data
nres
print_debug_names
dbg
if
nres
DW_DLV_ERROR
print_error_and_continue
dbg
print
debug_names
section
failed
nres
err
DROP_ERROR_INSTANCE
dbg
nres
err
Print
search
results
if
glflags
gf_search_print_results
glflags
gf_search_is_on
No
dwarf
errors
possible
in
this
function
print_search_results
The
right
time
to
do
this
is
unclear
But
we
need
to
do
it
if
glflags
gf_check_harmless
No
dwarf
errors
possible
in
this
function
print_any_harmless_errors
dbg
Print
error
report
only
if
errors
have
been
detected
Print
error
report
if
the
kd
option
No
errors
possible
in
this
function
print_checks_results
Print
the
detailed
attribute
usage
space
and
free
the
attributes_encoding
data
allocated
Option
kE
Also
prints
the
attr
formclass
form
reports
from
attr_form
c
See
build_attr_form_base
call
above
and
record_attr_form_use
in
print_die
c
if
glflags
gf_check_attr_encoding
int
ares
Dwarf_Error
aerr
ares
print_attributes_encoding
dbg
if
ares
DW_DLV_ERROR
print_error_and_continue
dbg
print
attributes
encoding
failed
ares
aerr
DROP_ERROR_INSTANCE
dbg
ares
aerr
Print
the
tags
and
attribute
usage
ku
or
kuf
if
glflags
gf_print_usage_tag_attr
int
tres
Dwarf_Error
err
tres
print_tag_attributes_usage
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
print
tag
attributes
usage
failed
tres
err
DROP_ERROR_INSTANCE
dbg
tres
err
if
glflags
gf_print_str_offsets
print
the
debug_str_offsets
section
if
any
int
lres
Dwarf_Error
err
lres
print_str_offsets_section
dbg
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
print
debug_str_offsets
failed
lres
err
DROP_ERROR_INSTANCE
dbg
lres
err
prints
nothing
unless
section
gnu_debuglink
is
present
Lets
print
for
a
few
critical
sections
if
glflags
gf_gnu_debuglink_flag
int
lres
Dwarf_Error
err
lres
print_gnu_debuglink
dbg
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
print
gnu_debuglink
data
failed
lres
err
DROP_ERROR_INSTANCE
dbg
lres
err
if
glflags
gf_debug_gnu_flag
int
lres
Dwarf_Error
err
lres
print_debug_gnu
dbg
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
print
debug_gnu
section
failed
lres
err
DROP_ERROR_INSTANCE
dbg
lres
err
if
glflags
gf_debug_sup_flag
int
lres
Dwarf_Error
err
lres
print_debug_sup
dbg
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
print
debug_sup
section
failed
lres
err
DROP_ERROR_INSTANCE
dbg
lres
err
if
glflags
gf_debug_addr_missing
printf
nERROR
At
some
point
the
debug_addr
section
was
needed
but
missing
meaning
some
frame
information
was
missing
relevant
function
names
See
the
dwarfdump
option
file
tied
path
to
executable
glflags
gf_count_major_errors
if
glflags
gf_error_code_search_by_address
printf
nERROR
At
some
point
There
was
some
data
corruption
in
frame
data
so
at
least
the
following
error
occurred
s
n
dwarf_errmsg_by_number
glflags
gf_error_code_search_by_address
glflags
gf_count_major_errors
Could
finish
dbg
first
Either
order
ok
if
dbgtied
dres
dwarf_finish
dbgtied
if
dres
DW_DLV_OK
print_error_and_continue
dbg
dwarf_finish
failed
on
tied
dbg
dres
onef_err
DROP_ERROR_INSTANCE
dbg
dres
onef_err
dbgtied
groups_restore_subsidiary_flags
dres
dwarf_finish
dbg
if
dres
DW_DLV_OK
print_error_and_continue
dbg
dwarf_finish
failed
dres
onef_err
DROP_ERROR_INSTANCE
dbg
dres
onef_err
dbg
printf
n
destroy_attr_form_trees
destruct_abbrev_array
esb_close_null_device
release_range_array_info
helpertree_clear_statistics
helpertree_clear_statistics
return
Generic
constants
for
debugging
define
DUMP_RANGES_INFO
Dump
RangesInfo
Table
Dump
Location
debug_loc
Info
define
DUMP_LOCATION_SECTION_INFO
Dump
Ranges
debug_ranges
Info
define
DUMP_RANGES_SECTION_INFO
define
DUMP_LINKONCE_INFO
Dump
Linkonce
Table
define
DUMP_VISITED_INFO
Dump
Visited
Info
START
of
dwarfdump
error
print
functions
int
simple_err_return_msg_either_action
int
res
const
char
msg
const
char
etype
No
entry
if
res
DW_DLV_ERROR
etype
Major
error
glflags
gf_count_major_errors
printf
s
fails
s
n
msg
etype
return
res
int
simple_err_return_action
int
res
const
char
msg
if
res
DW_DLV_ERROR
const
char
etype
Major
error
glflags
gf_count_major_errors
printf
s
s
n
msg
etype
return
res
int
simple_err_only_return_action
int
res
const
char
msg
const
char
etype
Major
error
const
char
msg
nERROR
dwarf_get_address_size
fails
glflags
gf_count_major_errors
printf
s
s
n
msg
etype
return
res
ARGSUSED
static
void
print_error_maybe_continue
Dwarf_Debug
dbg
UNUSEDARG
const
char
msg
int
dwarf_ret_val
Dwarf_Error
lerr
Dwarf_Bool
do_continue
unsigned
long
realmajorerr
glflags
gf_count_major_errors
printf
n
if
dwarf_ret_val
DW_DLV_ERROR
We
do
not
dwarf_dealloc
the
error
here
char
errmsg
dwarf_errmsg
lerr
We
now
April
guarantee
the
error
number
is
in
the
error
string
so
we
do
not
need
to
print
the
dwarf_errno
value
to
show
the
number
if
do_continue
printf
s
ERROR
s
s
Attempting
to
continue
n
glflags
program_name
msg
errmsg
else
printf
s
ERROR
s
s
n
glflags
program_name
msg
errmsg
else
if
dwarf_ret_val
DW_DLV_NO_ENTRY
printf
s
NO
ENTRY
s
n
glflags
program_name
msg
else
if
dwarf_ret_val
DW_DLV_OK
printf
s
s
n
glflags
program_name
msg
else
printf
s
InternalError
s
code
d
n
glflags
program_name
msg
dwarf_ret_val
Display
compile
unit
name
PRINT_CU_INFO
glflags
gf_count_major_errors
realmajorerr
void
print_error
Dwarf_Debug
dbg
const
char
msg
int
dwarf_ret_val
Dwarf_Error
lerr
print_error_maybe_continue
dbg
msg
dwarf_ret_val
lerr
FALSE
glflags
gf_count_major_errors
if
dwarf_ret_val
DW_DLV_ERROR
Dwarf_Error
ignored_err
If
dbg
was
never
initialized
this
still
cleans
up
the
Error
data
DROP_ERROR_INSTANCE
dbg
dwarf_ret_val
lerr
dwarf_finish
dbg
check_for_major_errors
check_for_notes
global_destructors
flag_data_post_cleanup
destroy_attr_form_trees
exit
FAILED
ARGSUSED
void
print_error_and_continue
Dwarf_Debug
dbg
const
char
msg
int
dwarf_ret_val
Dwarf_Error
lerr
glflags
gf_count_major_errors
print_error_maybe_continue
dbg
msg
dwarf_ret_val
lerr
TRUE
END
of
dwarfdump
error
print
functions
static
Dwarf_Bool
is_a_string_form
int
sf
switch
sf
case
DW_FORM_string
case
DW_FORM_GNU_strp_alt
case
DW_FORM_strp_sup
case
DW_FORM_GNU_str_index
case
DW_FORM_strx
case
DW_FORM_strx1
case
DW_FORM_strx2
case
DW_FORM_strx3
case
DW_FORM_strx4
case
DW_FORM_strp
case
DW_FORM_line_strp
There
is
some
hope
we
can
actually
get
the
string
itself
depending
on
other
factors
return
TRUE
Nope
No
string
is
possible
return
FALSE
Always
sets
the
return
argument
should_skip
whether
it
returns
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
or
DW_DLV_OK
determines
if
the
CU
should
be
skipped
as
the
DW_AT_name
of
the
CU
does
not
match
the
command
line
supplied
cu
name
The
two
callers
ignore
the
return
value
This
suppresses
any
errors
it
finds
no
Dwarf_Error
is
lost
and
none
is
returned
int
should_skip_this_cu
Dwarf_Debug
dbg
Dwarf_Bool
should_skip
Dwarf_Die
cu_die
Dwarf_Half
tag
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Error
skperr
int
dares
int
tres
int
fres
tres
dwarf_tag
cu_die
if
tres
DW_DLV_OK
print_error_and_continue
dbg
ERROR
Cannot
get
the
TAG
of
the
cu_die
to
check
if
we
should
skip
this
CU
or
not
tres
skperr
should_skip
FALSE
DROP_ERROR_INSTANCE
dbg
tres
skperr
return
tres
dares
dwarf_attr
cu_die
DW_AT_name
if
dares
DW_DLV_OK
print_error_and_continue
dbg
should
skip
this
cu?
cu
die
has
no
DW_AT_name
attribute
dares
skperr
should_skip
FALSE
DROP_ERROR_INSTANCE
dbg
dares
skperr
return
dares
fres
dwarf_whatform
attrib
if
fres
DW_DLV_OK
if
is_a_string_form
theform
char
temps
int
sres
dwarf_formstring
attrib
if
sres
DW_DLV_OK
char
lcun
esb_get_string
glflags
cu_name
char
p
temps
if
lcun
p
strrchr
temps
if
p
NULL
p
temps
else
p
Ignore
case
if
Windows
if
_WIN32
if
stricmp
lcun
p
skip
this
cu
dwarf_dealloc_attribute
attrib
should_skip
TRUE
return
DW_DLV_OK
else
if
strcmp
lcun
p
skip
this
cu
dwarf_dealloc_attribute
attrib
should_skip
TRUE
return
DW_DLV_OK
endif
_WIN32
else
if
sres
DW_DLV_ERROR
struct
esb_s
m
int
dwarf_names_print_on_error
dwarf_dealloc_attribute
attrib
esb_constructor
esb_append
In
determining
if
we
should
skip
this
CU
dwarf_formstring
gets
an
error
on
form
esb_append
get_FORM_name
theform
dwarf_names_print_on_error
esb_append
print_error_and_continue
dbg
esb_get_string
sres
skperr
should_skip
FALSE
esb_destructor
return
sres
else
DW_DLV_NO_ENTRY
on
the
string
itself
dwarf_dealloc_attribute
attrib
should_skip
FALSE
return
sres
else
if
fres
DW_DLV_ERROR
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_whatform
failed
on
a
CU_die
when
attempting
to
determine
if
this
CU
should
be
skipped
fres
skperr
else
DW_DLV_NO_ENTRY
dwarf_dealloc_attribute
attrib
should_skip
FALSE
return
fres
Returns
the
cu
of
the
CUn
the
name
fields
when
it
can
else
a
no
entry
else
DW_DLV_ERROR
int
get_cu_name
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Off
dieprint_cu_offset
char
short_name
char
long_name
Dwarf_Error
lerr
Dwarf_Attribute
name_attr
int
ares
ares
dwarf_attr
cu_die
DW_AT_name
lerr
if
ares
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_attr
fails
on
DW_AT_name
on
the
CU
die
ares
lerr
return
ares
else
if
ares
DW_DLV_NO_ENTRY
short_name
unknown
name
long_name
unknown
name
else
DW_DLV_OK
The
string
return
is
valid
until
the
next
call
to
this
function
so
if
the
caller
needs
to
keep
the
returned
string
the
string
must
be
copied
makename
char
filename
esb_empty_string
ares
get_attr_value
dbg
DW_TAG_compile_unit
cu_die
die_indent
dieprint_cu_offset
name_attr
NULL
show_form_used
verbose
lerr
if
ares
DW_DLV_OK
short_name
unknown
name
long_name
unknown
name
return
ares
long_name
esb_get_string
Generate
the
short
name
filename
filename
strrchr
long_name
if
filename
filename
strrchr
long_name
if
filename
filename
else
filename
long_name
esb_empty_string
esb_append
filename
short_name
esb_get_string
dwarf_dealloc_attribute
name_attr
return
ares
Returns
the
producer
of
the
CU
Caller
must
ensure
producernameout
is
a
valid
constructed
empty
esb_s
instance
before
calling
int
get_producer_name
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Off
dieprint_cu_offset
struct
esb_s
producernameout
Dwarf_Error
err
Dwarf_Attribute
producer_attr
int
ares
See
also
glflags
c
for
unknown
as
default
producer
string
if
cu_die
glflags
gf_count_major_errors
esb_append
producernameout
ERROR
CU
missing
DW_AT_producer
null
cu_die
return
DW_DLV_NO_ENTRY
ares
dwarf_attr
cu_die
DW_AT_producer
err
if
ares
DW_DLV_ERROR
glflags
gf_count_major_errors
esb_append
producernameout
ERROR
CU
DW_AT_producer
error
return
ares
if
ares
DW_DLV_NO_ENTRY
We
add
extra
quotes
so
it
looks
more
like
the
names
for
real
producers
that
get_attr_value
produces
Same
string
is
in
glflags
c
esb_append
producernameout
ERROR
CU
missing
DW_AT_producer
dwarf_dealloc_attribute
producer_attr
return
ares
DW_DLV_OK
ares
get_attr_value
dbg
DW_TAG_compile_unit
cu_die
die_indent
dieprint_cu_offset
producer_attr
NULL
producernameout
show_form_used
verbose
err
dwarf_dealloc_attribute
producer_attr
return
ares
void
print_secname
Dwarf_Debug
dbg
const
char
secname
if
glflags
gf_do_print_dwarf
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
secname
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
We
ll
check
for
errors
when
checking
print
only
if
printing
as
opposed
to
checking
static
int
print_gnu_debuglink
Dwarf_Debug
dbg
Dwarf_Error
err
int
res
char
name
unsigned
char
crcbytes
char
link_path
unsigned
link_path_len
unsigned
buildidtype
char
buildidowner
unsigned
char
buildidbyteptr
unsigned
buildidlength
char
paths_array
unsigned
paths_array_length
res
dwarf_gnu_debuglink
dbg
free
this
free
this
err
if
res
DW_DLV_NO_ENTRY
return
res
else
if
res
DW_DLV_ERROR
print_secname
dbg
gnu_debuglink
return
res
if
crcbytes
print_secname
dbg
gnu_debuglink
Done
with
error
checking
so
print
if
we
are
printing
if
glflags
gf_do_print_dwarf
printf
Debuglink
name
s
sanitized
name
unsigned
char
crc
unsigned
char
end
crc
crcbytes
end
crcbytes
printf
crc
for
crc
end
crc
printf
crc
printf
n
if
link_path_len
printf
Debuglink
target
s
n
sanitized
link_path
if
buildidlength
print_secname
dbg
note
gnu
build
id
if
glflags
gf_do_print_dwarf
printf
Build
id
type
u
n
buildidtype
printf
Build
id
ownername
s
n
sanitized
buildidowner
printf
Build
id
length
u
n
buildidlength
printf
Build
id
const
unsigned
char
cur
const
unsigned
char
end
cur
buildidbyteptr
end
cur
buildidlength
for
cur
end
cur
printf
unsigned
char
cur
printf
n
if
paths_array_length
unsigned
i
printf
Possible
gnu_debuglink
note
gnu
build
id
pathnames
for
n
printf
an
alternate
object
file
with
more
detailed
DWARF
n
for
i
paths_array_length
i
char
path
paths_array
i
char
outpath
unsigned
long
outpathlen
sizeof
outpath
unsigned
int
ftype
unsigned
int
endian
unsigned
int
offsetsize
Dwarf_Unsigned
filesize
See
DW_PATHSOURCE_dsym
for
what
pathsource
might
be
set
to
in
the
call
below
unsigned
char
pathsource
int
errcode
printf
u
s
n
i
sanitized
path
res
dwarf_object_detector_path_b
path
outpath
outpathlen
if
res
DW_DLV_NO_ENTRY
if
glflags
verbose
printf
file
above
does
not
exist
n
continue
if
res
DW_DLV_ERROR
printf
access
attempt
of
the
above
leads
to
error
s
n
dwarf_errmsg_by_number
errcode
continue
switch
ftype
case
DW_FTYPE_ELF
printf
file
above
is
an
Elf
object
n
break
case
DW_FTYPE_MACH_O
printf
file
above
is
a
Mach
O
object
n
break
case
DW_FTYPE_PE
printf
file
above
is
a
PE
object
break
case
DW_FTYPE_ARCHIVE
if
glflags
verbose
printf
file
above
is
an
archive
so
ignore
it
n
continue
default
if
glflags
verbose
printf
file
above
is
not
any
object
type
we
recognize
n
continue
printf
n
free
link_path
free
paths_array
return
DW_DLV_OK
GCC
linkonce
names
char
lo_text
text
gnu
linkonce
t
char
lo_debug_abbr
gnu
linkonce
wa
char
lo_debug_aranges
gnu
linkonce
wr
char
lo_debug_frame_1
gnu
linkonce
wf
char
lo_debug_frame_2
gnu
linkonce
wF
char
lo_debug_info
gnu
linkonce
wi
char
lo_debug_line
gnu
linkonce
wl
char
lo_debug_macinfo
gnu
linkonce
wm
char
lo_debug_loc
gnu
linkonce
wo
char
lo_debug_pubnames
gnu
linkonce
wp
char
lo_debug_ranges
gnu
linkonce
wR
char
lo_debug_str
gnu
linkonce
ws
SNC
compiler
linker
linkonce
names
char
nlo_text
text
char
nlo_debug_abbr
debug
wa
char
nlo_debug_aranges
debug
wr
char
nlo_debug_frame_1
debug
wf
char
nlo_debug_frame_2
debug
wF
char
nlo_debug_info
debug
wi
char
nlo_debug_line
debug
wl
char
nlo_debug_macinfo
debug
wm
char
nlo_debug_loc
debug
wo
char
nlo_debug_pubnames
debug
wp
char
nlo_debug_ranges
debug
wR
char
nlo_debug_str
debug
ws
Build
linkonce
section
information
void
build_linkonce_info
Dwarf_Debug
dbg
int
nCount
int
section_index
int
res
static
char
linkonce_names
text
text
debug_abbr
debug_abbr
debug_aranges
debug_aranges
debug_frame
debug_frame
debug_frame
debug_frame
debug_info
debug_info
debug_line
debug_line
debug_macinfo
debug_macinfo
debug_loc
debug_loc
debug_pubnames
debug_pubnames
debug_ranges
debug_ranges
debug_str
debug_str
NULL
const
char
section_name
NULL
Dwarf_Addr
section_addr
Dwarf_Unsigned
section_size
Dwarf_Error
error
int
nIndex
nCount
dwarf_get_section_count
dbg
Ignore
section
with
index
for
section_index
section_index
nCount
section_index
res
dwarf_get_section_info_by_index
dbg
section_index
if
res
DW_DLV_OK
for
nIndex
linkonce_names
nIndex
nIndex
if
section_name
strstr
section_name
linkonce_names
nIndex
Insert
only
linkonce
sections
AddEntryIntoBucketGroup
glflags
pLinkonceInfo
section_index
section_addr
section_addr
section_addr
section_size
section_name
TRUE
break
if
dump_linkonce_info
PrintBucketGroup
glflags
pLinkonceInfo
TRUE
Check
for
specific
TAGs
and
initialize
some
information
used
by
k
options
void
tag_specific_globals_setup
Dwarf_Debug
dbg
Dwarf_Half
val
int
die_indent_level
switch
val
DW_TAG_type
unit
will
not
have
addresses
DW_TAG_skeleton
unit
will
have
addresses
but
likely
no
children
But
they
are
useful
as
marking
glflags
seen_CU
TRUE
is
useful
case
DW_TAG_partial_unit
case
DW_TAG_compile_unit
case
DW_TAG_type_unit
case
DW_TAG_skeleton_unit
To
help
getting
the
compile
unit
name
glflags
seen_CU
TRUE
If
we
are
checking
line
information
build
the
table
containing
the
pairs
LowPC
and
HighPC
if
glflags
gf_check_decl_file
glflags
gf_check_ranges
glflags
gf_check_locations
Dwarf_Debug
td
if
dbg
ResetBucketGroup
glflags
pRangesInfo
else
Only
returns
DW_DLV_OK
dwarf_get_tied_dbg
dbg
With
a
tied
dbg
we
do
not
have
detailed
address
ranges
so
do
not
reset
the
single
text
size
bucket
group
if
td
ResetBucketGroup
glflags
pRangesInfo
The
following
flag
indicate
that
only
low_pc
and
high_pc
values
found
in
DW_TAG_subprograms
are
going
to
be
considered
when
building
the
address
table
used
to
check
ranges
lines
etc
glflags
need_PU_valid_code
TRUE
break
case
DW_TAG_subprogram
Keep
track
of
a
PU
if
die_indent_level
A
DW_TAG_subprogram
can
be
nested
when
is
used
to
declare
a
member
function
for
a
local
class
process
the
DIE
only
if
we
are
at
level
zero
in
the
DIEs
tree
glflags
seen_PU
TRUE
glflags
seen_PU_base_address
FALSE
glflags
seen_PU_high_address
FALSE
glflags
PU_name
glflags
need_PU_valid_code
TRUE
break
Print
CU
basic
information
but
use
the
local
DIE
for
the
offsets
void
PRINT_CU_INFO
void
Dwarf_Unsigned
loff
glflags
DIE_offset
Dwarf_Unsigned
goff
glflags
DIE_overall_offset
char
lbuf
char
hbuf
if
glflags
current_section_id
DEBUG_LINE
glflags
current_section_id
DEBUG_FRAME
glflags
current_section_id
DEBUG_FRAME_EH_GNU
glflags
current_section_id
DEBUG_ARANGES
glflags
current_section_id
DEBUG_MACRO
glflags
current_section_id
DEBUG_PUBNAMES
glflags
current_section_id
DEBUG_MACINFO
These
sections
involve
the
CU
die
so
use
the
CU
offsets
The
DEBUG_MAC
cases
are
logical
but
not
yet
useful
Dec
In
other
cases
the
local
DIE
offset
makes
more
sense
loff
glflags
DIE_CU_offset
goff
glflags
DIE_CU_overall_offset
if
cu_data_is_set
return
printf
n
printf
CU
Name
s
n
sanitized
glflags
CU_name
printf
CU
Producer
s
n
sanitized
glflags
CU_producer
printf
DIE
OFF
DW_PR_XZEROS
DW_PR_DUx
GOFF
DW_PR_XZEROS
DW_PR_DUx
loff
goff
We
used
to
print
leftover
and
incorrect
values
at
times
if
glflags
need_CU_high_address
safe_strcpy
hbuf
sizeof
hbuf
unknown
else
safe
hbuf
is
large
enough
sprintf
hbuf
DW_PR_XZEROS
DW_PR_DUx
glflags
CU_high_address
if
glflags
need_CU_base_address
safe_strcpy
lbuf
sizeof
lbuf
unknown
else
safe
lbuf
is
large
enough
sprintf
lbuf
DW_PR_XZEROS
DW_PR_DUx
glflags
CU_low_address
printf
Low
PC
s
High
PC
s
lbuf
hbuf
printf
n
void
DWARF_CHECK_ERROR_PRINT_CU
if
glflags
gf_check_verbose_mode
if
glflags
gf_print_unique_errors
if
glflags
gf_found_error_message
PRINT_CU_INFO
else
PRINT_CU_INFO
glflags
check_error
glflags
gf_record_dwarf_error
TRUE
Sometimes
is
useful
just
to
know
the
kind
of
errors
in
an
object
file
not
much
interest
in
the
number
of
errors
the
specific
case
is
just
to
have
a
general
idea
about
the
DWARF
quality
in
the
file
char
set_unique_errors
NULL
unsigned
int
set_unique_errors_entries
unsigned
int
set_unique_errors_size
define
SET_UNIQUE_ERRORS_DELTA
Create
the
space
to
store
the
unique
error
messages
void
allocate_unique_errors_table
void
if
set_unique_errors
set_unique_errors
char
malloc
SET_UNIQUE_ERRORS_DELTA
sizeof
char
set_unique_errors_size
SET_UNIQUE_ERRORS_DELTA
set_unique_errors_entries
ifdef
TESTING
Just
for
debugging
purposes
dump
the
unique
errors
table
void
dump_unique_errors_table
void
unsigned
int
index
printf
Unique
Errors
Table
n
printf
Delta
d
n
SET_UNIQUE_ERRORS_DELTA
printf
Size
d
n
set_unique_errors_size
printf
Entries
d
n
set_unique_errors_entries
for
index
index
set_unique_errors_entries
index
printf
s
n
index
set_unique_errors
index
endif
Release
the
space
used
to
store
the
unique
error
messages
void
release_unique_errors_table
void
unsigned
int
index
for
index
index
set_unique_errors_entries
index
free
set_unique_errors
index
free
set_unique_errors
set_unique_errors
set_unique_errors_entries
set_unique_errors_size
Returns
TRUE
if
the
text
is
already
in
the
set
otherwise
FALSE
Dwarf_Bool
add_to_unique_errors_table
char
error_text
unsigned
int
index
size_t
len
char
stored_text
char
filtered_text
char
start
NULL
char
end
NULL
char
pattern
char
white
char
question
Create
a
copy
of
the
incoming
text
filtered_text
makename
error_text
len
strlen
filtered_text
Remove
from
the
error_text
any
hexadecimal
numbers
start
with
because
for
some
errors
an
additional
information
is
given
in
the
form
of
addresses
we
are
interested
just
in
the
general
error
start
strstr
filtered_text
pattern
while
start
We
have
found
the
start
of
the
pattern
look
for
a
space
end
strstr
start
white
if
end
Preserve
any
line
terminator
end
filtered_text
len
memset
start
question
end
start
start
strstr
filtered_text
pattern
Check
if
the
error
text
is
already
in
the
table
for
index
index
set_unique_errors_entries
index
stored_text
set_unique_errors
index
if
strcmp
stored_text
filtered_text
return
TRUE
Store
the
new
text
check
if
we
have
space
to
store
the
error
text
if
set_unique_errors_entries
set_unique_errors_size
set_unique_errors_size
SET_UNIQUE_ERRORS_DELTA
set_unique_errors
char
realloc
set_unique_errors
set_unique_errors_size
sizeof
char
set_unique_errors
set_unique_errors_entries
filtered_text
set_unique_errors_entries
return
FALSE
Print
a
DWARF
error
message
and
if
in
reduced
output
only
print
one
error
of
each
kind
this
feature
is
useful
when
we
are
interested
only
in
the
kind
of
errors
and
not
on
the
number
of
errors
PRECONDITION
if
s3
non
null
so
are
s1
s2
If
s2
is
non
null
so
is
s1
s1
is
always
non
null
static
void
print_dwarf_check_error
const
char
s1
const
char
s2
const
char
s3
static
Dwarf_Bool
do_init
TRUE
Dwarf_Bool
found
FALSE
char
error_text
NULL
static
char
leader
n
DWARF
CHECK
static
char
trailer
n
if
do_init
esb_constructor
do_init
FALSE
esb_empty_string
esb_append
leader
if
s3
esb_append
s1
esb_append
esb_append
s2
esb_append
esb_append
s3
else
if
s2
esb_append
s1
esb_append
esb_append
s2
else
esb_append
s1
esb_append
trailer
error_text
esb_get_string
if
glflags
gf_print_unique_errors
found
add_to_unique_errors_table
error_text
if
found
printf
s
error_text
else
printf
s
error_text
To
indicate
if
the
current
error
message
has
been
found
or
not
glflags
gf_found_error_message
found
void
DWARF_CHECK_ERROR3
Dwarf_Check_Categories
category
const
char
str1
const
char
str2
const
char
strexpl
if
checking_this_compiler
DWARF_ERROR_COUNT
category
if
glflags
gf_check_verbose_mode
print_dwarf_check_error
str1
str2
strexpl
DWARF_CHECK_ERROR_PRINT_CU
This
is
too
much
to
put
in
the
DROP_ERROR_INSTANCE
macro
so
we
put
it
here
rather
arbitrarily
void
report_caller_error_drop_error
int
dwdlv
int
line
char
fname
printf
nERROR
in
dwarfdump
The
value
passed
to
the
macro
DROP_ERROR_INSTANCE
is
not
one
of
the
three
allowed
values
but
is
d
dwarfdump
has
a
bug
See
line
d
file
s
n
dwdlv
line
fname
glflags
gf_count_major_errors
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
config
h
include
globals
h
include
sanitized
h
include
esb
h
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
if
defined
_WIN32
include
windows
h
endif
_WIN32
include
globals
h
include
dwarf
h
include
libdwarf
h
include
ctype
h
include
dwconf
h
include
makename
h
The
nesting
level
is
arbitrary
should
suffice
But
at
least
this
prevents
an
infinite
loop
define
MAX_NEST_LEVEL
struct
token_s
unsigned
tk_len
char
tk_data
enum
linetype_e
LT_ERROR
LT_COMMENT
LT_BLANK
LT_BEGINABI
LT_REG
LT_FRAME_INTERFACE
LT_CFA_REG
LT_INITIAL_REG_VALUE
LT_SAME_VAL_REG
LT_UNDEFINED_VAL_REG
LT_REG_TABLE_SIZE
LT_ADDRESS_SIZE
LT_INCLUDEABI
LT_ENDABI
LT_OPTION
struct
comtable_s
enum
linetype_e
type
char
name
size_t
namelen
static
int
errcount
Count
errors
found
in
this
scan
of
the
configuration
file
static
char
name_begin_abi
beginabi
static
char
name_reg
reg
static
char
name_frame_interface
frame_interface
static
char
name_cfa_reg
cfa_reg
static
char
name_initial_reg_value
initial_reg_value
static
char
name_same_val_reg
same_val_reg
static
char
name_undefined_val_reg
undefined_val_reg
static
char
name_reg_table_size
reg_table_size
static
char
name_address_size
address_size
static
char
name_includeabi
includeabi
static
char
name_endabi
endabi
static
char
name_option
option
The
namelen
field
is
filled
in
at
runtime
with
the
correct
value
Filling
in
a
fake
avoids
a
compiler
warning
static
struct
comtable_s
comtable
LT_BEGINABI
name_begin_abi
LT_REG
name_reg
LT_FRAME_INTERFACE
name_frame_interface
LT_CFA_REG
name_cfa_reg
LT_INITIAL_REG_VALUE
name_initial_reg_value
LT_SAME_VAL_REG
name_same_val_reg
LT_UNDEFINED_VAL_REG
name_undefined_val_reg
LT_REG_TABLE_SIZE
name_reg_table_size
LT_ADDRESS_SIZE
name_address_size
LT_INCLUDEABI
name_includeabi
LT_ENDABI
name_endabi
LT_OPTION
name_option
struct
conf_internal_s
unsigned
long
beginabi_lineno
unsigned
long
frame_interface_lineno
unsigned
long
initial_reg_value_lineno
unsigned
long
reg_table_size_lineno
unsigned
long
address_size_lineno
unsigned
long
same_val_reg_lineno
unsigned
long
undefined_val_reg_lineno
unsigned
long
cfa_reg_lineno
unsigned
long
regcount
struct
dwconf_s
conf_out
const
char
conf_name_used
char
conf_defaults
static
void
init_conf_internal
struct
conf_internal_s
s
struct
dwconf_s
conf_out
s
beginabi_lineno
s
frame_interface_lineno
s
initial_reg_value_lineno
s
reg_table_size_lineno
s
address_size_lineno
s
same_val_reg_lineno
s
undefined_val_reg_lineno
s
cfa_reg_lineno
s
cfa_reg_lineno
s
conf_name_used
s
conf_defaults
s
regcount
s
conf_out
conf_out
static
unsigned
size_of_comtable
sizeof
comtable
sizeof
comtable
static
FILE
find_a_file
const
char
named_file
char
defaults
const
char
name_used
static
int
find_abi_start
FILE
stream
const
char
abi_name
long
offset
unsigned
long
lineno_out
static
int
parse_abi
FILE
stream
const
char
fname
const
char
abiname
struct
conf_internal_s
out
unsigned
long
lineno
unsigned
nest_level
static
char
get_token
char
cp
struct
token_s
outtok
This
finds
a
dwarfdump
conf
file
and
then
parses
it
It
updates
conf_out
as
appropriate
This
finds
the
first
file
looking
in
a
set
of
places
with
that
name
It
then
looks
for
the
right
ABI
entry
If
the
first
file
it
finds
does
not
have
that
ABI
entry
it
gives
up
It
would
also
be
reasonable
to
search
every
dwarfdump
conf
it
finds
for
the
abi
But
we
stop
at
the
first
dwarfdump
conf
we
find
This
is
the
internal
call
to
get
the
conf
data
to
implement
a
crude
includeabi
feature
Each
call
here
starts
at
offset
of
a
new
stream
Returns
if
no
errors
found
else
returns
static
int
find_conf_file_and_read_config_inner
const
char
named_file
const
char
named_abi
struct
conf_internal_s
conf_internal
unsigned
nest_level
FILE
conf_stream
const
char
name_used
long
offset
int
res
FALSE
unsigned
long
lineno
errcount
conf_stream
find_a_file
named_file
conf_internal
conf_defaults
if
conf_stream
errcount
if
named_file
strlen
named_file
printf
dwarfdump
found
no
dwarfdump
conf
file
in
any
of
the
standard
places
n
precede
all
arguments
with
option
show
dwarfdump
conf
to
see
what
file
paths
tried
n
If
no
print
check
arguments
also
provided
dwarfdump
may
silently
just
stop
n
else
printf
dwarfdump
found
no
dwarfdump
conf
file
s
n
If
no
print
check
arguments
also
provided
dwarfdump
may
silently
just
stop
n
sanitized
named_file
return
FOUND_ERROR
if
glflags
gf_show_dwarfdump_conf
printf
dwarfdump
using
configuration
file
s
n
sanitized
name_used
conf_internal
conf_name_used
name_used
And
option
lines
must
come
before
any
abi
data
res
find_abi_start
conf_stream
named_abi
if
res
FOUND_DONE
FOUND_OPTION
nothing
more
to
do
fclose
conf_stream
return
FOUND_DONE
if
res
FOUND_ERROR
errcount
fclose
conf_stream
printf
dwarfdump
found
no
usable
abi
s
in
file
s
n
named_abi?named_abi
not
looking
for
abi
name_used
return
FOUND_ERROR
res
FOUND_ABI_START
res
fseek
conf_stream
offset
SEEK_SET
if
res
errcount
fclose
conf_stream
printf
dwarfdump
seek
to
ld
offset
in
s
failed
n
offset
name_used
return
FOUND_ERROR
parse_abi
conf_stream
name_used
named_abi
conf_internal
lineno
nest_level
fclose
conf_stream
if
errcount
return
FOUND_ERROR
return
FOUND_ABI_START
This
is
the
external
facing
call
to
get
the
conf
data
int
find_conf_file_and_read_config
const
char
named_file
const
char
named_abi
char
defaults
struct
dwconf_s
conf_out
int
res
struct
conf_internal_s
conf_internal
init_conf_file_data
conf_out
init_conf_internal
conf_out
conf_internal
conf_defaults
defaults
res
find_conf_file_and_read_config_inner
named_file
named_abi
return
res
Given
path
strings
attempt
to
make
a
canonical
file
name
that
is
avoid
superfluous
so
that
no
or
worse
is
created
in
the
output
The
path
components
are
to
be
separated
so
at
least
one
is
to
appear
between
the
two
input
strings
when
creating
the
output
if
defined
BUILD_FOR_TEST
defined
_WIN32
static
char
canonical_append
char
target
unsigned
int
target_size
const
char
first_string
const
char
second_string
size_t
firstlen
strlen
first_string
Leave
room
for
added
and
final
NUL
though
that
is
overkill
as
we
drop
a
NUL
byte
too
if
firstlen
strlen
second_string
target_size
Not
enough
space
return
NULL
for
second_string
second_string
for
firstlen
first_string
firstlen
firstlen
target
if
firstlen
strncpy
target
first_string
firstlen
target
firstlen
target
firstlen
firstlen
target
firstlen
strcat
target
second_string
return
target
endif
defined
BUILD_FOR_TEST
defined
_WIN32
ifdef
BUILD_FOR_TEST
define
CANBUF
struct
canap_s
char
res_exp
char
first
char
second
canap
ab
c
ab
c
ab
c
ab
c
ab
c
ab
c
ab
c
ab
c
ab
ab
ab
ab
ab
ab
a
a
abcdefgbijkl
pqrstuvwxyzabcd
static
void
test_canonical_append
void
Make
buf
big
this
is
test
code
so
be
safe
char
lbuf
unsigned
i
unsigned
failcount
printf
Entry
test_canonical_append
n
for
i
i
char
res
if
canap
i
first
canap
i
second
break
res
canonical_append
lbuf
CANBUF
canap
i
first
canap
i
second
if
res
if
canap
i
res_exp
GOOD
printf
PASS
u
n
i
else
failcount
printf
FAIL
entry
u
wrong
expected
s
got
NULL
n
i
canap
i
res_exp
else
if
canap
i
res_exp
failcount
printf
FAIL
entry
u
wrong
got
s
expected
NULL
n
i
res
else
if
strcmp
res
canap
i
res_exp
printf
PASS
u
n
i
GOOD
else
failcount
printf
FAIL
entry
u
wrong
expected
s
got
s
n
i
canap
i
res_exp
res
printf
FAIL
count
u
n
failcount
endif
BUILD_FOR_TEST
Try
to
find
a
file
as
named
and
open
for
read
We
treat
each
name
as
a
full
name
we
are
not
combining
separate
name
and
path
components
This
is
an
arbitrary
choice
The
defaults
are
listed
in
command_options
c
in
the
array
config_file_defaults
Since
named_file
comes
from
an
esb_get_string
lname
may
be
non
null
but
pointing
to
empty
string
to
mean
no
name
static
FILE
find_a_file
const
char
named_file
char
defaults
const
char
name_used
FILE
fin
const
char
lname
named_file
const
char
type
r
int
i
ifdef
BUILD_FOR_TEST
test_canonical_append
endif
BUILD_FOR_TEST
if
lname
strlen
lname
Name
given
just
assume
it
is
fully
correct
try
no
other
printf
dwarfdump
looking
for
configuration
as
s
n
lname
fin
fopen
lname
type
if
fin
name_used
lname
return
fin
return
No
name
given
find
a
default
if
we
can
for
i
defaults
i
i
lname
defaults
i
ifdef
_WIN32
Open
the
configuration
file
located
in
the
directory
where
the
tool
is
loaded
from
static
char
szPath
MAX_PATH
if
GetModuleFileName
NULL
szPath
MAX_PATH
char
pDir
strrchr
szPath
size_t
len
if
pDir
pDir
strrchr
szPath
if
pDir
No
file
was
found
return
Add
the
configuration
name
to
the
pathname
pDir
len
pDir
szPath
safe_strcpy
pDir
sizeof
szPath
len
dwarfdump
conf
lname
szPath
else
non
Win
if
strncmp
lname
HOME
arbitrary
size
char
buf
char
homedir
getenv
HOME
if
homedir
char
cp
canonical_append
buf
sizeof
buf
homedir
lname
if
cp
OOps
ignore
this
one
continue
lname
makename
buf
endif
_WIN32
if
glflags
gf_show_dwarfdump_conf
if
lname
strlen
lname
lname
Impossible
name
string
printf
dwarfdump
looking
for
configuration
as
s
n
lname
fin
fopen
lname
type
if
fin
name_used
lname
return
fin
return
Start
at
a
token
begin
see
how
long
it
is
return
length
static
unsigned
find_token_len
char
cp
unsigned
len
for
cp
cp
if
isspace
cp
return
len
if
cp
return
len
begins
comment
len
return
len
Skip
past
all
whitespace
the
only
code
that
even
knows
what
whitespace
is
static
char
skipwhite
char
cp
for
cp
cp
if
isspace
cp
return
cp
return
cp
Return
TRUE
if
ok
FALSE
if
find
more
tokens
Emit
error
message
if
error
static
int
ensure_has_no_more_tokens
char
cp
const
char
fname
unsigned
long
lineno
struct
token_s
tok
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
extra
characters
after
command
operands
found
s
in
s
line
lu
n
tok
tk_data
fname
lineno
errcount
return
FALSE
return
TRUE
There
may
be
many
beginabi
lines
in
a
dwarfdump
conf
file
find
the
one
we
want
and
return
its
file
offset
static
int
find_abi_start
FILE
stream
const
char
abi_name
long
offset
unsigned
long
lineno_out
char
buf
unsigned
long
lineno
for
feof
stream
struct
token_s
tok
char
line
long
loffset
ftell
stream
line
fgets
buf
sizeof
buf
stream
lineno
if
line
if
abi_name
return
FOUND_DONE
errcount
return
FOUND_ERROR
line
get_token
buf
if
strcmp
tok
tk_data
option
get_token
line
if
tok
tk_data
strcmp
tok
tk_data
format
expr
ops
joined
print
expr
ops
joined
onto
one
line
matching
historical
behavior
glflags
gf_expr_ops_joined
TRUE
else
printf
ERROR
option
command
s
is
not
understood
giving
up
n
tok
tk_data
errcount
return
FOUND_ERROR
continue
if
strcmp
tok
tk_data
beginabi
continue
Is
beginabi
if
abi_name
continue
get_token
line
if
strcmp
tok
tk_data
abi_name
continue
offset
loffset
lineno_out
lineno
return
FOUND_ABI_START
if
abi_name
All
is
ok
return
FOUND_DONE
errcount
return
FALSE
Turn
a
non
delimited
input
char
array
into
a
NUL
terminated
C
string
with
the
help
of
makename
to
get
a
permanent
address
for
the
result
ing
string
static
char
build_string
unsigned
tlen
char
cp
struct
esb_s
x
char
buffer
char
ret
esb_constructor_fixed
buffer
sizeof
buffer
esb_appendn
cp
tlen
ret
makename
esb_get_string
esb_destructor
return
ret
The
tokenizer
for
our
simple
parser
static
char
get_token
char
cp
struct
token_s
outtok
char
lcp
skipwhite
cp
unsigned
tlen
find_token_len
lcp
outtok
tk_len
tlen
if
tlen
outtok
tk_data
build_string
tlen
lcp
else
outtok
tk_data
return
lcp
tlen
We
can
t
get
all
the
field
set
up
statically
very
easily
so
we
get
the
command
string
length
set
here
static
void
finish_comtable_setup
void
unsigned
i
for
i
i
size_of_comtable
i
comtable
i
namelen
strlen
comtable
i
name
Given
a
line
of
the
table
determine
if
it
is
a
command
or
not
and
if
a
command
which
one
is
it
Return
LT_ERROR
if
it
s
not
recognized
static
enum
linetype_e
which_command
char
cp
struct
comtable_s
tableentry
unsigned
i
struct
token_s
tok
if
cp
return
LT_COMMENT
if
cp
return
LT_BLANK
get_token
cp
for
i
i
size_of_comtable
i
if
tok
tk_len
comtable
i
namelen
strcmp
comtable
i
name
tok
tk_data
tableentry
i
return
comtable
i
type
return
LT_ERROR
static
int
parseoption
char
cp
const
char
fname
unsigned
long
lineno
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
cp
cp
clen
cp
skipwhite
cp
get_token
cp
if
tok
tk_data
printf
ERROR
empty
option
command
is
ignored
return
FALSE
ensure_has_no_more_tokens
cp
tok
tk_len
fname
lineno
if
strcmp
tok
tk_data
format
expr
ops
joined
glflags
gf_expr_ops_joined
TRUE
else
printf
ERROR
option
command
s
is
not
understood
and
is
ignored
tok
tk_data
return
FALSE
return
TRUE
We
are
promised
it
s
an
abiname
command
find
the
name
on
the
line
static
int
parsebeginabi
char
cp
const
char
fname
const
char
abiname
unsigned
long
lineno
struct
comtable_s
comtab
size_t
clen
comtab
namelen
size_t
abinamelen
strlen
abiname
struct
token_s
tok
cp
cp
clen
cp
skipwhite
cp
get_token
cp
if
tok
tk_len
abinamelen
strncmp
cp
abiname
abinamelen
printf
dwarfdump
internal
error
mismatch
s
with
s
s
line
lu
n
cp
tok
tk_data
fname
lineno
errcount
return
FALSE
ensure_has_no_more_tokens
cp
tok
tk_len
fname
lineno
return
TRUE
This
expands
register
names
as
required
but
does
not
ensure
no
names
duplicated
define
CONF_TABLE_OVERSIZE
static
void
add_to_reg_table
struct
dwconf_s
conf
char
rname
unsigned
long
rval
const
char
fname
unsigned
long
lineno
if
conf
cf_regs_malloced
conf
cf_regs
conf
cf_named_regs_table_size
if
rval
conf
cf_named_regs_table_size
char
newregs
unsigned
long
newtablen
rval
CONF_TABLE_OVERSIZE
unsigned
long
newtabsize
newtablen
sizeof
char
unsigned
long
oldtabsize
conf
cf_named_regs_table_size
sizeof
char
newregs
realloc
conf
cf_regs
newtabsize
if
newregs
printf
dwarfdump
unable
to
malloc
table
lu
bytes
s
line
lu
n
newtabsize
fname
lineno
exit
Zero
out
the
new
entries
memset
char
newregs
oldtabsize
newtabsize
oldtabsize
conf
cf_named_regs_table_size
unsigned
long
newtablen
conf
cf_regs
newregs
conf
cf_regs_malloced
conf
cf_regs
rval
rname
return
Our
input
is
supposed
to
be
a
number
Determine
the
value
and
return
it
or
generate
an
error
message
static
int
make_a_number
char
cmd
const
char
filename
unsigned
long
lineno
struct
token_s
tok
unsigned
long
val_out
char
endnum
unsigned
long
val
val
strtoul
tok
tk_data
if
val
endnum
tok
tk_data
printf
dwarfdump
conf
error
s
missing
register
number
s
not
valid
s
line
lu
n
cmd
tok
tk_data
filename
lineno
errcount
return
FALSE
if
endnum
tok
tk_data
tok
tk_len
printf
dwarfdump
conf
error
s
Missing
register
number
s
not
valid
s
line
lu
n
cmd
tok
tk_data
filename
lineno
errcount
return
FALSE
val_out
val
return
TRUE
We
are
guaranteed
it
s
a
reg
command
so
parse
that
command
and
record
the
interesting
data
static
int
parsereg
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
regnum
struct
token_s
tokreg
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
cp
get_token
cp
if
tokreg
tk_len
printf
dwarfdump
conf
error
reg
missing
register
name
s
line
lu
fname
lineno
errcount
return
FALSE
if
regnum
tk_len
printf
dwarfdump
conf
error
reg
missing
register
number
s
line
lu
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
add_to_reg_table
conf
conf_out
tokreg
tk_data
val
fname
lineno
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
an
frame_interface
command
Parse
it
and
record
the
value
data
static
int
parseframe_interface
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
interface
number
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
if
val
val
printf
dwarfdump
conf
error
s
only
interface
numbers
or
are
allowed
not
lu
s
line
lu
comtab
name
val
fname
lineno
errcount
return
FALSE
conf
conf_out
cf_interface_number
int
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
a
cfa_reg
command
Parse
it
and
record
the
important
data
static
int
parsecfa_reg
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
cfa_reg
number
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_cfa_reg
int
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
an
initial_reg_value
command
parse
it
and
put
the
reg
value
where
it
will
be
remembered
static
int
parseinitial_reg_value
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
initial
reg
value
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_initial_rule_value
int
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
static
int
parsesame_val_reg
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
same_reg
value
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_same_val
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
static
int
parseundefined_val_reg
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
undefined_reg
value
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_undefined_val
int
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
a
table
size
command
parse
it
and
record
the
table
size
static
int
parsereg_table_size
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
reg
table
size
value
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_table_entry_count
unsigned
long
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
a
table
size
command
parse
it
and
record
the
table
size
static
int
parseaddress_size
char
cp
const
char
fname
unsigned
long
lineno
struct
conf_internal_s
conf
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
unsigned
long
val
int
ok
FALSE
int
res
FALSE
cp
cp
clen
cp
get_token
cp
if
tok
tk_len
printf
dwarfdump
conf
error
s
missing
address
size
value
s
line
lu
comtab
name
fname
lineno
errcount
return
FALSE
ok
make_a_number
comtab
name
fname
lineno
if
ok
errcount
return
FALSE
conf
conf_out
cf_address_size
unsigned
long
val
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
We
are
guaranteed
it
s
an
endabi
command
parse
it
and
check
we
have
the
right
abi
static
int
parseendabi
char
cp
const
char
fname
const
char
abiname
unsigned
long
lineno
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
int
res
cp
cp
clen
cp
get_token
cp
if
strcmp
abiname
tok
tk_data
printf
s
error
mismatch
abi
name
s
here
vs
s
beginabi
s
line
lu
n
comtab
name
tok
tk_data
abiname
fname
lineno
errcount
return
FALSE
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
static
int
parseincludeabi
char
cp
const
char
fname
unsigned
long
lineno
char
abiname_out
struct
comtable_s
comtab
size_t
clen
comtab
namelen
struct
token_s
tok
char
name
int
res
FALSE
cp
cp
clen
cp
get_token
cp
name
makename
tok
tk_data
abiname_out
name
res
ensure_has_no_more_tokens
cp
fname
lineno
return
res
Return
TRUE
if
we
succeeded
and
filed
in
out
Return
FALSE
if
we
failed
and
fill
in
nothing
beginabi
abiname
reg
regname
dwarf
regnumber
frame_interface
integer
value
or
cfa_reg
number
initial_reg_value
number
normally
or
reg_table_size
size
of
table
endabi
abiname
We
are
positioned
at
the
start
of
a
beginabi
line
when
called
static
int
parse_abi
FILE
stream
const
char
fname
const
char
abiname
struct
conf_internal_s
conf_internal
unsigned
long
lineno
unsigned
int
nest_level
struct
dwconf_s
localconf
conf_internal
conf_out
char
buf
int
comtype
static
int
first_time_done
struct
comtable_s
comtabp
int
inourabi
FALSE
if
nest_level
MAX_NEST_LEVEL
errcount
printf
dwarfdump
conf
includeabi
nest
too
deep
in
s
at
line
lu
n
fname
lineno
return
FALSE
if
first_time_done
finish_comtable_setup
first_time_done
for
feof
stream
char
line
long
loffset
ftell
stream
line
fgets
buf
sizeof
buf
stream
if
line
errcount
printf
dwarfdump
end
of
file
or
error
before
endabi
in
s
line
lu
n
fname
lineno
return
FALSE
lineno
line
skipwhite
line
comtype
which_command
line
switch
comtype
case
LT_OPTION
if
inourabi
break
parseoption
line
fname
lineno
comtabp
break
case
LT_ERROR
errcount
printf
dwarfdump
Unknown
text
in
s
is
s
at
line
lu
n
fname
line
lineno
break
case
LT_COMMENT
break
case
LT_BLANK
break
case
LT_BEGINABI
if
conf_internal
beginabi_lineno
errcount
printf
dwarfdump
Encountered
beginabi
when
not
expected
s
line
lu
previous
beginabi
line
lu
n
fname
lineno
conf_internal
beginabi_lineno
conf_internal
beginabi_lineno
lineno
inourabi
parsebeginabi
line
fname
abiname
lineno
comtabp
break
case
LT_REG
if
inourabi
break
parsereg
line
fname
lineno
conf_internal
comtabp
conf_internal
regcount
break
case
LT_FRAME_INTERFACE
if
inourabi
break
if
conf_internal
frame_interface_lineno
errcount
printf
dwarfdump
Encountered
duplicate
frame_interface
s
line
lu
previous
frame_interface
line
lu
n
fname
lineno
conf_internal
frame_interface_lineno
conf_internal
frame_interface_lineno
lineno
parseframe_interface
line
fname
lineno
conf_internal
comtabp
break
case
LT_CFA_REG
if
inourabi
break
if
conf_internal
cfa_reg_lineno
printf
dwarfdump
Encountered
duplicate
cfa_reg
s
line
lu
previous
cfa_reg
line
lu
n
fname
lineno
conf_internal
cfa_reg_lineno
errcount
conf_internal
cfa_reg_lineno
lineno
parsecfa_reg
line
fname
lineno
conf_internal
comtabp
break
case
LT_INITIAL_REG_VALUE
if
inourabi
break
if
conf_internal
initial_reg_value_lineno
printf
dwarfdump
Encountered
duplicate
initial_reg_value
s
line
lu
previous
initial_reg_value
line
lu
n
fname
lineno
conf_internal
initial_reg_value_lineno
errcount
conf_internal
initial_reg_value_lineno
lineno
parseinitial_reg_value
line
fname
lineno
conf_internal
comtabp
break
case
LT_SAME_VAL_REG
if
inourabi
break
if
conf_internal
same_val_reg_lineno
errcount
printf
dwarfdump
Encountered
duplicate
same_val_reg
s
line
lu
previous
initial_reg_value
line
lu
n
fname
lineno
conf_internal
initial_reg_value_lineno
conf_internal
same_val_reg_lineno
lineno
parsesame_val_reg
line
fname
lineno
conf_internal
comtabp
break
case
LT_UNDEFINED_VAL_REG
if
inourabi
break
if
conf_internal
undefined_val_reg_lineno
errcount
printf
dwarfdump
Encountered
duplicate
undefined_val_reg
s
line
lu
previous
initial_reg_value
line
lu
n
fname
lineno
conf_internal
initial_reg_value_lineno
if
inourabi
break
conf_internal
undefined_val_reg_lineno
lineno
parseundefined_val_reg
line
fname
lineno
conf_internal
comtabp
break
case
LT_REG_TABLE_SIZE
if
inourabi
break
if
conf_internal
reg_table_size_lineno
printf
dwarfdump
duplicate
reg_table_size
s
line
lu
previous
reg_table_size
line
lu
n
fname
lineno
conf_internal
reg_table_size_lineno
errcount
conf_internal
reg_table_size_lineno
lineno
parsereg_table_size
line
fname
lineno
conf_internal
comtabp
break
case
LT_ENDABI
if
inourabi
break
parseendabi
line
fname
abiname
lineno
comtabp
if
conf_internal
regcount
localconf
cf_table_entry_count
printf
dwarfdump
more
registers
named
than
in
s
lu
named
vs
s
lu
s
line
lu
n
abiname
unsigned
long
conf_internal
regcount
name_reg_table_size
unsigned
long
localconf
cf_table_entry_count
fname
unsigned
long
lineno
errcount
inourabi
FALSE
return
TRUE
case
LT_ADDRESS_SIZE
if
inourabi
break
if
conf_internal
address_size_lineno
printf
dwarfdump
duplicate
address_size
s
line
lu
previous
address_size
line
lu
n
fname
lineno
conf_internal
address_size_lineno
errcount
conf_internal
address_size_lineno
lineno
parseaddress_size
line
fname
lineno
conf_internal
comtabp
break
case
LT_INCLUDEABI
char
abiname_inner
unsigned
long
abilno
conf_internal
beginabi_lineno
int
ires
if
inourabi
break
ires
parseincludeabi
line
fname
lineno
comtabp
if
ires
FALSE
return
FALSE
For
the
nested
abi
read
the
abi
line
number
must
be
set
as
if
not
yet
read
and
then
restored
conf_internal
beginabi_lineno
ires
find_conf_file_and_read_config_inner
conf_internal
conf_name_used
abiname_inner
conf_internal
nest_level
if
ires
FOUND_ERROR
return
ires
conf_internal
beginabi_lineno
abilno
break
default
printf
dwarfdump
internal
error
impossible
line
type
d
s
lu
n
int
comtype
fname
lineno
exit
errcount
printf
End
of
file
no
endabi
found
s
line
lu
n
fname
lineno
return
FALSE
Naming
a
few
registers
makes
printing
these
just
a
little
bit
faster
static
char
genericregnames
r0
r1
r2
r3
r4
r5
r6
r7
r8
r9
r10
r11
r12
r13
r14
r15
r16
r17
r18
r19
r20
This
is
a
simple
generic
set
of
registers
The
table
entry
count
is
pretty
arbitrary
void
init_conf_file_data
struct
dwconf_s
config_file_data
unsigned
generic_table_count
config_file_data
cf_abi_name
config_file_data
cf_config_file_path
config_file_data
cf_interface_number
config_file_data
cf_table_entry_count
config_file_data
cf_initial_rule_value
DW_FRAME_UNDEFINED_VAL
config_file_data
cf_cfa_reg
DW_FRAME_CFA_COL3
config_file_data
cf_address_size
config_file_data
cf_same_val
DW_FRAME_SAME_VAL
config_file_data
cf_undefined_val
DW_FRAME_UNDEFINED_VAL
config_file_data
cf_regs
genericregnames
generic_table_count
sizeof
genericregnames
sizeof
genericregnames
config_file_data
cf_named_regs_table_size
generic_table_count
config_file_data
cf_regs_malloced
A
generic
ABI
For
up
to
registers
Perhaps
cf_initial_rule_value
should
be
d
UNDEFINED
VALUE
instead
but
for
the
purposes
of
getting
the
dwarfdump
output
correct
either
will
work
void
init_generic_config_1200_regs
struct
dwconf_s
config_file_data
unsigned
long
generic_table_count
sizeof
genericregnames
sizeof
genericregnames
config_file_data
cf_interface_number
config_file_data
cf_table_entry_count
There
is
no
defined
name
for
cf_initial_rule_value
cf_same_val
or
cf_undefined_val
in
libdwarf
h
these
must
just
be
high
enough
to
be
higher
than
any
real
register
number
DW_FRAME_CFA_COL3
must
also
be
higher
than
any
real
register
number
config_file_data
cf_initial_rule_value
SAME
VALUE
config_file_data
cf_cfa_reg
DW_FRAME_CFA_COL3
config_file_data
cf_address_size
config_file_data
cf_same_val
config_file_data
cf_undefined_val
config_file_data
cf_regs
genericregnames
config_file_data
cf_named_regs_table_size
generic_table_count
config_file_data
cf_regs_malloced
Print
the
right
string
for
the
register
we
are
given
Deal
sensibly
with
the
special
regs
as
well
as
numbers
we
know
and
those
we
have
not
been
told
about
We
are
not
allowing
negative
register
numbers
void
print_reg_from_config_data
Dwarf_Unsigned
reg
struct
dwconf_s
config_data
char
name
if
reg
config_data
cf_cfa_reg
fputs
cfa
stdout
return
if
reg
config_data
cf_undefined_val
fputs
u
stdout
return
if
reg
config_data
cf_same_val
fputs
s
stdout
return
if
config_data
cf_regs
reg
config_data
cf_named_regs_table_size
printf
r
DW_PR_DUu
reg
return
name
config_data
cf_regs
reg
if
name
Can
happen
the
reg
names
table
can
be
sparse
printf
r
DW_PR_DUu
reg
return
fputs
name
stdout
return
void
free_all_dwconf
struct
dwconf_s
conf
if
conf
cf_regs_malloced
free
conf
cf_regs
conf
cf_regs
conf
cf_named_regs_table_size
conf
cf_regs_malloced
getopt
c
v
joerg
Exp
Modified
by
David
Anderson
to
work
with
GNU
Linux
and
freebsd
Added
for
clarity
Switched
to
standard
dwarfdump
formatting
Treatment
of
modified
so
that
gets
dwoptarg
NULL
if
space
follows
the
letter
the
dwoptarg
is
set
to
null
renamed
to
make
it
clear
this
is
a
private
version
Oct
Created
dwgetopt_long
See
dwgetopt
h
Copyright
c
The
Regents
of
the
University
of
California
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
Neither
the
name
of
the
University
nor
the
names
of
its
contributors
may
be
used
to
endorse
or
promote
products
derived
from
this
software
without
specific
prior
written
permission
THIS
SOFTWARE
IS
PROVIDED
BY
THE
REGENTS
AND
CONTRIBUTORS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
REGENTS
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
This
does
not
presently
handle
the
option
string
leading
or
leading
features
Such
are
not
used
by
by
libdwarfdump
Nor
does
it
understand
the
GNU
Env
var
POSIXLY_CORRECT
It
does
know
of
the
leading
in
the
option
string
See
BADCH
below
include
config
h
include
stdio
h
ifdef
HAVE_STRING_H
include
string
h
for
strchr
etc
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
exit
endif
HAVE_STDLIB_H
include
dwgetopt
h
define
STRIP_OFF_CONSTNESS
a
void
size_t
const
void
a
int
dwopterr
if
error
message
should
be
printed
dwoptind
index
into
parent
argv
vector
dwoptopt
character
checked
for
validity
dwoptreset
reset
getopt
char
dwoptarg
argument
associated
with
option
define
BADCH
int
define
BADARG
int
define
EMSG
define
TRUE
define
FALSE
if
FOR
DEBUGGING
ONLY
Use
for
testing
dwgetopt
only
Not
a
standard
function
void
dwgetoptresetfortestingonly
void
dwopterr
dwoptind
dwoptopt
dwoptreset
dwoptarg
endif
FOR
DEBUGGING
ONLY
static
const
char
place
EMSG
option
letter
processing
Post
Condition
if
return
FALSE
then
argerr
is
set
false
static
int
dwoptnamematches
const
struct
dwoption
dwlopt
const
char
iplace
const
char
argloc
int
argerr
const
char
eq
unsigned
namelen
unsigned
arglen
int
d
for
eq
iplace
eq
eq
if
eq
continue
Found
arg
should
follow
namelen
eq
iplace
if
namelen
unsigned
strlen
dwlopt
name
return
FALSE
eq
arglen
strlen
eq
break
if
namelen
d
strncmp
iplace
dwlopt
name
namelen
if
d
return
FALSE
if
dwlopt
has_arg
argerr
TRUE
return
TRUE
if
arglen
Discarding
const
avoiding
warning
Data
is
in
user
space
so
this
is
ok
dwoptarg
char
eq
argloc
const
char
eq
else
Has
arg
but
arg
is
empty
dwoptarg
return
TRUE
else
d
strcmp
iplace
dwlopt
name
if
d
return
FALSE
if
dwlopt
has_arg
argerr
TRUE
return
TRUE
dwoptarg
return
TRUE
dwgetopt_long
A
reimplemention
of
a
portion
of
the
getopt
GNU
Linux
getopt_long
See
dwgetopt
h
for
more
details
int
dwgetopt_long
int
nargc
char
const
nargv
const
char
ostr
const
struct
dwoption
longopts
int
longindex
char
lplace
if
dwoptreset
Not
really
supported
place
EMSG
return
if
place
int
v
dwgetopt
nargc
nargv
ostr
return
v
Use
local
lplace
in
case
we
need
to
call
getopt
just
below
lplace
nargv
dwoptind
if
dwoptind
nargc
lplace
Argument
is
absent
or
is
not
an
option
place
EMSG
return
if
lplace
Notice
place
not
disturbed
int
v
dwgetopt
nargc
nargv
ostr
return
v
Starts
with
two
dashes
Now
we
set
the
global
place
place
lplace
if
place
end
of
options
dwoptind
place
EMSG
return
We
think
this
is
a
longopt
int
lo_num
for
lo_num
const
struct
dwoption
dwlopt
longopts
lo_num
const
char
argloc
int
argerr
int
resmatch
if
dwlopt
name
dwoptind
void
fprintf
stderr
s
invalid
long
option
s
n
nargv
place
Leave
longindex
unchanged
place
EMSG
return
BADCH
resmatch
dwoptnamematches
dwlopt
place
if
resmatch
dwoptarg
if
argloc
Must
drop
const
here
Ugh
dwoptarg
char
argloc
if
argerr
resmatch
TRUE
arg
option
missing
if
required
present
but
not
allowed
GNU
Behavior
not
well
documented
Had
to
experiment
if
argument
not
allowed
and
we
have
one
do
If
argument
required
then
here
GNU
would
take
the
next
argv
as
the
argument
we
are
not
currently
doing
that
longindex
lo_num
if
dwlopt
has_arg
Missing
required
arg
this
does
not
match
GNU
getopt_long
behavior
of
taking
next
argv
as
the
arg
value
and
thus
making
getopt_long
succeed
void
fprintf
stderr
s
missing
required
long
option
argument
s
n
nargv
place
else
has
arg
but
should
not
void
fprintf
stderr
s
option
s
does
not
allow
an
argument
n
nargv
dwlopt
name
dwoptind
place
EMSG
return
BADCH
if
resmatch
longindex
lo_num
place
EMSG
dwoptind
return
dwlopt
val
Can
never
get
here
place
EMSG
dwoptind
return
getopt
Parse
argc
argv
argument
vector
a
means
afoo
a
foo
and
foo
is
returned
in
dwoptarg
b
means
b
and
dwoptarg
is
null
bother
and
dwoptarg
is
other
int
dwgetopt
int
nargc
char
const
nargv
const
char
ostr
char
oli
option
letter
list
index
if
dwoptreset
place
update
scanning
pointer
dwoptreset
place
nargv
dwoptind
if
dwoptind
nargc
place
Argument
is
absent
or
is
not
an
option
place
EMSG
return
dwoptopt
place
if
dwoptopt
place
end
of
options
dwoptind
place
EMSG
return
if
dwoptopt
Solitary
treat
as
a
option
if
the
program
eg
su
is
looking
for
it
place
EMSG
if
strchr
ostr
NULL
return
dwoptopt
else
dwoptopt
place
See
if
option
letter
is
one
the
caller
wanted
if
dwoptopt
oli
strchr
ostr
dwoptopt
NULL
if
place
dwoptind
if
dwopterr
ostr
void
fprintf
stderr
s
invalid
option
c
n
nargv
dwoptopt
return
BADCH
Does
this
option
need
an
argument?
if
oli
don
t
need
argument
dwoptarg
NULL
if
place
dwoptind
else
int
reqnextarg
if
oli
oli
Pair
of
means
special
treatment
of
dwoptarg
reqnextarg
Option
argument
is
either
the
rest
of
this
argument
or
the
entire
next
argument
if
place
Whether
or
dwoptarg
STRIP_OFF_CONSTNESS
place
else
if
reqnextarg
place
if
nargc
dwoptind
dwoptarg
nargv
dwoptind
else
place
EMSG
Next
arg
required
but
is
missing
if
ostr
Leading
in
ostr
calls
for
BADARG
return
return
BADARG
if
dwopterr
void
fprintf
stderr
s
option
requires
an
argument
c
n
nargv
dwoptopt
return
BADCH
else
place
The
key
part
of
treatment
dwoptarg
NULL
place
EMSG
dwoptind
return
dwoptopt
return
option
letter
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
esb
c
extensible
string
buffer
A
simple
means
vaguely
like
a
C
class
that
enables
safely
saving
strings
of
arbitrary
length
built
up
in
small
pieces
We
really
do
allow
only
C
strings
here
NUL
bytes
in
a
string
result
in
adding
only
up
to
the
NUL
and
in
the
case
of
certain
interfaces
here
a
warning
to
stderr
The
functions
assume
that
pointer
arguments
of
all
kinds
are
not
NULL
ifdef
_WIN32
define
_CRT_SECURE_NO_WARNINGS
endif
_WIN32
include
config
h
include
stdarg
h
include
esb
h
define
TRUE
INITIAL_ALLOC
value
takes
no
account
of
space
for
a
trailing
NUL
the
NUL
is
accounted
for
in
init_esb_string
and
in
later
tests
against
esb_allocated_size
ifdef
SELFTEST
define
INITIAL_ALLOC
SELFTEST
define
MALLOC_COUNT
else
There
is
nothing
magic
about
this
size
It
is
just
big
enough
to
avoid
most
resizing
define
INITIAL_ALLOC
endif
Allow
for
final
NUL
static
size_t
alloc_size
INITIAL_ALLOC
NULL
device
used
when
printing
formatted
strings
static
FILE
null_device_handle
ifdef
_WIN32
define
NULL_DEVICE_NAME
NUL
else
define
NULL_DEVICE_NAME
dev
null
endif
_WIN32
ifdef
MALLOC_COUNT
unsigned
long
malloc_count
unsigned
long
malloc_size
endif
m
must
be
a
string
like
ESBERR
for
this
to
work
define
ESBERR
m
esb_appendn_internal
data
m
sizeof
m
define
INCRVALIDATENEXT
n
do
n
if
format
n
ESBERR
ESBERR_next_followedby_end
return
while
FILE
esb_open_null_device
void
if
null_device_handle
null_device_handle
fopen
NULL_DEVICE_NAME
w
return
null_device_handle
Close
the
null
device
used
during
formatting
printing
void
esb_close_null_device
void
if
null_device_handle
fclose
null_device_handle
null_device_handle
min_len
is
overall
space
wanted
for
initial
alloc
ASSERT
esb_allocated_size
static
void
init_esb_string
struct
esb_s
data
size_t
min_len
char
d
if
data
esb_allocated_size
return
Only
esb_constructor
applied
so
far
Now
Allow
for
string
space
if
min_len
alloc_size
min_len
alloc_size
else
min_len
Allow
for
NUL
at
end
d
malloc
min_len
ifdef
MALLOC_COUNT
malloc_count
malloc_size
min_len
endif
if
d
fprintf
stderr
dwarfdump
is
out
of
memory
allocating
lu
bytes
n
unsigned
long
min_len
exit
data
esb_string
d
data
esb_allocated_size
min_len
data
esb_string
data
esb_used_bytes
Make
more
room
Leaving
contents
unchanged
effectively
The
NUL
byte
at
end
has
room
and
this
preserves
that
room
static
void
esb_allocate_more
struct
esb_s
data
size_t
len
size_t
new_size
char
newd
if
data
esb_rigid
return
if
data
esb_allocated_size
init_esb_string
data
alloc_size
new_size
data
esb_allocated_size
len
if
new_size
alloc_size
new_size
alloc_size
if
data
esb_fixed
newd
malloc
new_size
ifdef
MALLOC_COUNT
malloc_count
malloc_size
len
endif
if
newd
memcpy
newd
data
esb_string
data
esb_used_bytes
else
newd
realloc
data
esb_string
new_size
ifdef
MALLOC_COUNT
malloc_count
malloc_size
len
endif
if
newd
fprintf
stderr
dwarfdump
is
out
of
memory
allocating
lu
bytes
n
unsigned
long
new_size
exit
If
the
area
was
reallocated
by
realloc
the
earlier
space
was
free
d
by
realloc
data
esb_string
newd
data
esb_allocated_size
new_size
data
esb_fixed
Ensure
that
the
total
buffer
length
is
large
enough
that
at
least
minlen
bytes
are
available
unused
in
the
allocation
void
esb_force_allocation
struct
esb_s
data
size_t
minlen
size_t
target_len
if
data
esb_rigid
return
if
data
esb_allocated_size
init_esb_string
data
alloc_size
target_len
data
esb_used_bytes
minlen
if
data
esb_allocated_size
target_len
size_t
needed
target_len
data
esb_allocated_size
esb_allocate_more
data
needed
The
len
is
believed
Do
not
pass
in
strings
len
bytes
long
For
strlen
in_string
len
bytes
we
take
the
initial
len
bytes
len
does
not
include
the
trailing
NUL
static
void
esb_appendn_internal
struct
esb_s
data
const
char
in_string
size_t
len
size_t
remaining
size_t
needed
len
if
data
esb_allocated_size
size_t
maxlen
len
alloc_size
len
alloc_size
init_esb_string
data
maxlen
ASSERT
data
esb_allocated_size
data
esb_used_bytes
remaining
data
esb_allocated_size
data
esb_used_bytes
if
remaining
needed
if
data
esb_rigid
len
remaining
len
remaining
else
size_t
alloc_amt
needed
remaining
esb_allocate_more
data
alloc_amt
if
len
No
room
for
anything
more
or
no
more
requested
return
Might
be
that
len
string
len
so
do
not
assume
len
byte
is
a
NUL
byte
memcpy
esb_string
data
esb_used_bytes
in_string
len
data
esb_used_bytes
len
Insist
on
explicit
NUL
terminator
data
esb_string
data
esb_used_bytes
len
strlen
in_string
void
esb_appendn
struct
esb_s
data
const
char
in_string
size_t
len
size_t
full_len
strlen
in_string
if
full_len
len
ESBERR
ESBERR_appendn
bad
call
return
esb_appendn_internal
data
in_string
len
The
length
is
gotten
from
the
in_string
itself
this
is
the
usual
way
to
add
string
data
void
esb_append
struct
esb_s
data
const
char
in_string
size_t
len
if
in_string
len
strlen
in_string
if
len
esb_appendn_internal
data
in_string
len
Always
returns
an
empty
string
or
a
non
empty
string
Never
char
esb_get_string
struct
esb_s
data
if
data
esb_allocated_size
init_esb_string
data
alloc_size
return
data
esb_string
Sets
esb_used_bytes
to
zero
The
string
is
not
freed
and
esb_allocated_size
is
unchanged
void
esb_empty_string
struct
esb_s
data
if
data
esb_allocated_size
init_esb_string
data
alloc_size
data
esb_used_bytes
data
esb_string
Return
esb_used_bytes
size_t
esb_string_len
struct
esb_s
data
return
data
esb_used_bytes
data
is
presumed
to
contain
garbage
not
values
and
is
properly
initialized
here
void
esb_constructor
struct
esb_s
data
memset
data
sizeof
data
ASSERT
buflen
void
esb_constructor_fixed
struct
esb_s
data
char
buf
size_t
buflen
memset
data
sizeof
data
if
buflen
return
data
esb_string
buf
data
esb_string
data
esb_allocated_size
buflen
data
esb_used_bytes
data
esb_rigid
data
esb_fixed
The
string
is
freed
contents
of
data
set
to
zeros
void
esb_destructor
struct
esb_s
data
if
data
esb_fixed
data
esb_allocated_size
data
esb_used_bytes
data
esb_string
data
esb_rigid
data
esb_fixed
return
if
data
esb_string
free
data
esb_string
data
esb_string
esb_constructor
data
To
get
all
paths
in
the
code
tested
this
sets
the
initial
allocation
reallocation
file
static
which
can
be
quite
small
but
must
not
be
zero
The
alloc_size
variable
is
used
for
initializations
void
esb_alloc_size
size_t
size
if
size
size
alloc_size
size
size_t
esb_get_allocated_size
struct
esb_s
data
return
data
esb_allocated_size
static
void
esb_appendn_internal_spaces
struct
esb_s
data
size_t
l
static
char
spacebuf
size_t
charct
sizeof
spacebuf
while
l
charct
esb_appendn_internal
data
spacebuf
charct
l
charct
ASSERT
l
esb_appendn_internal
data
spacebuf
l
static
void
esb_appendn_internal_zeros
struct
esb_s
data
size_t
l
static
char
zeros
size_t
charct
sizeof
zeros
while
l
charct
esb_appendn_internal
data
zeros
charct
l
charct
ASSERT
l
esb_appendn_internal
data
zeros
l
void
esb_append_printf_s
struct
esb_s
data
const
char
format
const
char
s
size_t
stringlen
strlen
s
size_t
next
long
val
char
endptr
const
char
numptr
was
fixedlen
Zero
means
no
len
provided
size_t
fixedlen
was
nonzero
means
left
justify
long
leftjustify
size_t
prefixlen
while
format
next
format
next
next
prefixlen
if
prefixlen
esb_appendn_internal
data
format
prefixlen
if
format
next
No
operator
found
ESBERR
ESBERR
esb_append_printf_s
has
no
percent
operator
return
next
if
format
next
ESBERR
ESBERR_pct_followedby_space_in_s
return
if
format
next
ESBERR
ESBERR_pct_followedby_wrong_in_s
return
if
format
next
leftjustify
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
if
format
next
s
ESBERR
ESBERR_pct_s_missing_in_s
return
next
if
fixedlen
fixedlen
stringlen
leftjustify
if
leftjustify
esb_appendn_internal
data
s
stringlen
if
fixedlen
size_t
trailingspaces
fixedlen
stringlen
esb_appendn_internal_spaces
data
trailingspaces
else
if
fixedlen
fixedlen
stringlen
This
lets
us
have
fixedlen
stringlen
by
taking
all
the
chars
from
s
ignoring
the
fixedlen
esb_appendn_internal
data
s
stringlen
else
if
fixedlen
size_t
leadingspaces
fixedlen
stringlen
size_t
k
for
k
leadingspaces
k
esb_appendn_internal
data
esb_appendn_internal
data
s
stringlen
if
format
next
return
const
char
startpt
format
next
size_t
suffixlen
strlen
startpt
esb_appendn_internal
data
startpt
suffixlen
return
static
char
dtable
static
char
xtable
a
b
c
d
e
f
static
char
Xtable
A
B
C
D
E
F
With
gcc
version
a
version
using
const
char
formatp
instead
of
format
next
and
deleting
the
next
variable
is
a
few
hundredths
of
a
second
slower
repeatably
We
deal
with
formats
like
u
and
ld
and
lld
too
x
and
ld
and
lld
too
void
esb_append_printf_u
struct
esb_s
data
const
char
format
esb_unsigned
v
size_t
next
long
val
char
endptr
const
char
numptr
size_t
fixedlen
int
leadingzero
int
lcount
int
ucount
int
dcount
int
xcount
int
Xcount
char
ctable
size_t
divisor
size_t
prefixlen
while
format
next
format
next
next
prefixlen
esb_appendn_internal
data
format
prefixlen
if
format
next
No
operator
found
ESBERR
ESBERR
esb_append_printf_u
has
no
percent
operator
return
next
if
format
next
ESBERR
ESBERR_pct_followedby_space_in_s
return
if
format
next
ESBERR
ESBERR_pct_followedby_wrong_in_s
return
if
format
next
ESBERR
ESBERR_printf_u
format
not
supported
INCRVALIDATENEXT
next
if
format
next
leadingzero
INCRVALIDATENEXT
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
Following
is
lx
lu
or
u
or
llx
llu
we
take
all
this
to
mean
bits
ifdef
_WIN32
if
format
next
I
lcount
next
if
format
next
lcount
next
if
format
next
lcount
next
endif
_WIN32
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
u
ucount
next
if
format
next
d
dcount
next
if
format
next
x
xcount
next
if
format
next
X
Xcount
next
if
format
next
s
ESBERR
ESBERR_pct_scount_in_u
return
if
Xcount
xcount
dcount
ucount
ESBERR
ESBERR_pct_xcount_etc_u
error
return
if
lcount
ESBERR
ESBERR_pct_lcount_error_u
error
return
if
dcount
ESBERR
ESBERR_pct_dcount_error_u
error
return
if
ucount
divisor
ctable
dtable
else
divisor
if
xcount
ctable
xtable
else
ctable
Xtable
char
digbuf
char
digptr
size_t
digcharlen
esb_unsigned
remaining
v
if
divisor
digptr
digbuf
sizeof
digbuf
for
esb_unsigned
dig
dig
remaining
remaining
remaining
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
else
digptr
digbuf
sizeof
digbuf
digptr
digptr
for
esb_unsigned
dig
dig
remaining
divisor
remaining
divisor
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
if
fixedlen
digcharlen
esb_appendn_internal
data
digptr
digcharlen
else
if
leadingzero
size_t
justcount
fixedlen
digcharlen
esb_appendn_internal_spaces
data
justcount
esb_appendn_internal
data
digptr
digcharlen
else
size_t
prefixcount
fixedlen
digcharlen
esb_appendn_internal_zeros
data
prefixcount
esb_appendn_internal
data
digptr
digcharlen
if
format
next
size_t
trailinglen
strlen
format
next
esb_appendn_internal
data
format
next
trailinglen
static
char
v32m
static
char
v64m
We
deal
with
formats
like
d
d
and
ld
and
lld
too
void
esb_append_printf_i
struct
esb_s
data
const
char
format
esb_int
v
size_t
next
long
val
char
endptr
const
char
numptr
size_t
fixedlen
int
leadingzero
int
pluscount
int
lcount
int
ucount
int
dcount
int
xcount
int
Xcount
char
ctable
dtable
size_t
prefixlen
int
done
while
format
next
format
next
next
prefixlen
esb_appendn_internal
data
format
prefixlen
if
format
next
No
operator
found
ESBERR
ESBERR
esb_append_printf_i
has
no
percent
operator
return
next
if
format
next
ESBERR
ESBERR_pct_followedby_space_in_s
return
if
format
next
ESBERR
ESBERR_pct_followedby_wrong_in_s
return
if
format
next
ESBERR
ESBERR_printf_i
format
not
supported
INCRVALIDATENEXT
next
if
format
next
pluscount
INCRVALIDATENEXT
next
if
format
next
leadingzero
INCRVALIDATENEXT
next
numptr
format
next
val
strtol
numptr
if
endptr
numptr
fixedlen
val
next
endptr
format
Following
is
lx
lu
or
u
or
llx
llu
we
take
all
this
to
mean
bits
ifdef
_WIN32
if
format
next
I
lcount
next
if
format
next
lcount
next
if
format
next
lcount
next
endif
_WIN32
if
format
next
l
lcount
next
if
format
next
l
lcount
next
if
format
next
u
ucount
next
if
format
next
d
dcount
next
if
format
next
x
xcount
next
if
format
next
X
Xcount
next
if
format
next
s
ESBERR
ESBERR_pct_scount_in_i
return
if
dcount
lcount
Xcount
xcount
dcount
ucount
error
ESBERR
ESBERR_xcount_etc_i
return
char
digbuf
char
digptr
digbuf
sizeof
digbuf
size_t
digcharlen
esb_int
remaining
v
int
vissigned
esb_int
divisor
digptr
digptr
if
v
vissigned
This
test
is
for
twos
complement
machines
and
would
be
better
done
via
configure
with
a
compile
time
check
so
we
do
not
need
a
size
test
at
runtime
if
sizeof
v
esb_unsigned
vm
if
vm
esb_unsigned
memcpy
digbuf
v64m
sizeof
v64m
digcharlen
sizeof
v64m
digptr
digbuf
done
else
remaining
v
else
if
sizeof
v
esb_unsigned
vm
if
vm
esb_unsigned
memcpy
digbuf
v32m
sizeof
v32m
digcharlen
sizeof
v32m
digptr
digbuf
done
else
remaining
v
else
ESBERR
ESBERR_sizeof_v_i
error
return
if
done
for
esb_unsigned
dig
dig
remaining
divisor
remaining
divisor
digptr
ctable
dig
digcharlen
if
remaining
break
digptr
if
vissigned
digptr
digcharlen
digptr
else
if
pluscount
digptr
digcharlen
digptr
if
fixedlen
if
fixedlen
digcharlen
esb_appendn_internal
data
digptr
digcharlen
else
size_t
prefixcount
fixedlen
digcharlen
if
leadingzero
esb_appendn_internal_spaces
data
prefixcount
esb_appendn_internal
data
digptr
digcharlen
else
if
digptr
esb_appendn_internal
data
esb_appendn_internal_zeros
data
prefixcount
digptr
esb_appendn_internal
data
digptr
digcharlen
else
if
digptr
esb_appendn_internal
data
esb_appendn_internal_zeros
data
prefixcount
digptr
esb_appendn_internal
data
digptr
digcharlen
else
esb_appendn_internal_zeros
data
prefixcount
esb_appendn_internal
data
digptr
digcharlen
else
esb_appendn_internal
data
digptr
digcharlen
if
format
next
size_t
trailinglen
strlen
format
next
esb_appendn_internal
data
format
next
trailinglen
Append
a
formatted
string
void
esb_append_printf
struct
esb_s
data
const
char
in_string
va_list
ap
size_t
len
size_t
len2
size_t
remaining
if
null_device_handle
if
esb_open_null_device
esb_append
data
Unable
to
open
null
printf
device
on
esb_append
data
in_string
return
va_start
ap
in_string
len
vfprintf
null_device_handle
in_string
ap
va_end
ap
if
data
esb_allocated_size
init_esb_string
data
alloc_size
remaining
data
esb_allocated_size
data
esb_used_bytes
if
remaining
len
if
data
esb_rigid
No
room
give
up
return
else
esb_allocate_more
data
len
va_start
ap
in_string
ifdef
HAVE_VSNPRINTF
len2
vsnprintf
esb_string
data
esb_used_bytes
data
esb_allocated_size
in_string
ap
else
len2
vsprintf
esb_string
data
esb_used_bytes
in_string
ap
endif
va_end
ap
data
esb_used_bytes
len2
if
len2
len
We
are
in
big
trouble
this
should
be
impossible
We
have
trashed
something
in
memory
fprintf
stderr
dwarfdump
esb
internal
error
vsprintf
botch
lu
lu
n
unsigned
long
len2
unsigned
long
len
exit
return
Get
a
copy
of
the
internal
data
buffer
It
is
up
to
the
code
calling
this
to
free
the
string
using
the
pointer
returned
here
char
esb_get_copy
struct
esb_s
data
char
copy
NULL
is
ok
as
is
if
esb_allocated_size
is
size_t
len
data
esb_used_bytes
if
len
copy
char
malloc
len
ifdef
MALLOC_COUNT
malloc_count
malloc_size
len
endif
memcpy
copy
data
esb_string
len
return
copy
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
All
the
dwarfdump
flags
are
gathered
into
a
single
global
struct
as
it
has
been
hard
to
know
how
many
there
were
or
what
they
were
all
for
include
globals
h
include
limits
h
include
esb
h
For
flexible
string
buffer
include
dwconf
h
ifdef
HAVE_REGEX
regex_t
_search_re
endif
ifdef
TRIVIAL_NAMING
For
scripts
buildstandardsource
sh
struct
glflags_s
glflags
void
safe_strcpy
char
out
long
outlen
const
char
in
long
inlen
if
inlen
outlen
strncpy
out
in
outlen
out
outlen
else
strcpy
out
in
endif
TRIVIAL_NAMING
static
struct
section_high_offsets_s
_section_high_offsets_global
static
struct
dwconf_s
_config_file_data
used
in
special_program_name
only
static
struct
esb_s
_newprogname
static
struct
esb_s
_cu_name
static
struct
esb_s
_config_file_path
static
struct
esb_s
_config_file_tiedpath
void
init_global_flags
void
glflags
gf_debug_names_flag
FALSE
glflags
gf_info_flag
FALSE
glflags
gf_use_old_dwarf_loclist
FALSE
This
so
both
dwarf_loclist_n
and
dwarf_get_loclist_c
and
the
dwarf_loclist_from_expr
variations
can
be
tested
Defaults
to
new
dwarf_get_loclist_c
See
g
option
The
original
IRIX
dwarf_loclist
no
longer
tested
as
of
October
glflags
gf_line_flag_selection
s2l
glflags
gf_line_flag
FALSE
Setting
this
FALSE
tells
dwarfdump
to
use
the
old
line
table
interfaces
using
x
line5
no
The
new
interfaces
allow
for
both
two
level
line
tables
and
access
to
line
table
headers
in
case
we
have
a
DWARF5
skeleton
line
table
a
line
table
header
with
no
lines
glflags
gf_line_skeleton_flag
TRUE
glflags
gf_line_print_pc
TRUE
Print
pc
addresses
glflags
gf_abbrev_flag
FALSE
glflags
gf_frame_flag
FALSE
debug_frame
section
glflags
gf_eh_frame_flag
FALSE
GNU
eh_frame
section
glflags
gf_pubnames_flag
FALSE
DWARF2
Old
macro
section
glflags
gf_macinfo_flag
FALSE
DWARF5
and
DWARF4
extension
new
macro
section
glflags
gf_macro_flag
FALSE
glflags
gf_loc_flag
FALSE
glflags
gf_aranges_flag
FALSE
debug_aranges
section
glflags
gf_ranges_flag
FALSE
debug_ranges
section
glflags
gf_string_flag
FALSE
glflags
gf_reloc_flag
FALSE
glflags
gf_static_func_flag
FALSE
glflags
gf_static_var_flag
FALSE
glflags
gf_types_flag
FALSE
glflags
gf_weakname_flag
FALSE
Control
printing
of
Elf
header
glflags
gf_header_flag
FALSE
glflags
gf_gdbindex_flag
FALSE
List
of
CUs
per
compiler
glflags
gf_producer_children_flag
FALSE
glflags
gf_check_abbrev_code
FALSE
glflags
gf_check_pubname_attr
FALSE
glflags
gf_check_reloc_offset
FALSE
glflags
gf_check_tag_attr
FALSE
glflags
gf_check_tag_tree
FALSE
glflags
gf_check_type_offset
FALSE
glflags
gf_check_decl_file
FALSE
glflags
gf_check_macros
FALSE
glflags
gf_check_lines
FALSE
glflags
gf_check_fdes
FALSE
glflags
gf_check_ranges
FALSE
glflags
gf_check_aranges
FALSE
glflags
gf_check_harmless
FALSE
glflags
gf_check_abbreviations
FALSE
glflags
gf_check_dwarf_constants
FALSE
glflags
gf_check_di_gaps
FALSE
glflags
gf_check_forward_decl
FALSE
glflags
gf_check_self_references
FALSE
Attributes
encoding
glflags
gf_check_attr_encoding
FALSE
glflags
gf_generic_1200_regs
FALSE
glflags
gf_suppress_check_extensions_tables
FALSE
glflags
gf_check_duplicated_attributes
FALSE
glflags
gf_no_sanitize_strings
FALSE
lots
of
checks
make
no
sense
on
a
dwp
debugfission
object
glflags
gf_suppress_checking_on_dwp
FALSE
glflags
gf_file_use_no_libelf
FALSE
suppress_nested_name_search
is
a
band
aid
A
workaround
A
real
fix
for
N
behavior
is
needed
glflags
gf_suppress_nested_name_search
FALSE
glflags
gf_uri_options_translation
TRUE
glflags
gf_do_print_uri_in_input
TRUE
glflags
gf_print_unique_errors
FALSE
glflags
gf_found_error_message
FALSE
if
TRUE
use
old
behavior
of
all
expr
ops
joined
on
one
line
glflags
gf_expr_ops_joined
FALSE
glflags
gf_print_raw_rnglists
FALSE
glflags
gf_check_names
FALSE
During
k
mode
display
errors
glflags
gf_check_verbose_mode
TRUE
glflags
gf_check_frames
FALSE
Extensive
frames
check
glflags
gf_check_frames_extended
FALSE
glflags
gf_check_locations
FALSE
glflags
gf_print_usage_tag_attr
FALSE
glflags
gf_print_usage_tag_attr_full
FALSE
glflags
gf_check_all_compilers
TRUE
glflags
gf_check_snc_compiler
FALSE
glflags
gf_check_gcc_compiler
FALSE
glflags
gf_print_summary_all
FALSE
The
check
and
print
flags
here
make
it
easy
to
allow
check
only
or
print
only
We
no
longer
support
check
and
print
in
a
single
run
glflags
gf_do_check_dwarf
FALSE
glflags
gf_do_print_dwarf
FALSE
glflags
gf_check_show_results
FALSE
glflags
gf_record_dwarf_error
FALSE
A
test
has
failed
this
is
normally
set
FALSE
shortly
after
being
set
TRUE
it
is
a
short
range
hint
we
should
print
something
we
might
not
otherwise
print
under
the
circumstances
glflags
gf_check_debug_names
FALSE
Display
parent
children
when
in
wide
format?
glflags
gf_display_parent_tree
FALSE
glflags
gf_display_children_tree
FALSE
glflags
gf_stop_indent_level
is
sort
of
arbitrary
it
tries
to
keep
the
indentation
sane
a
level
DIE
tree
is
just
too
much
to
represent
with
prefix
spaces
glflags
gf_max_space_indent
Print
search
results
in
wide
format?
glflags
gf_search_wide_format
FALSE
S
option
strings
for
any
and
match
glflags
gf_search_is_on
FALSE
glflags
gf_search_print_results
FALSE
glflags
gf_cu_name_flag
FALSE
glflags
gf_show_global_offsets
FALSE
glflags
gf_display_offsets
TRUE
Means
we
need
to
search
by
addr
Split
Dwarf
glflags
gf_debug_addr_missing
glflags
gf_error_code_search_by_address
glflags
gf_all_cus_seen_search_by_address
Base
address
has
a
special
meaning
in
DWARF4
relative
to
address
ranges
glflags
seen_PU
FALSE
Detected
a
PU
glflags
seen_CU
FALSE
Detected
a
CU
glflags
need_CU_name
TRUE
Need
CU
name
glflags
need_CU_base_address
TRUE
Need
CU
Base
address
glflags
need_CU_high_address
TRUE
Need
CU
High
address
glflags
need_PU_valid_code
TRUE
Need
PU
valid
code
Involved
with
need_PU_valid_code
set
in
dwarfdump
c
in_valid_code
set
when
subprogram
DIE
or
CU
DIE
has
lowpc
and
highpc
glflags
in_valid_code
FALSE
Detected
a
Base
address
for
PU
glflags
seen_PU_base_address
FALSE
Detected
a
High
address
for
PU
glflags
seen_PU_high_address
FALSE
glflags
PU_base_address
PU
Base
address
glflags
PU_high_address
PU
High
address
glflags
DIE_offset
DIE
offset
in
compile
unit
glflags
DIE_overall_offset
DIE
offset
in
debug_info
These
globals
enable
better
error
reporting
CU
DIE
offset
in
compile
unit
glflags
DIE_CU_offset
CU
DIE
offset
in
debug_info
glflags
DIE_CU_overall_offset
glflags
current_section_id
Section
being
process
Base
Address
is
needed
for
range
lists
and
must
come
from
a
CU
Low
address
is
for
information
and
can
come
from
a
function
or
something
in
the
CU
glflags
CU_base_address
CU
Base
address
glflags
CU_low_address
CU
low
address
glflags
CU_high_address
CU
High
address
glflags
fde_offset_for_cu_low
DW_DLV_BADOFFSET
glflags
fde_offset_for_cu_high
DW_DLV_BADOFFSET
glflags
program_name
NULL
glflags
program_fullname
NULL
Able
to
generate
report
on
search
glflags
search_any_text
glflags
search_match_text
glflags
search_regex_text
glflags
search_occurrences
ifdef
HAVE_REGEX
glflags
search_re
endif
Start
verbose
at
zero
verbose
can
be
incremented
with
v
but
not
decremented
glflags
verbose
glflags
gf_show_dwarfdump_conf
glflags
dense
FALSE
glflags
ellipsis
FALSE
glflags
show_form_used
FALSE
break_after_n_units
is
mainly
for
testing
It
enables
easy
limiting
of
output
size
running
time
when
one
wants
the
output
limited
For
example
H
limits
the
i
output
to
compilation
units
and
the
f
or
F
output
to
FDEs
and
CIEs
glflags
break_after_n_units
INT_MAX
glflags
section_high_offsets_global
glflags
pRangesInfo
NULL
glflags
pLinkonceInfo
NULL
glflags
pVisitedInfo
NULL
These
names
make
diagnostic
messages
more
complete
the
fixed
length
is
safe
though
ultra
long
names
will
get
truncated
glflags
PU_name
glflags
CU_name
glflags
CU_producer
Options
to
enable
debug
tracing
int
i
for
i
MAX_TRACE_LEVEL
i
glflags
nTrace
i
Output
filename
glflags
output_file
glflags
group_number
Global
esb
buffers
glflags
newprogname
esb_constructor
glflags
newprogname
glflags
cu_name
esb_constructor
glflags
cu_name
glflags
config_file_path
esb_constructor
glflags
config_file_path
glflags
config_file_tiedpath
esb_constructor
glflags
config_file_tiedpath
glflags
config_file_data
Check
errors
glflags
check_error
glflags
gf_print_alloc_sums
void
reset_global_flags
void
esb_destructor
glflags
newprogname
esb_destructor
glflags
cu_name
esb_destructor
glflags
config_file_path
esb_destructor
glflags
config_file_tiedpath
When
we
add
a
print
option
after
an
option
requests
one
or
more
checks
we
turn
off
all
checking
putting
it
back
to
default
checking
state
void
set_checks_off
void
glflags
gf_check_abbrev_code
FALSE
glflags
gf_check_pubname_attr
FALSE
glflags
gf_check_reloc_offset
FALSE
glflags
gf_check_tag_attr
FALSE
glflags
gf_check_tag_tree
FALSE
glflags
gf_check_type_offset
FALSE
glflags
gf_check_decl_file
FALSE
glflags
gf_check_lines
FALSE
glflags
gf_check_fdes
FALSE
glflags
gf_check_ranges
FALSE
glflags
gf_check_aranges
FALSE
glflags
gf_check_harmless
FALSE
glflags
gf_check_abbreviations
FALSE
glflags
gf_check_dwarf_constants
FALSE
glflags
gf_check_di_gaps
FALSE
glflags
gf_check_forward_decl
FALSE
glflags
gf_check_self_references
FALSE
glflags
gf_check_attr_encoding
FALSE
glflags
gf_check_duplicated_attributes
FALSE
glflags
gf_check_debug_names
FALSE
Making
this
a
named
string
makes
it
simpler
to
change
what
the
reset
or
I
do
not
know
value
is
for
CU
name
or
producer
name
for
PRINT_CU_INFO
different
string
string
is
seen
in
dwarfdump
c
when
getting
producer
name
for
the
list
of
CUs
shown
by
P
print
producers
and
in
Compilers
detected
output
static
const
char
default_cu_producer
unknown
void
reset_overall_CU_error_data
void
safe_strcpy
glflags
CU_name
sizeof
glflags
CU_name
default_cu_producer
strlen
default_cu_producer
safe_strcpy
glflags
CU_producer
sizeof
glflags
CU_producer
default_cu_producer
strlen
default_cu_producer
glflags
DIE_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_CU_overall_offset
glflags
CU_base_address
glflags
CU_high_address
glflags
CU_low_address
Dwarf_Bool
cu_data_is_set
void
if
strcmp
glflags
CU_name
default_cu_producer
strcmp
glflags
CU_producer
default_cu_producer
return
if
glflags
DIE_offset
glflags
DIE_overall_offset
return
if
glflags
CU_base_address
glflags
CU_low_address
glflags
CU_high_address
return
return
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
endif
HAVE_STDINT_H
include
dwarf_tsearch
h
include
helpertree
h
define
TRUE
define
FALSE
WARNING
the
tree
walk
functions
will
if
presented
tree
when
tree
is
wanted
simply
find
nothing
No
error
just
bad
results
So
when
a
walk
produces
nothing
suspect
a
code
mistake
here
The
basic
problem
is
void
is
a
terrible
way
to
pass
in
a
pointer
But
it
s
how
tsearch
was
defined
long
ago
For
debug_info
not
for
tied
file
struct
Helpertree_Base_s
helpertree_offsets_base_info
For
debug_types
not
for
tied
file
struct
Helpertree_Base_s
helpertree_offsets_base_types
static
struct
Helpertree_Map_Entry_s
helpertree_map_create_entry
Dwarf_Unsigned
offset
int
val
struct
Helpertree_Map_Entry_s
mp
struct
Helpertree_Map_Entry_s
calloc
sizeof
struct
Helpertree_Map_Entry_s
if
mp
return
mp
hm_key
offset
mp
hm_val
val
return
mp
static
void
helpertree_map_free_func
void
mx
struct
Helpertree_Map_Entry_s
m
mx
free
m
static
int
helpertree_map_compare_func
const
void
l
const
void
r
const
struct
Helpertree_Map_Entry_s
ml
l
const
struct
Helpertree_Map_Entry_s
mr
r
if
ml
hm_key
mr
hm_key
return
if
ml
hm_key
mr
hm_key
return
return
static
void
helpertree_map_destroy
void
map
tdestroy
is
not
part
of
Posix
dwarf_tdestroy
map
helpertree_map_free_func
Globally
visible
functions
follow
this
line
struct
Helpertree_Map_Entry_s
helpertree_add_entry
Dwarf_Unsigned
offset
int
val
struct
Helpertree_Base_s
base
void
retval
struct
Helpertree_Map_Entry_s
re
struct
Helpertree_Map_Entry_s
e
void
tree1
tree1
hb_base
e
helpertree_map_create_entry
offset
val
tsearch
records
e
s
contents
unless
e
is
already
present
We
must
not
free
it
till
destroy
time
if
it
got
added
to
tree1
retval
dwarf_tsearch
e
tree1
helpertree_map_compare_func
if
retval
re
struct
Helpertree_Map_Entry_s
retval
if
re
e
We
returned
an
existing
record
e
not
needed
Set
val
re
hm_val
val
helpertree_map_free_func
e
else
Record
e
got
added
to
tree1
do
not
free
record
e
return
retval
return
NULL
struct
Helpertree_Map_Entry_s
helpertree_find
Dwarf_Unsigned
offset
struct
Helpertree_Base_s
base
void
retval
struct
Helpertree_Map_Entry_s
re
struct
Helpertree_Map_Entry_s
e
e
helpertree_map_create_entry
offset
retval
dwarf_tfind
e
hb_base
helpertree_map_compare_func
if
retval
re
struct
Helpertree_Map_Entry_s
retval
The
one
we
created
here
must
be
deleted
it
is
dead
We
look
at
the
returned
one
instead
helpertree_map_free_func
e
return
re
void
helpertree_clear_statistics
struct
Helpertree_Base_s
base
if
base
return
if
base
hb_base
return
helpertree_map_destroy
base
hb_base
base
hb_base
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
macrocheck
c
h
create
a
map
of
macro
import
operators
to
establish
that
they
are
resolved
and
that
their
offsets
refer
to
actual
macro
groups
This
is
across
all
CUs
in
the
object
file
not
per
cu
DEFECTS
There
are
some
things
done
here
that
are
not
correct
and
need
fixing
at
some
point
See
macfile_stack
macro_import_stack
macro_check_tree
and
macinfo_check_tree
here
and
in
print_macro
c
and
in
print_die
c
print_macro
c
print_die
c
and
macrocheck
c
work
together
in
checking
DWARF
macro
data
A
macro_import_stack
and
macfile_stack
are
global
to
dwarfdump
and
therefore
these
can
only
be
safely
used
with
DWARF5
style
debug_macro
data
Not
with
debug_macinfo
B
To
support
debug_macro_sup
in
a
separate
object
will
likely
require
moving
all
the
macro
data
out
of
global
and
into
something
per
open
dbg
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
endif
HAVE_STDINT_H
include
dwarf_tsearch
h
include
macrocheck
h
include
esb
h
define
TRUE
define
FALSE
WARNING
the
tree
walk
functions
will
if
presented
tree
when
tree
is
wanted
simply
find
nothing
No
error
just
bad
results
So
when
a
walk
produces
nothing
suspect
a
code
mistake
here
The
basic
problem
is
void
is
a
terrible
way
to
pass
in
a
pointer
But
it
s
how
tsearch
was
defined
long
ago
Dwarf_Unsigned
macro_import_stack
MACRO_IMPORT_STACK_DEPTH
unsigned
macro_import_stack_next_to_use
unsigned
macro_import_stack_max_seen
unsigned
macfile_stack_next_to_use
unsigned
macfile_stack
MACFILE_STACK_DEPTH_MAX
unsigned
macfile_stack_max_seen
void
macro_check_tree
DWARF5
macros
void
macinfo_check_tree
DWARF
macros
void
macdefundeftree
DWARF5
macros
static
struct
Macrocheck_Map_Entry_s
macrocheck_map_insert
Dwarf_Unsigned
off
unsigned
prim
unsigned
sec
Dwarf_Unsigned
linenum
unsigned
src_file_num
void
map
static
void
macrocheck_map_destroy
void
map
static
Dwarf_Unsigned
macro_count_recs
void
base
ifdef
SELFTEST
int
failcount
struct
glflags_s
glflags
endif
SELFTEST
static
struct
Macrocheck_Map_Entry_s
macrocheck_map_create_entry
Dwarf_Unsigned
offset
unsigned
add_primary
unsigned
add_secondary
struct
Macrocheck_Map_Entry_s
mp
struct
Macrocheck_Map_Entry_s
calloc
sizeof
struct
Macrocheck_Map_Entry_s
if
mp
return
mp
mp_key
offset
mp
mp_len
mp
mp_printed
mp
mp_refcount_primary
add_primary
mp
mp_refcount_secondary
add_secondary
return
mp
static
void
macrocheck_map_free_func
void
mx
struct
Macrocheck_Map_Entry_s
m
mx
free
m
static
int
macrocheck_map_compare_func
const
void
l
const
void
r
const
struct
Macrocheck_Map_Entry_s
ml
l
const
struct
Macrocheck_Map_Entry_s
mr
r
if
ml
mp_key
mr
mp_key
return
if
ml
mp_key
mr
mp_key
return
return
static
struct
Macrocheck_Map_Entry_s
macrocheck_map_insert
Dwarf_Unsigned
offset
unsigned
add_prim
unsigned
add_sec
Dwarf_Unsigned
line_num
unsigned
src_file_num
void
tree1
void
retval
struct
Macrocheck_Map_Entry_s
re
struct
Macrocheck_Map_Entry_s
e
e
macrocheck_map_create_entry
offset
add_prim
add_sec
tsearch
records
e
s
contents
unless
e
is
already
present
We
must
not
free
it
till
destroy
time
if
it
got
added
to
tree1
retval
dwarf_tsearch
e
tree1
macrocheck_map_compare_func
if
retval
re
struct
Macrocheck_Map_Entry_s
retval
if
re
e
We
returned
an
existing
record
e
not
needed
Increment
refcounts
Lets
update
line
filenum
to
latest
So
later
reports
show
latest
re
mp_import_linenum
line_num
re
mp_import_from_filenum
src_file_num
re
mp_refcount_primary
add_prim
re
mp_refcount_secondary
add_sec
macrocheck_map_free_func
e
else
New
record
e
mp_import_linenum
line_num
e
mp_import_from_filenum
src_file_num
Record
e
got
added
to
tree1
do
not
free
record
e
return
NULL
struct
Macrocheck_Map_Entry_s
macrocheck_map_find
Dwarf_Unsigned
offset
void
tree1
void
retval
struct
Macrocheck_Map_Entry_s
re
struct
Macrocheck_Map_Entry_s
e
e
macrocheck_map_create_entry
offset
retval
dwarf_tfind
e
tree1
macrocheck_map_compare_func
if
retval
re
struct
Macrocheck_Map_Entry_s
retval
The
one
we
created
here
must
be
deleted
it
is
dead
We
look
at
the
returned
one
instead
macrocheck_map_free_func
e
return
re
static
void
macrocheck_map_destroy
void
map
tdestroy
is
not
part
of
Posix
dwarf_tdestroy
map
macrocheck_map_free_func
void
add_macro_import_sup
void
base
UNUSEDARG
Dwarf_Unsigned
offset
UNUSEDARG
FIXME
return
void
add_macro_import
void
base
Dwarf_Bool
is_primary
Dwarf_Unsigned
offset
Dwarf_Unsigned
line_num
unsigned
src_filenum
Dwarf_Unsigned
prim_count
Dwarf_Unsigned
sec_count
if
is_primary
prim_count
else
sec_count
macrocheck_map_insert
offset
prim_count
sec_count
line_num
src_filenum
base
void
add_macro_area_len
void
base
Dwarf_Unsigned
offset
Dwarf_Unsigned
len
struct
Macrocheck_Map_Entry_s
re
re
macrocheck_map_find
offset
base
if
re
re
mp_len
len
static
Dwarf_Unsigned
reccount
static
void
macro_walk_count_recs
const
void
nodep
UNUSEDARG
const
DW_VISIT
which
const
int
depth
UNUSEDARG
if
which
dwarf_postorder
which
dwarf_endorder
return
reccount
static
Dwarf_Unsigned
macro_count_recs
void
base
reccount
dwarf_twalk
base
macro_walk_count_recs
return
reccount
static
Dwarf_Unsigned
lowestoff
static
Dwarf_Bool
lowestfound
FALSE
static
void
macro_walk_find_lowest
const
void
nodep
const
DW_VISIT
which
const
int
depth
UNUSEDARG
struct
Macrocheck_Map_Entry_s
re
struct
Macrocheck_Map_Entry_s
nodep
if
which
dwarf_postorder
which
dwarf_endorder
return
if
re
mp_printed
if
lowestfound
lowestoff
re
mp_key
lowestfound
TRUE
else
if
re
mp_key
lowestoff
lowestoff
re
mp_key
Never
returns
DW_DLV_ERROR
int
get_next_unprinted_macro_offset
void
tree
Dwarf_Unsigned
off
lowestfound
FALSE
lowestoff
This
walks
the
tree
to
find
one
entry
Which
could
get
slow
if
the
tree
has
lots
of
entries
dwarf_twalk
tree
macro_walk_find_lowest
if
lowestfound
return
DW_DLV_NO_ENTRY
off
lowestoff
return
DW_DLV_OK
void
mark_macro_offset_printed
void
base
Dwarf_Unsigned
offset
struct
Macrocheck_Map_Entry_s
re
re
macrocheck_map_find
offset
base
if
re
re
mp_printed
TRUE
static
struct
Macrocheck_Map_Entry_s
mac_as_array
static
unsigned
mac_as_array_next
static
void
macro_walk_to_array
const
void
nodep
const
DW_VISIT
which
const
int
depth
UNUSEDARG
struct
Macrocheck_Map_Entry_s
re
struct
Macrocheck_Map_Entry_s
nodep
if
which
dwarf_postorder
which
dwarf_endorder
return
mac_as_array
mac_as_array_next
re
mac_as_array_next
static
int
qsort_compare
const
void
lin
const
void
rin
const
struct
Macrocheck_Map_Entry_s
l
const
struct
Macrocheck_Map_Entry_s
lin
const
struct
Macrocheck_Map_Entry_s
r
const
struct
Macrocheck_Map_Entry_s
rin
if
l
mp_key
r
mp_key
return
if
l
mp_key
r
mp_key
return
if
l
mp_len
r
mp_len
return
if
l
mp_len
r
mp_len
return
return
static
void
warnprimeandsecond
struct
Macrocheck_Map_Entry_s
r
ifdef
SELFTEST
failcount
endif
glflags
gf_count_major_errors
printf
nERROR
For
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
there
is
a
nonzero
primary
count
of
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
with
a
secondary
count
of
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
r
mp_key
r
mp_key
r
mp_refcount_primary
r
mp_refcount_primary
r
mp_refcount_secondary
r
mp_refcount_secondary
int
print_macrocheck_statistics
const
char
name
void
tsbase
int
isdwarf5
Dwarf_Unsigned
section_size
Dwarf_Error
err
UNUSEDARG
Dwarf_Unsigned
count
Dwarf_Unsigned
lowest
Dwarf_Unsigned
highest
Dwarf_Unsigned
lastend
Dwarf_Unsigned
laststart
Dwarf_Unsigned
internalgap
Dwarf_Unsigned
wholegap
Dwarf_Unsigned
i
Dwarf_Unsigned
end
if
tsbase
return
DW_DLV_NO_ENTRY
count
macro_count_recs
tsbase
if
count
return
DW_DLV_NO_ENTRY
free
mac_as_array
mac_as_array
mac_as_array_next
mac_as_array
struct
Macrocheck_Map_Entry_s
calloc
count
sizeof
struct
Macrocheck_Map_Entry_s
if
mac_as_array
ifdef
SELFTEST
failcount
endif
glflags
gf_count_major_errors
printf
nERROR
Macro
checking
s
unable
to
allocate
DW_PR_DUu
pointers
n
name
count
Return
OK
so
dwarfdump
c
won
t
look
for
Dwarf_Error
return
DW_DLV_OK
dwarf_twalk
tsbase
macro_walk_to_array
printf
Macro
unit
count
s
DW_PR_DUu
n
name
count
qsort
mac_as_array
count
sizeof
struct
Macrocheck_Map_Entry_s
qsort_compare
for
i
i
count
i
struct
Macrocheck_Map_Entry_s
r
mac_as_array
i
if
printf
debugging
i
u
off
x
len
x
printed?
u
ref
prim
u
sec
u
n
unsigned
i
unsigned
r
mp_key
unsigned
r
mp_len
unsigned
r
mp_printed
unsigned
r
mp_refcount_primary
unsigned
r
mp_refcount_secondary
endif
if
r
mp_key
lowest
lowest
r
mp_key
end
r
mp_key
r
mp_len
if
end
highest
highest
end
if
r
mp_refcount_primary
ifdef
SELFTEST
failcount
endif
glflags
gf_count_major_errors
printf
nERROR
For
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
there
is
a
primary
reference
count
of
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
r
mp_key
r
mp_key
r
mp_refcount_primary
r
mp_refcount_primary
For
DWARF5
style
macros
in
debug_macro
having
both
counts
is
normal
Not
so
for
DWARF2
debug_macinfo
if
isdwarf5
r
mp_refcount_primary
r
mp_refcount_secondary
warnprimeandsecond
r
lastend
mac_as_array
mp_key
mac_as_array
mp_len
laststart
mac_as_array
mp_key
printf
Macro
Offsets
start
at
DW_PR_XZEROS
DW_PR_DUx
and
end
at
DW_PR_XZEROS
DW_PR_DUx
n
lowest
highest
for
i
i
count
i
struct
Macrocheck_Map_Entry_s
r
mac_as_array
i
if
printf
debugging
i
u
off
x
len
x
n
unsigned
i
unsigned
r
mp_key
unsigned
r
mp_len
endif
if
r
mp_key
lastend
internalgap
r
mp_key
lastend
else
if
r
mp_key
lastend
crazy
overlap
ifdef
SELFTEST
failcount
endif
glflags
gf_count_major_errors
printf
ERROR
For
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
there
is
a
crazy
overlap
with
the
previous
end
offset
of
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
previous
start
offset
of
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
r
mp_key
r
mp_key
lastend
lastend
laststart
laststart
laststart
r
mp_key
lastend
laststart
r
mp_len
wholegap
is
a
starting
offset
and
b
space
after
used
area
before
end
of
section
wholegap
mac_as_array
mp_key
internalgap
if
lastend
section_size
Something
seriously
wrong
ifdef
SELFTEST
failcount
endif
printf
ERROR
For
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
there
is
an
overlap
with
the
end
of
section
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
laststart
laststart
lastend
lastend
else
wholegap
section_size
lastend
if
wholegap
printf
Macro
Offsets
internal
unused
space
DW_PR_XZEROS
DW_PR_DUx
n
internalgap
printf
Macro
Offsets
total
unused
space
DW_PR_XZEROS
DW_PR_DUx
n
wholegap
if
macfile_stack_max_seen
printf
Maximum
nest
depth
of
DW_MACRO_start_file
u
n
macfile_stack_max_seen
if
macro_import_stack_max_seen
printf
Maximum
nest
depth
of
DW_MACRO_import
u
n
macro_import_stack_max_seen
free
mac_as_array
mac_as_array
mac_as_array_next
return
DW_DLV_OK
void
clear_macrocheck_statistics
void
tsbase
if
tsbase
return
macrocheck_map_destroy
tsbase
tsbase
void
print_macro_import_stack
void
unsigned
i
printf
Macro
Stack
Depth
u
n
macro_import_stack_next_to_use
for
i
macro_import_stack_next_to_use
i
printf
Macro
Stack
u
MOFF
DW_PR_XZEROS
DW_PR_DUx
n
i
macro_import_stack
i
Returns
DW_DLV_ERROR
if
the
push
could
not
done
which
would
be
because
full
Else
returns
DW_DLV_OK
int
macro_import_stack_push
Dwarf_Unsigned
offset
if
macro_import_stack_next_to_use
MACRO_IMPORT_STACK_DEPTH
printf
ERROR
The
macro_import_stack
has
exceeded
its
maximum
of
d
n
MACRO_IMPORT_STACK_DEPTH
print_macro_import_stack
glflags
gf_count_major_errors
return
DW_DLV_ERROR
macro_import_stack
macro_import_stack_next_to_use
offset
macro_import_stack_next_to_use
if
macro_import_stack_max_seen
macro_import_stack_next_to_use
macro_import_stack_max_seen
macro_import_stack_next_to_use
return
DW_DLV_OK
Returns
DW_DLV_ERROR
if
the
pop
could
not
done
else
returns
DW_DLV_OK
int
macro_import_stack_pop
void
if
macro_import_stack_next_to_use
printf
ERROR
The
macro_import_stack
is
empty
and
the
attempted
pop
is
impossible
A
dwarfdump
bug
n
glflags
gf_count_major_errors
return
DW_DLV_ERROR
macro_import_stack_next_to_use
return
DW_DLV_OK
Returns
DW_DLV_OK
if
offset
present
else
DW_DLV_NO_ENTRY
int
macro_import_stack_present
Dwarf_Unsigned
offset
unsigned
i
for
i
macro_import_stack_next_to_use
i
if
macro_import_stack
i
offset
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
void
macro_import_stack_cleanout
void
macro_import_stack_next_to_use
ifdef
SELFTEST
int
main
void
base
Dwarf_Unsigned
count
int
basefailcount
Dwarf_Error
err
int
isdwarf5
FALSE
Test
add_macro_import
TRUE
count
macro_count_recs
if
count
printf
FAIL
expect
count
got
DW_PR_DUu
n
count
failcount
print_macrocheck_statistics
test1
isdwarf5
Test
two
add_macro_area_len
add_macro_import
FALSE
add_macro_area_len
count
macro_count_recs
if
count
printf
FAIL
expect
count
got
DW_PR_DUu
n
count
failcount
print_macrocheck_statistics
test
isdwarf5
clear_macrocheck_statistics
Test
three
basefailcount
failcount
add_macro_import
TRUE
add_macro_area_len
add_macro_import
FALSE
add_macro_area_len
mark_macro_offset_printed
add_macro_import
FALSE
add_macro_area_len
add_macro_import
FALSE
add_macro_area_len
count
macro_count_recs
if
count
printf
FAIL
expect
count
got
DW_PR_DUu
n
count
failcount
printf
n
Expect
an
ERROR
about
overlap
with
the
end
of
section
n
print_macrocheck_statistics
test
isdwarf5
clear_macrocheck_statistics
if
basefailcount
failcount
printf
FAIL
Found
no
error
in
test
checking
n
failcount
else
failcount
basefailcount
Test
Four
basefailcount
failcount
add_macro_import
TRUE
add_macro_import
TRUE
add_macro_area_len
add_macro_import
FALSE
add_macro_import
FALSE
add_macro_import
FALSE
add_macro_area_len
printf
n
Expect
an
ERROR
about
offset
having
primaries
n
printf
and
Expect
an
ERROR
about
offset
having
n
primaries
and
a
secondary
n
printf
and
Expect
an
ERROR
about
crazy
overlap
n
n
print_macrocheck_statistics
test
isdwarf5
clear_macrocheck_statistics
if
basefailcount
failcount
printf
FAIL
Found
wrong
errors
in
test
checking
n
else
failcount
basefailcount
if
failcount
printf
FAIL
macrocheck
selftest
n
exit
printf
PASS
macrocheck
selftest
n
return
endif
SELFTEST
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
makename
c
This
used
to
be
elaborate
stuff
Now
it
is
trivial
as
duplicating
names
is
unimportant
in
dwarfdump
in
general
And
in
fact
this
is
only
called
for
attributes
and
tags
etc
whose
true
name
is
unknown
Not
for
any
normal
case
include
config
h
include
stdio
h
ifdef
HAVE_STRING_H
include
string
h
for
strchr
etc
endif
HAVE_STRING_H
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
exit
endif
HAVE_STDLIB_H
ifdef
HAVE_STDINT_H
include
stdint
h
endif
HAVE_STDINT_H
include
dwarf_tsearch
h
include
makename
h
include
globals
h
if
defined
__WIN32
defined
__GNUC__
defined
__clang__
pragma
warning
disable
Warning
when
migrated
to
VS2010
endif
_WIN32
define
TRUE
define
FALSE
static
void
makename_data
define
VALTYPE
char
static
int
value_compare_func
const
void
l
const
void
r
VALTYPE
ml
VALTYPE
l
VALTYPE
mr
VALTYPE
r
return
strcmp
ml
mr
Nothing
to
free
for
the
value
example
but
the
key
itself
static
void
value_node_free
void
valp
VALTYPE
v
VALTYPE
valp
free
v
void
makename_destructor
void
Pass
in
root
not
pointer
to
root
dwarf_tdestroy
makename_data
value_node_free
makename_data
WARNING
the
tree
walk
functions
will
if
presented
tree
when
tree
is
wanted
simply
find
nothing
No
error
just
bad
results
So
when
a
walk
produces
nothing
suspect
a
code
mistake
here
The
basic
problem
is
void
is
a
terrible
way
to
pass
in
a
pointer
But
it
s
how
tsearch
was
defined
long
ago
char
makename
const
char
s
char
newstr
VALTYPE
re
void
retval
if
s
return
newstr
char
strdup
s
retval
dwarf_tfind
newstr
value_compare_func
if
retval
We
found
our
string
it
existed
already
re
VALTYPE
retval
free
newstr
return
re
retval
dwarf_tsearch
newstr
value_compare_func
if
retval
Out
of
memory
lets
just
use
the
string
we
dup
d
and
let
it
leak
Things
will
surely
fail
anyway
return
newstr
re
VALTYPE
retval
return
re
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
naming
c
include
globals
h
include
dwarf
h
include
libdwarf
h
include
makename
h
include
naming
h
include
esb
h
ifndef
TRIVIAL_NAMING
static
const
char
skipunder
const
char
v
const
char
cp
v
int
undercount
for
cp
cp
if
cp
_
undercount
if
undercount
return
cp
return
endif
TRIVIAL_NAMING
static
const
char
ellipname
int
res
int
val_in
const
char
v
const
char
ty
int
printonerr
ifndef
TRIVIAL_NAMING
if
glflags
gf_check_dwarf_constants
checking_this_compiler
DWARF_CHECK_COUNT
dwarf_constants_result
endif
if
res
DW_DLV_OK
char
buf
char
n
struct
esb_s
eb
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_s
Unknown
s
ty
esb_append_printf_u
value
x
val_in
Capture
any
name
error
in
DWARF
constants
ifndef
TRIVIAL_NAMING
if
printonerr
glflags
gf_check_dwarf_constants
checking_this_compiler
if
glflags
gf_check_verbose_mode
printf
s
of
d
x
is
unknown
to
dwarfdump
Continuing
n
ty
val_in
val_in
DWARF_ERROR_COUNT
dwarf_constants_result
DWARF_CHECK_ERROR_PRINT_CU
else
This
is
for
the
tree
generation
not
dwarfdump
itself
if
printonerr
fprintf
stderr
s
of
d
x
is
unknown
to
dwarfdump
Continuing
n
ty
val_in
val_in
endif
n
makename
esb_get_string
esb_destructor
return
n
ifndef
TRIVIAL_NAMING
if
glflags
ellipsis
return
skipunder
v
endif
return
v
const
char
get_TAG_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_TAG_name
val_in
return
ellipname
res
val_in
v
TAG
printonerr
const
char
get_children_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_children_name
val_in
return
ellipname
res
val_in
v
children
printonerr
const
char
get_FORM_CLASS_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_FORM_CLASS_name
val_in
return
ellipname
res
val_in
v
FORM_CLASS
printonerr
const
char
get_FORM_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_FORM_name
val_in
return
ellipname
res
val_in
v
FORM
printonerr
const
char
get_AT_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_AT_name
val_in
return
ellipname
res
val_in
v
AT
printonerr
const
char
get_OP_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_OP_name
val_in
return
ellipname
res
val_in
v
OP
printonerr
const
char
get_ATE_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ATE_name
val_in
return
ellipname
res
val_in
v
ATE
printonerr
const
char
get_DS_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_DS_name
val_in
return
ellipname
res
val_in
v
DS
printonerr
const
char
get_END_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_END_name
val_in
return
ellipname
res
val_in
v
END
printonerr
const
char
get_ATCF_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ATCF_name
val_in
return
ellipname
res
val_in
v
ATCF
printonerr
const
char
get_ACCESS_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ACCESS_name
val_in
return
ellipname
res
val_in
v
ACCESS
printonerr
const
char
get_VIS_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_VIS_name
val_in
return
ellipname
res
val_in
v
VIS
printonerr
const
char
get_VIRTUALITY_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_VIRTUALITY_name
val_in
return
ellipname
res
val_in
v
VIRTUALITY
printonerr
const
char
get_LANG_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_LANG_name
val_in
return
ellipname
res
val_in
v
LANG
printonerr
const
char
get_ID_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ID_name
val_in
return
ellipname
res
val_in
v
ID
printonerr
const
char
get_CC_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_CC_name
val_in
return
ellipname
res
val_in
v
CC
printonerr
const
char
get_INL_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_INL_name
val_in
return
ellipname
res
val_in
v
INL
printonerr
const
char
get_ORD_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ORD_name
val_in
return
ellipname
res
val_in
v
ORD
printonerr
const
char
get_DSC_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_DSC_name
val_in
return
ellipname
res
val_in
v
DSC
printonerr
const
char
get_LNS_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_LNS_name
val_in
return
ellipname
res
val_in
v
LNS
printonerr
const
char
get_LNE_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_LNE_name
val_in
return
ellipname
res
val_in
v
LNE
printonerr
const
char
get_MACINFO_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_MACINFO_name
val_in
return
ellipname
res
val_in
v
MACINFO
printonerr
const
char
get_MACRO_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_MACRO_name
val_in
return
ellipname
res
val_in
v
MACRO
printonerr
const
char
get_CFA_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_CFA_name
val_in
return
ellipname
res
val_in
v
CFA
printonerr
const
char
get_EH_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_EH_name
val_in
return
ellipname
res
val_in
v
EH
printonerr
const
char
get_FRAME_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_FRAME_name
val_in
return
ellipname
res
val_in
v
FRAME
printonerr
const
char
get_CHILDREN_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_CHILDREN_name
val_in
return
ellipname
res
val_in
v
CHILDREN
printonerr
const
char
get_ADDR_name
unsigned
int
val_in
int
printonerr
const
char
v
int
res
dwarf_get_ADDR_name
val_in
return
ellipname
res
val_in
v
ADDR
printonerr
Generated
expression
ops
table
do
not
edit
include
opscounttab
h
struct
dwarf_opscounttab_s
dwarf_opscounttab
unused
unused
unused
DW_OP_addr
unused
unused
DW_OP_deref
unused
DW_OP_const1u
DW_OP_const1s
DW_OP_const2u
a
DW_OP_const2s
b
DW_OP_const4u
c
DW_OP_const4s
d
DW_OP_const8u
e
DW_OP_const8s
f
DW_OP_constu
DW_OP_consts
DW_OP_dup
DW_OP_drop
DW_OP_over
DW_OP_pick
DW_OP_swap
DW_OP_rot
DW_OP_xderef
DW_OP_abs
DW_OP_and
DW_OP_div
DW_OP_minus
DW_OP_mod
DW_OP_mul
DW_OP_neg
DW_OP_not
DW_OP_or
DW_OP_plus
DW_OP_plus_uconst
DW_OP_shl
DW_OP_shr
DW_OP_shra
DW_OP_xor
DW_OP_bra
DW_OP_eq
DW_OP_ge
DW_OP_gt
DW_OP_le
DW_OP_lt
DW_OP_ne
DW_OP_skip
DW_OP_lit0
DW_OP_lit1
DW_OP_lit2
DW_OP_lit3
DW_OP_lit4
DW_OP_lit5
DW_OP_lit6
DW_OP_lit7
DW_OP_lit8
DW_OP_lit9
DW_OP_lit10
DW_OP_lit11
DW_OP_lit12
DW_OP_lit13
DW_OP_lit14
DW_OP_lit15
DW_OP_lit16
DW_OP_lit17
DW_OP_lit18
DW_OP_lit19
DW_OP_lit20
DW_OP_lit21
DW_OP_lit22
DW_OP_lit23
DW_OP_lit24
DW_OP_lit25
DW_OP_lit26
DW_OP_lit27
DW_OP_lit28
DW_OP_lit29
DW_OP_lit30
DW_OP_lit31
DW_OP_reg0
DW_OP_reg1
DW_OP_reg2
DW_OP_reg3
DW_OP_reg4
DW_OP_reg5
DW_OP_reg6
DW_OP_reg7
DW_OP_reg8
DW_OP_reg9
DW_OP_reg10
DW_OP_reg11
DW_OP_reg12
DW_OP_reg13
DW_OP_reg14
DW_OP_reg15
DW_OP_reg16
DW_OP_reg17
DW_OP_reg18
DW_OP_reg19
DW_OP_reg20
DW_OP_reg21
DW_OP_reg22
DW_OP_reg23
DW_OP_reg24
DW_OP_reg25
DW_OP_reg26
DW_OP_reg27
DW_OP_reg28
DW_OP_reg29
DW_OP_reg30
DW_OP_reg31
DW_OP_breg0
DW_OP_breg1
DW_OP_breg2
DW_OP_breg3
DW_OP_breg4
DW_OP_breg5
DW_OP_breg6
DW_OP_breg7
DW_OP_breg8
DW_OP_breg9
DW_OP_breg10
DW_OP_breg11
DW_OP_breg12
DW_OP_breg13
DW_OP_breg14
DW_OP_breg15
DW_OP_breg16
DW_OP_breg17
DW_OP_breg18
DW_OP_breg19
DW_OP_breg20
DW_OP_breg21
DW_OP_breg22
DW_OP_breg23
DW_OP_breg24
DW_OP_breg25
DW_OP_breg26
DW_OP_breg27
DW_OP_breg28
DW_OP_breg29
DW_OP_breg30
DW_OP_breg31
DW_OP_regx
DW_OP_fbreg
DW_OP_bregx
DW_OP_piece
DW_OP_deref_size
DW_OP_xderef_size
DW_OP_nop
DW_OP_push_object_address
DW_OP_call2
DW_OP_call4
DW_OP_call_ref
DW_OP_form_tls_address
DW_OP_call_frame_cfa
DW_OP_bit_piece
DW_OP_implicit_value
DW_OP_stack_value
DW_OP_implicit_pointer
DW_OP_addrx
DW_OP_constx
DW_OP_entry_value
DW_OP_const_type
DW_OP_regval_type
DW_OP_deref_type
DW_OP_xderef_type
DW_OP_convert
DW_OP_reinterpret
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
DW_OP_GNU_push_tls_address
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
unused
DW_OP_GNU_uninit
DW_OP_GNU_encoded_addr
DW_OP_GNU_implicit_pointer
DW_OP_GNU_entry_value
DW_OP_GNU_const_type
DW_OP_GNU_regval_type
DW_OP_GNU_deref_type
DW_OP_GNU_convert
DW_OP_PGI_omp_thread_num
DW_OP_GNU_reinterpret
DW_OP_GNU_parameter_ref
DW_OP_GNU_addr_index
DW_OP_GNU_const_index
DW_OP_GNU_variable_value
unused
unused
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
include
naming
h
include
sanitized
h
include
esb
h
include
esb_using_functions
h
include
print_sections
h
define
TRUE
define
FALSE
The
following
relevent
for
one
specific
Linker
define
SNLINKER_MAX_ATTRIB_COUNT
a
warning
limit
which
is
arbitrary
but
leaves
a
bit
more
flexibility
define
GENERAL_MAX_ATTRIB_COUNT
Print
data
in
debug_abbrev
This
is
inherently
unsafe
as
it
assumes
there
are
no
byte
sequences
in
debug_abbrev
other
than
legal
abbrev
sequences
But
the
Dwarf
spec
does
not
promise
that
The
spec
only
promises
that
any
bytes
at
an
offset
referred
to
from
debug_info
are
legal
sequences
struct
abbrev_entry_s
Dwarf_Unsigned
ae_number
Dwarf_Unsigned
ae_offset
Dwarf_Unsigned
ae_attr
Dwarf_Unsigned
ae_form
Dwarf_Unsigned
ae_impl_const
unsigned
ae_dupcount
static
int
ab_compare
const
void
lin
const
void
rin
const
struct
abbrev_entry_s
l
const
struct
abbrev_entry_s
lin
const
struct
abbrev_entry_s
r
const
struct
abbrev_entry_s
rin
if
l
ae_attr
r
ae_attr
return
if
l
ae_attr
r
ae_attr
return
if
l
ae_form
r
ae_form
return
if
l
ae_form
r
ae_form
return
if
l
ae_number
r
ae_number
return
if
l
ae_number
r
ae_number
return
return
static
int
attr_unknown
Dwarf_Unsigned
attr
const
char
n
int
res
if
attr
return
TRUE
if
attr
DW_AT_loclists_base
return
FALSE
if
attr
DW_AT_hi_user
return
TRUE
res
dwarf_get_AT_name
attr
if
res
DW_DLV_NO_ENTRY
return
TRUE
return
FALSE
static
int
is_valid_form_we_know
Dwarf_Unsigned
form
int
res
const
char
n
res
dwarf_get_FORM_name
form
if
res
DW_DLV_NO_ENTRY
return
FALSE
return
TRUE
static
void
printdupab
struct
abbrev_entry_s
lastaep
struct
esb_s
msg
esb_constructor
esb_append_printf_u
Attribute
DW_PR_XZEROS
DW_PR_DUx
lastaep
ae_attr
esb_append_printf_s
s
get_AT_name
lastaep
ae_attr
dwarf_names_print_on_error
esb_append_printf_u
u
times
lastaep
ae_dupcount
esb_append_printf_u
near
offset
DW_PR_XZEROS
DW_PR_DUx
lastaep
ae_offset
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Duplicated
attribute
in
abbrevs
esb_destructor
static
int
print_one_abbrev_for_cu
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Unsigned
abbrev_num_in
Dwarf_Unsigned
length_out
Dwarf_Unsigned
abbrev_num_out
Dwarf_Error
error
const
char
tagname
struct
abbrev_entry_s
entryarray
unsigned
entryarray_size
Dwarf_Unsigned
abbrev_entry_count
Dwarf_Unsigned
abbrev_code
Dwarf_Half
tag
Dwarf_Unsigned
length
int
acres
Dwarf_Abbrev
ab
int
tres
Dwarf_Unsigned
abbrev_num
abbrev_num_in
Dwarf_Signed
child_flag
int
abres
Dwarf_Unsigned
i
abres
dwarf_get_abbrev
dbg
offset
error
if
abres
DW_DLV_ERROR
return
abres
if
abres
DW_DLV_NO_ENTRY
return
abres
Here
offset
is
the
global
offset
in
debug_abbrev
The
abbrev_num
is
a
relatively
worthless
counter
of
all
abbreviations
tres
dwarf_get_abbrev_tag
ab
error
if
tres
DW_DLV_ERROR
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
print_error_and_continue
dbg
Error
reading
abbreviation
Tag
tres
error
return
tres
tres
dwarf_get_abbrev_code
ab
error
if
tres
DW_DLV_OK
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
print_error_and_continue
dbg
Error
reading
abbreviation
code
tres
error
return
tres
if
tag
This
means
we
are
done
with
this
abbrev
set
abbrev
for
entire
CU
tagname
Abbrev
null
abbrev
entry
else
tagname
get_TAG_name
tag
dwarf_names_print_on_error
if
glflags
gf_do_print_dwarf
if
glflags
dense
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
code
DW_PR_DUu
abbrev_num
offset
abbrev_code
if
glflags
verbose
printf
length
DW_PR_XZEROS
DW_PR_DUx
length
printf
s
tagname
else
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
code
DW_PR_DUu
abbrev_num
offset
abbrev_code
if
glflags
verbose
printf
length
DW_PR_XZEROS
DW_PR_DUx
length
printf
tagname
Process
specific
TAGs
specially
tag_specific_globals_setup
dbg
tag
abbrev_num
acres
dwarf_get_abbrev_children_flag
ab
error
if
acres
DW_DLV_ERROR
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
print_error_and_continue
dbg
Error
reading
abbreviation
children
flag
acres
error
return
acres
if
acres
DW_DLV_NO_ENTRY
child_flag
If
tag
is
zero
it
is
a
null
byte
not
a
real
abbreviation
so
there
is
no
children
flag
to
print
if
tag
glflags
gf_do_print_dwarf
const
char
child_name
child_name
get_children_name
child_flag
dwarf_names_print_on_error
printf
s
child_name
if
glflags
dense
if
glflags
gf_do_print_dwarf
printf
n
if
abbrev_entry_count
if
tag
glflags
gf_do_print_dwarf
printf
This
abbreviation
code
has
no
entries
n
if
length
length
if
glflags
gf_do_print_dwarf
glflags
dense
printf
n
length_out
length
abbrev_num_out
abbrev_num
printed
null
abrev
name
above
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
return
DW_DLV_OK
Abbrev
contains
the
format
of
a
die
which
debug_info
then
points
to
with
the
real
data
So
here
we
just
print
the
given
format
entryarray_size
abbrev_entry_count
entryarray
calloc
entryarray_size
sizeof
struct
abbrev_entry_s
if
entryarray
printf
s
ERROR
Malloc
of
u
abbrev_entry_s
structs
failed
Near
section
global
offset
DW_PR_DUx
n
glflags
program_name
entryarray_size
offset
entryarray_size
for
i
i
abbrev_entry_count
i
int
aeres
Dwarf_Bool
dofilter
FALSE
Dwarf_Unsigned
form
struct
abbrev_entry_s
aep
entryarray
i
Dwarf_Unsigned
attr
Dwarf_Signed
impl_const
Dwarf_Off
off
aeres
dwarf_get_abbrev_entry_b
ab
i
dofilter
error
if
aeres
DW_DLV_ERROR
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
free
entryarray
print_error_and_continue
dbg
Error
reading
abbreviation
entry
aeres
error
return
aeres
aep
ae_number
i
aep
ae_attr
attr
aep
ae_form
form
aep
ae_offset
off
aep
ae_impl_const
impl_const
if
glflags
gf_do_print_dwarf
char
buf
struct
esb_s
m
buf
esb_constructor_fixed
buf
sizeof
buf
if
form
DW_FORM_implicit_const
esb_append_printf_i
d
impl_const
esb_append_printf_u
x
impl_const
if
glflags
dense
printf
ld
s
s
s
unsigned
long
off
get_AT_name
attr
dwarf_names_print_on_error
get_FORM_name
Dwarf_Half
form
dwarf_names_print_on_error
esb_get_string
else
if
esb_string_len
printf
s
n
unsigned
long
off
get_AT_name
attr
dwarf_names_print_on_error
get_FORM_name
Dwarf_Half
form
dwarf_names_print_on_error
else
printf
s
n
unsigned
long
off
get_AT_name
attr
dwarf_names_print_on_error
get_FORM_name
Dwarf_Half
form
dwarf_names_print_on_error
esb_get_string
esb_destructor
if
glflags
gf_check_abbreviations
entryarray_size
unsigned
l
struct
abbrev_entry_s
lastaep
DWARF_CHECK_COUNT
abbreviations_result
qsort
void
entryarray
entryarray_size
sizeof
struct
abbrev_entry_s
ab_compare
for
l
l
entryarray_size
l
struct
abbrev_entry_s
aep
entryarray
l
if
attr_unknown
aep
ae_attr
struct
esb_s
msg
esb_constructor
esb_append_printf_u
Attribute
DW_PR_XZEROS
DW_PR_DUx
aep
ae_attr
esb_append_printf_u
near
offset
DW_PR_XZEROS
DW_PR_DUx
aep
ae_offset
DWARF_CHECK_ERROR2
abbreviations_result
Attr
number
unknown
esb_get_string
esb_destructor
if
is_valid_form_we_know
aep
ae_form
struct
esb_s
msg
esb_constructor
esb_append_printf_u
Form
DW_PR_XZEROS
DW_PR_DUx
aep
ae_form
esb_append_printf_u
near
offset
DW_PR_XZEROS
DW_PR_DUx
aep
ae_offset
DWARF_CHECK_ERROR2
abbreviations_result
Form
number
unknown
esb_get_string
esb_destructor
if
l
lastaep
aep
else
if
lastaep
ae_attr
aep
ae_attr
lastaep
ae_dupcount
else
if
lastaep
ae_dupcount
printdupab
lastaep
lastaep
aep
if
lastaep
ae_dupcount
printdupab
lastaep
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
free
entryarray
entryarray
entryarray_size
length_out
length
abbrev_num_out
abbrev_num
if
glflags
gf_do_print_dwarf
glflags
dense
printf
n
return
DW_DLV_OK
int
print_all_abbrevs_for_cu
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Unsigned
abbrev_num_in
Dwarf_Unsigned
length_out
Dwarf_Unsigned
abbrev_num_out
Dwarf_Error
error
Dwarf_Unsigned
total_len
int
pres
Dwarf_Unsigned
loopcount
We
have
always
printed
the
abbrev_num
starting
with
Unclear
why
Dwarf_Unsigned
abbrev_num
abbrev_num_in
Dwarf_Unsigned
abbrev_num_ret
abbrev_num_in
for
loopcount
Dwarf_Unsigned
local_len
abbrev_num
abbrev_num_ret
pres
print_one_abbrev_for_cu
dbg
offset
abbrev_num
error
if
pres
DW_DLV_ERROR
return
pres
if
pres
DW_DLV_NO_ENTRY
if
loopcount
This
is
an
incomplete
final
entry
the
trailing
NUL
byte
for
a
CU
abbrev
set
is
missing
as
of
end
of
section
printf
ERROR
The
final
debug_abbrev
abbreviation
ends
without
its
required
final
NUL
byte
A
harmless
error
at
section
offset
DW_PR_XZEROS
DW_PR_DUx
offset
glflags
gf_count_major_errors
return
pres
return
pres
total_len
local_len
if
local_len
last
of
a
CU
data
printed
abbrev_num_out
abbrev_num_ret
length_out
total_len
return
DW_DLV_OK
offset
local_len
abbrev_num_out
abbrev_num_ret
length_out
total_len
return
DW_DLV_OK
int
print_abbrevs
Dwarf_Debug
dbg
Dwarf_Error
paerr
Dwarf_Abbrev
ab
Dwarf_Unsigned
offset
int
abres
int
tres
unsigned
loopct
Dwarf_Unsigned
length
Dwarf_Unsigned
unused_entry_count
Dwarf_Unsigned
abbrev_num
Dwarf_Unsigned
abbrev_num_ret
glflags
current_section_id
DEBUG_ABBREV
Doing
this
just
to
print
the
section
name
abres
dwarf_get_abbrev
dbg
offset
paerr
Do
this
after
a
dwarf_get_abbrev
so
the
section
is
loaded
and
uncompressed
if
necessary
We
get
information
printed
about
the
compression
if
any
this
way
print_secname
dbg
debug_abbrev
if
abres
DW_DLV_OK
discard
what
we
got
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
ab
else
if
abres
DW_DLV_ERROR
dwarf_dealloc_error
dbg
paerr
paerr
for
loopct
loopct
tres
print_all_abbrevs_for_cu
dbg
offset
abbrev_num
paerr
if
tres
DW_DLV_NO_ENTRY
if
loopct
return
DW_DLV_OK
return
DW_DLV_NO_ENTRY
if
tres
DW_DLV_ERROR
return
tres
offset
offset
length
abbrev_num
abbrev_num_ret
Abbreviations
array
info
for
checking
abbrev
tags
The
zero
entry
is
not
used
We
never
shrink
the
array
but
it
never
grows
beyond
the
largest
abbreviation
count
of
all
the
CUs
It
is
set
up
when
we
start
a
new
CU
and
used
to
validate
abbreviations
on
each
DIE
in
the
CU
See
print_die
c
static
Dwarf_Unsigned
abbrev_array
NULL
Size
of
the
array
the
same
as
the
abbrev
tag
count
of
the
CU
with
the
most
of
them
Be
careful
as
abbrev_array
abbrev_array_size
is
outside
the
high
bound
static
Dwarf_Unsigned
abbrev_array_size
define
ABBREV_ARRAY_INITIAL_SIZE
void
destruct_abbrev_array
void
free
abbrev_array
abbrev_array
abbrev_array_size
Normally
abbreviation
numbers
are
allocated
in
sequence
from
and
increase
by
but
in
case
of
a
compiler
bug
or
a
damaged
object
file
one
can
see
strange
things
This
looks
for
surprises
and
reports
them
Returns
the
abbrev_code
unless
the
value
looks
very
wrong
and
then
it
returns
zero
as
we
do
not
want
a
gigantic
abbrev
code
to
cause
trouble
static
Dwarf_Unsigned
check_abbrev_num_sequence
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
last_abbrev_code
Dwarf_Unsigned
l_abbrev_array_size
UNUSEDARG
Dwarf_Unsigned
ev_entry_count
UNUSEDARG
Dwarf_Unsigned
total_abbrevs_counted
UNUSEDARG
char
buf
DWARF_CHECK_COUNT
abbreviations_result
if
abbrev_code
last_abbrev_code
if
abbrev_code
last_abbrev_code
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
skips
up
by
DW_PR_DUu
abbrev_code
last_abbrev_code
esb_append_printf_u
from
last
abbrev
code
of
DW_PR_DUu
last_abbrev_code
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
Not
checking
reuse
esb_destructor
return
else
if
abbrev_code
last_abbrev_code
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
skips
up
by
DW_PR_DUu
abbrev_code
last_abbrev_code
esb_append_printf_u
from
last
abbrev
code
of
DW_PR_DUu
last_abbrev_code
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
esb_destructor
else
if
abbrev_code
last_abbrev_code
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
skips
down
by
DW_PR_DUu
last_abbrev_code
abbrev_code
esb_append_printf_u
from
last
abbrev
code
of
DW_PR_DUu
last_abbrev_code
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
esb_destructor
else
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
unchanged
from
last
abbrev
code
abbrev_code
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
esb_destructor
return
abbrev_code
static
void
check_reused_code
Dwarf_Unsigned
abbrev_code
Dwarf_Unsigned
abbrev_entry_count
char
buf
if
abbrev_code
abbrev_array_size
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
entry_count
unchecked
DW_PR_DUu
abbrev_entry_count
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
esb_destructor
return
if
abbrev_array
abbrev_code
DWARF_CHECK_COUNT
abbreviations_result
This
abbrev
code
slot
was
used
before
if
abbrev_array
abbrev_code
abbrev_entry_count
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
reused
for
same
entry_count
DW_PR_DUu
abbrev_entry_count
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Questionable
abbreviation
code
esb_destructor
else
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
reused
for
different
entry_count
DW_PR_DUu
abbrev_array
abbrev_code
esb_append_printf_u
now
DW_PR_DUu
abbrev_entry_count
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Invalid
abbreviation
code
esb_destructor
Calculate
the
number
of
abbreviations
for
the
current
CU
and
set
up
basic
abbreviations
array
info
storing
the
number
of
attributes
per
abbreviation
void
get_abbrev_array_info
Dwarf_Debug
dbg
Dwarf_Unsigned
offset_in
Dwarf_Unsigned
offset
offset_in
if
glflags
gf_check_abbreviations
Dwarf_Unsigned
length
Dwarf_Unsigned
last_abbrev_code
Dwarf_Bool
bMore
TRUE
Dwarf_Unsigned
CU_abbrev_count
if
abbrev_array
NULL
Allocate
initial
abbreviation
array
info
abbrev_array_size
ABBREV_ARRAY_INITIAL_SIZE
abbrev_array
Dwarf_Unsigned
calloc
abbrev_array_size
sizeof
Dwarf_Unsigned
else
Clear
out
values
from
previous
CU
memset
void
abbrev_array
abbrev_array_size
sizeof
Dwarf_Unsigned
while
bMore
Dwarf_Abbrev
ab
int
abres
DW_DLV_OK
Dwarf_Unsigned
abbrev_entry_count
Dwarf_Unsigned
abbrev_code
Dwarf_Error
aberr
abres
dwarf_get_abbrev
dbg
offset
if
abres
DW_DLV_ERROR
destruct_abbrev_array
print_error_and_continue
dbg
Error
reading
abbreviations
abres
aberr
dwarf_dealloc
dbg
aberr
DW_DLA_ERROR
bMore
FALSE
break
if
abres
DW_DLV_NO_ENTRY
destruct_abbrev_array
bMore
FALSE
break
Will
not
error
unless
ab
is
NULL
dwarf_get_abbrev_code
ab
if
abbrev_code
End
of
abbreviation
table
for
this
CU
offset
Skip
abbreviation
code
bMore
FALSE
else
Valid
abbreviation
code
We
hope
Dwarf_Unsigned
abhigh
check_abbrev_num_sequence
abbrev_code
last_abbrev_code
abbrev_array_size
abbrev_entry_count
CU_abbrev_count
if
abhigh
abbrev_array_size
It
is
a
new
high
but
is
not
outrageous
while
abbrev_code
abbrev_array_size
Dwarf_Unsigned
old_size
abbrev_array_size
size_t
addl_size_bytes
old_size
sizeof
Dwarf_Unsigned
Resize
abbreviation
array
Only
a
bogus
abbreviation
number
will
iterate
more
than
once
The
abhigh
check
prevents
a
runaway
abbrev_array_size
abbrev_array
Dwarf_Unsigned
realloc
abbrev_array
abbrev_array_size
sizeof
Dwarf_Unsigned
Zero
out
the
new
bytes
memset
abbrev_array
old_size
addl_size_bytes
last_abbrev_code
abbrev_code
check_reused_code
abbrev_code
abbrev_entry_count
abbrev_array
abbrev_code
abbrev_entry_count
else
Zero
is
the
case
of
too
high
abbrev_code
if
abhigh
More
or
less
normal
abbrev_code
last_abbrev_code
abbrev_code
check_reused_code
abbrev_code
abbrev_entry_count
abbrev_array
abbrev_code
abbrev_entry_count
CU_abbrev_count
offset
length
dwarf_dealloc
dbg
ab
DW_DLA_ABBREV
ab
Validate
an
abbreviation
for
the
current
CU
In
case
of
bogus
abbrev
input
the
CU_abbrev_count
might
not
be
as
large
as
abbrev_array_size
says
the
array
is
This
should
catch
that
case
This
just
checks
and
reports
errors
void
validate_abbrev_code
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Unsigned
abbrev_code
char
buf
DWARF_CHECK_COUNT
abbreviations_result
if
abbrev_code
abbrev_code
abbrev_array_size
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
outside
valid
range
of
DW_PR_DUu
abbrev_array_size
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Invalid
abbreviation
code
esb_destructor
else
Dwarf_Unsigned
abbrev_entry_count
abbrev_array
abbrev_code
if
abbrev_entry_count
SNLINKER_MAX_ATTRIB_COUNT
if
abbrev_entry_count
GENERAL_MAX_ATTRIB_COUNT
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
with
DW_PR_DUu
attributes
abbrev_entry_count
esb_append_printf_i
outside
a
sanity
check
maximum
of
d
GENERAL_MAX_ATTRIB_COUNT
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Number
of
attributes
exceeds
sanity
check
esb_destructor
else
These
apply
only
to
one
compiliation
environment
and
are
not
generally
applicable
struct
esb_s
ar
esb_constructor_fixed
buf
sizeof
buf
esb_append_printf_u
Abbrev
code
DW_PR_DUu
abbrev_code
esb_append_printf_u
with
DW_PR_DUu
attributes
abbrev_entry_count
esb_append_printf_i
outside
an
SN
LINKER
expected
maximum
of
d
SNLINKER_MAX_ATTRIB_COUNT
DWARF_CHECK_ERROR2
abbreviations_result
esb_get_string
Number
of
attributes
exceeds
SN
LINKER
specific
sanity
check
esb_destructor
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
static
int
do_checking
Dwarf_Debug
dbg
Dwarf_Arange
arange_buf
Dwarf_Signed
i
Dwarf_Off
cu_die_offset
Dwarf_Bool
first_cu
Dwarf_Off
cu_die_offset_prev
Dwarf_Die
cu_die
Dwarf_Error
err
int
dres
Dwarf_Off
cuhdroff
Dwarf_Off
cudieoff3
debug_types
has
no
address
ranges
only
debug_info
dwo
has
them
int
is_info
dres
dwarf_get_arange_cu_header_offset
arange_buf
i
err
if
dres
DW_DLV_OK
Dwarf_Off
cudieoff2
Get
the
CU
offset
for
easy
error
reporting
if
first_cu
cu_die_offset
cu_die_offset_prev
dres
dwarf_die_offsets
cu_die
DIE_overall_offset
DIE_offset
err
glflags
DIE_CU_overall_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_offset
if
dres
DW_DLV_OK
print_error_and_continue
dbg
ERROR
reading
dwarf_die_offsets
dres
err
return
dres
dres
dwarf_get_cu_die_offset_given_cu_header_offset_b
dbg
cuhdroff
is_info
err
if
dres
DW_DLV_OK
Get
the
CU
offset
for
easy
error
reporting
dwarf_die_offsets
cu_die
DIE_overall_offset
DIE_offset
err
glflags
DIE_CU_overall_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_offset
DWARF_CHECK_COUNT
aranges_result
if
cu_die_offset
cudieoff2
printf
Error
cu_die
offsets
mismatch
DW_PR_DUx
DW_PR_DUx
from
arange
data
cu_die_offset
cudieoff2
DWARF_CHECK_ERROR
aranges_result
dwarf_get_cu_die_offset_given_cu
gets
wrong
offset
else
print_error_and_continue
dbg
ERROR
from
arange
checking
dwarf_get_cu_die_offset_given
fails
dres
err
return
dres
else
print_error_and_continue
dbg
ERROR
from
arange
checking
dwarf_get_arange_cu_header_offset
fails
dres
err
return
dres
dres
dwarf_get_cu_die_offset
arange_buf
i
err
if
dres
DW_DLV_OK
DWARF_CHECK_COUNT
aranges_result
if
cudieoff3
cu_die_offset
printf
Error
cu_die
offsets
b
mismatch
DW_PR_DUx
DW_PR_DUx
from
arange
data
cu_die_offset
cudieoff3
DWARF_CHECK_ERROR
aranges_result
dwarf_get_cu_die_offset
gets
wrong
offset
else
print_error_and_continue
dbg
ERROR
from
arange
checking
dwarf_get_cu_die_offset
fails
dres
err
return
dres
return
DW_DLV_OK
static
void
aranges_dealloc_now
Dwarf_Debug
dbg
Dwarf_Signed
count
Dwarf_Arange
arange_buf
Dwarf_Signed
i
for
i
count
i
dwarf_dealloc
dbg
arange_buf
i
DW_DLA_ARANGE
dwarf_dealloc
dbg
arange_buf
DW_DLA_LIST
get
all
the
data
in
debug_aranges
int
print_aranges
Dwarf_Debug
dbg
Dwarf_Error
ga_err
Dwarf_Signed
count
Dwarf_Signed
i
Dwarf_Arange
arange_buf
NULL
int
ares
int
aires
Dwarf_Off
prev_off
Holds
previous
CU
offset
Dwarf_Bool
first_cu
TRUE
Dwarf_Off
cu_die_offset_prev
Reset
the
global
state
so
we
can
traverse
the
debug_info
glflags
seen_CU
FALSE
glflags
need_CU_name
TRUE
glflags
need_CU_base_address
TRUE
glflags
need_CU_high_address
TRUE
glflags
current_section_id
DEBUG_ARANGES
ares
dwarf_get_aranges
dbg
ga_err
if
glflags
gf_do_print_dwarf
Now
we
know
the
section
is
loaded
if
any
so
lets
get
the
true
name
with
any
compression
info
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_aranges
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
if
ares
DW_DLV_ERROR
print_error_and_continue
dbg
Unable
to
load
the
debug_aranges
section
ares
ga_err
return
ares
else
if
ares
DW_DLV_NO_ENTRY
return
ares
else
for
i
i
count
i
Dwarf_Unsigned
segment
Dwarf_Unsigned
segment_entry_size
Dwarf_Addr
start
Dwarf_Unsigned
length
Dwarf_Off
cu_die_offset
Dwarf_Die
cu_die
NULL
Dwarf_Bool
is_info
TRUE
has
to
be
debug_info
as
this
involves
addresses
aires
dwarf_get_arange_info_b
arange_buf
i
ga_err
if
aires
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_i
nERROR
attempt
to
read
arange
d
i
esb_append_printf_i
of
d
aranges
failed
count
simple_err_return_msg_either_action
aires
esb_get_string
esb_destructor
aranges_dealloc_now
dbg
count
arange_buf
return
aires
else
int
dres
Get
basic
locations
for
error
reporting
dres
dwarf_offdie_b
dbg
cu_die_offset
is_info
ga_err
if
dres
DW_DLV_OK
struct
esb_s
m
const
char
failtype
no
entry
if
dres
DW_DLV_ERROR
failtype
error
esb_constructor
esb_append_printf_s
nERROR
dwarf_offdie_b
gets
a
return
of
s
failtype
esb_append_printf_i
finding
the
compilation
unit
DIE
for
arange
number
d
and
that
should
never
happen
i
simple_err_return_msg_either_action
dres
esb_get_string
esb_destructor
aranges_dealloc_now
dbg
count
arange_buf
arange_buf
return
dres
if
glflags
gf_cu_name_flag
Dwarf_Bool
should_skip
FALSE
Always
sets
should_skip
should_skip_this_cu
dbg
cu_die
if
should_skip
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
Get
producer
name
for
this
CU
and
update
compiler
list
struct
esb_s
producer_name
int
pres
esb_constructor
pres
get_producer_name
dbg
cu_die
cu_die_offset
ga_err
if
pres
DW_DLV_ERROR
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
aranges_dealloc_now
dbg
count
arange_buf
return
pres
update_compiler_target
esb_get_string
esb_destructor
if
checking_this_compiler
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
cu_die
continue
if
glflags
gf_check_aranges
int
cres
cres
do_checking
dbg
arange_buf
i
cu_die_offset
first_cu
cu_die_offset_prev
cu_die
ga_err
if
cres
DW_DLV_ERROR
aranges_dealloc_now
dbg
count
arange_buf
return
cres
Get
the
offset
of
the
cu
header
itself
in
the
section
but
not
for
end
entries
if
start
length
Dwarf_Off
off
int
cures3
dwarf_get_arange_cu_header_offset
arange_buf
i
ga_err
if
cures3
DW_DLV_OK
struct
esb_s
m
const
char
failtype
no
entry
if
dres
DW_DLV_ERROR
failtype
error
esb_constructor
esb_append_printf_s
nERROR
dwarf_get_arange_cu_
header_offset
gets
a
return
of
s
failtype
esb_append_printf_i
finding
the
compilation
unit
DIE
offset
for
arange
number
d
and
that
should
never
happen
i
simple_err_return_msg_either_action
cures3
esb_get_string
esb_destructor
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
aranges_dealloc_now
dbg
count
arange_buf
return
cures3
Print
the
CU
information
if
different
if
prev_off
off
first_cu
first_cu
FALSE
prev_off
off
We
are
faking
the
indent
level
We
do
not
know
what
level
it
is
really
If
do_check_dwarf
we
do
not
want
to
do
the
die
print
call
as
it
will
do
check
print
we
may
not
have
asked
for
And
if
we
did
ask
for
debug_info
checks
this
will
do
the
checks
a
second
time
So
only
call
print_one_die
if
printing
if
glflags
gf_do_print_dwarf
There
is
no
die
if
its
a
set
end
entry
int
pres
Dwarf_Bool
attr_duplicated
FALSE
pres
print_one_die
dbg
cu_die
cu_die_offset
print_information
Dwarf_Bool
TRUE
indent_level
srcfiles
cnt
ignore_die_stack
TRUE
ga_err
if
pres
DW_DLV_ERROR
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
aranges_dealloc_now
dbg
count
arange_buf
return
pres
Reset
the
state
so
we
can
traverse
the
debug_info
glflags
seen_CU
FALSE
glflags
need_CU_name
TRUE
if
glflags
gf_do_print_dwarf
printf
n
if
glflags
gf_do_print_dwarf
Print
current
aranges
record
if
segment_entry_size
printf
narange
starts
at
seg
off
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
segment
Dwarf_Unsigned
start
else
printf
narange
starts
at
DW_PR_XZEROS
DW_PR_DUx
Dwarf_Unsigned
start
printf
length
of
DW_PR_XZEROS
DW_PR_DUx
cu_die_offset
DW_PR_XZEROS
DW_PR_DUx
length
Dwarf_Unsigned
cu_die_offset
if
glflags
verbose
glflags
gf_do_print_dwarf
printf
cuhdr
DW_PR_XZEROS
DW_PR_DUx
n
Dwarf_Unsigned
off
else
Must
be
a
range
end
We
really
do
want
to
print
this
as
there
is
a
real
record
here
an
arange
end
record
if
glflags
gf_do_print_dwarf
printf
narange
end
n
end
start||length
test
end
aires
DW_DLV_OK
test
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
cu_die
print
associated
die
too?
end
loop
on
arange_buf
aranges_dealloc_now
dbg
count
arange_buf
arange_buf
end
DW_DLV_OK
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
To
print
debug_gnu_pubnames
debug_gnu_typenames
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
print_debug_gnu
h
define
TRUE
define
FALSE
char
ikind_types
none
type
variable
function
other
unknown5
unknown6
unknown7
static
int
print_block_entries
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Bool
for_pubnames
UNUSEDARG
struct
esb_s
secname
UNUSEDARG
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
blocknum
Dwarf_Unsigned
entrycount
Dwarf_Error
error
Dwarf_Unsigned
i
int
res
printf
offset
Kind
Name
n
for
i
entrycount
i
Dwarf_Unsigned
offset_in_debug_info
const
char
name
unsigned
char
flag
unsigned
char
staticorglobal
unsigned
char
typeofentry
flag
is
all
bits
and
staticorglobal
and
typeofentry
were
extracted
from
the
flag
Present
here
so
we
can
check
all
bits
are
correct
lowest
should
be
zero
res
dwarf_get_gnu_index_block_entry
head
blocknum
i
error
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
printf
ERROR
Block
DW_PR_DUu
entry
DW_PR_DUu
does
not
exist
though
entry
count
is
DW_PR_DUu
something
is
wrong
n
blocknum
i
entrycount
glflags
gf_count_major_errors
return
res
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
i
offset_in_debug_info
printf
s
staticorglobal?
s
g
ikind_types
typeofentry
printf
s
sanitized
name
printf
n
if
flag&0xf
printf
ERROR
Block
DW_PR_DUu
entry
DW_PR_DUu
flag
x
The
lower
bits
are
non
zero
so
there
may
be
a
corruption
problem
blocknum
i
flag
glflags
gf_count_major_errors
printf
n
return
DW_DLV_OK
int
attrlist
DW_AT_GNU_dwo_name
DW_AT_dwo_name
DW_AT_comp_dir
DW_AT_GNU_dwo_id
static
void
error_report
int
errcode
const
char
text
Dwarf_Error
error
if
errcode
DW_DLV_ERROR
printf
ERROR
s
ignoring
other
attributes
here
s
n
text
dwarf_errmsg
error
glflags
gf_count_major_errors
return
else
printf
ERROR
impossible
DW_DLV_NO_ENTRY
s
ignoringother
attributes
here
n
text
return
static
void
print_selected_attributes
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Half
version
Dwarf_Half
offset_size
Dwarf_Error
error
int
res
int
i
for
attrlist
i
i
Dwarf_Attribute
attr
int
attrid
const
char
atname
Dwarf_Half
form
enum
Dwarf_Form_Class
fclass
char
formstring
int
print_str
FALSE
struct
esb_s
m
Dwarf_Sig8
sig
attrid
attrlist
i
res
dwarf_attr
die
attrid
error
if
res
DW_DLV_ERROR
error_report
res
dwarf_attr
returned
error
error
dwarf_dealloc_error
dbg
error
error
return
if
res
DW_DLV_NO_ENTRY
continue
ok
this
attribute
is
present
atname
get_AT_name
attrid
FALSE
res
dwarf_whatform
attr
error
if
res
DW_DLV_OK
error_report
res
dwarf_whatform
problem
error
dwarf_dealloc_error
dbg
error
dwarf_dealloc_attribute
attr
error
return
if
res
DW_DLV_NO_ENTRY
impossible
cannot
get
here
dwarf_dealloc_attribute
attr
continue
esb_constructor
fclass
dwarf_get_form_class
version
attrid
offset_size
form
if
fclass
DW_FORM_CLASS_STRING
res
dwarf_formstring
attr
error
if
res
DW_DLV_OK
print_str
TRUE
esb_append
formstring
else
error_report
res
dwarf_formstring
returned
error
error
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
dwarf_dealloc_attribute
attr
esb_destructor
break
else
if
fclass
DW_FORM_CLASS_CONSTANT
if
form
DW_FORM_data8
res
dwarf_formsig8_const
attr
error
if
res
DW_DLV_OK
print_str
TRUE
format_sig8_string
else
error_report
res
dwarf_formsig8_const
returned
error
error
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
esb_destructor
dwarf_dealloc_attribute
attr
break
else
if
fclass
DW_FORM_CLASS_REFERENCE
includes
DW_FORM_ref_sig8
DW_FORM_ref
if
form
DW_FORM_ref_sig8
res
dwarf_formsig8
attr
error
if
res
DW_DLV_OK
print_str
TRUE
esb_constructor
format_sig8_string
else
error_report
res
dwarf_formsig8
problem
error
error
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
esb_destructor
dwarf_dealloc_attribute
attr
break
if
print_str
printf
s
n
atname
esb_get_string
dwarf_dealloc_attribute
attr
esb_destructor
static
int
print_die_basics
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Unsigned
cudie_goff
UNUSEDARG
Dwarf_Error
error
int
res
Dwarf_Half
tag
Dwarf_Half
version
Dwarf_Bool
is_info
Dwarf_Bool
is_dwo
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Sig8
signature
Dwarf_Off
offset_of_length
Dwarf_Unsigned
total_byte_length
res
dwarf_cu_header_basics
die
error
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
printf
ERROR
Cannot
access
compilation
unit
data
s
dwarf_errmsg
error
dwarf_dealloc_error
dbg
error
error
else
printf
ERROR
Cannot
access
compilation
unit
data
No
such
found
glflags
gf_count_major_errors
return
DW_DLV_OK
printf
Compilation
unit
data
follows
n
printf
CU
version
d
n
version
if
is_info
printf
CU
section
is
debug_types
printf
CU
section
is
dwo?
s
n
is_dwo?
yes
no
printf
CU
offset
size
u
n
offset_size
printf
CU
extension
size
u
n
extension_size
printf
CU
address
size
u
n
address_size
printf
CU
beginning
offset
DW_PR_XZEROS
DW_PR_DUx
n
offset_of_length
printf
CU
total
length
DW_PR_XZEROS
DW_PR_DUx
n
total_byte_length
if
signature
struct
esb_s
m
char
buf
esb_constructor_fixed
buf
sizeof
buf
printf
CU
signature
format_sig8_string
signature
printf
s
n
esb_get_string
esb_destructor
res
dwarf_tag
die
error
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
printf
ERROR
Cannot
access
DIE
tag
ERROR
s
n
dwarf_errmsg
error
dwarf_dealloc_error
dbg
error
error
else
printf
ERROR
Cannot
access
DIE
tag
No
such
found
n
printf
n
glflags
gf_count_major_errors
else
const
char
actual_tag_name
actual_tag_name
get_TAG_name
tag
FALSE
printf
CU
die
TAG
s
n
actual_tag_name
print_selected_attributes
dbg
die
version
offset_size
error
return
DW_DLV_OK
static
int
print_all_blocks
Dwarf_Debug
dbg
Dwarf_Bool
for_pubnames
struct
esb_s
secname
Dwarf_Gnu_Index_Head
head
Dwarf_Unsigned
block_count
Dwarf_Error
error
Dwarf_Unsigned
i
int
res
for
i
block_count
i
Dwarf_Unsigned
block_length
Dwarf_Half
version
Dwarf_Unsigned
offset_into_debug_info
Dwarf_Unsigned
size_of_debug_info_area
Dwarf_Unsigned
entrycount
res
dwarf_get_gnu_index_block
head
i
error
if
res
DW_DLV_NO_ENTRY
printf
ERROR
Block
DW_PR_DUu
does
not
exist
though
block
count
is
DW_PR_DUu
something
is
wrong
n
i
block_count
glflags
gf_count_major_errors
return
res
if
res
DW_DLV_ERROR
return
res
printf
Blocknumber
DW_PR_DUu
n
i
printf
Block
length
DW_PR_DUu
n
block_length
printf
Version
u
n
version
printf
Offset
into
debug_info
section
DW_PR_XZEROS
DW_PR_DUx
n
offset_into_debug_info
printf
Size
of
area
in
debug_info
section
DW_PR_DUu
n
size_of_debug_info_area
printf
Number
of
entries
in
block
DW_PR_DUu
n
entrycount
The
CU
offsets
appear
to
be
those
in
the
executable
here
Not
in
any
dwo
object
The
offsets
within
the
entries
in
a
block
are
a
different
story
and
some
of
that
seems
odd
the
content
names
many
things
in
libraries
not
just
the
executable
or
its
dwo
res
dwarf_get_cu_die_offset_given_cu_header_offset_b
dbg
offset_into_debug_info
is_info
TRUE
error
if
res
DW_DLV_OK
printf
ERROR
Block
DW_PR_DUu
has
an
invalid
debug_info
offset
of
DW_PR_DUx
something
is
wrong
n
i
offset_into_debug_info
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
glflags
gf_count_major_errors
else
Dwarf_Die
die
Dwarf_Bool
is_info
TRUE
res
dwarf_offdie_b
dbg
offset_into_debug_info
is_info
error
if
res
DW_DLV_OK
printf
ERROR
Block
DW_PR_DUu
cu
DIE
offset
DW_PR_DUx
is
not
a
valid
DIE
offset
in
debug_info
n
i
offset_into_debug_info
if
res
DW_DLV_ERROR
dwarf_dealloc_error
dbg
error
error
glflags
gf_count_major_errors
else
Always
returns
DW_DLV_OK
print_die_basics
dbg
die
offset_into_debug_info
error
printf
n
dwarf_dealloc_die
die
res
print_block_entries
dbg
for_pubnames
secname
head
i
entrycount
error
if
res
DW_DLV_ERROR
return
res
return
DW_DLV_OK
November
gdb
binutils
source
can
print
these
sections
but
gdb
does
not
AFAICT
use
this
at
all
binutils
can
print
it
as
can
we
The
Block
offset
is
part
of
the
skeleton
and
refers
to
the
skeleton
CU
DIEs
when
that
is
involved
but
the
individual
item
offsets
are
referring
to
I
do
not
know
what
Block
zero
refers
to
the
single
CU_DIE
in
the
dwo
file
The
others
Nothing
suggests
how
things
actually
connect
up
int
print_debug_gnu
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
Dwarf_Gnu_Index_Head
head
Dwarf_Bool
for_pubnames
TRUE
Dwarf_Unsigned
block_count
const
char
stdname
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
truename
unsigned
int
i
for
i
i
i
esb_constructor_fixed
buf
DWARF_SECNAME_BUFFER_SIZE
if
i
glflags
current_section_id
DEBUG_GNU_PUBNAMES
for_pubnames
TRUE
stdname
debug_gnu_pubnames
else
for_pubnames
FALSE
glflags
current_section_id
DEBUG_GNU_PUBTYPES
stdname
debug_gnu_pubtypes
get_true_section_name
dbg
stdname
TRUE
res
dwarf_get_gnu_index_head
dbg
for_pubnames
error
if
res
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
problem
reading
s
s
n
sanitized
esb_get_string
dwarf_errmsg
error
dwarf_dealloc_error
dbg
error
error
continue
else
if
res
DW_DLV_NO_ENTRY
continue
printf
n
s
with
DW_PR_DUu
blocks
of
names
n
sanitized
esb_get_string
block_count
res
print_all_blocks
dbg
for_pubnames
head
block_count
error
if
res
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
problem
reading
s
s
n
sanitized
esb_get_string
dwarf_errmsg
error
dwarf_dealloc_error
dbg
error
error
else
if
res
DW_DLV_NO_ENTRY
impossible
else
normal
dwarf_gnu_index_dealloc
head
esb_destructor
return
DW_DLV_OK
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
sanitized
h
include
esb
h
include
esb_using_functions
h
int
print_debug_names
Dwarf_Debug
dbg
Dwarf_Error
error
Dwarf_Dnames_Head
dnhead
Dwarf_Unsigned
dn_count
Dwarf_Unsigned
dnindex
int
res
if
dbg
printf
ERROR
Cannot
print
debug_names
no
Dwarf_Debug
passed
in
return
DW_DLV_NO_ENTRY
glflags
current_section_id
DEBUG_NAMES
Only
print
anything
if
we
know
it
has
debug
names
present
And
for
now
there
is
none
FIXME
res
dwarf_debugnames_header
dbg
error
if
res
DW_DLV_NO_ENTRY
return
res
if
res
DW_DLV_ERROR
return
res
Do
nothing
if
not
printing
if
glflags
gf_do_print_dwarf
const
char
section_name
debug_names
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
section_name
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
if
glflags
gf_do_print_dwarf
printf
names
tables
DW_PR_DUu
n
dn_count
for
dnindex
dn_count
dnindex
if
glflags
gf_do_print_dwarf
printf
names
table
DW_PR_DUu
n
dnindex
dwarf_dealloc
dbg
dnhead
DW_DLA_DNAMES_HEAD
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
To
print
debug_sup
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
define
TRUE
define
FALSE
int
print_debug_sup
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
const
char
stdname
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
truename
Dwarf_Half
version
Dwarf_Small
is_supplementary
char
filename
Dwarf_Unsigned
checksum_len
Dwarf_Unsigned
i
Dwarf_Small
checksum_ptr
Dwarf_Small
curptr
esb_constructor_fixed
buf
DWARF_SECNAME_BUFFER_SIZE
glflags
current_section_id
DEBUG_SUP
stdname
debug_sup
get_true_section_name
dbg
stdname
TRUE
res
dwarf_get_debug_sup
dbg
error
if
res
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
problem
reading
s
s
n
sanitized
esb_get_string
dwarf_errmsg
error
dwarf_dealloc_error
dbg
error
error
esb_destructor
return
DW_DLV_OK
else
if
res
DW_DLV_NO_ENTRY
esb_destructor
return
res
printf
n
s
n
sanitized
esb_get_string
printf
Version
u
n
version
if
version
glflags
gf_count_major_errors
printf
ERROR
the
s
version
is
u
but
only
is
currently
valid
n
sanitized
esb_get_string
version
printf
Supplementary
file
u
s
n
is_supplementary
is_supplementary?
yes
no
if
is_supplementary
glflags
gf_count_major_errors
printf
ERROR
the
s
is_supplementary
field
is
u
but
only
or
is
currently
valid
n
sanitized
esb_get_string
is_supplementary
printf
Filename
s
n
sanitized
filename
printf
Checksum
Length
DW_PR_DUu
n
checksum_len
printf
Checksum
bytes
in
hex
n
curptr
checksum_ptr
if
checksum_len
printf
for
i
i
checksum_len
i
curptr
if
i
i
printf
n
printf
curptr
printf
n
esb_destructor
return
DW_DLV_OK
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
define
TRUE
define
FALSE
static
const
char
dw_dlv_string
int
res
if
res
DW_DLV_ERROR
return
DW_DLV_ERROR
if
res
DW_DLV_NO_ENTRY
return
DW_DLV_NO_ENTRY
if
res
DW_DLV_OK
return
DW_DLV_OK
return
ERROR
Impossible
libdwarf
DW_DLV
code
static
int
hashval_zero
Dwarf_Sig8
val
unsigned
u
for
u
u
sizeof
Dwarf_Sig8
u
if
val
signature
u
return
FALSE
return
TRUE
int
print_debugfission_index
Dwarf_Debug
dbg
const
char
type
Dwarf_Error
err
int
res
Dwarf_Xu_Index_Header
xuhdr
Dwarf_Unsigned
version_number
Dwarf_Unsigned
offsets_count
Dwarf_Unsigned
units_count
Dwarf_Unsigned
hash_slots_count
const
char
section_name
const
char
section_type2
const
char
section_name2
int
is_cu
strcmp
type
cu
FALSE
res
dwarf_get_xu_index_header
dbg
type
err
if
res
DW_DLV_NO_ENTRY
This
applies
to
most
object
files
return
res
if
res
DW_DLV_ERROR
simple_err_return_msg_either_action
res
ERROR
Call
to
dwarf_get_xu_index_header
failed
return
res
res
dwarf_get_xu_index_section_type
xuhdr
err
if
res
DW_DLV_NO_ENTRY
struct
esb_s
tmsg
esb_constructor
esb_append
ERROR
dwarf_get_xu_index_section_type
returned
DW_DLV_NO_ENTRY
which
should
be
impossible
esb_append
Something
is
corrupted
simple_err_return_action
DW_DLV_ERROR
esb_get_string
dwarf_xu_header_free
xuhdr
esb_destructor
We
have
no
way
to
return
a
DW_DLV_ERROR
as
we
cannot
manufacture
a
Dwarf_Error
return
res
if
res
DW_DLV_ERROR
simple_err_return_msg_either_action
res
ERROR
Call
to
dwarf_get_xu_index_section_type
failed
dwarf_xu_header_free
xuhdr
return
res
if
strcmp
section_type2
type
struct
esb_s
tmsg
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_xu_index_section_type
returned
section
type
s
sanitized
section_type2
esb_append_printf_s
whereas
the
call
was
for
section
type
s
sanitized
type
esb_append
Something
is
corrupted
simple_err_return_action
DW_DLV_ERROR
esb_get_string
esb_destructor
dwarf_xu_header_free
xuhdr
We
have
no
way
to
return
a
DW_DLV_ERROR
as
we
cannot
manufacture
a
Dwarf_Error
return
DW_DLV_OK
if
section_name
section_name
section_name
is_cu?
debug_cu_index
debug_tu_index
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
section_name
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
printf
Version
DW_PR_DUu
n
version_number
printf
Number
of
columns
N
DW_PR_DUu
n
offsets_count
printf
number
of
entries
U
DW_PR_DUu
n
units_count
printf
Number
of
slots
S
DW_PR_DUu
n
hash_slots_count
unsigned
n
Dwarf_Unsigned
sect_num
const
char
name
printf
n
printf
Columns
index
to
section
id
and
name
n
printf
id
name
n
for
n
offsets_count
n
res
dwarf_get_xu_section_names
xuhdr
n
err
if
res
DW_DLV_ERROR
return
res
if
res
DW_DLV_NO_ENTRY
printf
u
unused
n
n
else
printf
u
DW_PR_DUu
s
n
n
sect_num
name
if
hash_slots_count
printf
n
printf
slot
hash
index
n
For
h
S
Dwarf_Unsigned
h
for
h
h
hash_slots_count
h
Dwarf_Sig8
hashval
Dwarf_Unsigned
index
Dwarf_Unsigned
col
memset
sizeof
hashval
res
dwarf_get_xu_hash_entry
xuhdr
h
err
if
res
DW_DLV_ERROR
struct
esb_s
hmsg
esb_constructor
esb_append_printf_u
ERROR
dwarf_get_xu_hash_entry
failed
on
slot
number
u
h
esb_append_printf_u
of
u
slots
hash_slots_count
simple_err_return_action
res
esb_get_string
dwarf_xu_header_free
xuhdr
esb_destructor
return
res
else
if
res
DW_DLV_NO_ENTRY
Impossible
struct
esb_s
hmsg
esb_constructor
esb_append_printf_u
ERROR
dwarf_get_xu_hash_entry
got
NO_ENTRY
on
slot
number
u
h
esb_append_printf_u
of
u
slots
That
should
be
impossible
hash_slots_count
dwarf_xu_header_free
xuhdr
esb_destructor
return
res
else
if
index
if
hashval_zero
An
unused
hash
slot
we
do
not
print
them
else
struct
esb_s
hashhexstring
esb_constructor
format_sig8_string
printf
DW_PR_DUu
s
DW_PR_DUu
s
n
h
esb_get_string
index
Index
means
the
hash
gets
ignored
esb_destructor
continue
struct
esb_s
hashhexstring
esb_constructor
format_sig8_string
printf
DW_PR_DUu
s
DW_PR_DUu
n
h
esb_get_string
index
esb_destructor
printf
r
c
section
offset
size
n
for
col
col
offsets_count
col
Dwarf_Unsigned
off
Dwarf_Unsigned
len
const
char
name
Dwarf_Unsigned
num
res
dwarf_get_xu_section_names
xuhdr
col
err
if
res
DW_DLV_OK
struct
esb_s
hmsg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_xu_section_names
got
s
et
esb_append_printf_u
on
column
number
u
col
esb_append_printf_u
of
u
columns
offsets_count
simple_err_return_action
res
esb_get_string
esb_destructor
dwarf_xu_header_free
xuhdr
return
res
index
is
origin
We
use
it
that
way
res
dwarf_get_xu_section_offset
xuhdr
index
col
err
if
res
DW_DLV_OK
struct
esb_s
hmsg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_xu_section_offset
got
s
et
esb_append_printf_u
on
index
number
u
index
esb_append_printf_u
on
column
number
u
col
esb_append_printf_u
of
u
columns
offsets_count
simple_err_return_action
res
esb_get_string
esb_destructor
dwarf_xu_header_free
xuhdr
return
res
printf
DW_PR_DUu
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
index
col
name
off
off
len
len
dwarf_xu_header_free
xuhdr
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
print_frames
h
for
print_location_operations
include
macrocheck
h
include
helpertree
h
include
opscounttab
h
include
tag_common
h
include
attr_form
h
OpBranchHead_s
gives
us
nice
type
checking
in
calls
struct
OpBranchEntry_s
Dwarf_Unsigned
offset
Dwarf_Unsigned
target_offset
Dwarf_Small
op
struct
OpBranchHead_s
Dwarf_Half
opcount
struct
OpBranchEntry_s
ops_array
Defaults
to
all
never
changes
static
const
LoHiPc
lohipc_zero
Traverse
a
DIE
and
attributes
to
check
self
references
static
int
traverse_one_die
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
Dwarf_Bool
char
srcfiles
Dwarf_Signed
srcfiles_cnt
int
die_indent_level
Dwarf_Error
err
static
int
traverse_attribute
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
Dwarf_Half
attr
Dwarf_Attribute
attr_in
Dwarf_Bool
print_else_name_match
char
srcfiles
Dwarf_Signed
srcfiles_cnt
int
die_indent_level
Dwarf_Error
err
static
int
print_die_and_children_internal
Dwarf_Debug
dbg
Dwarf_Die
in_die_in
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
char
srcfiles
Dwarf_Signed
srcfiles_cnt
Dwarf_Error
static
int
print_one_die_section
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
pod_err
static
int
handle_rnglists
Dwarf_Die
die
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Unsigned
value
Dwarf_Unsigned
rle_offset_out
struct
esb_s
esbp
int
show_form
int
local_verbose
Dwarf_Error
err
static
int
_dwarf_print_one_expr_op
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Small
lkind
int
die_indent_level
Dwarf_Locdesc_c
exprc
int
index
Dwarf_Bool
has_skip_or_branch
struct
OpBranchHead_s
oparray
Dwarf_Bool
report_raw
non
zero
reports
cooked
values
Dwarf_Addr
baseaddr
struct
esb_s
string_out
Dwarf_Error
err
static
int
get_form_values
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Half
directform
Dwarf_Error
err
static
void
show_form_itself
int
show_form
int
verbose
int
theform
int
directform
struct
esb_s
str_out
static
int
print_attribute
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Half
attr
Dwarf_Attribute
actual_addr
Dwarf_Bool
print_else_name_match
int
die_indent_level
char
srcfiles
Dwarf_Signed
srcfcnt
LoHiPc
lohipc
Dwarf_Bool
attr_matched
Dwarf_Error
err
static
int
print_location_list
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attr
Dwarf_Bool
checking
int
die_indent_level
int
no_ending_newline
struct
esb_s
details
Dwarf_Error
static
int
formxdata_print_value
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attrib
Dwarf_Half
theform
struct
esb_s
esbp
Dwarf_Error
err
Dwarf_Bool
hex_format
static
void
bracket_hex
const
char
s1
Dwarf_Unsigned
v
const
char
s2
struct
esb_s
esbp
static
void
formx_unsigned
Dwarf_Unsigned
u
struct
esb_s
esbp
Dwarf_Bool
hex_format
static
void
formx_data16
Dwarf_Form_Data16
u
struct
esb_s
esbp
Dwarf_Bool
hex_format
static
void
formx_signed
Dwarf_Signed
s
struct
esb_s
esbp
static
int
pd_dwarf_names_print_on_error
static
int
die_stack_indent_level
static
Dwarf_Bool
local_symbols_already_began
FALSE
See
tag_specific_globals_setup
and
glflags
need_PU_valid_code
as
those
oversee
resetting
of
this
It
is
set
when
a
compilation
unit
DIE
or
a
subprogram
DIE
is
seen
and
that
DIE
setting
is
kept
till
the
next
such
is
seen
glflags
in_valid_code
Used
to
be
a
static
variable
static
const
Dwarf_Sig8
zerosig
if
static
void
dump_bytes
const
char
msg
Dwarf_Small
start
long
len
Dwarf_Small
end
start
len
Dwarf_Small
cur
start
printf
s
lx
msg
unsigned
long
start
for
cur
end
cur
printf
cur
printf
n
endif
characters
static
char
indentspace
static
int
indentspacelen
static
void
appendn
struct
esb_s
m
int
len
int
remaining
len
while
remaining
indentspacelen
esb_append
m
indentspace
remaining
indentspacelen
esb_appendn
m
indentspace
remaining
static
void
append_indent_prefix
struct
esb_s
m
int
prespaces
int
indent
int
postspaces
if
indent
glflags
gf_max_space_indent
appendn
m
indent
prespaces
postspaces
return
appendn
m
prespaces
esb_append_printf_i
m
d
indent
appendn
m
postspaces
static
int
standard_indent
void
Attribute
indent
The
global
offset
printed
length
is
actually
With
GOFF
the
length
is
actually
Usually
int
nColumn
glflags
gf_show_global_offsets
if
glflags
gf_display_offsets
nColumn
return
nColumn
static
void
print_indent_prefix
int
prespaces
int
indent
int
postspaces
if
indent
glflags
gf_max_space_indent
int
len
prespaces
postspaces
indent
printf
s
len
return
if
prespaces
printf
s
prespaces
printf
d
indent
if
postspaces
printf
s
postspaces
struct
die_stack_data_s
Dwarf_Die
die_
sibling_die_globaloffset_
is
set
while
processing
the
DIE
We
do
not
know
the
sibling
global
offset
when
we
create
the
stack
entry
If
the
sibling
attribute
absent
we
never
know
Dwarf_Off
sibling_die_globaloffset_
We
may
need
is_info
here
too
Dwarf_Off
cu_die_offset_
global
offset
Dwarf_Bool
already_printed_
static
struct
die_stack_data_s
empty_stack_entry
define
DIE_STACK_SIZE
static
struct
die_stack_data_s
die_stack
DIE_STACK_SIZE
define
SET_DIE_STACK_ENTRY
i
x
o
die_stack
i
die_
x
die_stack
i
cu_die_offset_
o
die_stack
i
sibling_die_globaloffset_
die_stack
i
already_printed_
FALSE
define
EMPTY_DIE_STACK_ENTRY
i
die_stack
i
empty_stack_entry
define
SET_DIE_STACK_SIBLING
x
die_stack
die_stack_indent_level
sibling_die_globaloffset_
x
static
void
report_die_stack_error
Dwarf_Debug
dbg
Dwarf_Error
err
struct
esb_s
m
esb_constructor
esb_append_printf_i
ERROR
compiled
in
DIE_STACK_SIZE
the
depth
of
the
DIE
tree
in
this
CU
of
d
exceeded
Likely
a
circular
DIE
reference
DIE_STACK_SIZE
dwarf_error_creation
dbg
err
esb_get_string
print_error_and_continue
dbg
esb_get_string
DW_DLV_OK
err
esb_destructor
Just
access
the
die
and
print
selected
fields
into
the
string
In
case
of
error
print
an
error
message
and
return
DW_DLV_NO_ENTRY
Initially
we
just
verify
the
offset
is
ok
define
NO_SPECIFIC_TAG
The
following
two
must
differ
but
value
unimportant
We
choose
each
to
be
a
small
prime
number
define
NON_ZERO_OFFSET_REQUIRED
define
ZERO_OFFSET_GENERIC_TYPE
define
WITHIN_CU
TRUE
static
void
check_die_expr_op_basic_data
Dwarf_Debug
dbg
Dwarf_Die
die
const
char
op_name
int
indentprespaces
int
die_indent_level
int
indentpostspaces
int
required_tag
int
required_offset
int
within_cu
Dwarf_Unsigned
offset
struct
esb_s
string_out
Dwarf_Error
err
Dwarf_Off
globaloff
Dwarf_Bool
is_info
Dwarf_Die
other_die
int
res
Dwarf_Half
tag
const
char
required_tag_name
const
char
actual_tag_name
if
glflags
gf_do_print_dwarf
We
are
checking
so
any
errors
detected
will
not
print
so
do
not
check
Even
though
this
all
seems
self
contradictory
return
if
within_cu
offset
required_offset
ZERO_OFFSET_GENERIC_TYPE
Means
the
offset
zero
represents
generic
type
not
a
DIE
DW_OP_convert
DW_OP_reinterpret
return
if
die
esb_append
string_out
No
DIE
cannot
verify
die
offset
return
is_info
dwarf_get_die_infotypes_flag
die
if
within_cu
Our
target
DIE
is
in
same
CU
as
die
argument
DW_OP_const_type
Dwarf_Unsigned
length
res
dwarf_die_CU_offset_range
die
if
res
DW_DLV_OK
esb_append_printf_s
string_out
ERROR
s
Cannot
access
CU
DIE
global
offset
char
op_name
if
res
DW_DLV_ERROR
esb_append
string_out
dwarf_errmsg
err
dwarf_dealloc_error
dbg
err
err
else
esb_append
string_out
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
return
Offset
passed
in
is
off
of
CU
header
not
CU
DIE
globaloff
offset
else
DW_OP_implicit_ptr
globaloff
offset
if
required_offset
NON_ZERO_OFFSET_REQUIRED
globaloff
esb_append_printf_s
string_out
ERROR
s
DIE
global
offset
but
not
allowed
op_name
glflags
gf_count_major_errors
return
if
globaloff
return
res
dwarf_offdie_b
dbg
globaloff
is_info
if
res
DW_DLV_OK
esb_append_printf_s
string_out
ERROR
s
Cannot
access
DIE
via
global
offset
op_name
esb_append_printf_u
string_out
x
globaloff
if
res
DW_DLV_ERROR
esb_append
string_out
dwarf_errmsg
err
esb_append
string_out
dwarf_dealloc_error
dbg
err
err
else
esb_append
string_out
DW_DLV_NO_ENTRY
if
within_cu
esb_append
string_out
DW_OP_implicit_ptr
offset
might
apply
to
another
object
file
glflags
gf_count_major_errors
return
res
dwarf_tag
other_die
if
res
DW_DLV_OK
esb_append_printf_s
string_out
ERROR
s
Cannot
access
DIE
tag
op_name
esb_append_printf_u
string_out
x
globaloff
if
res
DW_DLV_ERROR
esb_append
string_out
dwarf_errmsg
err
esb_append
string_out
dwarf_dealloc_error
dbg
err
err
else
esb_append
string_out
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
dwarf_dealloc_die
other_die
return
if
required_tag
required_tag_name
get_TAG_name
required_tag
FALSE
actual_tag_name
get_TAG_name
tag
FALSE
if
required_tag
tag
required_tag
esb_append_printf_s
string_out
ERROR
s
incorrect
target
die
tag
op_name
esb_append_printf_s
string_out
Tag
required
s
required_tag_name
esb_append_printf_s
string_out
Tag
found
s
actual_tag_name
glflags
gf_count_major_errors
if
glflags
dense
glflags
gf_expr_ops_joined
char
diename
GOFF
esb_append
string_out
n
append_indent_prefix
string_out
indentprespaces
die_indent_level
indentpostspaces
esb_append
string_out
Target
Die
if
within_cu
esb_append_printf_u
string_out
DW_PR_XZEROS
DW_PR_DUx
offset
if
glflags
gf_show_global_offsets
esb_append_printf_u
string_out
GOFF
DW_PR_XZEROS
DW_PR_DUx
globaloff
esb_append
string_out
else
esb_append_printf_u
string_out
GOFF
DW_PR_XZEROS
DW_PR_DUx
globaloff
esb_append
string_out
actual_tag_name
res
dwarf_diename
other_die
if
res
DW_DLV_OK
esb_append_printf_s
string_out
name
s
diename
else
if
res
DW_DLV_ERROR
esb_append_printf_s
string_out
ERROR
gets
error
reading
DW_AT_diename
s
dwarf_errmsg
err
dwarf_dealloc_error
dbg
err
err
Else
no
entry
dwarf_dealloc_die
other_die
The
first
non
zero
sibling
offset
we
can
find
is
what
we
want
to
return
The
lowest
sibling
offset
in
the
stack
Or
if
we
have
none
known
static
Dwarf_Off
get_die_stack_sibling
int
i
die_stack_indent_level
for
i
i
Dwarf_Off
v
die_stack
i
sibling_die_globaloffset_
if
v
return
v
return
static
void
possibly_increase_esb_alloc
struct
esb_s
esbp
Dwarf_Unsigned
count
Dwarf_Unsigned
entrysize
for
bytes
of
text
needed
per
element
Dwarf_Unsigned
targetsize
count
entrysize
Dwarf_Unsigned
used
esb_string_len
esbp
Dwarf_Unsigned
cursize
esb_get_allocated_size
esbp
if
targetsize
used
cursize
esb_force_allocation
esbp
targetsize
used
static
void
dealloc_all_srcfiles
Dwarf_Debug
dbg
char
srcfiles
Dwarf_Signed
srcfiles_cnt
Dwarf_Signed
i
if
srcfiles
return
for
i
srcfiles_cnt
i
dwarf_dealloc
dbg
srcfiles
i
DW_DLA_STRING
dwarf_dealloc
dbg
srcfiles
DW_DLA_LIST
Higher
stack
level
numbers
must
have
a
smaller
sibling
offset
than
lower
or
else
the
sibling
offsets
are
wrong
Stack
entries
with
sibling_die_globaloffset_
must
be
ignored
in
this
it
just
means
there
was
no
sibling
attribute
at
that
level
static
void
validate_die_stack_siblings
Dwarf_Debug
dbg
int
i
die_stack_indent_level
Dwarf_Off
innersiboffset
for
i
i
Dwarf_Off
v
die_stack
i
sibling_die_globaloffset_
if
v
innersiboffset
v
break
if
innersiboffset
no
sibling
values
to
check
return
for
i
i
i
outersiboffset
is
an
outer
sibling
offset
Dwarf_Off
outersiboffset
die_stack
i
sibling_die_globaloffset_
if
outersiboffset
if
outersiboffset
innersiboffset
char
small_buf
ESB_FIXED_ALLOC_SIZE
Dwarf_Error
ouerr
safe
all
values
known
length
struct
esb_s
pm
esb_constructor_fixed
small_buf
sizeof
small_buf
esb_append_printf_u
ERROR
Die
stack
sibling
error
outer
global
offset
DW_PR_XZEROS
DW_PR_DUx
outersiboffset
esb_append_printf_u
less
than
inner
global
offset
DW_PR_XZEROS
DW_PR_DUx
the
DIE
tree
is
erroneous
innersiboffset
esb_append_printf_i
Die
indent
level
d
i
print_error_and_continue
dbg
esb_get_string
DW_DLV_OK
ouerr
esb_destructor
return
We
only
need
check
one
level
with
an
offset
at
each
entry
break
return
static
void
append_local_prefix
struct
esb_s
esbp
esb_append
esbp
n
static
int
print_as_info_or_by_cuname
return
glflags
gf_info_flag
glflags
gf_types_flag
glflags
gf_cu_name_flag
if
Only
used
for
debugging
static
void
dump_die_offsets
Dwarf_Debug
dbg
Dwarf_Die
die
const
char
msg
Dwarf_Error
dderr
Dwarf_Off
goff
Dwarf_Off
loff
Dwarf_Half
tag
int
res
res
dwarf_die_offsets
die
DROP_ERROR_INSTANCE
dbg
res
dderr
res
dwarf_tag
die
DROP_ERROR_INSTANCE
dbg
res
dderr
printf
debugonly
Die
tag
x
GOFF
llx
Loff
llx
s
n
tag
goff
loff
msg
endif
These
for
sure
are
not
to
debug_info
or
debug_types
static
Dwarf_Bool
form_refers_local_info
Dwarf_Half
form
switch
form
case
DW_FORM_GNU_ref_alt
case
DW_FORM_GNU_strp_alt
case
DW_FORM_strp_sup
case
DW_FORM_line_strp
These
do
not
refer
to
the
current
section
and
cannot
be
checked
as
if
they
did
return
FALSE
return
TRUE
process
each
compilation
unit
in
debug_info
int
print_infos
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
pi_err
int
nres
nres
print_one_die_section
dbg
is_info
pi_err
return
nres
static
void
print_debug_fission_header
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
const
char
fissionsec
debug_cu_index
unsigned
i
struct
esb_s
hash_str
if
fsd
fsd
pcu_type
No
fission
data
return
esb_constructor
printf
n
if
strcmp
fsd
pcu_type
tu
fissionsec
debug_tu_index
printf
s
n
Fission
section
fissionsec
printf
DW_PR_XZEROS
DW_PR_DUx
n
Fission
index
fsd
pcu_index
format_sig8_string
pcu_hash
printf
s
n
Fission
hash
esb_get_string
is
always
unused
Skip
it
esb_destructor
printf
s
n
Fission
entries
offset
size
DW_SECTn
for
i
i
DW_FISSION_SECT_COUNT
i
const
char
nstring
Dwarf_Unsigned
off
Dwarf_Unsigned
size
fsd
pcu_size
i
int
res
if
size
continue
res
dwarf_get_SECT_name
i
if
res
DW_DLV_OK
nstring
Unknown
SECT
off
fsd
pcu_offset
i
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
n
nstring
off
size
i
static
void
print_cu_hdr_cudie
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Die
cudie
UNUSEDARG
Dwarf_Unsigned
overall_offset
Dwarf_Unsigned
offset
struct
Dwarf_Debug_Fission_Per_CU_s
fission_data
if
glflags
dense
printf
n
return
memset
sizeof
fission_data
printf
nCOMPILE_UNIT
header
overall
offset
DW_PR_XZEROS
DW_PR_DUx
Dwarf_Unsigned
overall_offset
offset
printf
n
static
void
print_cu_hdr_std
Dwarf_Unsigned
cu_header_length
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
version_stamp
Dwarf_Half
address_size
offset_size
is
often
called
length_size
in
libdwarf
Dwarf_Half
offset_size
int
debug_fission_res
Dwarf_Half
cu_type
struct
Dwarf_Debug_Fission_Per_CU_s
fsd
int
res
const
char
utname
res
dwarf_get_UT_name
cu_type
if
res
DW_DLV_OK
glflags
gf_count_major_errors
utname
ERROR
if
glflags
dense
printf
s
cu_header
printf
s
DW_PR_XZEROS
DW_PR_DUx
cu_header_length
cu_header_length
printf
s
version_stamp
version_stamp
printf
s
DW_PR_XZEROS
DW_PR_DUx
abbrev_offset
abbrev_offset
printf
s
address_size
address_size
printf
s
offset_size
offset_size
printf
s
s
cu_type
cu_type
utname
if
debug_fission_res
DW_DLV_OK
struct
esb_s
hash_str
unsigned
i
esb_constructor
format_sig8_string
pcu_hash
printf
s
DW_PR_XZEROS
DW_PR_DUx
fissionindex
fsd
pcu_index
printf
s
s
fissionhash
esb_get_string
esb_destructor
for
i
i
DW_FISSION_SECT_COUNT
i
const
char
nstring
Dwarf_Unsigned
off
Dwarf_Unsigned
size
fsd
pcu_size
i
int
fires
if
size
continue
fires
dwarf_get_SECT_name
i
if
fires
DW_DLV_OK
nstring
UnknownDW_SECT
off
fsd
pcu_offset
i
printf
s
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
nstring
off
size
else
printf
nCU_HEADER
n
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
cu_header_length
cu_header_length
cu_header_length
printf
u
n
version_stamp
version_stamp
version_stamp
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
abbrev_offset
abbrev_offset
abbrev_offset
printf
u
n
address_size
address_size
address_size
printf
u
n
offset_size
offset_size
offset_size
printf
s
n
cu_type
cu_type
utname
if
debug_fission_res
DW_DLV_OK
print_debug_fission_header
fsd
static
void
print_cu_hdr_signature
Dwarf_Sig8
signature
Dwarf_Unsigned
typeoffset
if
glflags
dense
struct
esb_s
sig8str
esb_constructor
format_sig8_string
signature
printf
s
s
signature
esb_get_string
printf
s
DW_PR_XZEROS
DW_PR_DUx
typeoffset
typeoffset
esb_destructor
else
struct
esb_s
sig8str
esb_constructor
format_sig8_string
signature
printf
s
n
signature
esb_get_string
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
typeoffset
typeoffset
typeoffset
esb_destructor
static
int
get_macinfo_offset
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Unsigned
offset
Dwarf_Error
macerr
Dwarf_Attribute
attrib
int
vres
int
ares
ares
dwarf_attr
cu_die
DW_AT_macro_info
macerr
if
ares
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
getting
dwarf_attr
for
DW_AT_macro_info
failed
ares
macerr
return
ares
else
if
ares
DW_DLV_NO_ENTRY
return
ares
vres
dwarf_global_formref
attrib
offset
macerr
if
vres
DW_DLV_ERROR
dwarf_dealloc_attribute
attrib
print_error_and_continue
dbg
ERROR
dwarf_global_formref
on
DW_AT_macro_info
failed
vres
macerr
return
vres
else
if
vres
DW_DLV_OK
dwarf_dealloc_attribute
attrib
return
vres
static
void
print_die_secname
Dwarf_Debug
dbg
int
is_info
if
print_as_info_or_by_cuname
glflags
gf_do_print_dwarf
const
char
section_name
struct
esb_s
truename
char
buf
ESB_FIXED_ALLOC_SIZE
if
is_info
section_name
debug_info
else
section_name
debug_types
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
section_name
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
static
Dwarf_Bool
empty_signature
const
Dwarf_Sig8
sigp
if
memcmp
sigp
sizeof
zerosig
return
FALSE
empty
return
TRUE
static
int
print_macinfo_for_cu
Dwarf_Debug
dbg
Dwarf_Die
cu_die2
Dwarf_Error
err
int
mres
Dwarf_Unsigned
offset
mres
get_macinfo_offset
dbg
cu_die2
err
if
mres
DW_DLV_NO_ENTRY
By
far
the
most
likely
result
return
mres
else
if
mres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
get_macinfo_offset
for
DWARF
or
failed
on
a
CU
die
mres
err
return
mres
else
mres
print_macinfo_by_offset
dbg
cu_die2
offset
err
if
mres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
printing
macros
for
a
CU
at
macinfo
offset
x
failed
offset
print_error_and_continue
dbg
esb_get_string
mres
err
esb_destructor
return
DW_DLV_OK
Called
with
a
CU_Die
as
in_die_in
static
int
print_die_and_children
Dwarf_Debug
dbg
Dwarf_Die
in_die_in
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
char
srcfiles
Dwarf_Signed
srcfiles_cnt
Dwarf_Error
err
int
res
local_symbols_already_began
FALSE
res
print_die_and_children_internal
dbg
in_die_in
dieprint_cu_goffset
is_info
srcfiles
srcfiles_cnt
err
return
res
static
int
print_cu_hdr_abbrev_data
Dwarf_Debug
dbg
Dwarf_Off
aboffset
Dwarf_Error
error
Dwarf_Unsigned
initial_abbnum
Dwarf_Unsigned
final_abbnum
Dwarf_Unsigned
length
int
ores
if
glflags
gf_do_print_dwarf
printf
nAbbreviation
table
this
CU
offset
DW_PR_XZEROS
DW_PR_DUx
n
aboffset
ores
print_all_abbrevs_for_cu
dbg
aboffset
initial_abbnum
error
return
ores
static
int
print_one_die_section
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
pod_err
Dwarf_Unsigned
cu_header_length
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
version_stamp
Dwarf_Half
address_size
Dwarf_Half
extension_size
Dwarf_Half
length_size
Dwarf_Unsigned
typeoffset
Dwarf_Unsigned
next_cu_offset
unsigned
loop_count
int
nres
DW_DLV_OK
int
cu_count
char
cu_short_name
NULL
char
cu_long_name
NULL
int
res
Dwarf_Off
dieprint_cu_goffset
glflags
current_section_id
is_info?DEBUG_INFO
DEBUG_TYPES
const
char
test_section_name
res
dwarf_get_die_section_name
dbg
is_info
pod_err
if
res
DW_DLV_NO_ENTRY
if
is_info
No
debug_types
Do
not
print
debug_types
name
return
DW_DLV_NO_ENTRY
Loop
until
it
fails
for
loop_count
int
sres
DW_DLV_OK
Dwarf_Die
cu_die
Dwarf_Die
cu_die2
struct
Dwarf_Debug_Fission_Per_CU_s
fission_data
int
fission_data_result
Dwarf_Half
cu_type
Dwarf_Sig8
signature
int
offres
signature
zerosig
glflags
DIE_overall_offset
in
case
dwarf_next_cu_header_d
fails
due
to
corrupt
dwarf
glflags
DIE_overall_offset
dieprint_cu_goffset
memset
sizeof
fission_data
nres
dwarf_next_cu_header_d
dbg
is_info
pod_err
if
loop_count
So
compress
flags
show
we
waited
till
section
loaded
to
do
this
print_die_secname
dbg
is_info
if
nres
DW_DLV_NO_ENTRY
return
nres
if
nres
DW_DLV_ERROR
With
corrupt
DWARF
due
to
a
bad
CU
die
we
won
t
know
much
print_error_and_continue
dbg
ERROR
Failure
reading
CU
header
or
DIE
corrupt
DWARF
nres
pod_err
return
nres
if
cu_count
glflags
break_after_n_units
const
char
m
CUs
if
cu_count
m
CU
printf
Break
at
d
s
n
cu_count
m
break
Regardless
of
any
options
used
get
basic
information
about
the
current
CU
producer
name
sres
dwarf_siblingof_b
dbg
NULL
is_info
pod_err
if
sres
DW_DLV_OK
There
is
no
CU
die
which
should
be
impossible
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
dwarf_siblingof_b
failed
no
CU
die
sres
pod_err
return
sres
print_error_and_continue
dbg
ERROR
dwarf_siblingof_b
got
NO_ENTRY
no
CU
die
sres
pod_err
return
sres
Get
the
CU
offset
when
we
can
for
easy
error
reporting
Ignore
errors
offres
dwarf_die_offsets
cu_die
DIE_overall_offset
DIE_offset
pod_err
DROP_ERROR_INSTANCE
dbg
offres
pod_err
glflags
DIE_CU_overall_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_offset
dieprint_cu_goffset
glflags
DIE_overall_offset
if
glflags
gf_cu_name_flag
Dwarf_Bool
should_skip
FALSE
always
sets
should_skip
even
if
error
should_skip_this_cu
dbg
cu_die
if
should_skip
dwarf_dealloc_die
cu_die
cu_die
cu_count
continue
Get
producer
name
for
this
CU
and
update
compiler
list
int
cures
struct
esb_s
producername
esb_constructor
Fills
in
some
producername
no
matter
what
status
returned
cures
get_producer_name
dbg
cu_die
dieprint_cu_goffset
pod_err
if
cures
DW_DLV_OK
update_compiler_target
esb_get_string
else
DROP_ERROR_INSTANCE
dbg
cures
pod_err
esb_destructor
Once
the
compiler
table
has
been
updated
see
if
we
need
to
generate
the
list
of
CU
compiled
by
all
the
producers
contained
in
the
elf
file
if
glflags
gf_producer_children_flag
int
chres
chres
get_cu_name
dbg
cu_die
dieprint_cu_goffset
pod_err
if
chres
DW_DLV_ERROR
return
chres
if
chres
DW_DLV_OK
Add
CU
name
to
current
compiler
entry
add_cu_name_compiler_target
cu_long_name
If
the
current
compiler
is
not
requested
by
the
user
then
move
to
the
next
CU
if
checking_this_compiler
dwarf_dealloc_die
cu_die
cu_count
cu_die
continue
fission_data_result
dwarf_get_debugfission_for_die
cu_die
pod_err
if
fission_data_result
DW_DLV_ERROR
dwarf_dealloc_die
cu_die
cu_die
print_error_and_continue
dbg
ERROR
Failure
looking
for
Debug
Fission
data
fission_data_result
pod_err
return
fission_data_result
if
fission_data_result
DW_DLV_OK
In
a
dwp
file
some
checks
get
all
sorts
of
spurious
errors
glflags
gf_suppress_checking_on_dwp
TRUE
glflags
gf_check_ranges
FALSE
glflags
gf_check_aranges
FALSE
glflags
gf_check_decl_file
FALSE
glflags
gf_check_lines
FALSE
glflags
gf_check_pubname_attr
FALSE
glflags
gf_check_fdes
FALSE
We
have
not
seen
the
compile
unit
yet
reset
these
error
reporting
globals
glflags
seen_CU
FALSE
glflags
need_CU_name
TRUE
glflags
need_CU_base_address
TRUE
glflags
need_CU_high_address
TRUE
Some
prerelease
gcc
versions
used
ranges
but
seemingly
assumed
the
lack
of
a
base
address
in
the
CU
was
defined
to
be
a
zero
base
Assuming
a
base
address
and
low
and
high
is
sensible
glflags
CU_base_address
glflags
CU_high_address
glflags
CU_low_address
Release
the
cu_die
created
by
the
call
to
dwarf_next_cu_header_d
at
the
top
of
the
main
loop
dwarf_dealloc_die
cu_die
cu_die
For
debugging
stale
die
should
be
NULL
if
glflags
gf_info_flag
glflags
gf_types_flag
glflags
gf_do_print_dwarf
if
glflags
verbose
print_cu_hdr_std
cu_header_length
abbrev_offset
version_stamp
address_size
length_size
fission_data_result
cu_type
if
empty_signature
print_cu_hdr_signature
typeoffset
if
glflags
dense
printf
n
else
if
empty_signature
if
glflags
dense
printf
s
cu_header
else
printf
nCU_HEADER
n
print_cu_hdr_signature
typeoffset
if
glflags
dense
printf
n
if
glflags
gf_check_abbreviations
glflags
verbose
glflags
gf_info_flag
glflags
gf_types_flag
glflags
gf_do_print_dwarf
int
hares
hares
print_cu_hdr_abbrev_data
dbg
abbrev_offset
pod_err
if
hares
DW_DLV_ERROR
Will
be
reported
later
no
doubt
DROP_ERROR_INSTANCE
dbg
hares
pod_err
pod_err
Get
abbreviation
info
for
this
CU
get_abbrev_array_info
dbg
abbrev_offset
Process
a
single
compilation
unit
in
debug_info
or
debug_types
cu_die2
sres
dwarf_siblingof_b
dbg
NULL
is_info
pod_err
if
sres
DW_DLV_OK
int
pres
Dwarf_Signed
srcfiles_cnt
char
srcfiles
int
srcf
Dwarf_Error
srcerr
srcf
dwarf_srcfiles
cu_die2
if
srcf
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
dwarf_srcfiles
problem
srcf
srcerr
DROP_ERROR_INSTANCE
dbg
srcf
srcerr
srcfiles
srcfiles_cnt
else
if
srcf
DW_DLV_NO_ENTRY
DW_DLV_NO_ENTRY
generally
means
there
there
is
no
DW_AT_stmt_list
attribute
and
we
do
not
want
to
print
anything
about
statements
in
that
case
if
print_as_info_or_by_cuname
glflags
gf_search_is_on
Do
regardless
if
dwarf_srcfiles
was
successful
to
print
die
and
children
as
best
we
can
even
with
errors
int
podres2
Dwarf_Error
lperr
Get
the
CU
offset
for
easy
error
reporting
podres2
dwarf_die_offsets
cu_die2
DIE_overall_offset
DIE_offset
DROP_ERROR_INSTANCE
dbg
podres2
lperr
glflags
DIE_CU_overall_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_offset
dieprint_cu_goffset
glflags
DIE_overall_offset
pres
print_die_and_children
dbg
cu_die2
dieprint_cu_goffset
is_info
srcfiles
srcfiles_cnt
pod_err
if
pres
DW_DLV_ERROR
if
srcfiles
dealloc_all_srcfiles
dbg
srcfiles
srcfiles_cnt
srcfiles
srcfiles_cnt
dwarf_dealloc_die
cu_die2
return
pres
Dump
Ranges
Information
if
dump_ranges_info
PrintBucketGroup
glflags
pRangesInfo
TRUE
Check
the
range
array
if
in
checl
mode
if
glflags
gf_check_ranges
int
rares
Dwarf_Error
raerr
rares
check_range_array_info
dbg
cu_die2
if
rares
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
range
array
checks
for
the
current
CU
failed
rares
raerr
DROP_ERROR_INSTANCE
dbg
rares
raerr
Traverse
the
line
section
if
in
check
mode
or
if
line
printing
requested
if
glflags
gf_line_flag
glflags
gf_check_decl_file
int
plnres
int
oldsection
glflags
current_section_id
plnres
print_line_numbers_this_cu
dbg
cu_die2
srcfiles
srcfiles_cnt
pod_err
if
plnres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Printing
line
numbers
for
the
current
CU
failed
plnres
pod_err
Suppress
the
error
so
we
print
whatever
we
can
DROP_ERROR_INSTANCE
dbg
plnres
pod_err
glflags
current_section_id
oldsection
if
glflags
gf_macro_flag
glflags
gf_check_macros
int
mres
Dwarf_Bool
in_import_list
FALSE
Dwarf_Unsigned
import_offset
int
oldsection
glflags
current_section_id
DWARF5
debug_macro
version
in
the
macro
header
or
GNU
extension
of
DWARF4
debug_macro
with
version
in
the
macro
header
macro_import_stack_cleanout
mres
print_macros_5style_this_cu
dbg
cu_die2
srcfiles
srcfiles_cnt
glflags
gf_do_print_dwarf
TRUE
descend_into_imports
in_import_list
import_offset
pod_err
if
mres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Printing
DWARF5
macros
for
the
current
CU
failed
mres
pod_err
Suppress
the
error
so
we
print
whatever
we
can
DROP_ERROR_INSTANCE
dbg
mres
pod_err
macro_import_stack_cleanout
in_import_list
TRUE
The
above
would
have
checked
all
reachable
macro
units
so
no
need
to
check
here
if
glflags
gf_do_check_dwarf
mres
DW_DLV_OK
for
Never
returns
DW_DLV_ERROR
mres
get_next_unprinted_macro_offset
if
mres
DW_DLV_OK
break
macro_import_stack_cleanout
mres
print_macros_5style_this_cu
dbg
cu_die2
srcfiles
srcfiles_cnt
glflags
gf_do_print_dwarf
FALSE
no
descend_into_imports
in_import_list
import_offset
pod_err
if
mres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
ERROR
Printing
DWARF5
macros
at
offset
x
for
the
current
macro
import
in
the
macros
failed
import_offset
print_error_and_continue
dbg
esb_get_string
mres
pod_err
DROP_ERROR_INSTANCE
dbg
mres
pod_err
esb_destructor
break
macro_import_stack_cleanout
glflags
current_section_id
oldsection
if
glflags
gf_macinfo_flag
glflags
gf_check_macros
int
mres
Macros
have
no
version
number
before
DWARF
mres
print_macinfo_for_cu
dbg
cu_die2
pod_err
if
mres
DW_DLV_ERROR
if
cu_die2
dwarf_dealloc_die
cu_die2
if
srcfiles
dealloc_all_srcfiles
dbg
srcfiles
srcfiles_cnt
srcfiles
srcfiles_cnt
return
mres
if
cu_die2
dwarf_dealloc_die
cu_die2
cu_die2
if
srcfiles
dealloc_all_srcfiles
dbg
srcfiles
srcfiles_cnt
srcfiles
srcfiles_cnt
else
if
sres
DW_DLV_NO_ENTRY
Do
nothing
I
guess
else
print_error_and_continue
dbg
ERROR
getting
a
compilation
unit
CU
die
failed
sres
pod_err
DROP_ERROR_INSTANCE
dbg
sres
pod_err
cu_die2
cu_count
End
loop
on
loop_count
return
nres
static
int
print_a_die_stack
Dwarf_Debug
dbg
char
srcfiles
Dwarf_Signed
srcfiles_cnt
int
lev
Dwarf_Error
err
Print_information
TRUE
means
attribute_matched
will
NOT
be
set
by
attribute
name
match
Just
print
the
die
at
the
top
of
stack
Dwarf_Bool
print_else_name_match
TRUE
Dwarf_Bool
ignore_die_stack
FALSE
Dwarf_Bool
attribute_matched
FALSE
int
res
res
print_one_die
dbg
die_stack
lev
die_
die_stack
lev
cu_die_offset_
print_else_name_match
lev
srcfiles
srcfiles_cnt
ignore_die_stack
err
return
res
static
int
print_die_stack
Dwarf_Debug
dbg
char
srcfiles
Dwarf_Signed
srcfiles_cnt
Dwarf_Error
err
int
lev
Print_information
TRUE
means
attribute_matched
will
NOT
be
set
by
attribute
name
match
Just
print
the
dies
in
the
stack
Dwarf_Bool
print_else_name_match
TRUE
Dwarf_Bool
ignore_die_stack
FALSE
Dwarf_Bool
attribute_matched
FALSE
for
lev
lev
die_stack_indent_level
lev
int
res
res
print_one_die
dbg
die_stack
lev
die_
die_stack
lev
cu_die_offset_
print_else_name_match
lev
srcfiles
srcfiles_cnt
ignore_die_stack
err
if
res
DW_DLV_ERROR
return
res
return
DW_DLV_OK
recursively
follow
the
die
tree
static
int
print_die_and_children_internal
Dwarf_Debug
dbg
Dwarf_Die
in_die_in
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
char
srcfiles
Dwarf_Signed
cnt
Dwarf_Error
err
Dwarf_Die
child
Dwarf_Die
sibling
int
cdres
Dwarf_Die
in_die
in_die_in
for
int
offres
Get
the
CU
offset
for
easy
error
reporting
offres
dwarf_die_offsets
in_die
DIE_overall_offset
DIE_offset
err
DROP_ERROR_INSTANCE
dbg
offres
err
SET_DIE_STACK_ENTRY
die_stack_indent_level
in_die
dieprint_cu_goffset
if
glflags
gf_check_tag_tree
glflags
gf_print_usage_tag_attr
DWARF_CHECK_COUNT
tag_tree_result
if
die_stack_indent_level
Dwarf_Half
tag
int
dtres
dtres
dwarf_tag
in_die
err
if
dtres
DW_DLV_OK
DROP_ERROR_INSTANCE
dbg
dtres
err
DWARF_CHECK_ERROR
tag_tree_result
Tag
tree
root
tag
unavailable
is
not
DW_TAG_compile_unit
else
if
tag
DW_TAG_skeleton_unit
OK
else
if
tag
DW_TAG_compile_unit
OK
else
if
tag
DW_TAG_partial_unit
OK
else
if
tag
DW_TAG_type_unit
OK
else
DWARF_CHECK_ERROR
tag_tree_result
tag
tree
root
is
not
DW_TAG_compile_unit
or
DW_TAG_partial_unit
or
DW_TAG_type_unit
else
Dwarf_Half
tag_parent
Dwarf_Half
tag_child
int
pres
int
cres
const
char
ctagname
child
tag
invalid
const
char
ptagname
parent
tag
invalid
pres
dwarf_tag
die_stack
die_stack_indent_level
die_
err
if
pres
DW_DLV_OK
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
cres
cres
dwarf_tag
in_die
err
if
cres
DW_DLV_OK
return
cres
Check
for
specific
compiler
if
checking_this_compiler
Process
specific
TAGs
tag_specific_globals_setup
dbg
tag_child
die_stack_indent_level
if
cres
DW_DLV_OK
pres
DW_DLV_OK
if
cres
DW_DLV_OK
ctagname
get_TAG_name
tag_child
pd_dwarf_names_print_on_error
if
pres
DW_DLV_OK
ptagname
get_TAG_name
tag_parent
pd_dwarf_names_print_on_error
DWARF_CHECK_ERROR3
tag_tree_result
ptagname
ctagname
Tag
tree
relation
is
not
standard
else
if
legal_tag_tree_combination
tag_parent
tag_child
OK
else
Report
errors
only
if
tag
tree
check
is
on
if
glflags
gf_check_tag_tree
DWARF_CHECK_ERROR3
tag_tree_result
get_TAG_name
tag_parent
pd_dwarf_names_print_on_error
get_TAG_name
tag_child
pd_dwarf_names_print_on_error
tag
tree
relation
is
not
standard
if
glflags
gf_record_dwarf_error
glflags
gf_check_verbose_mode
glflags
gf_record_dwarf_error
FALSE
Here
do
pre
descent
processing
of
the
die
Dwarf_Bool
an_attribute_match_local
FALSE
Dwarf_Bool
ignore_die_stack
FALSE
int
pdres
pdres
print_one_die
dbg
in_die
dieprint_cu_goffset
print_as_info_or_by_cuname
die_stack_indent_level
srcfiles
cnt
ignore_die_stack
err
if
pdres
DW_DLV_OK
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
pdres
validate_die_stack_siblings
dbg
if
print_as_info_or_by_cuname
an_attribute_match_local
if
glflags
gf_display_parent_tree
pdres
print_die_stack
dbg
srcfiles
cnt
err
if
pdres
DW_DLV_ERROR
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
pdres
else
if
glflags
gf_display_children_tree
pdres
print_a_die_stack
dbg
srcfiles
cnt
die_stack_indent_level
err
if
pdres
DW_DLV_ERROR
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
pdres
if
glflags
gf_display_children_tree
glflags
gf_stop_indent_level
die_stack_indent_level
glflags
gf_info_flag
TRUE
glflags
gf_types_flag
TRUE
cdres
dwarf_child
in_die
err
if
cdres
DW_DLV_ERROR
print_error_and_continue
dbg
Call
to
dwarf_child
failed
printing
die
tree
cdres
err
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
cdres
Check
for
specific
compiler
if
glflags
gf_check_abbreviations
checking_this_compiler
Dwarf_Half
ab_has_child
Dwarf_Bool
bError
FALSE
Dwarf_Half
tag
int
abtres
This
does
not
return
a
Dwarf_Error
value
abtres
dwarf_die_abbrev_children_flag
in_die
if
abtres
DW_DLV_OK
Dwarf_Error
tagerr
int
tagres
DWARF_CHECK_COUNT
abbreviations_result
tagres
dwarf_tag
in_die
if
tagres
DW_DLV_OK
switch
tag
case
DW_TAG_array_type
case
DW_TAG_class_type
case
DW_TAG_compile_unit
case
DW_TAG_type_unit
case
DW_TAG_partial_unit
case
DW_TAG_enumeration_type
case
DW_TAG_lexical_block
case
DW_TAG_namespace
case
DW_TAG_structure_type
case
DW_TAG_subprogram
case
DW_TAG_subroutine_type
case
DW_TAG_union_type
case
DW_TAG_entry_point
case
DW_TAG_inlined_subroutine
break
default
bError
cdres
DW_DLV_OK
ab_has_child
cdres
DW_DLV_NO_ENTRY
ab_has_child
if
bError
DWARF_CHECK_ERROR
abbreviations_result
check
dw_children
flag
combination
break
else
if
tagres
DW_DLV_ERROR
dwarf_dealloc_die
child
print_error_and_continue
dbg
Unable
to
read
die
tag
tagres
tagerr
tagerr
is
unrelated
to
error
but
leaving
error
NULL
should
be
ok
return
tagres
else
if
abtres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
Unable
to
read
die
children
flag
n
return
is
unrelated
to
error
but
leaving
error
NULL
should
be
ok
return
abtres
child
first
we
are
doing
depth
first
walk
if
cdres
DW_DLV_OK
If
the
global
offset
of
the
first
child
is
the
parent
DW_AT_sibling
global
offset
value
then
the
compiler
has
made
a
mistake
and
the
DIE
tree
is
corrupt
int
pdacres
Dwarf_Off
child_overall_offset
int
cores
dwarf_dieoffset
child
err
if
cores
DW_DLV_OK
Dwarf_Off
parent_sib_val
get_die_stack_sibling
if
parent_sib_val
parent_sib_val
child_overall_offset
char
small_buf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
pm
esb_constructor_fixed
small_buf
sizeof
small_buf
esb_append_printf_u
ERROR
A
parent
DW_AT_sibling
of
DW_PR_XZEROS
DW_PR_DUx
parent_sib_val
esb_append_printf_s
points
s
the
first
child
parent_sib_val
child_overall_offset
at
before
esb_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
so
the
die
tree
is
corrupt
showing
section
not
CU
offsets
child_overall_offset
dwarf_error_creation
dbg
err
esb_get_string
print_error_and_continue
dbg
esb_get_string
DW_DLV_ERROR
err
Original
test
did
a
print_error
here
which
did
exit
We
would
like
to
return
ERROR
all
the
way
back
but
have
no
way
at
present
to
generate
a
Dwarf_Error
record
Because
these
sorts
of
errors
are
not
really
recoverable
esb_destructor
dwarf_dealloc_die
child
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
DW_DLV_ERROR
else
if
cores
DW_DLV_ERROR
print_error_and_continue
dbg
Finding
a
DIE
offset
dwarf_dieoffset
failed
cores
err
dwarf_dealloc_die
child
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
cores
if
die_stack_indent_level
DIE_STACK_SIZE
report_die_stack_error
dbg
err
if
in_die
in_die_in
dwarf_dealloc_die
in_die
dwarf_dealloc_die
child
return
DW_DLV_ERROR
die_stack_indent_level
SET_DIE_STACK_ENTRY
die_stack_indent_level
dieprint_cu_goffset
pdacres
print_die_and_children_internal
dbg
child
dieprint_cu_goffset
is_info
srcfiles
cnt
err
EMPTY_DIE_STACK_ENTRY
die_stack_indent_level
dwarf_dealloc_die
child
die_stack_indent_level
if
pdacres
DW_DLV_ERROR
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
pdacres
child
else
if
cdres
DW_DLV_ERROR
dwarf_dealloc_die
child
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
cdres
Stop
the
display
of
all
children
if
glflags
gf_display_children_tree
glflags
gf_info_flag
glflags
gf_types_flag
glflags
gf_stop_indent_level
die_stack_indent_level
glflags
gf_info_flag
FALSE
glflags
gf_types_flag
FALSE
sibling
dwarf_dealloc_die
child
child
cdres
dwarf_siblingof_b
dbg
in_die
is_info
err
if
cdres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
dwarf_siblingof
fails
tracing
siblings
of
a
DIE
cdres
err
if
in_die
in_die_in
dwarf_dealloc_die
in_die
return
cdres
print_die_and_children
dbg
sibling
srcfiles
cnt
We
loop
around
to
actually
print
this
rather
than
recursing
Recursing
is
horribly
wasteful
of
stack
space
If
we
have
a
sibling
verify
that
its
offset
is
next
to
the
last
processed
DIE
An
incorrect
sibling
chain
is
a
nasty
bug
if
cdres
DW_DLV_OK
sibling
glflags
gf_check_di_gaps
checking_this_compiler
Dwarf_Off
glb_off
DWARF_CHECK_COUNT
di_gaps_result
if
dwarf_validate_die_sibling
sibling
DW_DLV_ERROR
Dwarf_Off
sib_off
struct
esb_s
msg
esb_constructor
dwarf_dieoffset
sibling
err
esb_append_printf_u
GSIB
DW_PR_XZEROS
DW_PR_DUx
sib_off
esb_append_printf_u
GOFF
DW_PR_XZEROS
DW_PR_DUx
glb_off
esb_append_printf_u
Gap
DW_PR_DUu
bytes
sib_off
glb_off
DWARF_CHECK_ERROR2
di_gaps_result
Incorrect
sibling
chain
esb_get_string
esb_destructor
Here
do
any
post
descent
ie
post
dwarf_child
processing
of
the
in_die
EMPTY_DIE_STACK_ENTRY
die_stack_indent_level
if
in_die
in_die_in
Dealloc
our
in_die
but
not
the
argument
die
it
belongs
to
our
caller
Whether
the
siblingof
call
worked
or
not
dwarf_dealloc_die
in_die
in_die
if
cdres
DW_DLV_OK
Set
to
process
the
sibling
loop
again
in_die
sibling
sibling
else
ASSERT
cdres
is
DW_DLV_NO_ENTRY
sibling
in_die
We
are
done
no
more
siblings
at
this
level
break
end
for
loop
on
siblings
return
DW_DLV_OK
static
void
dealloc_local_atlist
Dwarf_Debug
dbg
Dwarf_Attribute
atlist
Dwarf_Signed
atcnt
Dwarf_Signed
i
for
i
i
atcnt
i
dwarf_dealloc_attribute
atlist
i
atlist
i
dwarf_dealloc
dbg
atlist
DW_DLA_LIST
Print
one
die
on
error
and
verbose
or
non
check
mode
define
PRINTING_DIES
glflags
gf_do_print_dwarf
glflags
gf_record_dwarf_error
glflags
gf_check_verbose_mode
static
void
print_srcfiles
char
srcfiles
Dwarf_Signed
srcfcnt
Dwarf_Signed
i
const
char
cntstr
DW_PR_DSd
printf
dwarf_srcfiles
returned
strings
Count
DW_PR_DSd
n
srcfcnt
if
srcfcnt
glflags
gf_count_major_errors
printf
ERROR
dwarf_srcfiles
count
less
than
zero
which
should
be
impossible
Ignoring
srcfiles
return
if
srcfcnt
if
srcfcnt
cntstr
DW_PR_DSd
else
cntstr
DW_PR_DSd
for
i
srcfcnt
i
printf
cntstr
i
printf
s
n
sanitized
srcfiles
i
If
print_else_name_match
is
FALSE
check
for
attribute
matches
with
S
inr
print_attribute
and
if
found
print
the
information
anyway
if
print_else_name_match
is
true
do
not
check
for
attribute
name
matches
Just
print
Sets
an_attr_matched
TRUE
if
there
is
attribute
name
or
value
that
matches
a
S
option
the
long
form
option
starts
with
search
Returns
DW_DLV_OK
DW_DLV_ERROR
or
DW_DLV_NO_ENTRY
int
print_one_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
print_else_name_match
int
die_indent_level
char
srcfiles
Dwarf_Signed
srcfcnt
Dwarf_Bool
an_attr_matched_io
Dwarf_Bool
ignore_die_stack
Dwarf_Error
err
Dwarf_Signed
i
Dwarf_Signed
j
Dwarf_Off
offset
Dwarf_Off
overall_offset
const
char
tagname
Dwarf_Half
tag
Dwarf_Signed
atcnt
Dwarf_Attribute
atlist
int
tres
int
ores
Dwarf_Bool
attribute_matchedpod
FALSE
int
atres
int
abbrev_code
dwarf_die_abbrev_code
die
LoHiPc
lohipc
int
indentprespaces
lohipc
lohipc_zero
Print
using
indentation
see
standard_indent
above
GOFF
DW_TAG_pointer_type
DW_TAG_pointer_type
DW_TAG_pointer_type
if
glflags
gf_check_abbreviations
checking_this_compiler
validate_abbrev_code
dbg
abbrev_code
if
ignore_die_stack
die_stack
die_indent_level
already_printed_
FALSE
seems
safe
an_attr_matched_io
FALSE
return
DW_DLV_OK
indentprespaces
standard_indent
tres
dwarf_tag
die
err
if
tres
DW_DLV_OK
print_error_and_continue
dbg
ERROR
accessing
tag
of
die
tres
err
return
tres
tagname
get_TAG_name
tag
pd_dwarf_names_print_on_error
ifdef
HAVE_USAGE_TAG_ATTR
if
glflags
gf_print_usage_tag_attr
record_tag_usage
tag
endif
HAVE_USAGE_TAG_ATTR
tag_specific_globals_setup
dbg
tag
die_indent_level
ores
dwarf_dieoffset
die
err
if
ores
DW_DLV_OK
print_error_and_continue
dbg
ERROR
failed
dwarf_dieoffset
call
ores
err
return
ores
ores
dwarf_die_CU_offset
die
err
if
ores
DW_DLV_OK
print_error_and_continue
dbg
ERROR
dwarf_die_CU_offset
failed
ores
err
return
ores
if
dump_visited_info
glflags
gf_check_self_references
printf
DW_PR_XZEROS
DW_PR_DUx
GOFF
DW_PR_XZEROS
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
offset
Dwarf_Unsigned
overall_offset
print_indent_prefix
die_indent_level
printf
s
n
tagname
Print
the
die
if
PRINTING_DIES
print_else_name_match
if
ignore_die_stack
die_stack
die_indent_level
already_printed_
TRUE
if
die_indent_level
print_cu_hdr_cudie
dbg
die
overall_offset
offset
else
if
local_symbols_already_began
FALSE
die_indent_level
glflags
dense
printf
nLOCAL_SYMBOLS
n
local_symbols_already_began
TRUE
Print
just
the
Tags
and
Attributes
if
glflags
gf_display_offsets
Print
using
indentation
print_indent_prefix
die_indent_level
printf
s
n
tagname
else
if
glflags
dense
if
glflags
gf_show_global_offsets
if
die_indent_level
printf
d
DW_PR_DUx
DW_PR_DUx
GOFF
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
overall_offset
offset
Dwarf_Unsigned
offset
Dwarf_Unsigned
overall_offset
else
printf
d
DW_PR_DUx
GOFF
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
offset
Dwarf_Unsigned
overall_offset
else
if
die_indent_level
printf
d
DW_PR_DUx
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
overall_offset
offset
Dwarf_Unsigned
offset
else
printf
d
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
offset
printf
s
tagname
if
glflags
verbose
Dwarf_Off
agoff
Dwarf_Unsigned
acount
printf
abbrev
d
abbrev_code
if
glflags
gf_show_global_offsets
int
agres
agres
dwarf_die_abbrev_global_offset
die
err
if
agres
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_die_abbrev_global_offset
call
failed
agres
err
return
agres
else
if
agres
DW_DLV_NO_ENTRY
print_error_and_continue
dbg
dwarf_die_abbrev_global_offset
no
entry?
agres
err
return
agres
else
printf
ABGOFF
DW_PR_XZEROS
DW_PR_DUx
count
DW_PR_XZEROS
DW_PR_DUx
agoff
acount
printf
else
if
glflags
gf_show_global_offsets
printf
DW_PR_XZEROS
DW_PR_DUx
GOFF
DW_PR_XZEROS
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
offset
Dwarf_Unsigned
overall_offset
else
printf
DW_PR_XZEROS
DW_PR_DUx
die_indent_level
Dwarf_Unsigned
offset
Print
using
indentation
print_indent_prefix
die_indent_level
printf
s
tagname
if
glflags
verbose
Dwarf_Off
agoff
Dwarf_Unsigned
acount
printf
abbrev
d
abbrev_code
if
glflags
gf_show_global_offsets
int
agres
agres
dwarf_die_abbrev_global_offset
die
err
if
agres
DW_DLV_ERROR
print_error_and_continue
dbg
Call
to
dwarf_die_abbrev_global_offset
failed
agres
err
return
agres
else
if
agres
DW_DLV_NO_ENTRY
print_error_and_continue
dbg
Call
to
dwarf_die_abbrev_global_offset
returned
NO_ENTRY
agres
err
return
agres
else
printf
ABGOFF
DW_PR_XZEROS
DW_PR_DUx
count
DW_PR_XZEROS
DW_PR_DUx
agoff
acount
printf
fputs
n
stdout
if
glflags
verbose
die_indent_level
srcfcnt
PRINTING_DIES
print_srcfiles
srcfiles
srcfcnt
atres
dwarf_attrlist
die
err
if
atres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
A
call
to
dwarf_attrlist
failed
Impossible
error
atres
err
return
atres
else
if
atres
DW_DLV_NO_ENTRY
indicates
there
are
no
attrs
It
is
not
an
error
atcnt
Get
the
offset
for
easy
error
reporting
This
is
not
the
CU
die
atres
dwarf_die_offsets
die
DIE_overall_offset
DIE_offset
err
if
atres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
A
call
to
dwarf_die_offsets
failed
in
printing
an
attribute
atres
err
dealloc_local_atlist
dbg
atlist
atcnt
return
atres
for
i
i
atcnt
i
Dwarf_Half
attr
int
ares
ares
dwarf_whatattr
atlist
i
err
if
ares
DW_DLV_OK
Check
duplicated
attributes
use
brute
force
as
the
number
of
attributes
is
quite
small
the
problem
was
detected
with
the
LLVM
toolchain
generating
more
than
repeated
attributes
if
glflags
gf_check_duplicated_attributes
Dwarf_Half
attr_next
DWARF_CHECK_COUNT
duplicated_attributes_result
for
j
i
j
atcnt
j
ares
dwarf_whatattr
atlist
j
err
if
ares
DW_DLV_OK
if
attr
attr_next
DWARF_CHECK_ERROR2
duplicated_attributes_result
Duplicated
attribute
get_AT_name
attr
pd_dwarf_names_print_on_error
else
struct
esb_s
m
esb_constructor
esb_append_printf_i
ERROR
dwarf_whatattr
entry
missing
when
checking
for
duplicated
attributes
reading
attribute
j
print_error_and_continue
dbg
esb_get_string
ares
err
esb_destructor
dealloc_local_atlist
dbg
atlist
atcnt
return
ares
Print
using
indentation
if
glflags
dense
PRINTING_DIES
print_else_name_match
print_indent_prefix
indentprespaces
die_indent_level
Dwarf_Bool
attr_match_localb
FALSE
int
aresb
aresb
print_attribute
dbg
die
dieprint_cu_goffset
attr
atlist
i
print_else_name_match
die_indent_level
srcfiles
srcfcnt
err
if
aresb
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_i
ERROR
Failed
printing
attribute
d
i
esb_append_printf_i
of
d
attributes
atcnt
print_error_and_continue
dbg
esb_get_string
aresb
err
esb_destructor
DROP_ERROR_INSTANCE
dbg
aresb
err
if
print_else_name_match
FALSE
attr_match_localb
attribute_matchedpod
TRUE
if
glflags
gf_record_dwarf_error
glflags
gf_check_verbose_mode
glflags
gf_record_dwarf_error
FALSE
else
struct
esb_s
m
esb_constructor
esb_append_printf_i
ERROR
Failed
getting
attribute
d
i
esb_append_printf_i
of
d
attributes
atcnt
print_error_and_continue
dbg
esb_get_string
ares
err
esb_destructor
dealloc_local_atlist
dbg
atlist
atcnt
return
ares
atres
might
have
been
DW_DLV_NO_ENTRY
atlist
NULL
if
atlist
dealloc_local_atlist
dbg
atlist
atcnt
if
PRINTING_DIES
glflags
dense
print_else_name_match
printf
n
an_attr_matched_io
attribute_matchedpod
return
DW_DLV_OK
Encodings
have
undefined
signedness
Accept
either
signedness
The
values
are
integer
like
they
are
defined
in
the
DWARF
specification
so
the
form
the
compiler
uses
as
long
as
it
is
a
constant
value
is
a
non
issue
The
numbers
need
not
be
small
in
spite
of
the
function
name
but
the
result
should
be
an
integer
If
string_out
is
non
NULL
construct
a
string
output
either
an
error
message
or
the
name
of
the
encoding
The
function
pointer
passed
in
is
to
code
generated
by
a
script
at
dwarfdump
build
time
The
code
for
the
val_as_string
function
is
generated
from
dwarf
h
See
build
dir
dwarf_names
c
The
known_signed
bool
is
set
TRUE
nonzero
or
FALSE
zero
and
both
uval_out
and
sval_out
are
set
to
the
value
though
of
course
uval_out
cannot
represent
a
signed
value
properly
and
sval_out
cannot
represent
all
unsigned
values
properly
If
string_out
is
non
NULL
then
attr_name
and
val_as_string
must
also
be
non
NULL
int
dd_get_integer_and_name
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Unsigned
uval_out
const
char
attr_name
struct
esb_s
string_out
encoding_type_func
val_as_string
Dwarf_Error
err
int
show_form
Dwarf_Unsigned
uval
int
vres
dwarf_formudata
attrib
err
if
it
is
not
formudata
lets
check
further
DROP_ERROR_INSTANCE
dbg
vres
err
if
vres
DW_DLV_OK
Dwarf_Signed
sval
int
ires
ires
dwarf_formsdata
attrib
err
It
is
not
formudata
lets
check
further
DROP_ERROR_INSTANCE
dbg
ires
err
if
ires
DW_DLV_OK
int
jres
jres
dwarf_global_formref
attrib
err
if
jres
DW_DLV_OK
if
string_out
glflags
gf_count_major_errors
esb_append_printf_s
string_out
ERROR
s
has
a
bad
form
for
reading
a
value
attr_name
return
jres
uval_out
uval
else
uval
Dwarf_Unsigned
sval
uval_out
uval
else
uval_out
uval
if
string_out
Dwarf_Half
theform
Dwarf_Half
directform
char
fsbuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
fstring
int
fres
esb_constructor_fixed
fsbuf
sizeof
fsbuf
fres
get_form_values
dbg
attrib
err
if
fres
DW_DLV_ERROR
return
fres
esb_append
val_as_string
Dwarf_Half
uval
pd_dwarf_names_print_on_error
show_form_itself
show_form
glflags
verbose
theform
directform
esb_append
string_out
esb_get_string
esb_destructor
return
DW_DLV_OK
Called
for
DW_AT_SUN_func_offsets
We
need
a
bit
signed
number
here
But
we
re
getting
rid
of
the
__
u
int
n
_t
dependence
so
lets
use
plain
characters
This
is
rarely
if
ever
used
so
lets
report
errors
but
not
stop
the
processing
static
void
get_FLAG_BLOCK_string
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
struct
esb_s
esbp
int
fres
Dwarf_Block
tempb
Dwarf_Unsigned
array_len
Dwarf_Signed
array
Dwarf_Unsigned
next
Dwarf_Error
fblkerr
first
get
compressed
block
data
fres
dwarf_formblock
attrib
if
fres
DW_DLV_OK
print_error_and_continue
dbg
DW_FORM_blockn
cannot
get
block
n
fres
fblkerr
DROP_ERROR_INSTANCE
dbg
fres
fblkerr
return
fres
dwarf_uncompress_integer_block_a
dbg
tempb
bl_len
void
tempb
bl_data
uncompress
block
into
signed
int
array
It
s
really
a
block
of
sleb
numbers
so
the
compression
is
minor
unless
the
values
are
close
to
zero
if
fres
DW_DLV_OK
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
print_error_and_continue
dbg
DW_AT_SUN_func_offsets
cannot
uncompress
data
n
fblkerr
DROP_ERROR_INSTANCE
dbg
fres
fblkerr
return
if
array_len
print_error_and_continue
dbg
DW_AT_SUN_func_offsets
has
no
data
array
length
is
zero
something
badly
wrong
DW_DLV_OK
fblkerr
return
fill
in
string
buffer
next
while
next
array_len
unsigned
i
Print
a
full
line
esb_append
esbp
n
for
i
i
next
array_len
i
next
Dwarf_Signed
vs
array
next
Dwarf_Unsigned
vu
Dwarf_Unsigned
vs
if
i
esb_append
esbp
esb_append_printf_i
esbp
DW_PR_DSd
vs
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
vu
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
free
array
buffer
dwarf_dealloc_uncompressed_block
dbg
array
static
const
char
get_rangelist_type_descr
Dwarf_Ranges
r
switch
r
dwr_type
case
DW_RANGES_ENTRY
return
range
entry
case
DW_RANGES_ADDRESS_SELECTION
return
addr
selection
case
DW_RANGES_END
return
range
end
Impossible
return
Unknown
The
string
produced
here
will
need
to
be
passed
through
sanitized
before
actually
printing
Always
returns
DW_DLV_OK
int
print_ranges_list_to_extra
Dwarf_Debug
dbg
Dwarf_Unsigned
originaloff
Dwarf_Unsigned
finaloff
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
struct
esb_s
stringbuf
const
char
sec_name
Dwarf_Signed
i
struct
esb_s
truename
char
buf
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
buf
sizeof
buf
We
don
t
want
to
set
the
compress
data
into
the
secname
here
get_true_section_name
dbg
debug_ranges
FALSE
sec_name
esb_get_string
if
glflags
dense
esb_append_printf_i
stringbuf
ranges
DW_PR_DSd
rangecount
esb_append_printf_s
stringbuf
ranges
at
s
sanitized
sec_name
if
originaloff
finaloff
esb_append_printf_u
stringbuf
offset
DW_PR_DUu
finaloff
else
esb_append_printf_u
stringbuf
offset
with
non
zero
ranges
base
DW_PR_DUu
finaloff
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
finaloff
esb_append_printf_u
stringbuf
DW_PR_DUu
bytes
bytecount
else
esb_append_printf_i
stringbuf
ranges
DW_PR_DSd
rangecount
esb_append_printf_s
stringbuf
at
s
sanitized
sec_name
if
originaloff
finaloff
esb_append_printf_u
stringbuf
offset
DW_PR_DUu
finaloff
else
esb_append_printf_u
stringbuf
offset
with
non
zero
ranges
base
DW_PR_DUu
finaloff
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
finaloff
esb_append_printf_u
stringbuf
DW_PR_DUu
bytes
n
bytecount
for
i
i
rangecount
i
Dwarf_Ranges
r
rangeset
i
const
char
type
get_rangelist_type_descr
r
if
glflags
dense
esb_append_printf_i
stringbuf
DW_PR_DSd
i
esb_append_printf_s
stringbuf
s
type
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
r
dwr_addr1
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
r
dwr_addr2
else
esb_append_printf_i
stringbuf
DW_PR_DSd
i
esb_append_printf_s
stringbuf
type
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
r
dwr_addr1
esb_append_printf_u
stringbuf
DW_PR_XZEROS
DW_PR_DUx
n
r
dwr_addr2
esb_destructor
return
DW_DLV_OK
static
void
do_dump_visited_info
int
level
Dwarf_Off
loff
Dwarf_Off
goff
Dwarf_Off
cu_die_goff
const
char
atname
const
char
valname
printf
DW_PR_XZEROS
DW_PR_DUx
GOFF
DW_PR_XZEROS
DW_PR_DUx
CU
GOFF
DW_PR_XZEROS
DW_PR_DUx
level
loff
goff
cu_die_goff
print_indent_prefix
level
printf
s
s
n
atname
valname
Always
returns
DW_DLV_OK
Expected
attr
is
DW_AT_decl_file
or
DW_AT_call_file
static
int
turn_file_num_to_string
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Die
die
Dwarf_Attribute
attrib
UNUSEDARG
Dwarf_Half
theform
Dwarf_Half
dwversion
Dwarf_Unsigned
filenum
decl_file
number
char
srcfiles
Dwarf_Signed
srcfiles_cnt
struct
esb_s
esbp
Dwarf_Error
err
Dwarf_Half
offset_size
int
vres
char
declmsgbuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
declmsg
char
fname
Dwarf_Half
attrnum
vres
dwarf_whatattr
attrib
err
if
vres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append
ERROR
Cannot
get
DIE
context
attribute
number
for
attr
esb_append_printf_s
form
s
get_FORM_name
theform
FALSE
print_error_and_continue
dbg
esb_get_string
vres
err
esb_destructor
if
vres
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
vres
err
return
DW_DLV_OK
vres
dwarf_get_version_of_die
die
if
vres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_s
ERROR
Cannot
get
DIE
context
version
number
for
attr
s
get_AT_name
attrnum
FALSE
esb_append_printf_s
form
s
get_FORM_name
theform
FALSE
print_error_and_continue
dbg
esb_get_string
vres
err
esb_destructor
if
vres
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
vres
err
return
DW_DLV_OK
esb_constructor_fixed
declmsgbuf
sizeof
declmsgbuf
if
srcfiles
if
glflags
verbose
esb_append_printf_s
s
file
index
get_AT_name
attrnum
FALSE
esb_append_printf_u
DW_PR_DUu
filenum
esb_append
No
file
list
for
CU
esb_append
esbp
esb_append
esbp
esb_get_string
esb_destructor
return
DW_DLV_OK
else
Dwarf_Unsigned
localud
filenum
Dwarf_Bool
done
FALSE
if
dwversion
DWVERSION5
if
localud
Dwarf_Unsigned
srcfiles_cnt
fname
srcfiles
localud
esb_append
fname
done
TRUE
else
if
localud
Just
print
the
number
there
is
no
name
done
TRUE
else
if
localud
localud
Dwarf_Unsigned
srcfiles_cnt
fname
srcfiles
localud
esb_append
fname
done
TRUE
if
done
esb_append_printf_s
s
file
index
get_AT_name
attrnum
FALSE
esb_append_printf_u
DW_PR_DUu
filenum
esb_append
out
of
range
if
fname
esb_append
esbp
esb_append
esbp
esb_get_string
esb_destructor
return
DW_DLV_OK
static
void
append_useful_die_name
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Die
die
char
srcfiles
Dwarf_Signed
srcfiles_cnt
struct
esb_s
outstr
Dwarf_Error
err
int
res
Dwarf_Attribute
nattr
Dwarf_Half
nattr_form
Dwarf_Attribute
lattr
Dwarf_Unsigned
filenum
Dwarf_Unsigned
linenum
Dwarf_Half
version
Dwarf_Half
offset_size
res
dwarf_get_version_of_die
die
if
res
DW_DLV_OK
FAIL
return
res
dwarf_attr
die
DW_AT_decl_file
err
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
return
res
dwarf_whatform
nattr
err
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
dwarf_dealloc_attribute
nattr
return
res
dwarf_attr
die
DW_AT_decl_line
err
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
linenum
else
res
dwarf_formudata
lattr
err
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
linenum
dwarf_dealloc_attribute
lattr
lattr
turn_file_num_to_string
dbg
die
nattr
nattr_form
version
filenum
srcfiles
srcfiles_cnt
outstr
err
if
linenum
esb_append_printf_u
outstr
line
u
linenum
dwarf_dealloc_attribute
nattr
return
So
far
designed
for
DW_AT_type
with
a
Dwarf_Sig8
reference
Does
not
yet
look
at
tied
object
even
if
one
is
present
Does
not
currently
attempt
to
use
any
signature
resolution
fast
access
DWARF
sections
static
int
print_sig8_target
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
int
die_indent_level
char
srcfiles
Dwarf_Signed
srcfiles_cnt
struct
esb_s
valname
Dwarf_Error
err
Dwarf_Sig8
signature
Dwarf_Die
targdie
Dwarf_Bool
targ_is_info
FALSE
Dwarf_Half
targtag
Dwarf_Unsigned
targ_goff
const
char
targtagname
char
targdiename
int
res
res
dwarf_formsig8
attrib
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_formsig8
fails
in
attribute
traversal
res
err
return
res
if
res
DW_DLV_NO_ENTRY
return
res
res
dwarf_find_die_given_sig8
dbg
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_find_die_given_sig8
fails
following
a
signature
in
attribute
traversal
res
err
return
res
if
res
DW_DLV_NO_ENTRY
We
did
not
find
the
target
return
res
res
dwarf_dieoffset
targdie
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_dieoffset
fails
following
a
signature
in
attribute
traversal
res
err
dwarf_dealloc_die
targdie
return
res
if
res
DW_DLV_OK
if
glflags
dense
esb_append
valname
n
append_indent_prefix
valname
standard_indent
die_indent_level
esb_append_printf_u
valname
Target
GOFF
targ_goff
esb_append_printf_s
valname
in
section
s
targ_is_info?
debug_info
debug_types
res
dwarf_tag
targdie
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_tag
fails
following
a
signature
in
attribute
traversal
res
err
dwarf_dealloc_die
targdie
return
res
if
res
DW_DLV_OK
esb_append_printf_u
valname
TAG
targtag
targtagname
get_TAG_name
targtag
FALSE
esb_append_printf_s
valname
s
targtagname
res
dwarf_diename
targdie
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_tag
fails
following
a
signature
in
attribute
traversal
res
err
dwarf_dealloc_die
targdie
return
res
else
if
res
DW_DLV_NO_ENTRY
append_useful_die_name
dbg
targdie
srcfiles
srcfiles_cnt
valname
err
if
res
DW_DLV_OK
esb_append_printf_s
valname
name
s
targdiename
if
glflags
dense
esb_append
valname
n
If
we
get
here
we
extablished
the
target
dwarf_dealloc_die
targdie
return
DW_DLV_OK
DW_FORM_data16
should
not
apply
here
static
Dwarf_Bool
is_simple_location_expr
int
form
if
form
DW_FORM_block1
form
DW_FORM_block2
form
DW_FORM_block4
form
DW_FORM_block
form
DW_FORM_exprloc
return
TRUE
return
FALSE
static
Dwarf_Bool
is_location_form
int
form
if
form
DW_FORM_data4
form
DW_FORM_data8
form
DW_FORM_sec_offset
form
DW_FORM_loclistx
form
DW_FORM_rnglistx
return
TRUE
return
FALSE
static
void
show_attr_form_error
Dwarf_Debug
dbg
unsigned
attr
unsigned
form
struct
esb_s
out
const
char
n
int
res
Dwarf_Error
formerr
esb_append
out
ERROR
Attribute
esb_append_printf_u
out
u
attr
esb_append
out
res
dwarf_get_AT_name
attr
if
res
DW_DLV_OK
n
UknownAttribute
esb_append
out
n
esb_append
out
esb_append
out
has
form
esb_append_printf_u
out
u
form
esb_append
out
esb_append
out
get_FORM_name
form
FALSE
esb_append
out
a
form
which
is
not
appropriate
print_error_and_continue
dbg
esb_get_string
out
DW_DLV_OK
formerr
Traverse
an
attribute
and
following
any
reference
in
order
to
detect
self
references
to
DIES
loop
We
do
not
use
print_else_name_match
here
Just
looking
for
self
references
to
report
on
static
int
traverse_attribute
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
Dwarf_Half
attr
Dwarf_Attribute
attr_in
Dwarf_Bool
print_else_name_match
UNUSEDARG
char
srcfiles
Dwarf_Signed
srcfcnt
int
die_indent_level
Dwarf_Error
err
Dwarf_Attribute
attrib
const
char
atname
int
tres
Dwarf_Half
tag
struct
esb_s
valname
esb_constructor
is_info
dwarf_get_die_infotypes_flag
die
atname
get_AT_name
attr
pd_dwarf_names_print_on_error
The
following
gets
the
real
attribute
even
in
the
face
of
an
incorrect
doubling
or
worse
of
attributes
attrib
attr_in
Do
not
get
attr
via
dwarf_attr
if
there
are
erroneously
multiple
of
an
attr
in
a
DIE
dwarf_attr
will
not
get
the
second
erroneous
one
and
dwarfdump
will
print
the
first
one
multiple
times
Oops
tres
dwarf_tag
die
err
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DIE
tag
in
traverse_attribute
tres
err
esb_destructor
return
tres
else
if
tres
DW_DLV_NO_ENTRY
tag
else
ok
switch
attr
case
DW_AT_specification
case
DW_AT_abstract_origin
case
DW_AT_type
int
res
Dwarf_Off
die_goff
Dwarf_Off
ref_goff
Dwarf_Die
ref_die
struct
esb_s
specificationstr
Dwarf_Half
theform
Dwarf_Half
directform
char
buf
ESB_FIXED_ALLOC_SIZE
res
get_form_values
dbg
attrib
err
if
res
DW_DLV_OK
esb_destructor
return
res
if
form_refers_local_info
theform
break
esb_constructor_fixed
buf
sizeof
buf
die_indent_level
if
die_indent_level
DIE_STACK_SIZE
esb_destructor
report_die_stack_error
dbg
err
return
DW_DLV_ERROR
res
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfcnt
glflags
show_form_used
glflags
verbose
err
if
res
DW_DLV_OK
esb_destructor
return
res
esb_append
esb_get_string
esb_destructor
Get
the
global
offset
for
reference
if
theform
DW_FORM_ref_sig8
res
print_sig8_target
dbg
attrib
die_indent_level
srcfiles
srcfcnt
err
if
res
DW_DLV_ERROR
esb_destructor
return
res
break
res
dwarf_global_formref
attrib
err
if
res
DW_DLV_ERROR
int
dwerrno
dwarf_errno
err
if
dwerrno
DW_DLE_REF_SIG8_NOT_HANDLED
No
need
to
stop
ref_sig8
refers
out
of
the
current
section
DROP_ERROR_INSTANCE
dbg
res
err
break
else
print_error_and_continue
dbg
dwarf_global_formref
fails
in
attribute
traversal
res
err
esb_destructor
return
res
else
if
res
DW_DLV_NO_ENTRY
return
res
Gives
die
offset
in
section
res
dwarf_dieoffset
die
err
if
res
DW_DLV_ERROR
int
dwerrno
dwarf_errno
err
if
dwerrno
DW_DLE_REF_SIG8_NOT_HANDLED
No
need
to
stop
ref_sig8
refers
out
of
the
current
section
DROP_ERROR_INSTANCE
dbg
res
err
break
else
print_error_and_continue
dbg
dwarf_dieoffset
fails
in
attribute
traversal
res
err
esb_destructor
return
res
Follow
reference
chain
looking
for
self
references
res
dwarf_offdie_b
dbg
ref_goff
is_info
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_dieoff_b
fails
in
attribute
traversal
res
err
esb_destructor
return
res
if
res
DW_DLV_OK
Dwarf_Off
target_die_cu_goff
if
dump_visited_info
Dwarf_Off
die_loff
res
dwarf_die_CU_offset
die
err
if
res
DW_DLV_OK
esb_destructor
return
res
do_dump_visited_info
die_indent_level
die_loff
die_goff
dieprint_cu_goffset
atname
esb_get_string
die_indent_level
if
die_indent_level
DIE_STACK_SIZE
report_die_stack_error
dbg
err
esb_destructor
return
DW_DLV_ERROR
res
dwarf_CU_dieoffset_given_die
ref_die
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_dieoffset
accessing
cu_goff
die
fails
in
traversal
res
err
esb_destructor
return
res
res
traverse_one_die
dbg
attrib
ref_die
target_die_cu_goff
is_info
srcfiles
srcfcnt
die_indent_level
err
DeleteKeyInBucketGroup
glflags
pVisitedInfo
ref_goff
dwarf_dealloc_die
ref_die
if
res
DW_DLV_ERROR
esb_destructor
return
res
die_indent_level
ref_die
break
End
switch
esb_destructor
return
DW_DLV_OK
Traverse
one
DIE
in
order
to
detect
self
references
to
DIES
This
fails
to
deal
with
changing
CUs
via
global
references
so
srcfiles
and
cnt
have
possibly
inappropriate
values
FIXME
static
int
traverse_one_die
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Bool
is_info
char
srcfiles
Dwarf_Signed
cnt
int
die_indent_level
Dwarf_Error
err
Dwarf_Half
tag
Dwarf_Off
overall_offset
Dwarf_Signed
atcnt
int
res
Dwarf_Bool
print_else_name_match
FALSE
res
dwarf_tag
die
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
Problem
accessing
tag
of
die
from
traverse_one_die
res
err
return
res
res
dwarf_dieoffset
die
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_dieoffset
fails
in
traversing
die
res
err
return
res
if
dump_visited_info
Dwarf_Off
offset
const
char
tagname
res
dwarf_die_CU_offset
die
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_die_CU_offset
fails
in
traversing
die
res
err
return
res
tagname
get_TAG_name
tag
pd_dwarf_names_print_on_error
do_dump_visited_info
die_indent_level
offset
overall_offset
dieprint_cu_goffset
tagname
DWARF_CHECK_COUNT
self_references_result
if
FindKeyInBucketGroup
glflags
pVisitedInfo
overall_offset
char
localvaln
NULL
Dwarf_Half
attr
struct
esb_s
bucketgroupstr
const
char
atname
NULL
esb_constructor
res
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
cnt
glflags
show_form_used
glflags
verbose
err
if
res
DW_DLV_OK
return
res
localvaln
esb_get_string
res
dwarf_whatattr
attrib
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
ERROR
dwarf_whatattr
fails
in
traverse
die
res
err
return
res
atname
get_AT_name
attr
pd_dwarf_names_print_on_error
We
have
a
self
reference
DWARF_CHECK_ERROR3
self_references_result
Invalid
self
reference
to
DIE
atname
localvaln
esb_destructor
else
Dwarf_Signed
i
Dwarf_Attribute
atlist
Add
current
DIE
AddEntryIntoBucketGroup
glflags
pVisitedInfo
overall_offset
NULL
FALSE
res
dwarf_attrlist
die
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_attrlist
fails
in
traverse
die
res
err
else
if
res
DW_DLV_NO_ENTRY
indicates
there
are
no
attrs
It
is
not
an
error
atcnt
for
i
i
atcnt
i
Dwarf_Half
attr
int
ares
ares
dwarf_whatattr
atlist
i
err
if
ares
DW_DLV_OK
ares
traverse_attribute
dbg
die
dieprint_cu_goffset
is_info
attr
atlist
i
print_else_name_match
srcfiles
cnt
die_indent_level
err
if
ares
DW_DLV_ERROR
dealloc_local_atlist
dbg
atlist
atcnt
return
ares
else
print_error_and_continue
dbg
dwarf_whatattr
entry
missing
in
traverse
die
ares
err
return
ares
dealloc_local_atlist
dbg
atlist
atcnt
Delete
current
DIE
DeleteKeyInBucketGroup
glflags
pVisitedInfo
overall_offset
return
DW_DLV_OK
Extracted
this
from
print_attribute
to
get
tolerable
indents
In
other
words
to
make
it
readable
It
uses
global
data
fields
excessively
but
so
does
print_attribute
The
majority
of
the
code
here
is
checking
for
compiler
errors
Support
for
debug_rnglists
here
is
new
May
static
int
print_range_attribute
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Half
attr
Dwarf_Attribute
attr_in
Dwarf_Half
theform
int
pra_dwarf_names_print_on_error
Dwarf_Bool
print_else_name_match
int
append_extra_string
struct
esb_s
esb_extrap
Dwarf_Error
raerr
Dwarf_Unsigned
original_off
int
fres
Dwarf_Half
cu_version
Dwarf_Half
cu_offset_size
fres
dwarf_get_version_of_die
die
if
fres
DW_DLV_OK
simple_err_return_msg_either_action
fres
nERROR
Unable
to
get
version
of
a
DIE
to
print
a
range
attribute
so
something
is
badly
wrong
Assuming
DWARF2
offset
size
and
continuing
if
theform
DW_FORM_rnglistx
fres
dwarf_formudata
attr_in
raerr
if
fres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
In
printing
a
range
DW_FORM_rnglistx
attribute
dwarf_formudata
failed
fres
raerr
return
fres
else
fres
dwarf_global_formref
attr_in
raerr
if
fres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
In
printing
a
range
attribute
dwarf_global_formref
failed
fres
raerr
return
fres
if
fres
DW_DLV_OK
cu_version
DWVERSION5
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
Dwarf_Unsigned
realoffset
If
this
is
a
dwp
the
ranges
will
be
missing
or
reported
from
a
tied
file
For
now
we
add
the
ranges
to
dbg
not
tiedbg
as
we
do
not
mention
tieddbg
here
May
need
a
new
interface
FIXME?
In
the
dwp
case
where
the
actual
section
is
in
tied
ie
a
out
the
DW_AT_GNU_ranges_base
is
used
not
the
original_off
We
really
want
to
print
the
actual
offset
in
that
case
not
original_off
realoffset
is
that
final
actual
section
offset
int
rres
dwarf_get_ranges_b
dbg
original_off
die
raerr
if
rres
DW_DLV_OK
Ignore
ranges
inside
a
stripped
function
if
glflags
gf_suppress_checking_on_dwp
glflags
gf_check_ranges
glflags
in_valid_code
checking_this_compiler
Record
the
offset
as
the
ranges
check
will
be
done
at
the
end
of
the
compilation
unit
this
approach
solves
the
issue
of
DWARF4
generating
values
for
the
high
pc
as
offsets
relative
to
the
low
pc
and
the
compilation
unit
having
DW_AT_ranges
attribute
int
dores
Dwarf_Off
die_glb_offset
Dwarf_Off
die_off
dores
dwarf_die_offsets
die
raerr
if
dores
DW_DLV_ERROR
return
dores
if
dores
DW_DLV_OK
record_range_array_info_entry
die_glb_offset
realoffset
if
print_else_name_match
append_extra_string
print_ranges_list_to_extra
dbg
original_off
realoffset
rangeset
rangecount
bytecount
esb_extrap
dwarf_ranges_dealloc
dbg
rangeset
rangecount
else
if
rres
DW_DLV_ERROR
if
glflags
gf_suppress_checking_on_dwp
Ignore
checks
else
if
glflags
gf_do_print_dwarf
printf
ndwarf_get_ranges_a
cannot
find
DW_AT_ranges
at
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
original_off
original_off
else
DWARF_CHECK_COUNT
ranges_result
DWARF_CHECK_ERROR2
ranges_result
get_AT_name
attr
pra_dwarf_names_print_on_error
cannot
find
DW_AT_ranges
at
offset
return
rres
else
NO
ENTRY
if
glflags
gf_suppress_checking_on_dwp
Ignore
checks
else
if
glflags
gf_do_print_dwarf
printf
ndwarf_get_ranges_a
finds
no
DW_AT_ranges
at
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
original_off
original_off
else
DWARF_CHECK_COUNT
ranges_result
DWARF_CHECK_ERROR2
ranges_result
get_AT_name
attr
pra_dwarf_names_print_on_error
fails
to
find
DW_AT_ranges
at
offset
return
DW_DLV_OK
else
if
fres
DW_DLV_OK
cu_version
DWVERSION5
Here
we
have
to
access
the
debug_rnglists
section
data
with
a
new
layout
for
DW5
Here
we
do
not
need
to
actually
use
rleoffset
since
it
is
identical
to
original_off
int
res
Dwarf_Unsigned
rleoffset
res
handle_rnglists
die
attr_in
theform
original_off
esb_extrap
glflags
show_form_used
glflags
verbose
raerr
if
print_else_name_match
append_extra_string
return
res
DW_DLV_NO_ENTRY
or
DW_DLV_ERROR
if
glflags
gf_do_print_dwarf
struct
esb_s
local
char
tmp
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
tmp
sizeof
tmp
esb_append
fails
to
find
DW_AT_ranges
offset
esb_append_printf_u
attr
x
attr
esb_append_printf_u
form
x
theform
printf
s
esb_get_string
esb_destructor
else
DWARF_CHECK_COUNT
ranges_result
DWARF_CHECK_ERROR2
ranges_result
get_AT_name
attr
pra_dwarf_names_print_on_error
fails
to
find
DW_AT_ranges
offset
return
fres
A
DW_AT_name
in
a
CU
DIE
will
likely
have
dots
and
be
entirely
sensible
So
lets
not
call
things
a
possible
error
when
they
are
not
Some
assemblers
allow
in
an
identifier
too
This
is
a
heuristic
not
all
that
reliable
It
is
only
used
for
a
specific
DWARF_CHECK_ERROR
and
the
altabi
is
from
a
specific
unnamed
here
compiler
Return
FALSE
if
it
is
a
vaguely
standard
identifier
Else
return
TRUE
meaning
it
might
be
a
file
name
or
have
in
it
quite
sensibly
If
we
don
t
do
the
TAG
check
we
might
report
t
c
as
a
questionable
DW_AT_name
Which
would
be
silly
static
Dwarf_Bool
dot_ok_in_identifier
int
tag
const
char
val
if
strncmp
val
altabi
Ignore
the
names
of
the
form
altabi
name
which
apply
to
one
specific
compiler
return
TRUE
if
tag
DW_TAG_compile_unit
tag
DW_TAG_partial_unit
tag
DW_TAG_imported_unit
tag
DW_TAG_skeleton_unit
tag
DW_TAG_type_unit
return
TRUE
return
FALSE
static
void
trim_quotes
const
char
val
struct
esb_s
es
if
val
size_t
l
strlen
val
if
l
val
l
esb_appendn
es
val
l
return
esb_append
es
val
static
Dwarf_Bool
have_a_search_match
const
char
valname
const
char
atname
valname
may
have
had
quotes
inserted
but
search_match_text
will
not
So
we
need
to
use
a
new
copy
not
valname
here
char
matchbuf
not
ESB_FIXED_ALLOC_SIZE
struct
esb_s
esb_match
char
s2
esb_constructor_fixed
matchbuf
sizeof
matchbuf
trim_quotes
valname
s2
esb_get_string
if
glflags
search_match_text
if
strcmp
s2
glflags
search_match_text
strcmp
atname
glflags
search_match_text
esb_destructor
return
TRUE
if
glflags
search_any_text
if
is_strstrnocase
s2
glflags
search_any_text
is_strstrnocase
atname
glflags
search_any_text
esb_destructor
return
TRUE
ifdef
HAVE_REGEX
if
glflags
search_regex_text
if
regexec
glflags
search_re
s2
NULL
regexec
glflags
search_re
atname
NULL
esb_destructor
return
TRUE
endif
esb_destructor
return
FALSE
Use
our
local
die_stack
to
try
to
determine
signedness
of
the
DW_AT_discr_list
LEB
numbers
Returns
if
we
know
it
is
signed
Returns
if
we
know
it
is
unsigned
Returns
if
we
really
do
not
know
static
int
determine_discr_signedness
Dwarf_Debug
dbg
Dwarf_Die
parent
Dwarf_Half
tag
int
tres
Dwarf_Error
descrerr
if
die_stack_indent_level
We
have
no
idea
return
parent
die_stack
die_stack_indent_level
die_
if
parent
We
have
no
idea
return
tres
dwarf_tag
parent
if
tres
DW_DLV_OK
DROP_ERROR_INSTANCE
dbg
tres
descrerr
return
if
tag
DW_TAG_variant_part
return
Expect
DW_AT_discr
or
DW_AT_type
here
and
if
DW_AT_discr
that
might
have
the
DW_AT_type
FIXME
For
now
lets
just
punt
say
unsigned
return
static
void
checksignv
struct
esb_s
strout
const
char
title
Dwarf_Signed
sv
Dwarf_Unsigned
uv
The
test
and
output
are
not
entirely
meaningful
but
it
can
be
useful
for
readers
of
dwarfdump
output
if
uv
Dwarf_Unsigned
sv
Nothing
to
do
here
return
esb_append
strout
esb_append
strout
title
esb_append
strout
esb_append_printf_i
strout
DW_PR_DSd
sv
esb_append_printf_u
strout
DW_PR_DUu
uv
static
int
append_discr_array_vals
Dwarf_Debug
dbg
Dwarf_Dsc_Head
h
Dwarf_Unsigned
arraycount
int
isunsigned
struct
esb_s
strout
Dwarf_Error
paerr
Dwarf_Unsigned
u
if
isunsigned
esb_append
strout
discriminant
list
signedness
unknown
esb_append_printf_u
strout
n
discr
list
array
len
DW_PR_DUu
n
arraycount
for
u
u
arraycount
u
int
u2res
Dwarf_Half
dtype
Dwarf_Signed
slow
Dwarf_Signed
shigh
Dwarf_Unsigned
ulow
Dwarf_Unsigned
uhigh
const
char
dsc_name
u2res
dwarf_discr_entry_u
h
u
paerr
if
u2res
DW_DLV_ERROR
print_error_and_continue
dbg
DW_AT_discr_list
entry
access
fail
n
u2res
paerr
return
u2res
u2res
dwarf_discr_entry_s
h
u
paerr
if
u2res
DW_DLV_ERROR
print_error_and_continue
dbg
DW_AT_discr_list
entry
access
fail
n
u2res
paerr
if
u2res
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
esb_append_printf_u
strout
n
ERROR
discr
index
missing
DW_PR_DUu
u
break
esb_append_printf_u
strout
DW_PR_DUu
u
dsc_name
get_DSC_name
dtype
pd_dwarf_names_print_on_error
esb_append
strout
sanitized
dsc_name
esb_append
strout
if
dtype
if
isunsigned
esb_append_printf_i
strout
DW_PR_DSd
slow
checksignv
strout
as
signed
unsigned
slow
ulow
else
esb_append_printf_u
strout
DW_PR_DUu
ulow
checksignv
strout
as
signed
unsigned
slow
ulow
else
if
isunsigned
esb_append_printf_i
strout
DW_PR_DSd
slow
checksignv
strout
as
signed
unsigned
slow
ulow
else
esb_append_printf_u
strout
DW_PR_DUu
ulow
checksignv
strout
as
signed
unsigned
slow
ulow
if
isunsigned
esb_append_printf_i
strout
DW_PR_DSd
shigh
checksignv
strout
as
signed
unsigned
shigh
uhigh
else
esb_append_printf_u
strout
DW_PR_DUu
uhigh
checksignv
strout
as
signed
unsigned
shigh
uhigh
esb_append
strout
n
return
DW_DLV_OK
static
int
print_location_description
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Die
die
int
checking
Dwarf_Half
attr
int
die_indent_level
struct
esb_s
base
struct
esb_s
details
Dwarf_Error
err
The
attribute
is
a
location
description
or
location
list
int
res
Dwarf_Half
theform
Dwarf_Half
directform
Dwarf_Half
version
Dwarf_Half
offset_size
res
get_form_values
dbg
attrib
err
if
res
DW_DLV_ERROR
return
res
res
dwarf_get_version_of_die
die
if
is_simple_location_expr
theform
res
print_location_list
dbg
die
attrib
checking
die_indent_level
TRUE
base
err
if
res
DW_DLV_ERROR
return
res
else
if
is_location_form
theform
res
print_location_list
dbg
die
attrib
checking
die_indent_level
FALSE
details
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
location
list
data
res
err
return
res
else
show_attr_form_error
dbg
attr
theform
base
return
DW_DLV_OK
This
was
inside
print_attribute
static
void
check_attr_tag_combination
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Half
attr
const
char
tagname
tag
invalid
DWARF_CHECK_COUNT
attr_tag_result
if
legal_tag_attr_combination
tag
attr
OK
else
Report
errors
only
if
tag
attr
check
is
on
if
glflags
gf_check_tag_attr
tagname
get_TAG_name
tag
pd_dwarf_names_print_on_error
tag_specific_globals_setup
dbg
tag
die_stack_indent_level
DWARF_CHECK_ERROR3
attr_tag_result
tagname
get_AT_name
attr
pd_dwarf_names_print_on_error
check
the
tag
attr
combination
static
void
remark_wrong_string_format
Dwarf_Half
attr
Dwarf_Half
theform
enum
Dwarf_Form_Class
fc
UNUSEDARG
define
VSFBUFSZ
char
buf
VSFBUFSZ
struct
esb_s
m
esb_constructor_fixed
buf
VSFBUFSZ
esb_append_printf_s
ERROR
Cannot
print
the
value
of
attribute
s
get_AT_name
attr
FALSE
esb_append_printf_s
as
it
has
form
s
which
seems
wrong
get_FORM_name
theform
FALSE
esb_append
Corrupted
DWARF?
Continuing
simple_err_return_msg_either_action
DW_DLV_ERROR
esb_get_string
esb_destructor
return
undef
VSFBUFSZ
static
int
print_attribute
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_goffset
Dwarf_Half
attr
Dwarf_Attribute
attr_in
Dwarf_Bool
print_else_name_match
int
die_indent_level
char
srcfiles
Dwarf_Signed
srcfiles_cnt
LoHiPc
lohipc
Dwarf_Bool
attr_duplication
Dwarf_Error
err
Dwarf_Attribute
attrib
Dwarf_Unsigned
uval
const
char
atname
int
tres
Dwarf_Half
tag
int
append_extra_string
Dwarf_Bool
found_search_attr
FALSE
Dwarf_Bool
bTextFound
FALSE
Dwarf_Bool
is_info
FALSE
Dwarf_Addr
max_address
struct
esb_s
valname
struct
esb_s
esb_extra
char
valbuf
ESB_FIXED_ALLOC_SIZE
char
xtrabuf
ESB_FIXED_ALLOC_SIZE
int
res
Dwarf_Bool
checking
glflags
gf_do_check_dwarf
Dwarf_Half
theform
Dwarf_Half
directform
Dwarf_Half
version
Dwarf_Half
offset_size
enum
Dwarf_Form_Class
fc
DW_FORM_CLASS_UNKNOWN
esb_constructor_fixed
xtrabuf
sizeof
xtrabuf
esb_constructor_fixed
valbuf
sizeof
valbuf
is_info
dwarf_get_die_infotypes_flag
die
atname
get_AT_name
attr
pd_dwarf_names_print_on_error
res
get_address_size_and_max
dbg
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
Getting
address
maximum
failed
in
printing
attribute
res
err
return
res
The
following
gets
the
real
attribute
even
in
the
face
of
an
incorrect
doubling
or
worse
of
attributes
attrib
attr_in
res
get_form_values
dbg
attrib
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
form
values
res
err
esb_destructor
esb_destructor
return
res
res
dwarf_get_version_of_die
die
if
res
DW_DLV_OK
print_error_and_continue
dbg
ERROR
Cannot
get
DIE
context
version
number
for
DW_AT_discr_list
DW_DLV_OK
esb_destructor
esb_destructor
Returning
DW_DLV_ERROR
would
be
bogus
return
DW_DLV_NO_ENTRY
fc
dwarf_get_form_class
version
attr
offset_size
theform
Do
not
get
attr
via
dwarf_attr
if
there
are
erroneously
multiple
of
an
attr
in
a
DIE
dwarf_attr
will
not
get
the
second
erroneous
one
and
dwarfdump
will
print
the
first
one
multiple
times
Oops
tres
dwarf_tag
die
err
if
tres
DW_DLV_OK
print_error_and_continue
dbg
Getting
DIE
tag
failed
in
printing
an
attribute
tres
err
esb_destructor
esb_destructor
return
tres
if
glflags
gf_check_tag_attr
glflags
gf_print_usage_tag_attr
checking_this_compiler
check_attr_tag_combination
dbg
tag
attr
record_attr_form_use
dbg
tag
attr
Dwarf_Half
fc
theform
pd_dwarf_names_print_on_error
die_stack_indent_level
switch
attr
case
DW_AT_language
res
dd_get_integer_and_name
dbg
attrib
DW_AT_language
get_LANG_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_language
value
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_accessibility
res
dd_get_integer_and_name
dbg
attrib
DW_AT_accessibility
get_ACCESS_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_accessibility
value
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_visibility
res
dd_get_integer_and_name
dbg
attrib
DW_AT_visibility
get_VIS_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_visibility
value
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_virtuality
res
dd_get_integer_and_name
dbg
attrib
DW_AT_virtuality
get_VIRTUALITY_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_virtuality
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_identifier_case
res
dd_get_integer_and_name
dbg
attrib
DW_AT_identifier
get_ID_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_identifier_case
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_inline
res
dd_get_integer_and_name
dbg
attrib
DW_AT_inline
get_INL_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
DW_AT_inline
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_encoding
res
dd_get_integer_and_name
dbg
attrib
DW_AT_encoding
get_ATE_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
DW_AT_encoding
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_ordering
res
dd_get_integer_and_name
dbg
attrib
DW_AT_ordering
get_ORD_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
DW_AT_ordering
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_calling_convention
res
dd_get_integer_and_name
dbg
attrib
DW_AT_calling_convention
get_CC_name
err
glflags
show_form_used
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
DW_AT_calling_convention
res
err
esb_destructor
esb_destructor
return
res
break
case
DW_AT_discr_list
DWARF2
This
has
one
of
the
block
forms
It
should
be
in
a
DW_TAG_variant
Up
to
September
it
was
treated
as
integer
or
name
here
which
was
quite
wrong
if
fc
DW_FORM_CLASS_BLOCK
int
fres
Dwarf_Block
tempb
the
block
is
a
series
of
entries
each
of
one
of
these
formats
DW_DSC_label
caselabel
DW_DSC_range
lowvalue
highvalue
The
values
are
all
LEB
Signed
or
unsigned
depending
on
the
DW_TAG_variant_part
owning
the
DW_TAG_variant
The
DW_TAG_variant_part
will
have
a
DW_AT_type
or
a
DW_AT_discr
and
that
attribute
will
reveal
the
signedness
of
all
the
leb
values
As
a
practical
matter
DW_DSC_label
DW_DSC_range
value
zero
or
one
so
far
can
safely
be
read
as
ULEB
or
SLEB
and
one
gets
a
valid
value
whereas
the
caselabel
lowvalue
highvalue
must
be
decoded
with
the
proper
sign
the
high
level
dwarfdump
in
this
case
is
the
agent
that
should
determine
the
proper
signedness
fres
dwarf_formblock
attrib
err
if
fres
DW_DLV_OK
struct
esb_s
bformstr
int
isunsigned
Meaning
unknown
Dwarf_Dsc_Head
h
Dwarf_Unsigned
arraycount
int
sres
char
fbuf
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
fbuf
sizeof
fbuf
show_form_itself
glflags
show_form_used
glflags
verbose
theform
directform
isunsigned
determine_discr_signedness
dbg
esb_empty_string
sres
dwarf_discr_list
dbg
Dwarf_Small
tempb
bl_data
tempb
bl_len
err
if
sres
DW_DLV_NO_ENTRY
esb_append
empty
discriminant
list
break
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
DW_AT_discr_list
access
fail
sres
err
esb_destructor
esb_destructor
return
sres
sres
append_discr_array_vals
dbg
h
arraycount
isunsigned
err
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
getting
discriminant
values
failed
sres
err
esb_destructor
esb_destructor
return
sres
if
glflags
verbose
unsigned
u
esb_append_printf_u
n
block
byte
len
DW_PR_XZEROS
DW_PR_DUx
n
tempb
bl_len
for
u
u
tempb
bl_len
u
esb_append_printf_u
u
unsigned
char
tempb
bl_data
esb_append
esb_get_string
dwarf_dealloc
dbg
h
DW_DLA_DSC_HEAD
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
esb_destructor
tempb
else
print_error_and_continue
dbg
ERROR
DW_AT_discr_list
cannot
get
list
data
fres
err
esb_destructor
esb_destructor
return
fres
else
print_error_and_continue
dbg
DW_AT_discr_list
is
not
form
class
BLOCK
fc
err
esb_destructor
esb_destructor
return
fc
break
case
DW_AT_const_value
case
DW_AT_data_member_location
Value
is
a
constant
or
a
location
description
or
location
list
If
a
constant
it
could
be
signed
or
unsigned
Telling
whether
a
constant
or
a
reference
is
nontrivial
since
DW_FORM_data
could
be
either
in
DWARF
if
fc
DW_FORM_CLASS_CONSTANT
struct
esb_s
classconstantstr
Dwarf_Bool
chex
FALSE
int
wres
esb_constructor
Makes
no
sense
to
look
at
type
of
our
DIE
to
determine
how
to
print
the
constant
wres
formxdata_print_value
dbg
NULL
attrib
theform
err
chex
if
wres
DW_DLV_OK
esb_destructor
esb_destructor
return
wres
show_form_itself
glflags
show_form_used
glflags
verbose
theform
directform
esb_empty_string
esb_append
esb_get_string
esb_destructor
break
FALL
THRU
this
is
a
a
location
description
or
a
reference
to
one
or
a
mistake
Fall
Through
case
DW_AT_call_value
case
DW_AT_call_data_value
case
DW_AT_call_data_location
case
DW_AT_frame_base
case
DW_AT_GNU_call_site_value
case
DW_AT_GNU_call_site_target
case
DW_AT_byte_size
case
DW_AT_bit_size
case
DW_AT_location
case
DW_AT_return_addr
case
DW_AT_segment
case
DW_AT_static_link
case
DW_AT_string_length
case
DW_AT_use_location
case
DW_AT_vtable_elem_location
Dwarf_Bool
showform
glflags
show_form_used
If
DW_FORM_block
show_form_used
get_attr_value
results
in
duplicating
the
form
name
with
M
For
block
forms
this
will
show
block
len
and
bytes
and
if
showing
form
then
form
shown
res
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
showform
glflags
verbose
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
attr
form
value
res
err
DROP_ERROR_INSTANCE
dbg
res
err
break
append_extra_string
TRUE
if
fc
DW_FORM_CLASS_EXPRLOC
fc
DW_FORM_CLASS_LOCLIST
fc
DW_FORM_CLASS_LOCLISTPTR
Form
class
exprloc
is
set
even
for
DWARF2&3
see
libdwarf
dwarf_get_form_class
res
print_location_description
dbg
attrib
die
checking
attr
die_indent_level
err
if
res
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
location
data
attr
with
M
also
form
follow
res
err
DROP_ERROR_INSTANCE
dbg
res
err
break
break
case
DW_AT_SUN_func_offsets
value
is
a
location
description
or
location
list
char
buf
struct
esb_s
funcformstr
esb_constructor_fixed
buf
sizeof
buf
get_FLAG_BLOCK_string
dbg
attrib
show_form_itself
glflags
show_form_used
glflags
verbose
theform
directform
esb_empty_string
esb_append
esb_get_string
esb_destructor
break
case
DW_AT_SUN_cf_kind
Dwarf_Half
kind
Dwarf_Unsigned
tempud
int
wres
struct
esb_s
cfkindstr
esb_constructor
wres
dwarf_formudata
attrib
err
if
wres
DW_DLV_OK
kind
tempud
esb_append
get_ATCF_name
kind
pd_dwarf_names_print_on_error
else
if
wres
DW_DLV_NO_ENTRY
esb_append
else
print_error_and_continue
dbg
Cannot
get
formudata
length
field
for
DW_AT_SUN_cf_kind
wres
err
esb_destructor
esb_destructor
return
res
show_form_itself
glflags
show_form_used
glflags
verbose
theform
directform
esb_empty_string
esb_append
esb_get_string
esb_destructor
break
case
DW_AT_upper_bound
int
rv
struct
esb_s
upperboundstr
esb_constructor
switch
theform
case
DW_FORM_block1
append_extra_string
TRUE
rv
print_location_list
dbg
die
attrib
checking
die_indent_level
TRUE
err
if
rv
DW_DLV_ERROR
esb_destructor
esb_destructor
return
rv
show_form_itself
glflags
show_form_used
glflags
verbose
theform
directform
break
default
rv
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
rv
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
Cannot
get
DW_AT_upper_bound
form
value
rv
err
esb_destructor
esb_destructor
return
rv
esb_empty_string
esb_append
esb_get_string
break
esb_destructor
break
case
DW_AT_low_pc
case
DW_AT_high_pc
int
rv
rv
print_hipc_lopc_attribute
dbg
tag
die
die_indent_level
dieprint_cu_goffset
srcfiles
srcfiles_cnt
attrib
attr
max_address
lohipc
err
if
rv
DW_DLV_OK
esb_destructor
esb_destructor
return
rv
break
case
DW_AT_ranges
int
rv
rv
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
rv
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
find
Attr
value
for
DW_AT_ranges
rv
err
esb_destructor
esb_destructor
return
rv
rv
print_range_attribute
dbg
die
attr
attr_in
theform
pd_dwarf_names_print_on_error
print_else_name_match
err
if
rv
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
print
range
attribute
for
DW_AT_ranges
rv
err
We
will
not
stop
this
is
an
omission
in
libdwarf
on
DWARF5
rnglists
DROP_ERROR_INSTANCE
dbg
rv
err
break
case
DW_AT_MIPS_linkage_name
int
ml
char
linknamebuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
linkagenamestr
esb_constructor_fixed
linknamebuf
sizeof
linknamebuf
ml
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
ml
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
value
for
DW_AT_MIPS_linkage_name
ml
err
esb_destructor
esb_destructor
esb_destructor
return
ml
if
fc
DW_FORM_CLASS_STRING
remark_wrong_string_format
attr
theform
fc
esb_destructor
esb_destructor
esb_destructor
return
DW_DLV_NO_ENTRY
esb_empty_string
esb_append
esb_get_string
esb_destructor
if
glflags
gf_check_locations
glflags
gf_check_ranges
int
local_show_form
int
local_verbose
const
char
name
struct
esb_s
lesb
esb_constructor
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
local_show_form
local_verbose
err
Look
for
specific
name
forms
attempting
to
notice
and
report
odd
identifiers
Used
in
the
SNC
LinkOnce
feature
name
esb_get_string
safe_strcpy
glflags
PU_name
sizeof
glflags
PU_name
name
strlen
name
esb_destructor
break
case
DW_AT_name
case
DW_AT_GNU_template_name
char
atnamebuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
templatenamestr
if
fc
DW_FORM_CLASS_STRING
remark_wrong_string_format
attr
theform
fc
esb_destructor
esb_destructor
return
DW_DLV_NO_ENTRY
esb_constructor_fixed
atnamebuf
sizeof
atnamebuf
tres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
value
for
DW_AT_name
DW_AT_GNU_template_name
tres
err
esb_destructor
esb_destructor
return
tres
if
fc
DW_FORM_CLASS_STRING
remark_wrong_string_format
attr
theform
fc
esb_destructor
esb_destructor
return
DW_DLV_NO_ENTRY
esb_empty_string
esb_append
esb_get_string
esb_destructor
if
glflags
gf_check_names
checking_this_compiler
int
local_show_form
FALSE
int
local_verbose
struct
esb_s
lesb
const
char
name
esb_constructor
tres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
local_show_form
local_verbose
err
Look
for
specific
name
forms
attempting
to
notice
and
report
odd
identifiers
if
tres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
check_names
value
for
DW_AT_name
DW_AT_GNU_template_name
tres
err
esb_destructor
esb_destructor
esb_destructor
return
tres
name
esb_get_string
DWARF_CHECK_COUNT
names_result
if
strcmp
null
name
DWARF_CHECK_ERROR
names_result
string
attribute
is
null
else
if
dot_ok_in_identifier
tag
name
glflags
need_CU_name
strchr
name
This
is
a
suggestion
there
might
be
a
surprising
name
not
a
guarantee
of
an
error
DWARF_CHECK_ERROR
names_result
string
attribute
is
invalid
esb_destructor
If
we
are
in
checking
mode
and
we
do
not
have
a
PU
name
if
glflags
gf_check_locations
glflags
gf_check_ranges
glflags
seen_PU
glflags
PU_name
int
local_show_form
FALSE
int
local_verbose
const
char
name
struct
esb_s
lesb
int
vres
esb_constructor
vres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
local_show_form
local_verbose
err
if
vres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
check
locations
value
for
DW_AT_name
DW_AT_GNU_template_name
vres
err
esb_destructor
esb_destructor
esb_destructor
return
vres
name
esb_get_string
safe_strcpy
glflags
PU_name
sizeof
glflags
PU_name
name
strlen
name
esb_destructor
If
we
are
processing
the
compile
unit
record
the
name
if
glflags
seen_CU
glflags
need_CU_name
Lets
not
get
the
form
name
included
struct
esb_s
lesb
int
local_show_form_used
FALSE
int
local_verbose
int
sres
esb_constructor
sres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
local_show_form_used
local_verbose
err
if
sres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
CU
name
for
DW_AT_name
DW_AT_GNU_template_name
sres
err
esb_destructor
esb_destructor
esb_destructor
return
sres
safe_strcpy
glflags
CU_name
sizeof
glflags
CU_name
esb_get_string
esb_string_len
glflags
need_CU_name
FALSE
esb_destructor
break
case
DW_AT_linkage_name
case
DW_AT_comp_dir
case
DW_AT_producer
struct
esb_s
lesb
int
pres
if
fc
DW_FORM_CLASS_STRING
remark_wrong_string_format
attr
theform
fc
esb_destructor
esb_destructor
return
DW_DLV_NO_ENTRY
esb_constructor
pres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
pres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
value
for
DW_AT_producer
pres
err
esb_destructor
esb_destructor
esb_destructor
return
pres
if
fc
DW_FORM_CLASS_STRING
remark_wrong_string_format
attr
theform
fc
esb_destructor
esb_destructor
esb_destructor
return
DW_DLV_NO_ENTRY
esb_empty_string
esb_append
esb_get_string
esb_destructor
If
we
are
in
checking
mode
identify
the
compiler
if
attr
DW_AT_producer
glflags
gf_do_check_dwarf
glflags
gf_search_is_on
Do
not
use
show
form
here
We
just
want
the
producer
name
not
the
form
name
int
show_form_local
FALSE
int
local_verbose
struct
esb_s
local_e
esb_constructor
pres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
show_form_local
local_verbose
err
if
pres
DW_DLV_ERROR
print_error_and_continue
dbg
Cannot
get
checking
value
for
DW_AT_producer
pres
err
esb_destructor
esb_destructor
esb_destructor
return
pres
Check
if
this
compiler
version
is
a
target
update_compiler_target
esb_get_string
esb_destructor
break
When
dealing
with
SNC
linkonce
symbols
the
low_pc
and
high_pc
are
associated
with
a
specific
symbol
SNC
always
generate
a
name
with
DW_AT_MIPS_linkage_name
GCC
does
not
instead
gcc
generates
DW_AT_abstract_origin
or
DW_AT_specification
in
that
case
we
have
to
traverse
this
attribute
in
order
to
get
the
name
for
the
linkonce
case
DW_AT_specification
case
DW_AT_abstract_origin
case
DW_AT_type
char
typebuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
lesb
esb_constructor_fixed
typebuf
sizeof
typebuf
tres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
tres
DW_DLV_ERROR
struct
esb_s
m
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_constructor
esb_append
Cannot
get
get
value
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
tres
err
esb_destructor
esb_destructor
esb_destructor
return
tres
if
theform
DW_FORM_ref_sig8
res
print_sig8_target
dbg
attrib
die_indent_level
srcfiles
srcfiles_cnt
err
if
res
DW_DLV_ERROR
esb_destructor
return
res
esb_empty_string
esb_append
esb_get_string
esb_destructor
if
glflags
gf_check_forward_decl
glflags
gf_check_self_references
glflags
gf_search_is_on
Dwarf_Off
die_goff
Dwarf_Off
ref_goff
int
frres
int
suppress_check
frres
dwarf_global_formref
attrib
err
if
frres
DW_DLV_ERROR
int
myerr
dwarf_errno
err
if
myerr
DW_DLE_REF_SIG8_NOT_HANDLED
DW_DLE_REF_SIG8_NOT_HANDLED
No
offset
available
it
makes
little
sense
to
delve
into
this
sort
of
reference
unless
we
think
a
graph
of
self
refs
across
type
units
is
possible
Hmm
FIXME?
suppress_check
DWARF_CHECK_COUNT
self_references_result
DWARF_CHECK_ERROR
self_references_result
DW_AT_ref_sig8
not
handled
so
self
references
not
fully
checked
DROP_ERROR_INSTANCE
dbg
frres
err
else
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
struct
esb_s
m
esb_constructor
esb_append
Cannot
get
formref
global
offset
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
frres
err
esb_destructor
esb_destructor
esb_destructor
return
frres
else
if
frres
DW_DLV_NO_ENTRY
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
struct
esb_s
m
esb_constructor
esb_append
Cannot
get
formref
global
offset
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
frres
err
esb_destructor
esb_destructor
esb_destructor
return
frres
frres
dwarf_dieoffset
die
err
if
frres
DW_DLV_OK
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
struct
esb_s
m
esb_constructor
esb_append
Cannot
get
formref
dieoffset
offset
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
frres
err
esb_destructor
esb_destructor
esb_destructor
return
frres
if
suppress_check
glflags
gf_check_self_references
form_refers_local_info
theform
Dwarf_Die
ref_die
int
ifres
ResetBucketGroup
glflags
pVisitedInfo
AddEntryIntoBucketGroup
glflags
pVisitedInfo
die_goff
NULL
FALSE
Follow
reference
chain
looking
for
self
references
frres
dwarf_offdie_b
dbg
ref_goff
is_info
err
if
frres
DW_DLV_OK
Dwarf_Off
ref_die_cu_goff
Dwarf_Off
die_loff
CU
relative
int
fresb
if
dump_visited_info
fresb
dwarf_die_CU_offset
die
err
if
fresb
DW_DLV_OK
do_dump_visited_info
die_indent_level
die_loff
die_goff
dieprint_cu_goffset
atname
esb_get_string
else
esb_destructor
esb_destructor
return
fresb
die_indent_level
fresb
dwarf_CU_dieoffset_given_die
ref_die
err
Check
above
call
return
status?
FIXME
if
fresb
DW_DLV_OK
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
struct
esb_s
m
esb_constructor
esb_append
Cannot
get
CU
dieoffset
given
die
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
frres
err
esb_destructor
esb_destructor
esb_destructor
return
frres
ifres
traverse_one_die
dbg
attrib
ref_die
ref_die_cu_goff
is_info
srcfiles
srcfiles_cnt
die_indent_level
err
dwarf_dealloc_die
ref_die
ref_die
die_indent_level
if
ifres
DW_DLV_OK
esb_destructor
esb_destructor
return
ifres
DeleteKeyInBucketGroup
glflags
pVisitedInfo
die_goff
if
frres
DW_DLV_ERROR
esb_destructor
esb_destructor
return
frres
if
suppress_check
glflags
gf_check_forward_decl
if
attr
DW_AT_specification
Check
the
DW_AT_specification
does
not
make
forward
references
to
DIEs
DWARF4
specifications
section
but
really
they
are
legal
this
test
is
probably
wrong
DWARF_CHECK_COUNT
forward_decl_result
if
ref_goff
die_goff
DWARF_CHECK_ERROR2
forward_decl_result
Invalid
forward
reference
to
DIE
esb_get_string
When
doing
search
if
the
attribute
is
DW_AT_specification
or
DW_AT_abstract_origin
get
any
name
associated
with
the
DIE
referenced
in
the
offset
The
more
typical
cases
are
Member
functions
where
DIES
are
generated
DIE
for
the
declaration
and
DIE
for
the
definition
and
connected
via
the
DW_AT_specification
Inlined
functions
where
DIES
are
generated
DIE
for
the
concrete
instance
and
DIE
for
the
abstract
instance
and
connected
via
the
DW_AT_abstract_origin
if
glflags
gf_search_is_on
attr
DW_AT_specification
attr
DW_AT_abstract_origin
Dwarf_Die
ref_die
int
srcres
Follow
reference
chain
looking
for
the
DIE
name
srcres
dwarf_offdie_b
dbg
ref_goff
is_info
err
if
srcres
DW_DLV_OK
Get
the
DIE
name
char
name
srcres
dwarf_diename
ref_die
err
if
srcres
DW_DLV_OK
esb_empty_string
esb_append
name
if
srcres
DW_DLV_ERROR
glflags
gf_count_major_errors
esb_empty_string
esb_append
ERROR
no
name
for
reference
DROP_ERROR_INSTANCE
dbg
srcres
err
Release
the
allocated
DIE
dwarf_dealloc_die
ref_die
else
if
srcres
DW_DLV_ERROR
glflags
gf_count_major_errors
esb_empty_string
esb_append
ERROR
no
referred
to
die
found
DROP_ERROR_INSTANCE
dbg
srcres
err
If
we
are
in
checking
mode
and
we
do
not
have
a
PU
name
if
glflags
gf_check_locations
glflags
gf_check_ranges
glflags
seen_PU
glflags
PU_name
if
tag
DW_TAG_subprogram
This
gets
the
DW_AT_name
if
this
DIE
has
one
Dwarf_Addr
low_pc
struct
esb_s
pn
int
found
The
cu_die_for_print_frames
will
not
be
changed
by
get_proc_name_by_die
Used
when
printing
frames
Dwarf_Die
cu_die_for_print_frames
esb_constructor
Only
looks
in
this
one
DIE
s
attributes
found
get_proc_name_by_die
dbg
die
low_pc
pcMap
err
if
found
DW_DLV_ERROR
struct
esb_s
m
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_constructor
esb_append
Cannot
get
get
value
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
found
err
esb_destructor
return
found
if
found
DW_DLV_OK
safe_strcpy
glflags
PU_name
sizeof
glflags
PU_name
esb_get_string
esb_string_len
esb_destructor
break
default
char
ebuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
lesb
int
dres
esb_constructor_fixed
ebuf
sizeof
ebuf
dres
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
srcfiles_cnt
glflags
show_form_used
glflags
verbose
err
if
dres
DW_DLV_ERROR
struct
esb_s
m
const
char
n
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_constructor
esb_append
Cannot
get
get
value
for
a
esb_append
n
print_error_and_continue
dbg
esb_get_string
dres
err
esb_destructor
esb_destructor
esb_destructor
return
dres
esb_empty_string
esb_append
esb_get_string
esb_destructor
break
end
switch
statment
on
attribute
code
res
value
above
no
longer
relevant
if
print_else_name_match
if
have_a_search_match
esb_get_string
atname
Count
occurrence
of
text
glflags
search_occurrences
if
glflags
gf_search_wide_format
found_search_attr
TRUE
else
PRINT_CU_INFO
bTextFound
TRUE
if
DEBUGGING
ONLY
This
prints
all
the
actual
fields
as
well
as
the
macro
results
that
use
the
fields
printf
DEBUGONLY
std
print?
attr
name
u
u
u
u
u
u
u
n
unsigned
PRINTING_UNIQUE
unsigned
PRINTING_DIES
unsigned
print_else_name_match
unsigned
bTextFound
unsigned
glflags
gf_do_print_dwarf
unsigned
glflags
gf_check_verbose_mode
unsigned
glflags
gf_record_dwarf_error
endif
DEBUGGING
ONLY
Above
we
created
detailed
messages
in
the
valname
and
esb_extra
strings
If
we
re
just
printing
everything
we
will
now
print
those
Otherwise
If
we
re
checking
things
we
will
print
those
that
failed
a
check
a
DWARF_CHECK
message
was
just
printed
Otherwise
if
searching
for
specific
attributes
the
else_name_match
of
the
following
if
stmt
a
match
means
we
print
the
strings
Otherwise
we
will
just
discard
the
valname
and
esb_extra
strings
That
s
why
the
big
IF
below
has
so
much
in
it
if
PRINTING_UNIQUE
PRINTING_DIES
print_else_name_match
bTextFound
Print
just
the
Tags
and
Attributes
if
glflags
gf_display_offsets
printf
n
atname
else
if
glflags
dense
char
v
v
esb_get_string
printf
s
s
atname
sanitized
v
if
append_extra_string
v
esb_get_string
printf
s
sanitized
v
else
char
v
printf
atname
if
strlen
atname
printf
v
esb_get_string
printf
s
n
sanitized
v
if
append_extra_string
v
esb_get_string
printf
s
sanitized
v
esb_destructor
esb_destructor
attr_duplication
found_search_attr
return
DW_DLV_OK
static
void
alloc_skip_branch_array
Dwarf_Half
no_of_ops
struct
OpBranchHead_s
op_branch_checking
op_branch_checking
opcount
op_branch_checking
ops_array
if
no_of_ops
return
op_branch_checking
ops_array
struct
OpBranchEntry_s
calloc
no_of_ops
sizeof
struct
OpBranchEntry_s
if
op_branch_checking
ops_array
return
op_branch_checking
opcount
no_of_ops
static
Dwarf_Bool
skip_branch_target_ok
struct
OpBranchHead_s
op_branch_checking
Dwarf_Half
index
struct
OpBranchEntry_s
ein
Dwarf_Half
i
struct
OpBranchEntry_s
ec
if
ein
target_offset
ein
offset
Infinite
loop
return
FALSE
else
if
ein
target_offset
ein
offset
ec
op_branch_checking
ops_array
for
i
index
i
ec
if
ec
offset
ein
target_offset
return
TRUE
return
FALSE
i
index
ec
op_branch_checking
ops_array
i
for
i
op_branch_checking
opcount
i
ec
if
ec
offset
ein
target_offset
return
TRUE
return
FALSE
static
void
check_skip_branch_offsets
struct
OpBranchHead_s
op_branch_checking
struct
esb_s
str
Dwarf_Half
i
Dwarf_Half
high
op_branch_checking
opcount
struct
OpBranchEntry_s
e
op_branch_checking
ops_array
for
i
high
i
e
char
opname
DW_OP_skip
if
e
op
DW_OP_bra
e
op
DW_OP_skip
continue
if
e
op
DW_OP_bra
opname
DW_OP_bra
if
skip_branch_target_ok
op_branch_checking
i
e
continue
Oops
An
error
The
skip
or
branch
target
is
wrong
Corrupt
dwarf
esb_append_printf_s
str
nERROR
The
operation
s
opname
esb_append_printf_u
str
at
expression
block
offset
e
offset
esb_append_printf_u
str
has
target
of
which
is
not
a
valid
expression
offset
in
this
expression
block
n
e
target_offset
glflags
gf_count_major_errors
static
void
dealloc_skip_branch_array
struct
OpBranchHead_s
op_branch_checking
if
op_branch_checking
opcount
free
op_branch_checking
ops_array
op_branch_checking
ops_array
op_branch_checking
opcount
static
Dwarf_Bool
op_is_skip_or_branch
Dwarf_Debug
dbg
Dwarf_Locdesc_c
exprc
int
index
Dwarf_Error
err
Dwarf_Small
op
Dwarf_Unsigned
opd1
Dwarf_Unsigned
opd2
Dwarf_Unsigned
opd3
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
raw3
Dwarf_Unsigned
offsetforbranch
int
res
res
dwarf_get_location_op_value_d
exprc
index
err
if
res
DW_DLV_OK
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
err
return
FALSE
if
op
DW_OP_bra
return
TRUE
if
op
DW_OP_skip
return
TRUE
return
FALSE
int
dwarfdump_print_location_operations
Dwarf_Debug
dbg
Dwarf_Die
die
int
die_indent_level
Dwarf_Locdesc_c
locdesc
for
interface
Dwarf_Unsigned
llent
UNUSEDARG
Which
desc
we
have
Dwarf_Unsigned
entrycount
Dwarf_Small
lkind
int
no_ending_newlines
UNUSEDARG
Dwarf_Addr
baseaddr
struct
esb_s
string_out
Dwarf_Error
err
Dwarf_Half
no_of_ops
unsigned
i
Dwarf_Bool
report_raw
TRUE
Dwarf_Bool
has_skip_or_branch
FALSE
struct
OpBranchHead_s
op_branch_checking
alloc_skip_branch_array
ASSERT
locs
NULL
no_of_ops
entrycount
possibly_increase_esb_alloc
string_out
no_of_ops
if
no_of_ops
for
i
i
no_of_ops
i
if
op_is_skip_or_branch
dbg
locdesc
i
err
has_skip_or_branch
TRUE
break
if
has_skip_or_branch
alloc_skip_branch_array
no_of_ops
for
i
i
no_of_ops
i
int
res
res
_dwarf_print_one_expr_op
dbg
die
lkind
die_indent_level
locdesc
i
has_skip_or_branch
report_raw
baseaddr
string_out
err
if
res
DW_DLV_ERROR
dealloc_skip_branch_array
return
res
if
has_skip_or_branch
check_skip_branch_offsets
string_out
dealloc_skip_branch_array
return
DW_DLV_OK
static
int
op_has_no_operands
Dwarf_Small
op
return
dwarf_opscounttab
op
oc_opcount
static
void
show_contents
struct
esb_s
string_out
unsigned
int
length
const
unsigned
char
bp
unsigned
int
i
if
length
return
esb_append
string_out
contents
for
i
length
i
bp
Do
not
use
DW_PR_DUx
here
the
value
bp
is
a
const
unsigned
char
esb_append_printf_u
string_out
bp
int
_dwarf_print_one_expr_op
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Small
lkind
UNUSEDARG
int
die_indent_level
Dwarf_Locdesc_c
exprc
int
index
Dwarf_Bool
has_skip_or_branch
struct
OpBranchHead_s
oparray
Dwarf_Bool
report_raw
Dwarf_Addr
baseaddr
UNUSEDARG
struct
esb_s
string_out
Dwarf_Error
err
Dwarf_Small
op
Dwarf_Unsigned
opd1
Dwarf_Unsigned
opd2
Dwarf_Unsigned
opd3
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
raw3
Dwarf_Unsigned
offsetforbranch
const
char
op_name
int
indentprespaces
int
indentpostspaces
Dwarf_Bool
showblockoffsets
FALSE
struct
OpBranchEntry_s
echecking
if
glflags
dense
glflags
gf_expr_ops_joined
indentprespaces
standard_indent
indentpostspaces
esb_append
string_out
n
append_indent_prefix
string_out
indentprespaces
die_indent_level
indentpostspaces
else
if
index
esb_append
string_out
DWARF
and
DWARF5
style
int
res
res
dwarf_get_location_op_value_d
exprc
index
err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_get_location_op_value_c
did
not
get
a
value
res
err
return
res
if
report_raw
opd1
raw1
opd2
raw2
opd3
raw3
op_name
get_OP_name
op
pd_dwarf_names_print_on_error
if
has_skip_or_branch
glflags
verbose
showblockoffsets
TRUE
if
showblockoffsets
New
January
showing
offsets
relevant
to
DW_OP_bra
and
DW_OP_skip
offsetforbranch
comes
from
a
bit
field
so
is
never
large
esb_append_printf_u
string_out
blkoff
DW_PR_DUx
offsetforbranch
if
oparray
oparray
opcount
index
oparray
opcount
echecking
oparray
ops_array
index
echecking
op
op
echecking
offset
offsetforbranch
esb_append
string_out
op_name
if
op_has_no_operands
op
Nothing
to
add
else
if
op
DW_OP_breg0
op
DW_OP_breg31
esb_append_printf_i
string_out
DW_PR_DSd
opd1
else
switch
op
case
DW_OP_addr
bracket_hex
opd1
string_out
break
case
DW_OP_const1s
case
DW_OP_const2s
case
DW_OP_const4s
case
DW_OP_const8s
case
DW_OP_consts
case
DW_OP_fbreg
esb_append
string_out
formx_signed
opd1
string_out
if
FIX
Turn
on
later
if
opd1
esb_append_printf_u
string_out
DW_PR_XZEROS
DW_PR_DUx
opd1
endif
break
case
DW_OP_skip
case
DW_OP_bra
esb_append
string_out
formx_signed
opd1
string_out
if
showblockoffsets
Dwarf_Signed
targ
Dwarf_Signed
opd1
offsetforbranch
is
the
op
offset
and
we
need
the
the
value
past
the
bytes
in
the
DW_OP
Dwarf_Signed
off
offsetforbranch
off
off
targ
if
off
esb_append_printf_i
string_out
ERROR
branch
skip
target
erronous
d
off
glflags
gf_count_major_errors
else
esb_append_printf_u
string_out
target
op
DW_PR_DUx
Dwarf_Unsigned
off
if
echecking
echecking
target_offset
off
break
case
DW_OP_GNU_addr_index
unsigned
val
case
DW_OP_addrx
DWARF5
unsigned
val
case
DW_OP_GNU_const_index
case
DW_OP_constx
DWARF5
unsigned
val
case
DW_OP_const1u
case
DW_OP_const2u
case
DW_OP_const4u
case
DW_OP_const8u
case
DW_OP_constu
case
DW_OP_pick
case
DW_OP_plus_uconst
case
DW_OP_regx
case
DW_OP_piece
case
DW_OP_deref_size
case
DW_OP_xderef_size
esb_append_printf_u
string_out
DW_PR_DUu
opd1
if
FIX
Turn
on
later
if
opd1
esb_append_printf_u
string_out
DW_PR_XZEROS
DW_PR_DUx
opd1
endif
break
case
DW_OP_bregx
bracket_hex
opd1
string_out
esb_append
string_out
formx_signed
opd2
string_out
break
case
DW_OP_call2
bracket_hex
opd1
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
NO_SPECIFIC_TAG
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_call4
bracket_hex
opd1
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
NO_SPECIFIC_TAG
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_call_ref
bracket_hex
opd1
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
NO_SPECIFIC_TAG
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_bit_piece
bracket_hex
opd1
string_out
bracket_hex
offset
opd2
string_out
break
case
DW_OP_implicit_value
define
IMPLICIT_VALUE_PRINT_MAX
unsigned
int
print_len
bracket_hex
opd1
string_out
The
other
operand
is
a
block
of
opd1
bytes
FIXME
print_len
opd1
if
print_len
IMPLICIT_VALUE_PRINT_MAX
print_len
IMPLICIT_VALUE_PRINT_MAX
undef
IMPLICIT_VALUE_PRINT_MAX
const
unsigned
char
bp
This
is
a
really
ugly
cast
a
way
to
implement
DW_OP_implicit
value
in
this
libdwarf
context
bp
const
unsigned
char
uintptr_t
opd2
show_contents
string_out
print_len
bp
break
We
do
not
know
what
the
operands
if
any
are
case
DW_OP_HP_unknown
case
DW_OP_HP_is_value
case
DW_OP_HP_fltconst4
case
DW_OP_HP_fltconst8
case
DW_OP_HP_mod_range
case
DW_OP_HP_unmod_range
case
DW_OP_HP_tls
case
DW_OP_INTEL_bit_piece
break
case
DW_OP_stack_value
DWARF4
break
case
DW_OP_GNU_uninit
DW_OP_APPLE_uninit
No
operands
break
case
DW_OP_GNU_encoded_addr
bracket_hex
opd1
string_out
break
case
DW_OP_GNU_variable_value
bracket_hex
opd1
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
NO_SPECIFIC_TAG
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_implicit_pointer
DWARF5
case
DW_OP_GNU_implicit_pointer
opd1
is
a
section
offset
not
a
CU
offset
We
don
t
know
if
DW_OP_GNU_implicit_pointer
allows
a
zero
offset
meaning
generic
type
but
GNU
C
x
google
prerelease
generates
zero
in
DWARF4
DWARF5
does
not
allow
zero
bracket_hex
opd1
string_out
esb_append
string_out
formx_signed
opd2
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
NO_SPECIFIC_TAG
op
DW_OP_implicit_pointer?
ZERO_OFFSET_GENERIC_TYPE
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_entry_value
DWARF5
case
DW_OP_GNU_entry_value
const
unsigned
char
bp
unsigned
int
length
length
opd1
bracket_hex
opd1
string_out
bp
Dwarf_Small
uintptr_t
opd2
if
bp
esb_append
string_out
ERROR
Null
databyte
pointer
DW_OP_entry_value
else
show_contents
string_out
length
bp
break
case
DW_OP_const_type
DWARF5
case
DW_OP_GNU_const_type
const
unsigned
char
bp
unsigned
int
length
opd1
is
cu
relative
offset
of
type
DIE
we
have
a
die
in
the
relevant
CU
in
the
arg
list
bracket_hex
opd1
string_out
length
opd2
esb_append
string_out
const
length
esb_append_printf_u
string_out
u
length
Now
point
to
the
data
bytes
of
the
const
bp
Dwarf_Small
uintptr_t
opd3
if
bp
esb_append
string_out
ERROR
Null
databyte
pointer
DW_OP_const_type
else
show_contents
string_out
length
bp
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
DW_TAG_base_type
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd1
string_out
break
case
DW_OP_regval_type
DWARF5
case
DW_OP_GNU_regval_type
esb_append_printf_u
string_out
DW_PR_DUx
opd1
bracket_hex
opd2
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
DW_TAG_base_type
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd2
string_out
break
case
DW_OP_xderef_type
DWARF5
case
DW_OP_deref_type
DWARF5
case
DW_OP_GNU_deref_type
esb_append_printf_u
string_out
DW_PR_DUx
opd1
bracket_hex
opd2
string_out
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
DW_TAG_base_type
NON_ZERO_OFFSET_REQUIRED
WITHIN_CU
opd2
string_out
break
case
DW_OP_convert
DWARF5
case
DW_OP_GNU_convert
case
DW_OP_reinterpret
DWARF5
case
DW_OP_GNU_reinterpret
For
following
case
unsure
if
non
zero
opd2
is
required
or
not
Assume
not
case
DW_OP_GNU_parameter_ref
esb_append_printf_u
string_out
DW_PR_DUx
opd1
check_die_expr_op_basic_data
dbg
die
op_name
indentprespaces
die_indent_level
indentpostspaces
DW_TAG_base_type
ZERO_OFFSET_GENERIC_TYPE
WITHIN_CU
opd2
string_out
break
default
esb_append_printf_u
string_out
DWARF
DW_OP_
unknown
x
unsigned
op
break
return
DW_DLV_OK
void
loc_error_check
const
char
tagname
const
char
attrname
Dwarf_Addr
lopcfinal
Dwarf_Addr
rawlopc
Dwarf_Addr
hipcfinal
Dwarf_Addr
rawhipc
Dwarf_Unsigned
offset
Dwarf_Addr
base_address
Dwarf_Bool
bError
DWARF_CHECK_COUNT
locations_result
Check
the
low_pc
and
high_pc
are
within
a
valid
range
in
the
text
section
if
IsValidInBucketGroup
glflags
pRangesInfo
lopcfinal
IsValidInBucketGroup
glflags
pRangesInfo
hipcfinal
Valid
values
do
nothing
else
At
this
point
may
be
we
are
dealing
with
a
linkonce
symbol
if
IsValidInLinkonce
glflags
pLinkonceInfo
glflags
PU_name
lopcfinal
hipcfinal
Valid
values
do
nothing
else
struct
esb_s
m
esb_constructor
bError
TRUE
esb_append_printf_s
debug_loc
lists
Address
outside
a
valid
text
range
TAG
s
tagname
esb_append_printf_s
with
attribute
s
attrname
DWARF_CHECK_ERROR
locations_result
esb_get_string
if
glflags
gf_check_verbose_mode
PRINTING_UNIQUE
printf
Offset
DW_PR_XZEROS
DW_PR_DUx
Base
DW_PR_XZEROS
DW_PR_DUx
Low
DW_PR_XZEROS
DW_PR_DUx
rawlow
DW_PR_XZEROS
DW_PR_DUx
High
DW_PR_XZEROS
DW_PR_DUx
rawhigh
DW_PR_XZEROS
DW_PR_DUx
n
offset
base_address
lopcfinal
rawlopc
hipcfinal
rawhipc
esb_destructor
static
void
print_loclists_context_head
Dwarf_Small
lkind
Dwarf_Unsigned
lle_count
Dwarf_Unsigned
lle_version
Dwarf_Unsigned
loclists_index
Dwarf_Unsigned
bytes_total_in_lle
Dwarf_Half
offset_size
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Unsigned
overall_offset_of_this_context
Dwarf_Unsigned
total_length_of_this_context
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
Dwarf_Bool
loclists_base_present
Dwarf_Addr
loclists_base
Dwarf_Bool
loclists_base_address_present
Dwarf_Addr
loclists_base_address
Dwarf_Bool
loclists_debug_addr_base_present
Dwarf_Addr
loclists_debug_addr_base
Dwarf_Unsigned
loclists_offset_lle_set
struct
esb_s
esbp
append_local_prefix
esbp
esb_append_printf_u
esbp
bytes
total
this
loclist
bytes_total_in_lle
append_local_prefix
esbp
esb_append_printf_u
esbp
number
of
entries
lle_count
append_local_prefix
esbp
esb_append_printf_u
esbp
context
number
loclists_index
append_local_prefix
esbp
esb_append_printf_u
esbp
version
lle_version
append_local_prefix
esbp
esb_append_printf_u
esbp
address
size
address_size
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
size
offset_size
if
segment_selector_size
append_local_prefix
esbp
esb_append_printf_u
esbp
segment
selector
size
segment_selector_size
if
lkind
DW_LKIND_loclists
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
of
context
DW_PR_XZEROS
DW_PR_DUx
overall_offset_of_this_context
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
table
entrycount
offset_table_entrycount
if
offset_table_entrycount
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
table
offset
DW_PR_XZEROS
DW_PR_DUx
offset_table_offset
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
of
this
list
set
DW_PR_XZEROS
DW_PR_DUx
loclists_offset_lle_set
append_local_prefix
esbp
esb_append_printf_u
esbp
length
of
context
total_length_of_this_context
append_local_prefix
esbp
esb_append_printf_u
esbp
end
of
context
offset
DW_PR_XZEROS
DW_PR_DUx
overall_offset_of_this_context
total_length_of_this_context
if
loclists_base_present
append_local_prefix
esbp
esb_append_printf_u
esbp
DW_AT_loclists_base
DW_PR_XZEROS
DW_PR_DUx
loclists_base
if
loclists_base_address_present
append_local_prefix
esbp
esb_append_printf_u
esbp
DW_AT_low_pc
base
addr
DW_PR_XZEROS
DW_PR_DUx
loclists_base_address
if
loclists_debug_addr_base_present
append_local_prefix
esbp
esb_append_printf_u
esbp
DW_AT_addr_base
DW_PR_XZEROS
DW_PR_DUx
loclists_debug_addr_base
esb_append
esbp
n
Fill
buffer
with
location
lists
data
for
printing
This
does
the
details
It
s
up
to
the
caller
to
determine
which
esb
to
put
the
result
in
ARGSUSED
static
int
print_location_list
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attr
Dwarf_Bool
checking
int
die_indent_level
int
no_end_newline
struct
esb_s
details
Dwarf_Error
llerr
Dwarf_Unsigned
no_of_elements
Dwarf_Loc_Head_c
loclist_head
loclist
interface
int
lres
unsigned
int
llent
Base
address
used
to
update
entries
in
debug_loc
CU_base_address
is
a
global
Terrible
way
to
pass
in
this
value
FIXME
See
also
CU_low_address
as
base
address
is
special
for
address
ranges
Dwarf_Addr
base_address
glflags
CU_base_address
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Bool
bError
FALSE
Dwarf_Small
lle_value
DWARF5
Dwarf_Unsigned
lle_count
Dwarf_Unsigned
loclists_index
This
is
the
section
offset
of
the
expression
not
the
location
description
prefix
Dwarf_Unsigned
expr_section_offset
Dwarf_Half
address_size
Dwarf_Half
segment_selector_size
Dwarf_Addr
max_address
Dwarf_Unsigned
lle_version
Dwarf_Half
version
Dwarf_Half
offset_size
Dwarf_Small
lkind
DW_LKIND_unknown
Dwarf_Unsigned
bytes_total_in_lle
Dwarf_Unsigned
overall_offset_of_this_context
Dwarf_Unsigned
total_length_of_this_context
Dwarf_Bool
loclists_base_present
FALSE
Dwarf_Unsigned
loclists_base
Dwarf_Bool
loclists_base_address_present
FALSE
Dwarf_Unsigned
loclists_base_address
Dwarf_Bool
loclists_debug_addr_base_present
FALSE
Dwarf_Unsigned
loclists_debug_addr_base
Dwarf_Unsigned
loclists_offset_lle_set
Dwarf_Unsigned
offset_table_offset
Dwarf_Unsigned
offset_table_entrycount
struct
esb_s
section_truename
lres
dwarf_get_version_of_die
die
if
lres
DW_DLV_OK
is
DW_DLV_ERROR
see
libdwarf
query
c
simple_err_only_return_action
lres
nERROR
die
or
context
bad
calling
dwarf_get_version_of_die
in
print_location_list
Something
is
very
wrong
return
DW_DLV_NO_ENTRY
lres
get_address_size_and_max
dbg
llerr
if
lres
DW_DLV_OK
print_error_and_continue
dbg
Getting
address
size
and
maximum
failed
while
getting
location
list
lres
llerr
return
lres
Preferred
interface
Deals
with
DWARF2
lres
dwarf_get_loclist_c
attr
llerr
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
dwarf_get_loclist_c
fails
lres
llerr
return
lres
else
if
lres
DW_DLV_NO_ENTRY
return
lres
lres
dwarf_get_loclist_head_basics
loclist_head
llerr
if
lres
DW_DLV_OK
return
lres
version
lle_version
append_local_prefix
esbp
No
here
the
newline
grates
causes
blank
line
in
the
output
So
Just
add
spaces
the
output
already
has
a
newline
if
lkind
DW_LKIND_expression
esb_append
details
esb_constructor
if
lkind
DW_LKIND_loclists
get_true_section_name
dbg
debug_loclists
FALSE
else
get_true_section_name
dbg
debug_loc
FALSE
esb_append_printf_s
details
esb_get_string
esb_append_printf_u
details
offset
DW_PR_XZEROS
DW_PR_DUx
loclists_offset_lle_set
esb_destructor
if
glflags
verbose
print_loclists_context_head
lkind
lle_count
lle_version
loclists_index
bytes_total_in_lle
offset_size
address_size
segment_selector_size
overall_offset_of_this_context
total_length_of_this_context
offset_table_offset
offset_table_entrycount
loclists_base_present
loclists_base
loclists_base_address_present
loclists_base_address
loclists_debug_addr_base_present
loclists_debug_addr_base
loclists_offset_lle_set
details
else
things
look
better
with
this
no
v
esb_append
details
n
possibly_increase_esb_alloc
details
no_of_elements
for
llent
llent
no_of_elements
llent
Dwarf_Unsigned
locdesc_offset
Dwarf_Locdesc_c
locentry
Dwarf_Unsigned
rawlowpc
Dwarf_Unsigned
rawhipc
Dwarf_Unsigned
ulocentry_count
Dwarf_Bool
debug_addr_unavailable
FALSE
This
has
values
DW_LKIND
the
same
values
that
were
in
loclist
source
in
but
with
the
new
value
of
DW_LKIND_loclists
for
DWARF5
See
libdwarf
h
Dwarf_Small
loclist_source
int
no_ending_newline
FALSE
lres
dwarf_get_locdesc_entry_d
loclist_head
llent
llerr
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
dwarf_get_locdesc_entry_c
fails
lres
llerr
return
lres
else
if
lres
DW_DLV_NO_ENTRY
return
lres
if
loclist_source
DW_LKIND_expression
lle_value
DW_LLE_start_end
printf
ERROR
With
DW_LKIND_expression
lle_value
should
be
DW_LLE_start_end
not
u
n
lle_value
glflags
gf_count_major_errors
If
we
have
a
location
list
refering
to
the
debug_loc
Check
for
specific
compiler
we
are
validating
if
glflags
gf_check_locations
glflags
in_valid_code
loclist_source
checking_this_compiler
checking
TRUE
if
glflags
dense
loclist_source
DW_LKIND_expression
if
llent
These
messages
go
with
the
list
of
entries
switch
loclist_source
case
DW_LKIND_loclist
esb_append_printf_u
details
loclist
at
offset
DW_PR_XZEROS
DW_PR_DUx
loclists_offset_lle_set
esb_append_printf_i
details
with
ld
entries
follows
no_of_elements
break
case
DW_LKIND_GNU_exp_list
esb_append_printf_u
details
dwo
loclist
at
offset
DW_PR_XZEROS
DW_PR_DUx
loclists_offset_lle_set
esb_append_printf_i
details
with
ld
entries
follows
no_of_elements
break
case
DW_LKIND_loclists
esb_append_printf_u
details
debug_loclists
offset
DW_PR_XZEROS
DW_PR_DUx
loclists_offset_lle_set
esb_append_printf_i
details
with
ld
entries
follows
no_of_elements
break
esb_append_printf_i
details
n
llent
else
no_ending_newline
TRUE
When
dwarf_debug_addr_index_to_addr
fails
it
is
probably
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
because
no
TIED
file
supplied
but
we
don
t
distinguish
that
from
other
errors
here
We
use
DW_LLE
names
for
DW_LKIND_loclist
and
DW_LKIND_loclists
We
use
LLEX
names
for
DW_LKIND_GNU_exp_list
if
loclist_source
Dwarf_Half
tag
Dwarf_Half
attrnum
const
char
tagname
const
char
attrname
int
res
res
dwarf_tag
die
llerr
if
res
DW_DLV_OK
return
res
res
dwarf_whatattr
attr
llerr
if
res
DW_DLV_OK
return
res
attrname
get_AT_name
attrnum
FALSE
tagname
get_TAG_name
tag
FALSE
if
loclist_source
DW_LKIND_GNU_exp_list
print_llex_linecodes
dbg
checking
tagname
attrname
llent
lle_value
base_address
rawlowpc
rawhipc
debug_addr_unavailable
lopc
hipc
locdesc_offset
details
else
if
loclist_source
DW_LKIND_loclist
print_original_loclist_linecodes
dbg
checking
tagname
attrname
llent
lle_value
base_address
rawlowpc
rawhipc
debug_addr_unavailable
lopc
hipc
locdesc_offset
details
else
loclist_source
DW_LKIND_loclists
print_debug_loclists_linecodes
dbg
checking
tagname
attrname
llent
lle_value
base_address
rawlowpc
rawhipc
debug_addr_unavailable
lopc
hipc
locdesc_offset
details
lres
dwarfdump_print_location_operations
dbg
die
die_indent_level
Either
llbuf
or
locentry
non
zero
Not
both
locentry
llent
Which
loc
desc
this
is
ulocentry_count
How
many
ops
in
this
loc
desc
loclist_source
no_ending_newline
base_address
details
llerr
if
lres
DW_DLV_ERROR
return
lres
if
no_end_newline
if
bError
glflags
gf_check_verbose_mode
PRINTING_UNIQUE
esb_append
details
n
else
if
glflags
gf_do_print_dwarf
esb_append
details
n
dwarf_loc_head_c_dealloc
loclist_head
return
DW_DLV_OK
New
October
The
decimal
representation
here
is
questionable
static
void
formx_data16
Dwarf_Form_Data16
u
struct
esb_s
esbp
Dwarf_Bool
hex_format
unsigned
i
for
i
sizeof
Dwarf_Form_Data16
i
esb_append
esbp
if
hex_format
esb_append_printf_u
esbp
u
fd_data
i
else
esb_append_printf_i
esbp
u
fd_data
i
static
void
formx_unsigned
Dwarf_Unsigned
u
struct
esb_s
esbp
Dwarf_Bool
hex_format
if
hex_format
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
u
else
esb_append_printf_u
esbp
DW_PR_DUu
u
static
void
formx_signed
Dwarf_Signed
s
struct
esb_s
esbp
esb_append_printf_i
esbp
DW_PR_DSd
s
static
void
formx_unsigned_and_signed_if_neg
Dwarf_Unsigned
tempud
Dwarf_Signed
tempd
const
char
leader
Dwarf_Bool
hex_format
struct
esb_s
esbp
formx_unsigned
tempud
esbp
hex_format
if
tempd
esb_append
esbp
leader
formx_signed
tempd
esbp
esb_append
esbp
If
the
DIE
DW_AT_type
exists
and
is
directly
known
signed
unsigned
return
for
signed
for
unsigned
Otherwise
return
meaning
no
information
So
we
only
need
to
a
messy
lookup
once
per
type
die
offset
static
int
check_for_type_unsigned
Dwarf_Debug
dbg
Dwarf_Die
die
struct
esb_s
esbp
UNUSEDARG
Dwarf_Bool
is_info
struct
Helpertree_Base_s
helperbase
struct
Helpertree_Map_Entry_s
e
int
res
Dwarf_Attribute
attr
Dwarf_Attribute
encodingattr
Dwarf_Error
error
Dwarf_Unsigned
diegoffset
Dwarf_Unsigned
typedieoffset
Dwarf_Die
typedie
Dwarf_Unsigned
tempud
int
show_form_here
FALSE
int
retval
if
die
return
is_info
dwarf_get_die_infotypes_flag
die
if
is_info
helperbase
else
helperbase
res
dwarf_dieoffset
die
if
res
DW_DLV_ERROR
esb_append
esbp
helper
dieoffset
FAIL
return
else
if
res
DW_DLV_NO_ENTRY
We
don
t
know
sign
esb_append
esbp
helper
dieoffset
NO
ENTRY
return
This
might
be
wrong
See
the
typedieoffset
check
below
which
is
correct
e
helpertree_find
diegoffset
helperbase
if
e
bracket_hex
helper
FOUND
offset
diegoffset
esbp
bracket_hex
helper
FOUND
val
e
hm_val
esbp
return
e
hm_val
We
look
up
the
DW_AT_type
die
if
any
and
use
that
offset
to
check
for
signedness
res
dwarf_attr
die
DW_AT_type
if
res
DW_DLV_ERROR
bracket_hex
helper
dwarf_attr
FAIL
diegoffset
esbp
helpertree_add_entry
diegoffset
helperbase
return
else
if
res
DW_DLV_NO_ENTRY
We
don
t
know
sign
bracket_hex
helper
dwarf_attr
no
entry
diegoffset
esbp
helpertree_add_entry
diegoffset
helperbase
return
res
dwarf_global_formref
attr
if
res
DW_DLV_ERROR
bracket_hex
helper
global_formreff
FAIL
diegoffset
esbp
dwarf_dealloc_attribute
attr
helpertree_add_entry
diegoffset
helperbase
return
else
if
res
DW_DLV_NO_ENTRY
esb_append
esbp
helper
NO
ENTRY
FAIL
bracket_hex
helper
global_formreff
NO
ENTRY
diegoffset
esbp
dwarf_dealloc_attribute
attr
helpertree_add_entry
diegoffset
helperbase
return
dwarf_dealloc_attribute
attr
attr
e
helpertree_find
typedieoffset
helperbase
if
e
bracket_hex
helper
FOUND
typedieoffset
typedieoffset
esbp
bracket_hex
helper
FOUND
val
e
hm_val
esbp
return
e
hm_val
res
dwarf_offdie_b
dbg
typedieoffset
is_info
if
res
DW_DLV_ERROR
bracket_hex
helper
dwarf_offdie_b
FAIL
diegoffset
esbp
helpertree_add_entry
diegoffset
helperbase
helpertree_add_entry
typedieoffset
helperbase
return
else
if
res
DW_DLV_NO_ENTRY
bracket_hex
helper
dwarf_offdie_b
NO
ENTRY
diegoffset
esbp
helpertree_add_entry
diegoffset
helperbase
helpertree_add_entry
typedieoffset
helperbase
return
res
dwarf_attr
typedie
DW_AT_encoding
if
res
DW_DLV_ERROR
bracket_hex
helper
dwarf_attr
typedie
FAIL
diegoffset
esbp
dwarf_dealloc_die
typedie
helpertree_add_entry
diegoffset
helperbase
helpertree_add_entry
typedieoffset
helperbase
return
else
if
res
DW_DLV_NO_ENTRY
bracket_hex
helper
dwarf_attr
typedie
NO
ENTRY
diegoffset
esbp
dwarf_dealloc_die
typedie
helpertree_add_entry
diegoffset
helperbase
helpertree_add_entry
typedieoffset
helperbase
return
res
dd_get_integer_and_name
dbg
encodingattr
attrname
const
char
NULL
err_string
struct
esb_s
NULL
encoding_type_func
show_form_here
if
res
DW_DLV_OK
DROP_ERROR_INSTANCE
dbg
res
error
bracket_hex
helper
small
encoding
FAIL
diegoffset
esbp
dealloc
attr
first
then
die
dwarf_dealloc_attribute
encodingattr
dwarf_dealloc_die
typedie
helpertree_add_entry
diegoffset
helperbase
helpertree_add_entry
typedieoffset
helperbase
return
if
tempud
DW_ATE_signed
tempud
DW_ATE_signed_char
esb_append
esbp
helper
small
encoding
SIGNED
retval
else
if
tempud
DW_ATE_unsigned
tempud
DW_ATE_unsigned_char
retval
bracket_hex
helper
ENTERED
die
diegoffset
esbp
bracket_hex
helper
ENTERED
typedie
typedieoffset
esbp
helpertree_add_entry
diegoffset
retval
helperbase
helpertree_add_entry
typedieoffset
retval
helperbase
dealloc
attr
first
then
die
dwarf_dealloc_attribute
encodingattr
dwarf_dealloc_die
typedie
return
retval
We
think
this
is
an
integer
Figure
out
how
to
print
it
In
case
the
signedness
is
ambiguous
such
as
on
DW_FORM_data1
ie
unknown
signedness
print
two
ways
If
we
were
to
look
at
DW_AT_type
in
the
base
DIE
we
could
follow
it
and
determine
if
the
type
was
unsigned
or
signed
usually
easily
and
use
that
information
static
int
formxdata_print_value
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attrib
Dwarf_Half
theform
struct
esb_s
esbp
Dwarf_Error
pverr
Dwarf_Bool
hex_format
Dwarf_Signed
tempsd
Dwarf_Unsigned
tempud
int
sres
int
ures
if
theform
DW_FORM_data16
Dwarf_Form_Data16
v16
ures
dwarf_formdata16
attrib
pverr
if
ures
DW_DLV_OK
formx_data16
esbp
hex_format
return
DW_DLV_OK
else
if
ures
DW_DLV_NO_ENTRY
impossible
return
ures
else
return
ures
ures
dwarf_formudata
attrib
pverr
if
ures
DW_DLV_OK
sres
dwarf_formsdata
attrib
pverr
if
sres
DW_DLV_OK
if
tempud
Dwarf_Unsigned
tempsd
tempsd
Data
is
the
same
value
and
not
negative
so
makes
no
difference
which
we
print
formx_unsigned
tempud
esbp
hex_format
return
DW_DLV_OK
else
Here
we
don
t
know
if
signed
or
not
and
Assuming
one
or
the
other
changes
the
interpretation
of
the
bits
int
helpertree_unsigned
helpertree_unsigned
check_for_type_unsigned
dbg
die
esbp
if
die
helpertree_unsigned
Signedness
unclear
formx_unsigned_and_signed_if_neg
tempud
tempsd
hex_format
esbp
return
DW_DLV_OK
else
if
helpertree_unsigned
formx_unsigned
tempud
esbp
hex_format
return
DW_DLV_OK
else
Value
signed
formx_signed
tempsd
esbp
return
DW_DLV_OK
else
if
sres
DW_DLV_NO_ENTRY
formx_unsigned
tempud
esbp
hex_format
return
DW_DLV_OK
else
DW_DLV_ERROR
formx_unsigned
tempud
esbp
hex_format
DROP_ERROR_INSTANCE
dbg
sres
pverr
return
DW_DLV_OK
else
if
ures
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
ures
pverr
sres
dwarf_formsdata
attrib
pverr
if
sres
DW_DLV_OK
formx_signed
tempsd
esbp
return
sres
else
if
sres
DW_DLV_ERROR
esb_append_printf_u
esbp
ERROR
form
x
theform
esb_append
esbp
get_FORM_name
theform
FALSE
esb_append
esbp
not
readable
signed
or
unsigned
simple_err_only_return_action
sres
esb_get_string
esbp
Neither
worked
return
DW_DLV_ERROR
NO_ENTRY
is
crazy
impossible
return
DW_DLV_NO_ENTRY
static
void
bracket_hex
const
char
s1
Dwarf_Unsigned
v
const
char
s2
struct
esb_s
esbp
Dwarf_Bool
hex_format
TRUE
esb_append
esbp
s1
formx_unsigned
v
esbp
hex_format
esb_append
esbp
s2
Borrow
the
definition
from
pro_encode_nm
h
Bytes
needed
to
encode
a
number
Not
a
tight
bound
just
a
reasonable
bound
ifndef
ENCODE_SPACE_NEEDED
define
ENCODE_SPACE_NEEDED
sizeof
Dwarf_Unsigned
endif
ENCODE_SPACE_NEEDED
Table
indexed
by
the
attribute
value
only
standard
attributes
are
included
ie
in
the
range
DW_AT_lo_user
we
waste
a
little
bit
of
space
but
accessing
the
table
is
fast
typedef
struct
attr_encoding
Dwarf_Unsigned
entries
Attribute
occurrences
Dwarf_Unsigned
formx
Space
used
by
current
encoding
Dwarf_Unsigned
leb128
Space
used
with
LEB128
encoding
a_attr_encoding
The
other
DW_FORM_datan
are
lower
form
values
than
data16
so
the
following
is
safe
for
the
unchanging
static
table
static
int
attributes_encoding_factor
DW_FORM_data16
These
must
be
reset
for
each
object
if
we
are
processing
an
archive
see
print_attributes_encoding
static
a_attr_encoding
attributes_encoding_table
NULL
static
Dwarf_Bool
attributes_encoding_do_init
TRUE
Check
the
potential
amount
of
space
wasted
by
attributes
values
that
can
be
represented
as
an
unsigned
LEB128
Only
attributes
with
forms
DW_FORM_data1
DW_FORM_data2
DW_FORM_data4
and
DW_FORM_data
are
checked
static
void
check_attributes_encoding
Dwarf_Half
attr
Dwarf_Half
theform
Dwarf_Unsigned
value
if
attributes_encoding_do_init
Create
table
on
first
call
attributes_encoding_table
a_attr_encoding
calloc
DW_AT_lo_user
sizeof
a_attr_encoding
We
use
only
slots
in
the
table
for
quick
access
index
attributes_encoding_factor
DW_FORM_data1
index
attributes_encoding_factor
DW_FORM_data2
index
attributes_encoding_factor
DW_FORM_data4
index
attributes_encoding_factor
DW_FORM_data8
index
index
attributes_encoding_factor
DW_FORM_data16
attributes_encoding_do_init
FALSE
Regardless
of
the
encoding
form
count
the
checks
DWARF_CHECK_COUNT
attr_encoding_result
For
DW_AT_stmt_list
due
to
the
way
is
generated
the
value
can
be
unknown
at
compile
time
and
only
the
assembler
can
decide
how
to
represent
the
offset
ignore
this
attribute
if
DW_AT_stmt_list
attr
DW_AT_macros
attr
DW_AT_GNU_macros
attr
if
theform
DW_FORM_addr
struct
esb_s
lesb
esb_constructor
esb_append_printf_s
Attribute
s
has
form
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_append_printf_s
s
An
error
get_FORM_name
theform
pd_dwarf_names_print_on_error
DWARF_CHECK_ERROR
attr_encoding_result
esb_get_string
esb_destructor
return
Only
checks
those
attributes
that
have
DW_FORM_dataX
DW_FORM_data1
DW_FORM_data2
DW_FORM_data4
and
DW_FORM_data8
DWARF5
adds
DW_FORM_data16
but
we
ignore
data16
here
as
it
makes
no
sense
as
a
uleb
if
theform
DW_FORM_data1
theform
DW_FORM_data2
theform
DW_FORM_data4
theform
DW_FORM_data8
int
res
Size
of
the
byte
stream
buffer
that
needs
to
be
memcpy
ed
int
leb128_size
To
encode
the
attribute
value
char
encode_buffer
ENCODE_SPACE_NEEDED
res
dwarf_encode_leb128
value
encode_buffer
sizeof
encode_buffer
if
res
DW_DLV_OK
if
attributes_encoding_factor
theform
leb128_size
int
wasted_bytes
attributes_encoding_factor
theform
leb128_size
struct
esb_s
lesb
esb_constructor
esb_append_printf_i
DW_PR_DSd
wasted
byte
s
wasted_bytes
DWARF_CHECK_ERROR2
attr_encoding_result
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_get_string
esb_destructor
Add
the
optimized
size
to
the
specific
attribute
only
if
we
are
dealing
with
a
standard
attribute
if
attr
DW_AT_lo_user
attributes_encoding_table
attr
entries
attributes_encoding_table
attr
formx
attributes_encoding_factor
theform
attributes_encoding_table
attr
leb128
leb128_size
ignoring
error
it
should
be
impossible
Print
a
detailed
encoding
usage
per
attribute
kE
int
print_attributes_encoding
Dwarf_Debug
dbg
Dwarf_Error
attr_error
if
attributes_encoding_table
Dwarf_Bool
print_header
TRUE
Dwarf_Unsigned
total_entries
Dwarf_Unsigned
total_bytes_formx
Dwarf_Unsigned
total_bytes_leb128
Dwarf_Unsigned
entries
Dwarf_Unsigned
bytes_formx
Dwarf_Unsigned
bytes_leb128
int
index
int
count
float
saved_rate
for
index
index
DW_AT_lo_user
index
if
attributes_encoding_table
index
leb128
if
print_header
printf
n
SPACE
USED
BY
ATTRIBUTE
ENCODINGS
n
printf
Nro
Attribute
Name
Entries
Data_x
leb128
Rate
n
print_header
FALSE
entries
attributes_encoding_table
index
entries
bytes_formx
attributes_encoding_table
index
formx
bytes_leb128
attributes_encoding_table
index
leb128
total_entries
entries
total_bytes_formx
bytes_formx
total_bytes_leb128
bytes_leb128
saved_rate
bytes_leb128
bytes_formx
printf
DW_PR_XZEROS
DW_PR_DUu
Entries
DW_PR_XZEROS
DW_PR_DUu
FORMx
DW_PR_XZEROS
DW_PR_DUu
LEB128
n
count
get_AT_name
index
pd_dwarf_names_print_on_error
entries
bytes_formx
bytes_leb128
saved_rate
if
print_header
At
least
we
have
an
entry
print
summary
and
percentage
Dwarf_Addr
lower
Dwarf_Unsigned
size
int
infoerr
saved_rate
total_bytes_leb128
total_bytes_formx
printf
Summary
DW_PR_XZEROS
DW_PR_DUu
Entries
DW_PR_XZEROS
DW_PR_DUu
FORMx
DW_PR_XZEROS
DW_PR_DUu
LEB128
n
total_entries
total_bytes_formx
total_bytes_leb128
saved_rate
Get
debug_info
size
Very
unlikely
to
have
an
error
here
infoerr
dwarf_get_section_info_by_name
dbg
debug_info
attr_error
if
infoerr
DW_DLV_ERROR
free
attributes_encoding_table
attributes_encoding_table
attributes_encoding_do_init
TRUE
return
infoerr
saved_rate
total_bytes_formx
total_bytes_leb128
size
if
saved_rate
printf
n
debug_info
size
can
be
reduced
by
n
saved_rate
free
attributes_encoding_table
attributes_encoding_table
attributes_encoding_do_init
TRUE
return
DW_DLV_OK
static
void
check_decl_file_only
char
srcfiles
Dwarf_Unsigned
fileindex
Dwarf_Signed
srcfiles_cnt
Dwarf_Half
dwversion
int
attr
Zero
is
always
a
legal
index
for
DWARF2
and
it
means
no
source
name
provided
For
DWARF
we
ve
determined
that
the
standard
is
wrong
and
zero
meaning
none
just
does
not
work
File
numbers
must
start
from
zero
See
the
dwarfstd
org
wiki
DWARF_CHECK_COUNT
decl_file_result
if
dwversion
DWVERSION5
if
fileindex
Dwarf_Unsigned
srcfiles_cnt
struct
esb_s
msgb
esb_constructor
if
srcfiles
esb_append
There
is
a
file
number
esb_append_printf_u
DW_PR_DUu
fileindex
esb_append
but
no
source
files
Extra
space
char
here
to
avoid
pointless
regression
test
issues
with
older
versions
esb_append
are
known
else
esb_append
Does
not
index
to
valid
DWARF5
file
name
esb_append
filenum
esb_append_printf_u
DW_PR_DUu
fileindex
esb_append
arraysize
esb_append_printf_i
DW_PR_DSd
srcfiles_cnt
esb_append
DWARF_CHECK_ERROR2
decl_file_result
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_get_string
esb_destructor
return
zero
means
no
file
applicable
if
fileindex
fileindex
Dwarf_Unsigned
srcfiles_cnt
struct
esb_s
msgb
esb_constructor
if
srcfiles
esb_append
There
is
a
file
number
esb_append_printf_u
DW_PR_DUu
fileindex
esb_append
but
no
source
files
Extra
space
char
here
to
avoid
pointless
regression
test
issues
with
older
versions
esb_append
are
known
else
esb_append
Does
not
index
to
valid
file
name
esb_append
filenum
esb_append_printf_u
DW_PR_DUu
fileindex
esb_append
arraysize
esb_append_printf_i
DW_PR_DSd
srcfiles_cnt
esb_append
DWARF_CHECK_ERROR2
decl_file_result
get_AT_name
attr
pd_dwarf_names_print_on_error
esb_get_string
esb_destructor
static
int
expand_rnglist_entries
Dwarf_Die
die
UNUSEDARG
Dwarf_Rnglists_Head
rnglhead
Dwarf_Unsigned
rnglentriescount
Dwarf_Unsigned
rnglglobal_offset
struct
esb_s
esbp
int
show_form
UNUSEDARG
int
local_verbose
Dwarf_Error
err
Dwarf_Unsigned
count
Dwarf_Unsigned
i
int
res
Dwarf_Unsigned
secoffset
rnglglobal_offset
Dwarf_Bool
no_debug_addr_available
FALSE
count
rnglentriescount
if
local_verbose
esb_append
esbp
n
secoff
for
i
count
i
unsigned
entrylen
unsigned
rle_code
Dwarf_Unsigned
raw1
Dwarf_Unsigned
raw2
Dwarf_Unsigned
cooked1
Dwarf_Unsigned
cooked2
res
dwarf_get_rnglists_entry_fields_a
rnglhead
i
err
if
res
DW_DLV_OK
return
res
if
local_verbose
no_debug_addr_available
const
char
codename
unknown
code
dwarf_get_RLE_name
rle_code
esb_append
esbp
n
esb_append_printf_u
esbp
i
esb_append_printf_s
esbp
codename
if
rle_code
DW_RLE_end_of_list
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
raw1
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
raw2
else
esb_append
esbp
if
local_verbose
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
secoffset
if
no_debug_addr_available
esb_append
esbp
no
debug_addr
available
if
no_debug_addr_available
const
char
codename
start
end
esb_append
esbp
n
esb_append_printf_u
esbp
i
if
rle_code
DW_RLE_base_addressx
rle_code
DW_RLE_base_address
codename
base
address
else
if
rle_code
DW_RLE_end_of_list
codename
end
of
list
esb_append_printf_s
esbp
codename
if
rle_code
DW_RLE_end_of_list
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
cooked1
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
cooked2
else
esb_append
esbp
if
local_verbose
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
secoffset
secoffset
entrylen
esb_append
esbp
n
return
DW_DLV_OK
DWARF5
debug_rnglists
dwo
only
static
int
handle_rnglists
Dwarf_Die
die
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Unsigned
attrval
Dwarf_Unsigned
output_rle_set_offset
struct
esb_s
esbp
int
show_form
int
local_verbose
Dwarf_Error
err
This
is
DWARF5
by
definition
Not
earlier
Dwarf_Unsigned
global_offset_of_rle_set
Dwarf_Unsigned
count_rnglists_entries
Dwarf_Rnglists_Head
rnglhead
int
res
res
dwarf_rnglists_get_rle_head
attrib
theform
attrval
index
val
or
offset
depending
on
form
err
if
res
DW_DLV_OK
return
res
output_rle_set_offset
global_offset_of_rle_set
Here
we
put
newline
at
start
of
each
line
of
output
different
from
the
usual
practice
append_local_prefix
esbp
esb_append_printf_u
esbp
Offset
of
rnglists
entries
DW_PR_XZEROS
DW_PR_DUx
global_offset_of_rle_set
if
local_verbose
Dwarf_Unsigned
version
Dwarf_Unsigned
context_index
Dwarf_Unsigned
rle_count
Dwarf_Unsigned
total_bytes_in_rle
Dwarf_Half
loffset_size
Dwarf_Half
laddress_size
Dwarf_Half
lsegment_selector_size
Dwarf_Unsigned
section_offset_of_context
Dwarf_Unsigned
length_of_context
Dwarf_Bool
rnglists_base_present
Dwarf_Unsigned
rnglists_base
Dwarf_Bool
rnglists_base_address_present
Dwarf_Unsigned
rnglists_base_address
Dwarf_Bool
debug_addr_base_present
Dwarf_Unsigned
debug_addr_base
Dwarf_Unsigned
offsets_table_offset
Dwarf_Unsigned
offsets_table_entrycount
res
dwarf_get_rnglist_head_basics
rnglhead
err
if
res
DW_DLV_OK
dwarf_dealloc_rnglists_head
rnglhead
return
res
append_local_prefix
esbp
esb_append_printf_u
esbp
Index
of
rnglist
head
u
context_index
append_local_prefix
esbp
esb_append_printf_u
esbp
rnglist
head
version
u
version
append_local_prefix
esbp
esb_append_printf_u
esbp
Record
count
rnglist
set
u
rle_count
append_local_prefix
esbp
esb_append_printf_u
esbp
Bytes
this
rnglist
set
u
total_bytes_in_rle
append_local_prefix
esbp
esb_append_printf_u
esbp
offset
size
u
loffset_size
append_local_prefix
esbp
esb_append_printf_u
esbp
address
size
u
laddress_size
if
rnglists_base_present
append_local_prefix
esbp
esb_append_printf_u
esbp
CU
DW_AT_rnglists_base
DW_PR_XZEROS
DW_PR_DUx
rnglists_base
if
rnglists_base_address_present
append_local_prefix
esbp
esb_append_printf_u
esbp
CU
DW_AT_low_pc
baseaddr
DW_PR_XZEROS
DW_PR_DUx
rnglists_base_address
if
debug_addr_base_present
append_local_prefix
esbp
esb_append_printf_u
esbp
CU
DW_AT_addr_base
DW_PR_XZEROS
DW_PR_DUx
debug_addr_base
append_local_prefix
esbp
esb_append_printf_u
esbp
section
offset
CU
rnglists
DW_PR_XZEROS
DW_PR_DUx
section_offset_of_context
append_local_prefix
esbp
esb_append_printf_u
esbp
section
length
CU
rnglists
DW_PR_XZEROS
DW_PR_DUx
length_of_context
esb_append_printf_u
esbp
u
length_of_context
res
expand_rnglist_entries
die
rnglhead
count_rnglists_entries
global_offset_of_rle_set
esbp
show_form
local_verbose
err
dwarf_dealloc_rnglists_head
rnglhead
return
res
This
detects
a
special
case
attr
form
compiler
mistake
because
we
have
one
in
the
regression
tests
A
more
general
approach
would
be
better
February
static
void
check_sensible_addr_for_form
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Error
e
Dwarf_Half
attrnum
int
res
res
dwarf_whatattr
attrib
if
res
DW_DLV_OK
switch
attrnum
default
return
case
DW_AT_stmt_list
case
DW_AT_macros
case
DW_AT_GNU_macros
struct
esb_s
m
esb_constructor
esb_append_printf_s
Attribute
s
has
form
get_AT_name
attrnum
FALSE
esb_append
get_FORM_name
theform
FALSE
esb_append
which
is
improper
DWARF
Attempting
to
continue
glflags
gf_count_major_errors
printf
ERROR
WARNING
s
n
esb_get_string
esb_destructor
return
Something
crazy
Will
be
noted
elsewhere
if
res
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
res
e
return
Fill
buffer
with
attribute
value
We
pass
in
tag
so
we
can
try
to
do
the
right
thing
with
broken
compiler
DW_TAG_enumerator
cnt
is
signed
for
historical
reasons
a
mistake
in
an
interface
but
the
value
is
never
negative
We
append
to
esbp
s
buffer
int
get_attr_value
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Die
die
int
die_indent_level
UNUSEDARG
Dwarf_Off
dieprint_cu_goffset
Dwarf_Attribute
attrib
char
srcfiles
Dwarf_Signed
srcfiles_cnt
struct
esb_s
esbp
int
show_form
int
local_verbose
Dwarf_Error
err
Dwarf_Half
theform
char
temps
Dwarf_Block
tempb
Dwarf_Signed
tempsd
Dwarf_Unsigned
tempud
Dwarf_Off
off
Dwarf_Die
die_for_check
Dwarf_Half
tag_for_check
Dwarf_Addr
addr
int
fres
int
bres
int
wres
int
dres
Dwarf_Half
direct_form
Dwarf_Bool
is_info
TRUE
struct
esb_s
esb_expr
int
esb_expr_alive
FALSE
is_info
dwarf_get_die_infotypes_flag
die
Dwarf_whatform
gets
the
real
form
DW_FORM_indir
is
never
returned
instead
the
real
form
following
DW_FORM_indir
is
returned
fres
dwarf_whatform
attrib
err
Depending
on
the
form
and
the
attribute
process
the
form
if
fres
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_whatform
cannot
Find
Attr
Form
fres
err
return
fres
else
if
fres
DW_DLV_NO_ENTRY
return
fres
dwarf_whatform_direct
gets
the
direct
form
so
if
the
form
is
DW_FORM_indir
that
is
what
is
returned
fres
dwarf_whatform_direct
attrib
err
DROP_ERROR_INSTANCE
dbg
fres
err
Ignore
errors
in
dwarf_whatform_direct
switch
theform
case
DW_FORM_GNU_addr_index
case
DW_FORM_addrx
case
DW_FORM_addrx1
DWARF5
case
DW_FORM_addrx2
DWARF5
case
DW_FORM_addrx3
DWARF5
case
DW_FORM_addrx4
DWARF5
case
DW_FORM_addr
check_sensible_addr_for_form
dbg
attrib
theform
bres
dwarf_formaddr
attrib
err
if
bres
DW_DLV_OK
if
dwarf_addr_form_is_indexed
theform
Dwarf_Unsigned
index
int
res
dwarf_get_debug_addr_index
attrib
err
if
res
DW_DLV_OK
struct
esb_s
lstr
esb_constructor
esb_append
ERROR
getting
debug
addr
index
on
form
esb_append
get_FORM_name
theform
FALSE
esb_append
missing
index?
print_error_and_continue
dbg
esb_get_string
res
err
esb_destructor
return
res
bracket_hex
addr_index
index
esbp
bracket_hex
addr
esbp
else
if
bres
DW_DLV_ERROR
if
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
dwarf_errno
err
Dwarf_Unsigned
index
int
res
DROP_ERROR_INSTANCE
dbg
bres
err
glflags
gf_debug_addr_missing
res
dwarf_get_debug_addr_index
attrib
err
if
res
DW_DLV_OK
struct
esb_s
lstr
esb_constructor
esb_append
get_FORM_name
theform
FALSE
esb_append
missing
index
print_error_and_continue
dbg
esb_get_string
res
err
esb_destructor
return
res
addr
bracket_hex
addr_index
index
no
debug_addr
section
esbp
This
is
normal
in
a
dwo
DWP
file
The
debug_addr
is
in
a
o
and
in
the
final
executable
else
Some
bad
error
struct
esb_s
lstr
esb_constructor
esb_append
get_FORM_name
theform
FALSE
esb_append
form
with
no
addr
print_error_and_continue
dbg
esb_get_string
bres
err
esb_destructor
if
glflags
gf_error_code_search_by_address
glflags
gf_error_code_search_by_address
dwarf_errno
err
return
bres
else
DW_DLV_NO_ENTRY
struct
esb_s
lstr
esb_constructor
esb_append
get_FORM_name
theform
FALSE
esb_append
is
a
DW_DLV_NO_ENTRY?
something
is
wrong
print_error_and_continue
dbg
esb_get_string
bres
err
esb_destructor
return
bres
break
case
DW_FORM_ref_addr
Dwarf_Half
attr
DW_FORM_ref_addr
is
not
accessed
thru
formref
it
is
an
address
global
section
offset
in
the
debug_info
section
bres
dwarf_global_formref
attrib
err
if
bres
DW_DLV_OK
bracket_hex
GOFF
off
esbp
else
print_error_and_continue
dbg
DW_FORM_ref_addr
form
with
no
reference?
Something
is
corrupted
bres
err
return
bres
wres
dwarf_whatattr
attrib
err
if
wres
DW_DLV_OK
print_error_and_continue
dbg
DW_FORM_ref_addr
no
attribute
number?
Something
is
corrupted
wres
err
return
wres
if
attr
DW_AT_sibling
The
value
had
better
be
inside
the
current
CU
else
there
is
a
nasty
error
here
as
a
sibling
has
to
be
in
the
same
CU
it
seems
The
target
offset
off
had
better
be
following
the
die
s
global
offset
else
we
have
a
serious
botch
this
FORM
defines
the
value
as
a
debug_info
global
offset
Dwarf_Off
cuoff
Dwarf_Off
culen
Dwarf_Off
die_overall_offset
int
res
int
ores
dwarf_dieoffset
die
err
if
ores
DW_DLV_OK
print_error_and_continue
dbg
dwarf_dieoffsetnot
available
for
DW_AT_sibling
Something
is
corrupted
ores
err
return
ores
if
die_stack_indent_level
DIE_STACK_SIZE
report_die_stack_error
dbg
err
return
DW_DLV_ERROR
SET_DIE_STACK_SIBLING
off
if
die_overall_offset
off
struct
esb_s
msg
esb_constructor
esb_append_printf_u
ERROR
Sibling
DW_FORM_ref_offset
DW_PR_XZEROS
DW_PR_DUx
off
esb_append_printf_s
points
s
die
Global
offset
die_overall_offset
off
at
before
esb_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
die_overall_offset
simple_err_only_return_action
DW_DLV_ERROR
esb_get_string
esb_destructor
DWARF_CHECK_COUNT
tag_tree_result
res
dwarf_die_CU_offset_range
die
err
if
res
DW_DLV_OK
DWARF_CHECK_ERROR
tag_tree_result
DW_AT_sibling
DW_FORM_ref_addr
offset
range
of
the
CU
is
not
available
DROP_ERROR_INSTANCE
dbg
res
err
else
Dwarf_Off
cuend
cuoff
culen
if
off
cuoff
off
cuend
DWARF_CHECK_ERROR
tag_tree_result
DW_AT_sibling
DW_FORM_ref_addr
offset
points
outside
of
current
CU
break
case
DW_FORM_ref1
case
DW_FORM_ref2
case
DW_FORM_ref4
case
DW_FORM_ref8
case
DW_FORM_ref_udata
int
refres
Dwarf_Half
attr
Dwarf_Off
goff
Global
offset
CU
relative
offset
returned
refres
dwarf_formref
attrib
err
if
refres
DW_DLV_OK
struct
esb_s
msg
esb_constructor
Report
incorrect
offset
esb_append_printf_s
reference
form
on
attr
s
has
no
valid
cu_relative
offset?
get_AT_name
attr
FALSE
esb_append_printf_u
for
offset
DW_PR_XZEROS
DW_PR_DUx
off
print_error_and_continue
dbg
esb_get_string
refres
err
esb_destructor
return
refres
refres
dwarf_whatattr
attrib
err
if
refres
DW_DLV_OK
struct
esb_s
lstr
esb_constructor
esb_append
get_AT_name
attr
FALSE
esb_append
is
an
attribute
with
no
number?
Impossible
print_error_and_continue
dbg
esb_get_string
refres
err
esb_destructor
return
refres
Convert
the
local
offset
off
into
a
global
section
offset
goff
refres
dwarf_convert_to_global_offset
attrib
off
err
if
refres
DW_DLV_OK
Report
incorrect
offset
struct
esb_s
msg
esb_constructor
esb_append_printf_u
invalid
offset
off
DW_PR_XZEROS
DW_PR_DUx
off
esb_append
attr
esb_append
get_AT_name
attr
FALSE
esb_append
local
offset
has
no
global
offset
print_error_and_continue
dbg
esb_get_string
refres
err
esb_destructor
return
refres
if
attr
DW_AT_sibling
The
value
had
better
be
inside
the
current
CU
else
there
is
a
nasty
error
here
as
a
sibling
has
to
be
in
the
same
CU
it
seems
The
target
offset
off
had
better
be
following
the
die
s
global
offset
else
we
have
a
serious
botch
this
FORM
defines
the
value
as
a
debug_info
global
offset
Dwarf_Off
die_overall_offset
int
ores
dwarf_dieoffset
die
err
if
ores
DW_DLV_OK
struct
esb_s
lstr
esb_constructor
esb_append
DW_AT_sibling
attr
and
DIE
has
esb_append
no
die_offset?
print_error_and_continue
dbg
esb_get_string
ores
err
esb_destructor
return
ores
SET_DIE_STACK_SIBLING
goff
if
die_overall_offset
goff
struct
esb_s
lstr
esb_constructor
esb_append
ERROR
in
DW_AT_sibling
esb_append
get_FORM_name
theform
FALSE
esb_append_printf_u
Sibling
offset
DW_PR_XZEROS
DW_PR_DUx
points
goff
esb_append
die_overall_offset
goff
at
before
esb_append_printf_u
its
own
die
GOFF
DW_PR_XZEROS
DW_PR_DUx
die_overall_offset
simple_err_only_return_action
DW_DLV_ERROR
esb_get_string
esb_destructor
At
present
no
way
to
create
a
Dwarf_Error
inside
dwarfdump
Do
references
inside
to
distinguish
them
from
constants
In
dense
form
this
results
in
Ugly
for
dense
form
but
better
than
ambiguous
davea
if
glflags
gf_show_global_offsets
bracket_hex
off
esbp
bracket_hex
GOFF
goff
esbp
else
bracket_hex
off
esbp
if
glflags
gf_check_type_offset
if
attr
DW_AT_type
form_refers_local_info
theform
dres
dwarf_offdie_b
dbg
goff
is_info
err
if
dres
DW_DLV_OK
struct
esb_s
msgc
esb_constructor
esb_append_printf_u
DW_AT_type
offset
does
not
point
to
a
DIE
for
global
offset
DW_PR_XZEROS
DW_PR_DUx
goff
esb_append_printf_u
cu
off
DW_PR_XZEROS
DW_PR_DUx
dieprint_cu_goffset
esb_append_printf_u
local
offset
DW_PR_XZEROS
DW_PR_DUx
off
esb_append_printf_u
tag
x
tag
DWARF_CHECK_ERROR
type_offset_result
esb_get_string
DROP_ERROR_INSTANCE
dbg
dres
err
esb_destructor
else
int
tres2
dwarf_tag
die_for_check
err
if
tres2
DW_DLV_OK
switch
tag_for_check
case
DW_TAG_array_type
case
DW_TAG_class_type
case
DW_TAG_enumeration_type
case
DW_TAG_pointer_type
case
DW_TAG_reference_type
case
DW_TAG_rvalue_reference_type
case
DW_TAG_restrict_type
case
DW_TAG_string_type
case
DW_TAG_structure_type
case
DW_TAG_subroutine_type
case
DW_TAG_typedef
case
DW_TAG_union_type
case
DW_TAG_ptr_to_member_type
case
DW_TAG_set_type
case
DW_TAG_subrange_type
case
DW_TAG_base_type
case
DW_TAG_const_type
case
DW_TAG_file_type
case
DW_TAG_packed_type
case
DW_TAG_thrown_type
case
DW_TAG_volatile_type
case
DW_TAG_template_type_parameter
case
DW_TAG_template_value_parameter
case
DW_TAG_unspecified_type
Template
alias
case
DW_TAG_template_alias
OK
break
default
struct
esb_s
msga
esb_constructor
esb_append_printf_u
DW_AT_type
offset
DW_PR_XZEROS
DW_PR_DUx
goff
esb_append_printf_u
does
not
point
to
Type
info
we
got
tag
x
tag_for_check
esb_append
get_TAG_name
tag_for_check
pd_dwarf_names_print_on_error
DWARF_CHECK_ERROR
type_offset_result
esb_get_string
esb_destructor
break
dwarf_dealloc_die
die_for_check
die_for_check
else
DWARF_CHECK_ERROR
type_offset_result
DW_AT_type
offset
does
not
exist
DROP_ERROR_INSTANCE
dbg
tres2
err
break
case
DW_FORM_block
case
DW_FORM_block1
case
DW_FORM_block2
case
DW_FORM_block4
case
DW_FORM_exprloc
fres
dwarf_formblock
attrib
err
if
fres
DW_DLV_OK
unsigned
u
esb_append_printf_u
esbp
len
tempb
bl_len
if
tempb
bl_len
esb_append
esbp
for
u
u
tempb
bl_len
u
esb_append_printf_u
esbp
u
unsigned
char
tempb
bl_data
if
tempb
bl_len
esb_append
esbp
dwarf_dealloc
dbg
tempb
DW_DLA_BLOCK
tempb
else
struct
esb_s
lstr
esb_constructor
esb_append
Form
form
esb_append
get_FORM_name
theform
FALSE
esb_append
cannot
get
block
print_error_and_continue
dbg
esb_get_string
fres
err
esb_destructor
return
fres
break
case
DW_FORM_data1
case
DW_FORM_data2
case
DW_FORM_data4
case
DW_FORM_data8
case
DW_FORM_data16
Dwarf_Half
attr
fres
dwarf_whatattr
attrib
err
if
fres
DW_DLV_OK
struct
esb_s
lstr
esb_constructor
esb_append
Form
esb_append
get_FORM_name
theform
FALSE
esb_append
cannot
get
attribute
print_error_and_continue
dbg
esb_get_string
fres
err
esb_destructor
return
fres
else
switch
attr
case
DW_AT_ordering
case
DW_AT_byte_size
case
DW_AT_bit_offset
case
DW_AT_bit_size
case
DW_AT_inline
case
DW_AT_language
case
DW_AT_visibility
case
DW_AT_virtuality
case
DW_AT_accessibility
case
DW_AT_address_class
case
DW_AT_calling_convention
case
DW_AT_discr_list
DWARF2
case
DW_AT_encoding
case
DW_AT_identifier_case
case
DW_AT_MIPS_loop_unroll_factor
case
DW_AT_MIPS_software_pipeline_depth
case
DW_AT_decl_column
case
DW_AT_decl_file
case
DW_AT_decl_line
case
DW_AT_call_column
case
DW_AT_call_file
case
DW_AT_call_line
case
DW_AT_start_scope
case
DW_AT_byte_stride
case
DW_AT_bit_stride
case
DW_AT_count
case
DW_AT_stmt_list
case
DW_AT_MIPS_fde
int
show_form_here
wres
dd_get_integer_and_name
dbg
attrib
attrname
const
char
NULL
err_string
struct
esb_s
NULL
encoding_type_func
err
show_form_here
if
wres
DW_DLV_OK
Dwarf_Bool
hex_format
TRUE
Dwarf_Half
dwversion
formx_unsigned
tempud
esbp
hex_format
Check
attribute
encoding
if
glflags
gf_check_attr_encoding
check_attributes_encoding
attr
theform
tempud
if
attr
DW_AT_decl_file
attr
DW_AT_call_file
turn_file_num_to_string
dbg
die
attrib
theform
dwversion
tempud
srcfiles
srcfiles_cnt
esbp
err
Validate
integrity
of
file
indices
referenced
in
debug_line
if
glflags
gf_check_decl_file
check_decl_file_only
srcfiles
tempud
srcfiles_cnt
dwversion
attr
end
decl_file
and
call_file
processing
else
not
DW_DLV_OK
on
get
small
encoding
struct
esb_s
lstr
esb_constructor
esb_append
For
form
esb_append
get_FORM_name
theform
FALSE
esb_append
and
attribute
esb_append
get_AT_name
attr
FALSE
esb_append
Cannot
get
encoding
attribute
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
case
DW_AT_const_value
Do
not
use
hexadecimal
format
Dwarf_Bool
chex
FALSE
wres
formxdata_print_value
dbg
die
attrib
theform
esbp
err
hex
format?
chex
if
wres
DW_DLV_OK
String
appended
already
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
struct
esb_s
lstr
esb_constructor
esb_append
For
form
esb_append
get_FORM_name
theform
FALSE
esb_append
and
attribute
esb_append
get_AT_name
attr
FALSE
esb_append
Cannot
get
const
value
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
case
DW_AT_GNU_dwo_id
case
DW_AT_GNU_odr_signature
case
DW_AT_dwo_id
Dwarf_Sig8
v
v
zerosig
wres
dwarf_formsig8_const
attrib
err
if
wres
DW_DLV_OK
struct
esb_s
t
esb_constructor
format_sig8_string
esb_append
esbp
esb_get_string
esb_destructor
else
if
wres
DW_DLV_NO_ENTRY
nothing?
esb_append
esbp
Impossible
no
entry
for
esb_append
esbp
get_FORM_name
theform
FALSE
esb_append
esbp
dwo_id
else
struct
esb_s
lstr
esb_constructor
esb_append
For
form
esb_append
get_FORM_name
theform
FALSE
esb_append
and
attribute
esb_append
get_AT_name
attr
FALSE
esb_append
Cannot
get
Dwarf_Sig8
value
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
case
DW_AT_upper_bound
case
DW_AT_lower_bound
default
Dwarf_Bool
chex
FALSE
Dwarf_Die
tdie
die
if
DW_AT_ranges
attr
DW_AT_location
attr
DW_AT_vtable_elem_location
attr
DW_AT_string_length
attr
DW_AT_return_addr
attr
DW_AT_use_location
attr
DW_AT_static_link
attr
DW_AT_frame_base
attr
Do
not
look
for
data
type
for
unsigned
signed
and
do
use
HEX
chex
TRUE
tdie
NULL
Do
not
use
hexadecimal
format
except
for
DW_AT_ranges
wres
formxdata_print_value
dbg
tdie
attrib
theform
esbp
err
chex
if
wres
DW_DLV_OK
String
appended
already
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
struct
esb_s
lstr
esb_constructor
esb_append
For
form
esb_append
get_FORM_name
theform
FALSE
esb_append
and
attribute
esb_append
get_AT_name
attr
FALSE
esb_append
Cannot
get
Dwarf_Sig8
value
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
if
glflags
gf_cu_name_flag
if
attr
DW_AT_MIPS_fde
if
glflags
fde_offset_for_cu_low
DW_DLV_BADOFFSET
glflags
fde_offset_for_cu_low
glflags
fde_offset_for_cu_high
tempud
else
if
tempud
glflags
fde_offset_for_cu_low
glflags
fde_offset_for_cu_low
tempud
else
if
tempud
glflags
fde_offset_for_cu_high
glflags
fde_offset_for_cu_high
tempud
break
case
DW_FORM_sdata
wres
dwarf_formsdata
attrib
err
if
wres
DW_DLV_OK
Dwarf_Bool
hxform
TRUE
tempud
tempsd
formx_unsigned_and_signed_if_neg
tempud
tempsd
hxform
esbp
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
print_error_and_continue
dbg
Cannot
get
DW_FORM_sdata
value
wres
err
return
wres
break
case
DW_FORM_udata
wres
dwarf_formudata
attrib
err
if
wres
DW_DLV_OK
Dwarf_Bool
hex_format
TRUE
formx_unsigned
tempud
esbp
hex_format
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
print_error_and_continue
dbg
Cannot
get
DW_FORM_udata
value
wres
err
return
wres
break
various
forms
for
strings
case
DW_FORM_string
case
DW_FORM_strp
case
DW_FORM_strx
DWARF5
case
DW_FORM_strx1
DWARF5
case
DW_FORM_strx2
DWARF5
case
DW_FORM_strx3
DWARF5
case
DW_FORM_strx4
DWARF5
case
DW_FORM_strp_sup
DWARF5
String
in
altrnt
tied
file
case
DW_FORM_GNU_strp_alt
String
in
altrnt
tied
file
case
DW_FORM_line_strp
DWARF5
offset
to
debug_line_str
unsigned
offset
in
size
of
an
offset
case
DW_FORM_GNU_str_index
int
sres
dwarf_formstring
attrib
err
if
sres
DW_DLV_OK
if
theform
DW_FORM_strx
theform
DW_FORM_strx1
theform
DW_FORM_strx2
theform
DW_FORM_strx3
theform
DW_FORM_strx4
theform
DW_FORM_GNU_str_index
char
saverbuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
saver
Dwarf_Unsigned
index
esb_constructor_fixed
saverbuf
sizeof
saverbuf
sres
dwarf_get_debug_str_index
attrib
err
esb_append
temps
if
sres
DW_DLV_OK
bracket_hex
indexed
string
index
esbp
else
DROP_ERROR_INSTANCE
dbg
sres
err
esb_append
esbp
ERROR
indexed
string
no
string
provided?
esb_append
esbp
esb_get_string
esb_destructor
else
esb_append
esbp
temps
else
if
sres
DW_DLV_NO_ENTRY
if
theform
DW_FORM_strx
theform
DW_FORM_GNU_str_index
theform
DW_FORM_strx1
theform
DW_FORM_strx2
theform
DW_FORM_strx3
theform
DW_FORM_strx4
esb_append
esbp
indexed
string
no
string
provided?
else
esb_append
esbp
no
string
provided?
else
DW_DLV_ERROR
if
theform
DW_FORM_strx
theform
DW_FORM_GNU_str_index
theform
DW_FORM_strx1
theform
DW_FORM_strx2
theform
DW_FORM_strx3
theform
DW_FORM_strx4
struct
esb_s
lstr
esb_constructor
esb_append
Cannot
get
an
indexed
string
on
esb_append
get_FORM_name
theform
FALSE
esb_append
print_error_and_continue
dbg
esb_get_string
sres
err
esb_destructor
return
sres
struct
esb_s
lstr
esb_constructor
esb_append
Cannot
get
the
form
on
esb_append
get_FORM_name
theform
FALSE
esb_append
print_error_and_continue
dbg
esb_get_string
sres
err
esb_destructor
return
sres
break
case
DW_FORM_flag
Dwarf_Bool
tempbool
wres
dwarf_formflag
attrib
err
if
wres
DW_DLV_OK
if
tempbool
esb_append_printf_i
esbp
yes
d
tempbool
else
esb_append
esbp
no
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
print_error_and_continue
dbg
Cannot
get
formflag
p
wres
err
return
wres
break
case
DW_FORM_indirect
We
should
not
ever
get
here
since
the
true
form
was
determined
and
direct_form
has
the
DW_FORM_indirect
if
it
is
used
here
in
this
attr
esb_append
esbp
get_FORM_name
theform
pd_dwarf_names_print_on_error
break
case
DW_FORM_sec_offset
DWARF4
DWARF5
char
emptyattrname
int
show_form_here
wres
dd_get_integer_and_name
dbg
attrib
emptyattrname
err_string
NULL
encoding_type_func
err
show_form_here
if
wres
DW_DLV_NO_ENTRY
Show
nothing?
else
if
wres
DW_DLV_ERROR
print_error_and_continue
dbg
ERROR
cannot
et
DW_FORM_sec_offset
value
content
wres
err
return
wres
else
bracket_hex
tempud
esbp
break
case
DW_FORM_flag_present
DWARF4
esb_append
esbp
yes
break
case
DW_FORM_ref_sig8
DWARF4
Dwarf_Sig8
sig8data
sig8data
zerosig
wres
dwarf_formsig8
attrib
err
if
wres
DW_DLV_OK
Show
nothing?
print_error_and_continue
dbg
ERROR
cannot
et
DW_FORM_ref_sig8
value
content
wres
err
return
wres
else
struct
esb_s
sig8str
esb_constructor
format_sig8_string
esb_append
esbp
esb_get_string
esb_destructor
if
show_form
esb_append
esbp
type
signature
break
DWARF5
attr
val
is
signed
uleb
case
DW_FORM_implicit_const
wres
dwarf_formsdata
attrib
err
if
wres
DW_DLV_OK
Dwarf_Bool
hxform
TRUE
tempud
tempsd
formx_unsigned_and_signed_if_neg
tempud
tempsd
hxform
esbp
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
print_error_and_continue
dbg
ERROR
cannot
get
signed
value
of
DW_FORM_implicit_const
wres
err
return
wres
break
case
DW_FORM_loclistx
DWARF5
index
into
debug_loclists
wres
dwarf_formudata
attrib
err
if
wres
DW_DLV_OK
Fall
through
to
end
to
show
the
form
details
Dwarf_Bool
hex_format
TRUE
esb_append
esbp
index
to
debug_loclists
formx_unsigned
tempud
esbp
hex_format
esb_append
esbp
break
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
struct
esb_s
lstr
esb_constructor
esb_append
Cannot
get
formudata
on
esb_append
DW_FORM_loclistx
esb_append
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
case
DW_FORM_rnglistx
DWARF5
index
into
debug_rnglists
Can
appear
only
on
DW_AT_ranges
attribute
wres
dwarf_formudata
attrib
err
if
wres
DW_DLV_OK
Fall
through
to
end
to
show
the
form
details
Dwarf_Bool
hex_format
TRUE
esb_append
esbp
index
to
debug_rnglists
formx_unsigned
tempud
esbp
hex_format
esb_append
esbp
else
if
wres
DW_DLV_NO_ENTRY
nothing?
else
struct
esb_s
lstr
esb_constructor
esb_append
Cannot
get
formudata
on
esb_append
DW_FORM_rnglistx
esb_append
print_error_and_continue
dbg
esb_get_string
wres
err
esb_destructor
return
wres
break
case
DW_FORM_ref_sup4
DWARF5
case
DW_FORM_ref_sup8
DWARF5
case
DW_FORM_GNU_ref_alt
bres
dwarf_global_formref
attrib
err
if
bres
DW_DLV_OK
bracket_hex
off
esbp
else
struct
esb_s
lstr
esb_constructor
esb_append
get_FORM_name
theform
FALSE
esb_append
form
with
no
reference?
print_error_and_continue
dbg
esb_get_string
bres
err
esb_destructor
return
wres
break
default
struct
esb_s
lstr
esb_constructor
esb_append_printf_u
ERROR
dwarf_whatform
unexpected
value
form
code
theform
simple_err_only_return_action
DW_DLV_ERROR
esb_get_string
esb_destructor
break
end
switch
on
theform
show_form_itself
show_form
local_verbose
theform
direct_form
esbp
if
esb_expr_alive
So
the
expr
ops
follow
the
FORM
of
the
attribute
if
indeed
FORMs
shown
esb_append
esbp
esb_get_string
esb_destructor
return
DW_DLV_OK
void
format_sig8_string
Dwarf_Sig8
data
struct
esb_s
out
unsigned
i
esb_append
out
for
i
sizeof
data
signature
i
esb_append_printf_u
out
unsigned
char
data
signature
i
static
int
get_form_values
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Attribute
attrib
Dwarf_Half
theform
Dwarf_Half
directform
Dwarf_Error
err
int
res
res
dwarf_whatform
attrib
theform
err
if
res
DW_DLV_OK
return
res
res
dwarf_whatform_direct
attrib
directform
err
return
res
static
void
show_form_itself
int
local_show_form
int
local_verbose
int
theform
int
directform
struct
esb_s
esbp
if
local_show_form
directform
directform
DW_FORM_indirect
char
form_indir
used
DW_FORM_indirect
char
form_indir2
esb_append
esbp
form_indir
if
local_verbose
esb_append_printf_i
esbp
d
DW_FORM_indirect
esb_append
esbp
form_indir2
if
local_show_form
esb_append
esbp
form
esb_append
esbp
get_FORM_name
theform
pd_dwarf_names_print_on_error
if
local_verbose
esb_append_printf_i
esbp
d
theform
esb_append
esbp
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
From
through
print_frames
relied
on
the
order
of
the
fdes
matching
the
order
of
the
functions
in
the
CUs
when
it
came
to
printing
a
function
name
with
an
FDE
This
sometimes
worked
for
SGI
IRIX
because
of
the
way
the
compiler
often
emitted
things
It
always
worked
poorly
for
gcc
and
other
compilers
As
of
the
addrmap
h
addrmap
h
code
provides
help
in
doing
a
better
job
when
the
tsearch
functions
part
of
POSIX
are
available
include
globals
h
include
print_frames
h
include
dwconf
h
include
dwconf_using_functions
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
addrmap
h
include
naming
h
ifdef
WORDS_BIGENDIAN
define
ASNAR
func
t
s
do
unsigned
tbyte
sizeof
t
sizeof
s
t
func
char
tbyte
sizeof
s
while
else
LITTLE
ENDIAN
define
ASNAR
func
t
s
do
t
func
sizeof
s
while
endif
end
LITTLE
BIG
ENDIAN
define
true
define
false
Dwarf_Sig8
zero_type_signature
static
void
print_one_frame_reg_col
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Unsigned
rule_id
Dwarf_Small
value_type
Dwarf_Unsigned
reg_used
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
dwconf_s
config_data
Dwarf_Signed
offset_relevant
Dwarf_Signed
offset
Dwarf_Ptr
block_ptr
static
void
print_frame_inst_bytes
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Ptr
cie_init_inst
Dwarf_Signed
len
Dwarf_Signed
data_alignment_factor
int
code_alignment_factor
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
dwconf_s
config_data
A
strcpy
which
ensures
NUL
terminated
string
and
never
overruns
the
output
void
safe_strcpy
char
out
long
outlen
const
char
in
long
inlen
if
inlen
outlen
strncpy
out
in
outlen
out
outlen
else
strcpy
out
in
static
void
dealloc_local_atlist
Dwarf_Debug
dbg
Dwarf_Attribute
atlist
Dwarf_Signed
atcnt
Dwarf_Signed
k
for
k
atcnt
k
dwarf_dealloc
dbg
atlist
k
DW_DLA_ATTR
dwarf_dealloc
dbg
atlist
DW_DLA_LIST
Executing
this
for
a
reporting
side
effect
PRINT_CU_INFO
in
dwarfdump
c
static
void
load_CU_error_data
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Signed
atcnt
Dwarf_Attribute
atlist
Dwarf_Half
tag
char
srcfiles
Dwarf_Signed
srccnt
int
local_show_form_used
int
local_verbose
int
atres
Dwarf_Signed
i
Dwarf_Signed
k
Dwarf_Error
loadcuerr
Dwarf_Off
cu_die_goff
if
cu_die
return
atres
dwarf_attrlist
cu_die
if
atres
DW_DLV_OK
Something
is
seriously
wrong
if
it
is
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
atres
loadcuerr
return
atres
dwarf_tag
cu_die
if
atres
DW_DLV_OK
for
k
k
atcnt
k
dwarf_dealloc
dbg
atlist
k
DW_DLA_ATTR
dealloc_local_atlist
dbg
atlist
atcnt
Something
is
seriously
wrong
if
it
is
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
atres
loadcuerr
return
The
offsets
will
be
zero
if
it
fails
Let
it
pass
atres
dwarf_die_offsets
cu_die
DIE_overall_offset
DIE_offset
cu_die_goff
glflags
DIE_overall_offset
DROP_ERROR_INSTANCE
dbg
atres
loadcuerr
glflags
DIE_CU_overall_offset
glflags
DIE_overall_offset
glflags
DIE_CU_offset
glflags
DIE_offset
for
i
i
atcnt
i
Dwarf_Half
attr
int
ares
Dwarf_Attribute
attrib
atlist
i
ares
dwarf_whatattr
attrib
if
ares
DW_DLV_OK
for
k
k
atcnt
k
dwarf_dealloc
dbg
atlist
k
DW_DLA_ATTR
dealloc_local_atlist
dbg
atlist
atcnt
DROP_ERROR_INSTANCE
dbg
ares
loadcuerr
return
For
now
we
will
not
fully
deal
with
the
complexity
of
DW_AT_high_pc
being
an
offset
of
low
pc
switch
attr
case
DW_AT_low_pc
ares
dwarf_formaddr
attrib
CU_base_address
DROP_ERROR_INSTANCE
dbg
ares
loadcuerr
glflags
CU_low_address
glflags
CU_base_address
break
case
DW_AT_high_pc
This
is
wrong
for
DWARF4
instances
where
the
attribute
is
really
an
offset
It
s
also
useless
for
CU
DIEs
that
do
not
have
the
DW_AT_high_pc
high
so
CU_high_address
will
be
zero
ares
dwarf_formaddr
attrib
CU_high_address
DROP_ERROR_INSTANCE
dbg
ares
loadcuerr
break
case
DW_AT_name
case
DW_AT_producer
const
char
name
struct
esb_s
namestr
esb_constructor
ares
get_attr_value
dbg
tag
cu_die
die_indent_level
cu_die_goff
attrib
srcfiles
srccnt
local_show_form_used
local_verbose
DROP_ERROR_INSTANCE
dbg
ares
loadcuerr
if
esb_string_len
name
esb_get_string
if
attr
DW_AT_name
safe_strcpy
glflags
CU_name
sizeof
glflags
CU_name
name
strlen
name
else
safe_strcpy
glflags
CU_producer
sizeof
glflags
CU_producer
name
strlen
name
esb_destructor
break
default
do
nothing
break
dealloc_local_atlist
dbg
atlist
atcnt
return
define
MAXLEBLEN
define
BITSPERBYTE
decode
ULEB
static
int
local_dwarf_decode_u_leb128_chk
unsigned
char
leb128
unsigned
int
leb128_length
Dwarf_Unsigned
value_out
Dwarf_Small
data_end
Dwarf_Unsigned
byte
Dwarf_Unsigned
number
unsigned
int
shift
unsigned
int
byte_length
byte
leb128
if
leb128
data_end
return
DW_DLV_ERROR
for
if
shift
sizeof
number
BITSPERBYTE
return
DW_DLV_ERROR
number
byte
shift
shift
if
byte
if
leb128_length
NULL
leb128_length
byte_length
value_out
number
return
DW_DLV_OK
byte_length
if
byte_length
MAXLEBLEN
return
DW_DLV_ERROR
leb128
if
leb128
data_end
return
DW_DLV_ERROR
byte
leb128
return
DW_DLV_ERROR
define
BITSINBYTE
static
int
local_dwarf_decode_s_leb128_chk
unsigned
char
leb128
unsigned
int
leb128_length
Dwarf_Signed
value_out
Dwarf_Small
data_end
Dwarf_Signed
number
Dwarf_Bool
sign
unsigned
shift
Dwarf_Unsigned
byte
unsigned
byte_length
byte_length
being
the
number
of
bytes
of
data
absorbed
so
far
in
turning
the
leb
into
a
Dwarf_Signed
if
leb128
data_end
return
DW_DLV_ERROR
byte
leb128
for
sign
byte
if
shift
sizeof
number
BITSPERBYTE
return
DW_DLV_ERROR
number
byte
shift
shift
if
byte
break
leb128
if
leb128
data_end
return
DW_DLV_ERROR
if
byte_length
MAXLEBLEN
return
DW_DLV_ERROR
byte
leb128
byte_length
if
sign
The
following
avoids
undefined
behavior
unsigned
shiftlim
sizeof
Dwarf_Signed
BITSINBYTE
if
shift
shiftlim
number
Dwarf_Signed
Dwarf_Unsigned
shift
else
if
shift
shiftlim
number
Dwarf_Unsigned
shift
if
leb128_length
NULL
leb128_length
byte_length
value_out
number
return
DW_DLV_OK
For
inlined
functions
try
to
find
name
If
we
fail
due
to
error
we
hide
the
error
For
now
Returns
DW_DLV_OK
or
DW_DLV_NO_ENTRY
for
now
static
int
get_abstract_origin_funcname
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Attribute
attr
struct
esb_s
name_out
Dwarf_Off
off
Dwarf_Die
origin_die
Dwarf_Attribute
atlist
NULL
Dwarf_Signed
atcnt
Dwarf_Signed
i
int
dres
int
atres
int
name_found
int
res
Dwarf_Error
err
Dwarf_Bool
is_info
dwarf_get_die_infotypes_flag
die
res
dwarf_global_formref
attr
if
res
DW_DLV_ERROR
dwarf_dealloc
dbg
err
DW_DLA_ERROR
return
DW_DLV_NO_ENTRY
if
res
DW_DLV_NO_ENTRY
return
DW_DLV_NO_ENTRY
dres
dwarf_offdie_b
dbg
off
is_info
if
dres
DW_DLV_ERROR
dwarf_dealloc
dbg
err
DW_DLA_ERROR
return
DW_DLV_NO_ENTRY
if
dres
DW_DLV_NO_ENTRY
return
DW_DLV_NO_ENTRY
atres
dwarf_attrlist
origin_die
if
atres
DW_DLV_ERROR
dwarf_dealloc
dbg
origin_die
DW_DLA_DIE
dwarf_dealloc
dbg
err
DW_DLA_ERROR
return
DW_DLV_NO_ENTRY
if
atres
DW_DLV_NO_ENTRY
dwarf_dealloc
dbg
origin_die
DW_DLA_DIE
return
DW_DLV_NO_ENTRY
for
i
i
atcnt
i
Dwarf_Half
lattr
int
ares
ares
dwarf_whatattr
atlist
i
if
ares
DW_DLV_ERROR
break
else
if
ares
DW_DLV_OK
if
lattr
DW_AT_name
int
sres
char
tempsl
sres
dwarf_formstring
atlist
i
if
sres
DW_DLV_OK
esb_append
name_out
tempsl
name_found
true
break
for
i
i
atcnt
i
dwarf_dealloc
dbg
atlist
i
DW_DLA_ATTR
dwarf_dealloc
dbg
atlist
DW_DLA_LIST
dwarf_dealloc
dbg
origin_die
DW_DLA_DIE
if
name_found
return
DW_DLV_NO_ENTRY
return
DW_DLV_OK
Returns
DW_DLV_OK
if
a
proc
with
this
low_pc
found
Else
returns
DW_DLV_NO_ENTRY
From
print_die
c
this
has
no
pcMap
passed
in
we
do
not
really
have
a
sensible
context
so
this
really
just
looks
at
the
current
attributes
for
a
name
From
print_frames
c
we
do
have
a
pcMap
int
get_proc_name_by_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Addr
low_pc
struct
esb_s
proc_name
Dwarf_Die
cu_die_for_print_frames
void
pcMap
Dwarf_Error
err
Dwarf_Signed
atcnt
Dwarf_Signed
i
Dwarf_Attribute
atlist
NULL
Dwarf_Addr
low_pc_for_die
int
atres
int
funcpcfound
int
funcres
DW_DLV_OK
int
funcnamefound
int
loop_ok
true
if
pcMap
struct
Addr_Map_Entry
ame
ame
addr_map_find
low_pc
pcMap
if
ame
ame
mp_name
mp_name
is
NULL
only
if
we
ran
out
of
heap
space
esb_append
proc_name
ame
mp_name
return
DW_DLV_OK
if
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
if
glflags
gf_debug_addr_missing
return
DW_DLV_NO_ENTRY
atres
dwarf_attrlist
die
err
if
atres
DW_DLV_ERROR
load_CU_error_data
dbg
cu_die_for_print_frames
simple_err_only_return_action
atres
nERROR
dwarf_attrlist
call
fails
in
attempt
to
get
a
procedure
function
name
return
atres
if
atres
DW_DLV_NO_ENTRY
return
atres
for
i
i
atcnt
i
Dwarf_Half
attr
int
ares
char
temps
int
sres
int
dres
if
loop_ok
break
if
funcnamefound
funcpcfound
stop
as
soon
as
both
found
break
ares
dwarf_whatattr
atlist
i
err
if
ares
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
load_CU_error_data
dbg
cu_die_for_print_frames
esb_append_printf_s
nERROR
dwarf_whatattr
fails
with
s
dwarf_errmsg
err
simple_err_only_return_action
ares
esb_get_string
esb_destructor
return
DW_DLV_ERROR
else
if
ares
DW_DLV_OK
Dwarf_Error
aterr
switch
attr
case
DW_AT_specification
case
DW_AT_abstract_origin
if
funcnamefound
Only
use
this
if
we
have
not
seen
DW_AT_name
yet
int
aores
get_abstract_origin_funcname
dbg
die
atlist
i
proc_name
if
aores
DW_DLV_OK
FOUND
THE
NAME
funcnamefound
break
case
DW_AT_name
Even
if
we
saw
DW_AT_abstract_origin
go
ahead
and
take
DW_AT_name
sres
dwarf_formstring
atlist
i
if
sres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
formstring
in
get_proc_name
failed
n
esb_append
proc_name
ERROR
in
dwarf_formstring
dwarf_dealloc
dbg
aterr
DW_DLA_ERROR
aterr
else
if
sres
DW_DLV_NO_ENTRY
esb_append
proc_name
NO
ENTRY
on
dwarf_formstring?
else
esb_append
proc_name
temps
funcnamefound
FOUND
THE
NAME
sort
of
if
error
break
case
DW_AT_low_pc
dres
dwarf_formaddr
atlist
i
funcpcfound
if
dres
DW_DLV_ERROR
if
DW_DLE_MISSING_NEEDED_DEBUG_ADDR_SECTION
dwarf_errno
aterr
glflags
gf_debug_addr_missing
else
glflags
gf_count_major_errors
printf
nERROR
dwarf_formaddr
failed
in
get_proc_name
s
n
dwarf_errmsg
aterr
the
long
name
is
horrible
if
glflags
gf_error_code_search_by_address
glflags
gf_error_code_search_by_address
dwarf_errno
aterr
dwarf_dealloc
dbg
aterr
DW_DLA_ERROR
aterr
funcpcfound
low_pc_for_die
low_pc_for_die
loop_ok
false
ensure
no
match
else
if
dres
DW_DLV_NO_ENTRY
funcpcfound
loop_ok
false
break
default
break
end
switch
end
DW_DLV_OK
end
for
loop
on
atcnt
dealloc_local_atlist
dbg
atlist
atcnt
if
funcnamefound
funcpcfound
pcMap
Insert
the
name
to
map
even
if
not
the
low_pc
we
are
looking
for
This
version
does
extra
work
in
that
early
symbols
in
a
CU
will
be
inserted
multiple
times
the
extra
times
have
no
effect
addr_map_insert
low_pc_for_die
esb_get_string
proc_name
pcMap
if
funcnamefound
funcpcfound
low_pc
low_pc_for_die
funcres
DW_DLV_NO_ENTRY
return
funcres
Modified
Depth
First
Search
looking
for
the
procedure
a
only
looks
for
children
of
subprogram
b
With
subprogram
looks
at
current
die
before
looking
for
a
child
Needed
since
some
languages
including
SGI
MP
Fortran
have
nested
functions
Return
on
failure
on
success
static
int
load_nested_proc_name
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Addr
low_pc
struct
esb_s
ret_name
Dwarf_Die
cu_die_for_print_frames
void
pcMap
Dwarf_Error
err
Dwarf_Die
curdie
die
int
die_locally_gotten
Dwarf_Die
prev_child
Dwarf_Die
newchild
Dwarf_Die
newsibling
Dwarf_Half
tag
int
chres
DW_DLV_OK
struct
esb_s
nestname
esb_constructor
while
chres
DW_DLV_OK
int
tres
esb_empty_string
tres
dwarf_tag
curdie
err
newchild
if
tres
DW_DLV_OK
int
lchres
if
tag
DW_TAG_subprogram
int
gotit
Dwarf_Error
locerr
gotit
get_proc_name_by_die
dbg
curdie
low_pc
cu_die_for_print_frames
pcMap
if
gotit
DW_DLV_OK
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_append
ret_name
esb_get_string
esb_destructor
return
DW_DLV_OK
if
gotit
DW_DLV_ERROR
dwarf_dealloc
dbg
locerr
DW_DLA_ERROR
locerr
Check
children
of
subprograms
recursively
should
this
really
be
check
children
of
anything
or
just
children
of
subprograms?
lchres
dwarf_child
curdie
err
esb_empty_string
if
lchres
DW_DLV_OK
int
newprog
Dwarf_Error
innererr
look
for
inner
subprogram
newprog
load_nested_proc_name
dbg
newchild
low_pc
cu_die_for_print_frames
pcMap
dwarf_dealloc
dbg
newchild
DW_DLA_DIE
if
newprog
DW_DLV_OK
Found
it
We
could
just
take
this
name
or
we
could
concatenate
names
together
For
now
just
take
name
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_append
ret_name
esb_get_string
esb_destructor
return
DW_DLV_OK
else
if
newprog
DW_DLV_ERROR
dwarf_dealloc
dbg
innererr
DW_DLA_ERROR
innererr
else
if
lchres
DW_DLV_NO_ENTRY
nothing
to
do
else
load_CU_error_data
dbg
cu_die_for_print_frames
simple_err_only_return_action
lchres
nERROR
load_nested_proc_name
dwarf_child
failed
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_destructor
return
lchres
end
if
TAG_subprogram
else
esb_empty_string
if
tres
DW_DLV_ERROR
struct
esb_s
m
load_CU_error_data
dbg
cu_die_for_print_frames
esb_constructor
esb_append_printf_s
nERROR
load_nested_proc_name
dwarf_tag
failed
trying
to
get
proc
name
Error
is
s
dwarf_errmsg
err
simple_err_only_return_action
tres
esb_get_string
esb_destructor
esb_destructor
return
tres
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_destructor
return
DW_DLV_NO_ENTRY
try
next
sibling
prev_child
curdie
esb_empty_string
chres
dwarf_siblingof_b
dbg
curdie
dwarf_get_die_infotypes_flag
curdie
err
if
chres
DW_DLV_ERROR
struct
esb_s
m
load_CU_error_data
dbg
cu_die_for_print_frames
esb_constructor
esb_append
nERROR
Looking
for
function
name
for
a
frame
dwarf_siblingof
failed
trying
to
get
the
name
print_error_and_continue
dbg
esb_get_string
chres
err
esb_destructor
DROP_ERROR_INSTANCE
dbg
chres
err
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_destructor
return
DW_DLV_NO_ENTRY
else
if
chres
DW_DLV_NO_ENTRY
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
prev_child
DW_DLA_DIE
Not
there
at
this
level
esb_destructor
return
DW_DLV_NO_ENTRY
DW_DLV_OK
curdie
newsibling
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
prev_child
DW_DLA_DIE
prev_child
die_locally_gotten
if
die_locally_gotten
If
we
got
this
die
from
the
parent
we
do
not
want
to
dealloc
here
dwarf_dealloc
dbg
curdie
DW_DLA_DIE
esb_destructor
return
DW_DLV_NO_ENTRY
For
SGI
MP
Fortran
and
other
languages
functions
nest
As
a
result
we
must
dig
thru
all
functions
not
just
the
top
level
This
remembers
the
CU
die
and
restarts
each
search
at
the
start
of
the
current
cu
Return
DW_DLV_OK
means
found
name
Return
DW_DLV_NO_ENTRY
means
not
found
name
Never
returns
DW_DLV_ERROR
static
int
get_fde_proc_name_by_address
Dwarf_Debug
dbg
Dwarf_Addr
low_pc
const
char
frame_section_name
struct
esb_s
name
Dwarf_Die
cu_die_for_print_frames
void
pcMap
Dwarf_Error
err
Dwarf_Unsigned
cu_header_length
Dwarf_Unsigned
abbrev_offset
Dwarf_Half
version_stamp
Dwarf_Half
address_size
Dwarf_Unsigned
next_cu_offset
int
cures
DW_DLV_OK
int
dres
DW_DLV_OK
int
chres
DW_DLV_OK
struct
Addr_Map_Entry
ame
Dwarf_Half
length_size
Dwarf_Half
extension_size
Dwarf_Sig8
type_signature
Dwarf_Unsigned
typeoffset
Dwarf_Half
header_cu_type
Dwarf_Bool
is_info
TRUE
An
assumption
but
sensible
as
functions
will
not
be
in
debug_types
type_signature
zero_type_signature
ame
addr_map_find
low_pc
pcMap
if
ame
ame
mp_name
esb_append
name
ame
mp_name
return
DW_DLV_OK
if
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
if
glflags
gf_debug_addr_missing
return
DW_DLV_NO_ENTRY
if
cu_die_for_print_frames
NULL
Call
depends
on
dbg
cu_context
to
know
what
to
do
cures
dwarf_next_cu_header_d
dbg
is_info
err
if
cures
DW_DLV_ERROR
If
there
is
a
serious
error
in
DIE
information
we
just
skip
looking
for
a
procedure
name
Perhaps
we
should
report
something?
printf
nERROR
Error
getting
next
cu
header
looking
for
a
subroutine
procedure
name
Section
s
Err
is
s
n
sanitized
frame_section_name
dwarf_errmsg
err
glflags
gf_all_cus_seen_search_by_address
DROP_ERROR_INSTANCE
dbg
cures
err
return
DW_DLV_NO_ENTRY
else
if
cures
DW_DLV_NO_ENTRY
loop
thru
the
list
again
cu_die_for_print_frames
else
DW_DLV_OK
dres
dwarf_siblingof_b
dbg
NULL
is_info
cu_die_for_print_frames
err
if
dres
DW_DLV_ERROR
If
there
is
a
serious
error
in
DIE
information
we
just
skip
looking
for
a
procedure
name
Perhaps
we
should
report
something?
printf
nERROR
Error
getting
dwarf_siblingof
when
looking
for
procedure
name
Section
s
Err
is
s
n
sanitized
frame_section_name
dwarf_errmsg
err
glflags
gf_count_major_errors
DROP_ERROR_INSTANCE
dbg
dres
err
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
if
dres
DW_DLV_NO_ENTRY
No
initial
die?
Something
is
wrong
return
dres
if
dres
DW_DLV_OK
Dwarf_Die
child
if
cu_die_for_print_frames
no
information
Possibly
a
stripped
file
return
DW_DLV_NO_ENTRY
chres
dwarf_child
cu_die_for_print_frames
err
if
chres
DW_DLV_ERROR
printf
nERROR
Error
getting
dwarf_child
Section
s
Err
is
s
n
sanitized
frame_section_name
dwarf_errmsg
err
DROP_ERROR_INSTANCE
dbg
chres
err
glflags
gf_count_major_errors
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
else
if
chres
DW_DLV_NO_ENTRY
FALL
THROUGH
to
look
for
more
CU
headers
else
DW_DLV_OK
int
gotname
gotname
load_nested_proc_name
dbg
child
low_pc
name
cu_die_for_print_frames
pcMap
err
dwarf_dealloc
dbg
child
DW_DLA_DIE
if
gotname
DW_DLV_OK
return
DW_DLV_OK
if
gotname
DW_DLV_ERROR
glflags
gf_all_cus_seen_search_by_address
DROP_ERROR_INSTANCE
dbg
gotname
err
return
DW_DLV_NO_ENTRY
child
for
Dwarf_Die
ldie
type_signature
zero_type_signature
cures
dwarf_next_cu_header_d
dbg
is_info
err
if
cures
DW_DLV_OK
if
cures
DW_DLV_ERROR
printf
nERROR
Error
getting
next_cu_header
Section
s
Err
is
s
n
sanitized
frame_section_name
dwarf_errmsg
err
DROP_ERROR_INSTANCE
dbg
cures
err
glflags
gf_count_major_errors
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
glflags
gf_all_cus_seen_search_by_address
break
dres
dwarf_siblingof_b
dbg
NULL
is_info
err
if
cu_die_for_print_frames
dwarf_dealloc
dbg
cu_die_for_print_frames
DW_DLA_DIE
cu_die_for_print_frames
if
dres
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
dres
err
glflags
gf_all_cus_seen_search_by_address
return
dres
else
if
dres
DW_DLV_NO_ENTRY
return
dres
DW_DLV_OK
In
normal
processing
ie
when
doing
print_info
we
would
call
print_attribute
for
each
die
including
cu_die
and
thus
get
CU_base_address
CU_high_address
PU_base_address
PU_high_address
CU_name
for
PRINT_CU_INFO
in
case
of
error
cu_die_for_print_frames
ldie
int
chpfres
Dwarf_Die
child
chpfres
dwarf_child
cu_die_for_print_frames
err
if
chpfres
DW_DLV_ERROR
load_CU_error_data
dbg
cu_die_for_print_frames
glflags
gf_count_major_errors
printf
nERROR
Getting
procedure
name
dwarf_child
fails
s
n
dwarf_errmsg
err
DROP_ERROR_INSTANCE
dbg
chpfres
err
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
else
if
chpfres
DW_DLV_NO_ENTRY
FALL
THROUGH
to
loop
more
else
DW_DLV_OK
int
gotname
gotname
load_nested_proc_name
dbg
child
low_pc
name
cu_die_for_print_frames
pcMap
err
dwarf_dealloc
dbg
child
DW_DLA_DIE
if
gotname
DW_DLV_OK
return
gotname
if
gotname
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
gotname
err
glflags
gf_all_cus_seen_search_by_address
return
DW_DLV_NO_ENTRY
reset_overall_CU_error_data
return
DW_DLV_NO_ENTRY
Attempting
to
take
care
of
overflows
so
we
only
accept
good
as
true
static
Dwarf_Bool
valid_fde_content
Dwarf_Small
fde_start
Dwarf_Unsigned
fde_length
Dwarf_Small
data_ptr
Dwarf_Unsigned
data_ptr_length
Dwarf_Small
fde_end
fde_start
fde_length
Dwarf_Small
data_end
if
data_ptr
fde_start
data_ptr
fde_end
return
false
data_end
data_ptr
data_ptr_length
if
data_end
fde_start
data_end
data_ptr
return
false
if
data_end
fde_end
return
false
return
true
Gather
the
fde
print
logic
here
so
the
control
logic
determining
what
FDE
to
print
is
clearer
static
int
print_one_fde
Dwarf_Debug
dbg
const
char
frame_section_name
Dwarf_Fde
fde
Dwarf_Unsigned
fde_index
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
version
int
is_eh
struct
dwconf_s
config_data
void
pcMap
void
lowpcSet
Dwarf_Die
cu_die_for_print_frames
Dwarf_Error
err
Dwarf_Addr
j
Dwarf_Addr
low_pc
Dwarf_Unsigned
func_length
Dwarf_Addr
end_func_addr
Dwarf_Ptr
fde_bytes
NULL
Dwarf_Unsigned
fde_bytes_length
Dwarf_Off
cie_offset
Dwarf_Signed
cie_index
Dwarf_Off
fde_offset
Dwarf_Signed
eh_table_offset
int
fres
int
offres
struct
esb_s
temps
int
printed_intro_addr
char
local_buf
char
temps_buf
fres
dwarf_get_fde_range
fde
err
if
fres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
calling
dwarf_get_fde_range
on
index
DW_PR_DUu
gets
an
error
Error
is
s
n
fde_index
dwarf_errmsg
err
return
fres
if
fres
DW_DLV_NO_ENTRY
return
DW_DLV_NO_ENTRY
if
glflags
gf_cu_name_flag
glflags
fde_offset_for_cu_low
DW_DLV_BADOFFSET
fde_offset
glflags
fde_offset_for_cu_low
fde_offset
glflags
fde_offset_for_cu_high
return
DW_DLV_NO_ENTRY
eh_table_offset
is
IRIX
ONLY
fres
dwarf_get_fde_exception_info
fde
err
if
fres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
Got
error
looking
for
SGI
only
exception
table
offset
from
fde
Error
is
s
n
dwarf_errmsg
err
return
fres
esb_constructor_fixed
temps_buf
sizeof
temps_buf
if
glflags
gf_suppress_nested_name_search
do
nothing
else
struct
Addr_Map_Entry
mp
esb_empty_string
mp
addr_map_find
low_pc
lowpcSet
if
glflags
gf_check_frames
glflags
gf_check_frames_extended
DWARF_CHECK_COUNT
fde_duplication
fres
get_fde_proc_name_by_address
dbg
low_pc
frame_section_name
cu_die_for_print_frames
pcMap
err
if
fres
DW_DLV_ERROR
Failing
to
get
the
name
is
not
a
crucial
thing
Do
not
error
off
We
should
not
get
here
as
the
invariant
for
get_fde_proc_name_by_address
says
it
never
returns
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
fres
err
fres
DW_DLV_NO_ENTRY
If
found
the
name
is
in
temps
now
or
temps
is
the
empty
string
if
mp
if
glflags
gf_check_frames
glflags
gf_check_frames_extended
struct
esb_s
msg
esb_constructor_fixed
local_buf
sizeof
local_buf
if
esb_string_len
esb_append_printf_u
An
fde
low
pc
of
DW_PR_DUx
is
not
the
first
fde
with
that
pc
low_pc
esb_append_printf_s
The
first
is
named
s
sanitized
esb_get_string
else
esb_append_printf_u
An
fde
low
pc
of
DW_PR_DUx
is
not
the
first
fde
with
that
pc
The
first
is
not
named
Dwarf_Unsigned
low_pc
DWARF_CHECK_ERROR
fde_duplication
esb_get_string
esb_destructor
else
if
fres
DW_DLV_OK
addr_map_insert
low_pc
lowpcSet
Else
we
just
don
t
know
anything
so
record
nothing
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
Printing
the
FDE
header
printf
DW_PR_DSd
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
s
cie
offset
DW_PR_XZEROS
DW_PR_DUx
cie
index
DW_PR_DUu
fde
offset
DW_PR_XZEROS
DW_PR_DUx
length
DW_PR_XZEROS
DW_PR_DUx
fde_index
Dwarf_Unsigned
low_pc
Dwarf_Unsigned
low_pc
func_length
sanitized
esb_get_string
Dwarf_Unsigned
cie_offset
Dwarf_Unsigned
cie_index
Dwarf_Unsigned
fde_offset
fde_bytes_length
esb_destructor
if
is_eh
IRIX
uses
eh_table_offset
No
one
else
uses
it
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
if
eh_table_offset
DW_DLX_NO_EH_OFFSET
printf
eh
offset
s
n
none
else
if
eh_table_offset
DW_DLX_EH_OFFSET_UNAVAILABLE
printf
eh
offset
s
n
unknown
else
printf
eh
offset
DW_PR_XZEROS
DW_PR_DUx
n
eh_table_offset
else
Printing
the
eh_frame
header
augmentation
string
if
any
int
ares
Dwarf_Small
data
Dwarf_Unsigned
len
ares
dwarf_get_fde_augmentation_data
fde
err
if
ares
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
on
getting
augmentation
data
for
an
fde
Error
is
s
n
dwarf_errmsg
err
return
ares
if
ares
DW_DLV_NO_ENTRY
do
nothing
else
if
ares
DW_DLV_OK
if
glflags
gf_do_print_dwarf
printf
n
eh
aug
data
len
DW_PR_DUx
len
if
len
if
valid_fde_content
fde_bytes
fde_bytes_length
data
len
glflags
gf_count_major_errors
printf
ERROR
The
eh_frame
augmentation
data
is
too
large
to
print
else
Dwarf_Unsigned
k2
for
k2
k2
len
k2
if
k2
printf
bytes
printf
unsigned
char
data
k2
printf
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
printf
n
end_func_addr
low_pc
func_length
for
j
low_pc
j
end_func_addr
j
Dwarf_Half
k
Dwarf_Addr
cur_pc_in_table
cur_pc_in_table
j
Dwarf_Signed
reg
Dwarf_Signed
offset_relevant
Dwarf_Small
value_type
Dwarf_Signed
offset_or_block_len
Dwarf_Signed
offset
Dwarf_Ptr
block_ptr
Dwarf_Addr
row_pc
Dwarf_Bool
has_more_rows
Dwarf_Addr
subsequent_pc
int
fires
dwarf_get_fde_info_for_cfa_reg3_b
fde
j
err
offset
offset_or_block_len
if
fires
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
on
getting
fde
details
for
fde
row
for
address
DW_PR_XZEROS
DW_PR_DUx
n
j
return
fires
if
fires
DW_DLV_NO_ENTRY
continue
if
has_more_rows
j
low_pc
func_length
else
if
subsequent_pc
j
Loop
head
will
increment
j
to
make
up
for
here
j
subsequent_pc
Do
not
print
if
in
check
mode
if
printed_intro_addr
glflags
gf_do_print_dwarf
printf
DW_PR_XZEROS
DW_PR_DUx
Dwarf_Unsigned
cur_pc_in_table
printed_intro_addr
print_one_frame_reg_col
dbg
cu_die_for_print_frames
config_data
cf_cfa_reg
value_type
reg
address_size
offset_size
version
config_data
offset_relevant
offset
block_ptr
for
k
k
config_data
cf_table_entry_count
k
Dwarf_Signed
reg
Dwarf_Signed
offset_relevant
int
fires
Dwarf_Small
value_type
Dwarf_Ptr
block_ptr
Dwarf_Signed
offset_or_block_len
Dwarf_Signed
offset
Dwarf_Addr
row_pc
Dwarf_Bool
has_more_rows
FALSE
Dwarf_Addr
subsequent_pc
fires
dwarf_get_fde_info_for_reg3_b
fde
k
cur_pc_in_table
err
offset
offset_or_block_len
if
fires
DW_DLV_ERROR
printf
n
glflags
gf_count_major_errors
printf
nERROR
on
getting
fde
details
for
row
address
DW_PR_XZEROS
DW_PR_DUx
table
column
d
n
j
k
return
fires
if
fires
DW_DLV_NO_ENTRY
continue
if
row_pc
cur_pc_in_table
row_pc
cur_pc_in_table
means
this
pc
has
no
new
register
value
the
last
one
found
still
applies
hence
this
is
a
duplicate
row
row_pc
j
cannot
happen
the
libdwarf
function
will
not
return
such
continue
Do
not
print
if
in
check
mode
if
printed_intro_addr
glflags
gf_do_print_dwarf
printf
DW_PR_XZEROS
DW_PR_DUx
Dwarf_Unsigned
j
printed_intro_addr
print_one_frame_reg_col
dbg
cu_die_for_print_frames
k
value_type
reg
address_size
offset_size
version
config_data
offset_relevant
offset
block_ptr
if
printed_intro_addr
printf
n
printed_intro_addr
if
glflags
verbose
Dwarf_Off
fde_off
Dwarf_Off
cie_off
Get
the
fde
instructions
and
print
them
in
raw
form
just
like
cie
instructions
Dwarf_Ptr
instrs
Dwarf_Unsigned
ilen
int
res
res
dwarf_get_fde_instr_bytes
fde
err
res
will
be
checked
below
offres
dwarf_fde_section_offset
dbg
fde
err
if
offres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
on
getting
fde
section
offset
of
this
fde
n
return
offres
if
offres
DW_DLV_OK
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
printf
fde
section
offset
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
cie
offset
for
fde
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
n
Dwarf_Unsigned
fde_off
Dwarf_Unsigned
fde_off
Dwarf_Unsigned
cie_off
Dwarf_Unsigned
cie_off
if
res
DW_DLV_ERROR
DW_DLV_ERROR
printf
nERROR
on
getting
fde
instruction
bytes
for
fde
index
DW_PR_DUu
n
fde_index
glflags
gf_count_major_errors
return
res
if
res
DW_DLV_OK
int
cires
Dwarf_Unsigned
cie_length
Dwarf_Small
cie_version
char
augmenter
Dwarf_Unsigned
code_alignment_factor
Dwarf_Signed
data_alignment_factor
Dwarf_Half
return_address_register_rule
Dwarf_Ptr
initial_instructions
Dwarf_Unsigned
initial_instructions_length
Dwarf_Half
cie_offset_size
if
cie_index
cie_element_count
glflags
gf_count_major_errors
printf
nERROR
Bad
cie
index
DW_PR_DSd
with
fde
index
DW_PR_DUu
table
entry
max
DW_PR_DSd
n
cie_index
fde_index
cie_element_count
return
DW_DLV_NO_ENTRY
cires
dwarf_get_offset_size
dbg
err
if
cires
DW_DLV_OK
return
res
cires
dwarf_get_cie_info_b
cie_data
cie_index
err
if
cires
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
Bad
cie
index
DW_PR_DSd
with
fde
index
DW_PR_DUu
n
cie_index
fde_index
return
cires
if
cires
DW_DLV_NO_ENTRY
else
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
print_frame_inst_bytes
dbg
cu_die_for_print_frames
instrs
Dwarf_Signed
ilen
data_alignment_factor
int
code_alignment_factor
address_size
cie_offset_size
cie_version
config_data
else
if
res
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
ERROR
Impossible
no
instr
bytes
for
fde
index
DW_PR_DUu
n
fde_index
glflags
gf_count_major_errors
return
DW_DLV_OK
Print
a
cie
Gather
the
print
logic
here
so
the
control
logic
deciding
what
to
print
is
clearer
int
print_one_cie
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Cie
cie
Dwarf_Unsigned
cie_index
Dwarf_Half
address_size
struct
dwconf_s
config_data
Dwarf_Error
err
int
cires
Dwarf_Unsigned
cie_length
Dwarf_Small
version
char
augmenter
Dwarf_Unsigned
code_alignment_factor
Dwarf_Signed
data_alignment_factor
Dwarf_Half
return_address_register_rule
Dwarf_Ptr
initial_instructions
Dwarf_Unsigned
initial_instructions_length
Dwarf_Off
cie_off
Dwarf_Half
offset_size
cires
dwarf_get_cie_info_b
cie
err
if
cires
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
calling
dwarf_get_cie_info_b
fails
n
return
cires
if
cires
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
ERROR
Impossible
DW_DLV_NO_ENTRY
on
cie
DW_PR_DUu
n
cie_index
return
cires
if
glflags
gf_do_print_dwarf
printf
DW_PR_DUu
version
d
n
cie_index
version
cires
dwarf_cie_section_offset
dbg
cie
err
if
cires
DW_DLV_OK
printf
cie
section
offset
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
n
Dwarf_Unsigned
cie_off
Dwarf_Unsigned
cie_off
This
augmentation
is
from
debug_frame
or
eh_frame
of
a
cie
A
string
bytes
of
initial
instructions
printf
augmentation
s
n
sanitized
augmenter
printf
code_alignment_factor
DW_PR_DUu
n
code_alignment_factor
printf
data_alignment_factor
DW_PR_DSd
n
data_alignment_factor
printf
return_address_register
d
n
return_address_register_rule
int
ares
Dwarf_Small
data
Dwarf_Unsigned
len
This
call
only
returns
DW_DLV_OK
if
the
augmentation
is
cie
aug
from
eh_frame
The
return
is
DW_DLV_OK
only
if
there
is
eh_frame
style
augmentation
bytes
its
not
a
string
ares
dwarf_get_cie_augmentation_data
cie
err
if
ares
DW_DLV_NO_ENTRY
No
Aug
data
len
zero
do
nothing
else
if
ares
DW_DLV_OK
We
have
the
gnu
eh_frame
aug
data
bytes
if
glflags
gf_do_print_dwarf
unsigned
k2
bytes
of
initial
instructions
printf
eh
aug
data
len
DW_PR_DUx
len
for
k2
data
k2
len
k2
if
k2
printf
bytes
printf
unsigned
char
data
k2
printf
n
else
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
calling
dwarf_get_cie_augmentation_data
fails
n
return
ares
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
printf
bytes
of
initial
instructions
DW_PR_DUu
n
initial_instructions_length
printf
cie
length
DW_PR_DUu
n
cie_length
For
better
layout
printf
initial
instructions
n
print_frame_inst_bytes
dbg
die
initial_instructions
Dwarf_Signed
initial_instructions_length
data_alignment_factor
int
code_alignment_factor
address_size
offset_size
version
config_data
return
DW_DLV_OK
int
print_location_operations
Dwarf_Debug
dbg
Dwarf_Die
die
int
die_indent_level
Dwarf_Ptr
bytes_in
Dwarf_Unsigned
block_len
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
esb_s
out_string
Dwarf_Error
err
Dwarf_Unsigned
ulistlen
int
res2
Dwarf_Addr
baseaddr
Really
unknown
See
PRINTING_DIES
macro
in
print_die
c
Dwarf_Loc_Head_c
head
Dwarf_Locdesc_c
locentry
int
lres
Dwarf_Unsigned
lopc
Dwarf_Unsigned
hipc
Dwarf_Unsigned
ulocentry_count
Dwarf_Unsigned
section_offset
Dwarf_Unsigned
locdesc_offset
Dwarf_Small
lle_value
Dwarf_Small
loclist_source
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
FALSE
res2
dwarf_loclist_from_expr_c
dbg
bytes_in
block_len
addr_size
offset_size
version
err
if
res2
DW_DLV_NO_ENTRY
return
res2
if
res2
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
calling
dwarf_loclist_from_expr_c
return
res2
lres
dwarf_get_locdesc_entry_d
head
Data
from
LocDesc
err
if
lres
DW_DLV_ERROR
dwarf_loc_head_c_dealloc
head
glflags
gf_count_major_errors
printf
nERROR
calling
dwarf_locdesc_entry_c
on
LocDesc
return
lres
else
if
lres
DW_DLV_NO_ENTRY
dwarf_loc_head_c_dealloc
head
return
lres
ASSERT
loclist_source
DW_LKIND_expression
ASSERT
lle_value
DW_LLE_start_end
lres
dwarfdump_print_location_operations
dbg
die
die_indent_level
locentry
index
locdesc
ulocentry_count
DW_LKIND_expression
loclist_source
no
die
indent
baseaddr
out_string
err
dwarf_loc_head_c_dealloc
head
return
lres
DW_CFA_nop
may
be
omitted
for
alignment
so
we
do
not
flag
that
one
static
int
lastop_pointless
int
op
if
op
DW_CFA_remember_state
op
DW_CFA_MIPS_advance_loc8
op
DW_CFA_advance_loc
op
DW_CFA_advance_loc4
op
DW_CFA_advance_loc2
op
DW_CFA_advance_loc1
op
DW_CFA_set_loc
return
true
The
last
op
is
hopefully
useful
return
false
iregion_start
iregion_end
are
the
overall
block
of
fde
cie
instructions
idata
idata
end
are
the
area
next
to
be
read
and
they
must
lie
within
the
iregion
range
The
end
address
is
one
past
the
last
byte
We
are
decoding
here
libdwarf
has
not
decoded
these
bytes
so
it
is
up
to
us
to
check
for
corrupt
data
in
the
frame
section
static
int
check_finstr_addrs
unsigned
char
iregionstart
unsigned
char
idata
unsigned
char
idata_end
unsigned
char
iregionend
const
char
msg
if
idata
idata_end
zero
length
allowed
But
maybe
overflow
happened
glflags
gf_count_major_errors
printf
ERROR
frame
instruction
internal
error
reading
s
n
msg
return
DW_DLV_ERROR
if
idata
iregionstart
glflags
gf_count_major_errors
printf
nERROR
frame
instruction
overflow
reading
s
n
msg
return
DW_DLV_ERROR
if
idata_end
iregionend
Dwarf_Unsigned
bytes_in
bytes_in
idata
iregionstart
glflags
gf_count_major_errors
printf
nERROR
frame
instruction
reads
off
end
DW_PR_DUu
bytes
into
instructions
for
s
n
bytes_in
msg
return
DW_DLV_ERROR
return
DW_DLV_OK
Print
the
frame
instructions
in
detail
for
a
glob
of
instructions
The
frame
data
has
not
been
checked
by
libdwarf
as
libdwarf
has
not
transformed
it
into
simple
structs
We
are
reading
the
raw
data
ARGSUSED
static
void
print_frame_inst_bytes
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Ptr
cie_init_inst
Dwarf_Signed
len_in
Dwarf_Signed
data_alignment_factor
int
code_alignment_factor
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
dwconf_s
config_data
unsigned
char
instp
unsigned
char
cie_init_inst
unsigned
char
startpoint
instp
Dwarf_Unsigned
uval
Dwarf_Unsigned
uval2
unsigned
int
uleblen
unsigned
int
off
unsigned
int
loff
unsigned
u16
unsigned
int
u32
Dwarf_Unsigned
u64
int
res
Dwarf_Small
endpoint
Dwarf_Signed
remaining_len
int
lastop
char
exprstr_buf
void
copy_word
void
const
void
unsigned
long
copy_word
dwarf_get_endian_copy_function
dbg
if
copy_word
glflags
gf_count_major_errors
printf
nERROR
Unable
to
print
frame
instruction
bytes
Missing
the
word
copy
function
n
return
if
len_in
return
remaining_len
len_in
endpoint
instp
remaining_len
for
remaining_len
unsigned
char
ibyte
int
top
int
bottom
int
delta
int
reg
if
check_finstr_addrs
startpoint
instp
instp
endpoint
start
next
instruction
DW_DLV_OK
return
ibyte
instp
top
ibyte
bottom
ibyte
lastop
top
switch
top
case
DW_CFA_advance_loc
delta
ibyte
printf
DW_CFA_advance_loc
d
off
int
delta
code_alignment_factor
if
glflags
verbose
printf
d
d
int
delta
int
code_alignment_factor
printf
n
break
case
DW_CFA_offset
loff
off
reg
ibyte
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_offset
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_offset
loff
printreg
reg
config_data
printf
DW_PR_DSd
Dwarf_Signed
Dwarf_Signed
uval
data_alignment_factor
if
glflags
verbose
printf
DW_PR_DUu
DW_PR_DSd
uval
data_alignment_factor
printf
n
break
case
DW_CFA_restore
reg
ibyte
printf
DW_CFA_restore
off
printreg
reg
config_data
printf
n
break
default
loff
off
lastop
top
switch
bottom
case
DW_CFA_set_loc
operand
is
address
so
need
address
size
which
will
be
or
if
check_finstr_addrs
startpoint
instp
instp
addr_size
endpoint
DW_CFA_set_loc
DW_DLV_OK
return
switch
addr_size
case
Dwarf_Unsigned
v32
char
b32
memcpy
b32
instp
ASNAR
copy_word
v32
b32
uval
v32
break
case
Dwarf_Unsigned
v64
char
b64
memcpy
b64
instp
ASNAR
copy_word
v64
b64
uval
v64
break
default
glflags
gf_count_major_errors
printf
nERROR
Unexpected
address
size
d
in
DW_CFA_set_loc
n
addr_size
uval
instp
addr_size
remaining_len
Dwarf_Signed
addr_size
off
addr_size
printf
DW_CFA_set_loc
DW_PR_DUu
n
loff
uval
break
case
DW_CFA_advance_loc1
if
check_finstr_addrs
startpoint
instp
instp
endpoint
DW_CFA_advance_loc1
DW_DLV_OK
return
delta
unsigned
char
instp
uval2
delta
instp
remaining_len
off
printf
DW_CFA_advance_loc1
DW_PR_DUu
n
loff
uval2
break
case
DW_CFA_advance_loc2
if
check_finstr_addrs
startpoint
instp
instp
endpoint
DW_CFA_advance_loc2
DW_DLV_OK
return
char
u2
memcpy
u2
instp
ASNAR
copy_word
u16
u2
uval2
u16
instp
remaining_len
off
printf
DW_CFA_advance_loc2
DW_PR_DUu
n
loff
uval2
break
case
DW_CFA_advance_loc4
if
check_finstr_addrs
startpoint
instp
instp
endpoint
DW_CFA_advance_loc4
DW_DLV_OK
return
char
u4
memcpy
u4
instp
ASNAR
copy_word
u32
u4
uval2
u32
instp
remaining_len
off
printf
DW_CFA_advance_loc4
DW_PR_DUu
n
loff
uval2
break
case
DW_CFA_MIPS_advance_loc8
if
check_finstr_addrs
startpoint
instp
instp
endpoint
DW_CFA_MIPS_advance_loc8
DW_DLV_OK
return
char
u8
memcpy
u8
instp
ASNAR
copy_word
u64
u8
uval2
u64
instp
remaining_len
off
printf
DW_CFA_MIPS_advance_loc8
DW_PR_DUu
n
loff
uval2
break
case
DW_CFA_offset_extended
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_offset_extended
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_offset_extended
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_offset_extended
loff
printreg
uval
config_data
printf
DW_PR_DSd
Dwarf_Signed
Dwarf_Signed
uval2
data_alignment_factor
if
glflags
verbose
printf
DW_PR_DUu
d
uval2
int
data_alignment_factor
printf
n
break
case
DW_CFA_restore_extended
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_restore_extended
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_restore_extended
loff
printreg
uval
config_data
printf
n
break
case
DW_CFA_undefined
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_undefined
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_undefined
loff
printreg
uval
config_data
printf
n
break
case
DW_CFA_same_value
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_undefined
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_same_value
loff
printreg
uval
config_data
printf
n
break
case
DW_CFA_register
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_register
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_register
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_register
loff
printreg
uval
config_data
printf
printreg
uval2
config_data
printf
n
break
case
DW_CFA_remember_state
printf
DW_CFA_remember_state
n
loff
break
case
DW_CFA_restore_state
printf
DW_CFA_restore_state
n
loff
break
case
DW_CFA_def_cfa
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa
loff
printreg
uval
config_data
printf
DW_PR_DUu
uval2
printf
n
break
case
DW_CFA_def_cfa_register
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_register
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa_register
loff
printreg
uval
config_data
printf
n
break
case
DW_CFA_def_cfa_offset
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_offset
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa_offset
DW_PR_DUu
n
loff
uval
break
case
DW_CFA_nop
printf
DW_CFA_nop
n
loff
break
case
DW_CFA_def_cfa_expression
DWARF3
Dwarf_Unsigned
block_len
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_expression
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa_expression
expr
block
len
DW_PR_DUu
n
loff
block_len
if
remaining_len
block_len
Dwarf_Unsigned
remaining_len
glflags
gf_count_major_errors
printf
nERROR
expression
length
DW_PR_DUu
too
large
for
section
DW_CFA_def_cfa_expression
n
block_len
return
if
check_finstr_addrs
startpoint
instp
instp
block_len
endpoint
DW_CFA_def_cfa_expression
DW_DLV_OK
return
dump_block
char
instp
Dwarf_Signed
block_len
printf
n
if
glflags
verbose
struct
esb_s
exprstring
Dwarf_Error
cerr
int
gres
esb_constructor_fixed
exprstr_buf
sizeof
exprstr_buf
gres
print_location_operations
dbg
die
indent
instp
block_len
addr_size
offset_size
version
if
gres
DW_DLV_OK
printf
s
n
sanitized
esb_get_string
else
if
gres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
nERROR
Unable
to
get
string
from
DW_CFA_def_cfa_expression
block
of
length
DW_PR_DUu
bytes
n
block_len
else
glflags
gf_count_major_errors
printf
nERROR
No
string
from
DW_CFA_def_cfa_expression
block
of
length
DW_PR_DSd
bytes
n
block_len
printf
Error
s
n
dwarf_errmsg
cerr
dwarf_dealloc
dbg
cerr
DW_DLA_ERROR
cerr
esb_destructor
instp
block_len
remaining_len
block_len
off
block_len
break
case
DW_CFA_expression
DWARF3
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_expression
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
Dwarf_Unsigned
block_len
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_expression
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_expression
DW_PR_DUu
expr
block
len
DW_PR_DUu
n
loff
uval
block_len
if
remaining_len
block_len
Dwarf_Unsigned
remaining_len
glflags
gf_count_major_errors
printf
nERROR
expression
length
DW_PR_DUu
too
long
for
section
DW_CFA_expression
n
block_len
return
if
check_finstr_addrs
startpoint
instp
instp
block_len
endpoint
DW_CFA_expression
DW_DLV_OK
return
dump_block
char
instp
Dwarf_Signed
block_len
printf
n
if
glflags
verbose
struct
esb_s
exprstring
int
gres
Dwarf_Error
cerr
esb_constructor_fixed
exprstr_buf
sizeof
exprstr_buf
gres
print_location_operations
dbg
die
indent
instp
block_len
addr_size
offset_size
version
if
gres
DW_DLV_OK
printf
s
n
sanitized
esb_get_string
else
if
gres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
nERROR
Unable
to
get
string
from
DW_CFA_cfa_expression
block
of
length
DW_PR_DUu
bytes
n
block_len
else
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
No
string
from
DW_CFA_cfa_expression
block
of
length
DW_PR_DUu
bytes
n
block_len
printf
Error
s
n
dwarf_errmsg
cerr
dwarf_dealloc
dbg
cerr
DW_DLA_ERROR
printf
s
n
sanitized
esb_get_string
esb_destructor
instp
block_len
remaining_len
block_len
off
block_len
break
case
DW_CFA_offset_extended_sf
DWARF3
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_offset_extended_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
Dwarf_Signed
sval2
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_s_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_offset_extended_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_offset_extended_sf
loff
printreg
uval
config_data
printf
DW_PR_DSd
Dwarf_Signed
sval2
data_alignment_factor
if
glflags
verbose
printf
DW_PR_DSd
d
sval2
int
data_alignment_factor
printf
n
break
case
DW_CFA_def_cfa_sf
DWARF3
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
Dwarf_Signed
sval2
res
local_dwarf_decode_s_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa_sf
loff
printreg
uval
config_data
printf
DW_PR_DSd
sval2
printf
data
alignment
factor
DW_PR_DSd
Dwarf_Signed
sval2
data_alignment_factor
printf
n
break
case
DW_CFA_def_cfa_offset_sf
DWARF3
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
Dwarf_Signed
sval
res
local_dwarf_decode_s_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_def_cfa_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_def_cfa_offset_sf
DW_PR_DSd
data
alignment
factor
DW_PR_DSd
n
loff
sval
Dwarf_Signed
data_alignment_factor
sval
break
case
DW_CFA_val_offset
DWARF3
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_offset
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
Dwarf_Signed
sval2
res
local_dwarf_decode_s_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_offset
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_val_offset
loff
printreg
uval
config_data
printf
DW_PR_DSd
Dwarf_Signed
sval2
data_alignment_factor
if
glflags
verbose
printf
DW_PR_DSd
d
Dwarf_Signed
sval2
int
data_alignment_factor
printf
n
break
case
DW_CFA_val_offset_sf
DWARF3
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_offset_sf
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
Dwarf_Signed
sval2
res
local_dwarf_decode_s_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_offset
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_val_offset_sf
loff
printreg
uval
config_data
printf
DW_PR_DSd
Dwarf_Signed
sval2
data_alignment_factor
if
glflags
verbose
printf
DW_PR_DSd
d
sval2
int
data_alignment_factor
printf
n
break
case
DW_CFA_val_expression
DWARF3
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_expression
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
Dwarf_Unsigned
block_len
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_val_expression
n
return
instp
uleblen
remaining_len
uleblen
off
uleblen
printf
DW_CFA_val_expression
DW_PR_DUu
expr
block
len
DW_PR_DUu
n
loff
uval
block_len
if
remaining_len
block_len
Dwarf_Unsigned
remaining_len
glflags
gf_count_major_errors
printf
nERROR
expression
length
DW_PR_DUu
too
large
for
section
DW_CFA_val_expression
n
block_len
return
if
check_finstr_addrs
startpoint
instp
instp
block_len
endpoint
DW_CFA_val_expression
DW_DLV_OK
return
dump_block
char
instp
Dwarf_Signed
block_len
printf
n
if
glflags
verbose
struct
esb_s
exprstring
int
pres
Dwarf_Error
cerr
esb_constructor_fixed
exprstr_buf
sizeof
exprstr_buf
pres
print_location_operations
dbg
die
indent
instp
block_len
addr_size
offset_size
version
if
pres
DW_DLV_OK
printf
s
n
sanitized
esb_get_string
else
if
pres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
nERROR
Unable
to
get
string
from
DW_CFA_def_cfa_val_expression
block
of
length
DW_PR_DUu
bytes
n
block_len
else
glflags
gf_count_major_errors
printf
nERROR
No
string
from
DW_CFA_def_cfa_val_expression
block
of
length
DW_PR_DUu
bytes
n
block_len
printf
Error
s
n
dwarf_errmsg
cerr
esb_destructor
instp
block_len
remaining_len
block_len
off
block_len
break
Only
in
Metaware
Unknown
meaning
case
DW_CFA_METAWARE_info
Dwarf_Unsigned
val
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_METAWARE_info
n
return
printf
DW_CFA_METAWARE_info
value
DW_PR_DUu
n
loff
val
instp
uleblen
remaining_len
uleblen
off
uleblen
break
ifdef
DW_CFA_GNU_window_save
case
DW_CFA_GNU_window_save
no
information
this
just
tells
unwinder
to
restore
the
window
registers
from
the
previous
frame
s
window
save
area
printf
DW_CFA_GNU_window_save
n
loff
break
endif
ifdef
DW_CFA_GNU_negative_offset_extended
case
DW_CFA_GNU_negative_offset_extended
printf
DW_CFA_GNU_negative_offset_extended
n
loff
break
endif
ifdef
DW_CFA_GNU_args_size
single
uleb128
is
the
current
arg
area
size
in
bytes
no
register
exists
yet
to
save
this
in
case
DW_CFA_GNU_args_size
Dwarf_Unsigned
lreg
instp
is
always
byte
back
so
we
need
when
we
use
it
See
the
final
increment
of
this
for
loop
res
local_dwarf_decode_u_leb128_chk
instp
endpoint
if
res
DW_DLV_OK
glflags
gf_count_major_errors
printf
nERROR
reading
leb
in
DW_CFA_GNU_args_size
n
return
printf
DW_CFA_GNU_args_size
arg
size
DW_PR_DUu
n
loff
lreg
instp
uleblen
remaining_len
uleblen
off
uleblen
break
endif
default
printf
u
Unexpected
op
x
n
loff
unsigned
int
bottom
remaining_len
break
instp
remaining_len
off
if
remaining_len
glflags
gf_count_major_errors
printf
nERROR
reading
frame
instructions
remaining
length
negative
DW_PR_DSd
n
remaining_len
return
if
lastop_pointless
lastop
printf
Warning
Final
FDE
operator
is
useless
but
not
an
error
s
n
get_CFA_name
lastop
true
Print
our
register
names
for
the
cases
we
have
a
name
Delegate
to
the
configure
code
to
actually
do
the
print
void
printreg
Dwarf_Unsigned
reg
struct
dwconf_s
config_data
print_reg_from_config_data
reg
config_data
Actually
does
the
printing
of
a
rule
in
the
table
This
may
print
something
or
may
print
nothing
static
void
print_one_frame_reg_col
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Unsigned
rule_id
Dwarf_Small
value_type
Dwarf_Unsigned
reg_used
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
dwconf_s
config_data
Dwarf_Signed
offset_relevant
Dwarf_Signed
offset
Dwarf_Ptr
block_ptr
char
type_title
int
print_type_title
if
glflags
gf_do_print_dwarf
return
if
reg_used
config_data
cf_initial_rule_value
value_type
DW_EXPR_OFFSET
value_type
DW_EXPR_VAL_OFFSET
This
is
really
an
empty
column
Nothing
to
do
Would
be
great
if
we
could
tell
the
caller
the
next
column
used
here
or
something
return
switch
value_type
case
DW_EXPR_OFFSET
type_title
off
goto
preg2
case
DW_EXPR_VAL_OFFSET
type_title
valoff
preg2
if
print_type_title
printf
s
type_title
printreg
rule_id
config_data
printf
if
offset_relevant
printreg
reg_used
config_data
printf
else
printf
DW_PR_DSd
offset
printf
printreg
reg_used
config_data
printf
if
print_type_title
printf
break
case
DW_EXPR_EXPRESSION
type_title
expr
goto
pexp2
case
DW_EXPR_VAL_EXPRESSION
type_title
valexpr
pexp2
if
print_type_title
printf
s
type_title
printreg
rule_id
config_data
printf
Here
offset
is
actually
block
length
printf
expr
block
len
DW_PR_DSd
offset
if
print_type_title
printf
if
glflags
verbose
printf
printf
s
type_title
printf
bytes
The
data
being
dumped
comes
direct
from
libdwarf
so
libdwarf
validated
it
dump_block
block_ptr
offset
printf
if
glflags
verbose
struct
esb_s
exprstring
char
local_buf
int
gres
Dwarf_Error
cerr
esb_constructor_fixed
local_buf
sizeof
local_buf
Here
offset
is
actually
block
length
gres
print_location_operations
dbg
die
indent
block_ptr
offset
addr_size
offset_size
version
if
gres
DW_DLV_OK
printf
expr
s
sanitized
esb_get_string
else
if
gres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
nERROR
Unable
to
get
string
from
DW_EXPR_VAL_EXPRESSION
block
of
length
DW_PR_DSd
bytes
n
offset
else
glflags
gf_count_major_errors
printf
nERROR
No
string
from
DW_EXPR_VAL_EXPRESSION
block
of
length
DW_PR_DSd
bytes
n
offset
printf
Error
s
n
dwarf_errmsg
cerr
esb_destructor
break
default
printf
Internal
error
in
libdwarf
value
type
d
n
value_type
exit
return
We
do
NOT
want
to
free
cie
fde
data
as
we
will
use
that
in
print_all_cies
static
int
print_all_fdes
Dwarf_Debug
dbg
const
char
frame_section_name
Dwarf_Fde
fde_data
Dwarf_Signed
fde_element_count
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
version
int
is_eh
struct
dwconf_s
config_data
void
map_lowpc_to_name
void
lowpcSet
Dwarf_Die
cu_die_for_print_frames
Dwarf_Error
err
Dwarf_Signed
i
int
frame_count
Do
not
print
if
in
check
mode
if
glflags
gf_do_print_dwarf
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
const
char
stdsecname
if
is_eh
stdsecname
debug_frame
else
stdsecname
eh_frame
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
stdsecname
true
printf
n
s
n
sanitized
esb_get_string
esb_destructor
printf
nfde
n
for
i
i
fde_element_count
i
int
fdres
fdres
print_one_fde
dbg
frame_section_name
fde_data
i
i
cie_data
cie_element_count
address_size
offset_size
version
is_eh
config_data
map_lowpc_to_name
lowpcSet
cu_die_for_print_frames
err
if
fdres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
Printing
fde
DW_PR_DSd
fails
Error
s
n
i
dwarf_errmsg
err
return
fdres
if
fdres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
ERROR
Printing
fde
DW_PR_DSd
fails
saying
no
entry
Impossible
n
i
return
fdres
frame_count
if
frame_count
glflags
break_after_n_units
break
return
DW_DLV_OK
static
int
print_all_cies
Dwarf_Debug
dbg
Dwarf_Cie
cie_data
Dwarf_Signed
cie_element_count
Dwarf_Half
address_size
struct
dwconf_s
config_data
Dwarf_Die
cu_die_for_print_frames
Dwarf_Error
err
Print
the
cie
set
Do
not
print
if
in
check
mode
Dwarf_Signed
i
Dwarf_Signed
cie_count
if
glflags
gf_do_print_dwarf
printf
ncie
n
for
i
i
cie_element_count
i
int
cres
cres
print_one_cie
dbg
cu_die_for_print_frames
cie_data
i
i
address_size
config_data
err
if
cres
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
nERROR
Printing
cie
DW_PR_DSd
fails
Error
s
n
i
dwarf_errmsg
err
return
cres
else
if
cres
DW_DLV_NO_ENTRY
glflags
gf_count_major_errors
printf
nERROR
Printing
cie
DW_PR_DSd
fails
saying
NO_ENTRY
n
i
return
cres
else
cie_count
if
cie_count
glflags
break_after_n_units
break
return
DW_DLV_OK
get
all
the
data
in
debug_frame
or
eh_frame
The
versions
mean
print
using
the
dwarf3
new
interfaces
The
non
mean
use
the
old
interfaces
All
combinations
of
requests
are
possible
int
print_frames
Dwarf_Debug
dbg
int
want_eh
struct
dwconf_s
config_data
Pass
these
next
so
preserved
from
eh_frame
to
debug_frame
Dwarf_Die
cu_die_for_print_frames
void
map_lowpc_to_name
void
lowpcSet
Dwarf_Error
err
int
fres
Dwarf_Half
address_size
Dwarf_Half
offset_size
Dwarf_Half
version
We
only
get
here
if
a
flag
says
we
want
to
process
the
section
want_eh
is
either
or
glflags
current_section_id
DEBUG_FRAME
Only
in
DWARF4
or
later
is
there
a
real
address
size
known
in
the
frame
data
itself
If
any
DIE
is
known
then
a
real
address
size
can
be
gotten
from
dwarf_get_die_address_size
fres
dwarf_get_address_size
dbg
err
if
fres
DW_DLV_OK
glflags
gf_count_major_errors
printf
ERROR
Unable
to
print
frame
section
as
we
cannot
get
the
address
size
n
return
fres
Dwarf_Cie
cie_data
NULL
Dwarf_Signed
cie_element_count
Dwarf_Fde
fde_data
NULL
Dwarf_Signed
fde_element_count
const
char
frame_section_name
int
silent_if_missing
int
is_eh
if
want_eh
Dwarf_Error
localerr
glflags
current_section_id
DEBUG_FRAME
Do
not
free
frame_section_name
fres
dwarf_get_frame_section_name
dbg
if
fres
DW_DLV_OK
frame_section_name
strlen
frame_section_name
frame_section_name
debug_frame
if
fres
DW_DLV_ERROR
dwarf_dealloc
dbg
localerr
DW_DLA_ERROR
localerr
Big
question
here
is
how
to
print
all
the
info?
Can
print
the
logical
matrix
but
that
is
huge
though
could
skip
lines
that
don
t
change
Either
that
or
print
the
instruction
statement
program
that
describes
the
changes
fres
dwarf_get_fde_list
dbg
err
if
glflags
gf_check_harmless
print_any_harmless_errors
dbg
else
want_eh
Dwarf_Error
localerr
glflags
current_section_id
DEBUG_FRAME_EH_GNU
is_eh
This
is
gnu
g
exceptions
in
a
eh_frame
section
Which
is
just
like
debug_frame
except
that
the
empty
or
special
CIE_id
is
not
to
distinguish
fde
from
cie
And
the
augmentation
is
eh
As
of
egcs
anyway
A
non
zero
cie_id
is
in
a
fde
and
is
the
difference
between
the
fde
address
and
the
beginning
of
the
cie
it
belongs
to
This
makes
sense
as
this
is
intended
to
be
referenced
at
run
time
and
is
part
of
the
running
image
For
more
on
augmentation
strings
see
libdwarf
dwarf_frame
c
Big
question
here
is
how
to
print
all
the
info?
Can
print
the
logical
matrix
but
that
is
huge
though
could
skip
lines
that
don
t
change
Either
that
or
print
the
instruction
statement
program
that
describes
the
changes
silent_if_missing
Do
not
free
frame_section_name
fres
dwarf_get_frame_section_name_eh_gnu
dbg
if
fres
DW_DLV_OK
frame_section_name
strlen
frame_section_name
frame_section_name
eh_frame
if
fres
DW_DLV_ERROR
dwarf_dealloc
dbg
localerr
DW_DLA_ERROR
localerr
fres
dwarf_get_fde_list_eh
dbg
err
if
glflags
gf_check_harmless
print_any_harmless_errors
dbg
if
fres
DW_DLV_ERROR
const
char
loc
dwarf_get_fde_list
if
is_eh
loc
dwarf_get_fde_list_eh
glflags
gf_count_major_errors
printf
nERROR
s
not
loadable
s
s
n
sanitized
frame_section_name
loc
dwarf_errmsg
err
return
fres
Do
not
print
any
frame
info
if
in
check
mode
if
glflags
gf_check_frames
if
fres
DW_DLV_OK
dwarf_fde_cie_list_dealloc
dbg
cie_data
cie_element_count
fde_data
fde_element_count
return
DW_DLV_OK
if
fres
DW_DLV_NO_ENTRY
if
silent_if_missing
printf
n
s
is
not
present
n
sanitized
frame_section_name
no
frame
information
return
fres
else
DW_DLV_OK
int
res
res
print_all_fdes
dbg
frame_section_name
fde_data
fde_element_count
cie_data
cie_element_count
address_size
offset_size
version
is_eh
config_data
map_lowpc_to_name
lowpcSet
cu_die_for_print_frames
err
if
res
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
printing
fdes
fails
s
Attempting
to
continue
n
dwarf_errmsg
err
dwarf_dealloc_error
dbg
err
err
res
print_all_cies
dbg
frame_section_name
cie_data
cie_element_count
address_size
offset_size
version
is_eh
config_data
map_lowpc_to_name
lowpcSet
cu_die_for_print_frames
err
if
res
DW_DLV_ERROR
glflags
gf_count_major_errors
printf
ERROR
printing
cies
fails
s
Attempting
to
continue
n
dwarf_errmsg
err
dwarf_dealloc_error
dbg
err
err
Here
we
do
the
free
Not
earlier
dwarf_fde_cie_list_dealloc
dbg
cie_data
cie_element_count
fde_data
fde_element_count
End
inner
scope
not
a
loop
End
inner
scope
not
a
loop
return
DW_DLV_OK
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
static
const
char
dw_dlv_string
int
res
if
res
DW_DLV_ERROR
return
DW_DLV_ERROR
if
res
DW_DLV_NO_ENTRY
return
DW_DLV_NO_ENTRY
if
res
DW_DLV_OK
return
DW_DLV_OK
return
ERROR
Impossible
libdwarf
DW_DLV
code
static
int
print_culist_array
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
cu_list_len
Dwarf_Error
err
Dwarf_Unsigned
list_len
Dwarf_Unsigned
i
int
res
dwarf_gdbindex_culist_array
gdbindex
err
if
res
DW_DLV_NO_ENTRY
return
res
if
res
DW_DLV_ERROR
simple_err_return_msg_either_action
res
ERROR
dwarf_gdbindex_culist_array
failed
return
res
printf
CU
list
array
length
DW_PR_DUu
format
entry
cuoffset
culength
n
list_len
for
i
i
list_len
i
Dwarf_Unsigned
cuoffset
Dwarf_Unsigned
culength
res
dwarf_gdbindex_culist_entry
gdbindex
i
err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_culist_entry
got
s
et
esb_append_printf_u
on
entry
u
i
esb_append_printf_u
of
u
entries
list_len
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
n
i
cuoffset
culength
printf
n
cu_list_len
list_len
return
DW_DLV_OK
static
int
print_types_culist_array
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindex
Dwarf_Error
cular_err
Dwarf_Unsigned
list_len
Dwarf_Unsigned
i
int
res
res
dwarf_gdbindex_types_culist_array
gdbindex
cular_err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_gdbindex_types_culist_array
call
failed
res
cular_err
return
res
printf
TU
list
array
length
DW_PR_DUu
format
entry
cuoffset
culength
signature
n
list_len
for
i
i
list_len
i
Dwarf_Unsigned
cuoffset
Dwarf_Unsigned
culength
Dwarf_Unsigned
signature
res
dwarf_gdbindex_types_culist_entry
gdbindex
i
cular_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_culist_entry
call
got
s
et
esb_append_printf_u
on
entry
u
i
esb_append_printf_u
of
u
entries
list_len
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
n
i
cuoffset
culength
signature
printf
n
return
DW_DLV_OK
static
int
print_addressarea
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindex
Dwarf_Error
addra_err
Dwarf_Unsigned
list_len
Dwarf_Unsigned
i
int
res
dwarf_gdbindex_addressarea
gdbindex
addra_err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_gdbindex_addressarea
failed
res
addra_err
return
res
printf
Address
table
array
length
DW_PR_DUu
format
entry
lowpc
highpc
cu
index
n
list_len
for
i
i
list_len
i
Dwarf_Unsigned
lowpc
Dwarf_Unsigned
highpc
Dwarf_Unsigned
cu_index
res
dwarf_gdbindex_addressarea_entry
gdbindex
i
addra_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_addressarea_entry
call
got
s
et
esb_append_printf_u
on
entry
u
i
esb_append_printf_u
of
u
entries
list_len
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
printf
DW_PR_DUu
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
i
lowpc
highpc
cu_index
printf
n
return
DW_DLV_OK
const
char
kind_list
unknown
type
var
enum
function
other
sym
reserved
function
reserved
static
void
get_kind_string
struct
esb_s
out
unsigned
k
if
k
esb_append
out
sanitized
kind_list
k
return
esb_append
out
kind
erroneous
NOTE
Returns
pointer
to
static
local
string
Use
the
returned
pointer
immediately
or
things
will
not
work
properly
static
void
get_cu_index_string
struct
esb_s
out
Dwarf_Unsigned
index
Dwarf_Unsigned
culist_len
Dwarf_Unsigned
type_index
if
index
culist_len
esb_append_printf_u
out
DW_PR_DUu
index
return
type_index
index
culist_len
esb_append_printf_u
out
DW_PR_DUu
index
esb_append_printf_u
out
T
DW_PR_DUu
type_index
return
static
int
print_symtab_entry
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
index
Dwarf_Unsigned
symnameoffset
Dwarf_Unsigned
cuvecoffset
Dwarf_Unsigned
culist_len
Dwarf_Error
sym_err
int
res
const
char
name
Dwarf_Unsigned
cuvec_len
Dwarf_Unsigned
ii
if
symnameoffset
cuvecoffset
if
glflags
verbose
printf
DW_PR_DUu
empty
hash
entry
n
index
return
DW_DLV_OK
res
dwarf_gdbindex_string_by_offset
gdbindex
symnameoffset
sym_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_string_by_offset
call
failed
with
s
et
esb_append_printf_u
on
offset
lx
symnameoffset
esb_append_printf_u
u
symnameoffset
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
res
dwarf_gdbindex_cuvector_length
gdbindex
cuvecoffset
sym_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_cuvector_length
call
failed
with
s
et
esb_append_printf_u
on
cu
vector
offset
lx
cuvecoffset
esb_append_printf_u
u
cuvecoffset
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
if
glflags
verbose
printf
DW_PR_DUu
stroff
DW_PR_XZEROS
DW_PR_DUx
cuvecoff
DW_PR_XZEROS
DW_PR_DUx
cuveclen
DW_PR_XZEROS
DW_PR_DUx
n
index
symnameoffset
cuvecoffset
cuvec_len
for
ii
ii
cuvec_len
ii
Dwarf_Unsigned
attributes
Dwarf_Unsigned
cu_index
Dwarf_Unsigned
reserved1
Dwarf_Unsigned
symbol_kind
Dwarf_Unsigned
is_static
struct
esb_s
tmp_cuindx
struct
esb_s
tmp_kind
res
dwarf_gdbindex_cuvector_inner_attributes
gdbindex
cuvecoffset
ii
sym_err
if
res
DW_DLV_OK
print_error_and_continue
dbg
dwarf_gdbindex_cuvector_inner_attributes
failed
res
sym_err
return
res
res
dwarf_gdbindex_cuvector_instance_expand_value
gdbindex
attributes
sym_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_gdbindex_cuvector_instance_expand
_value
call
failed
with
s
et
esb_append_printf_u
on
cu
vector
index
d
ii
esb_append_printf_u
on
of
d
entries
cuvec_len
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
if
cu_index
is
the
cu
count
then
it
refers
to
a
tu_index
of
cu_index
cu
count
esb_constructor
esb_constructor
get_kind_string
symbol_kind
get_cu_index_string
cu_index
culist_len
if
cuvec_len
printf
DW_PR_DUu
s
s
s
s
n
index
esb_get_string
is_static?
static
global
esb_get_string
sanitized
name
else
if
ii
printf
DW_PR_DUu
s
n
index
sanitized
name
printf
s
s
s
n
esb_get_string
is_static?
static
global
esb_get_string
else
printf
s
s
s
n
esb_get_string
is_static?
static
global
esb_get_string
esb_destructor
esb_destructor
if
glflags
verbose
printf
DW_PR_DUu
attr
DW_PR_XZEROS
DW_PR_DUx
cuindx
DW_PR_XZEROS
DW_PR_DUx
kind
DW_PR_XZEROS
DW_PR_DUx
static
DW_PR_XZEROS
DW_PR_DUx
n
ii
attributes
cu_index
symbol_kind
is_static
return
DW_DLV_OK
static
int
print_symboltable
Dwarf_Debug
dbg
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
culist_len
Dwarf_Error
symt_err
Dwarf_Unsigned
list_len
Dwarf_Unsigned
i
int
res
dwarf_gdbindex_symboltable_array
gdbindex
symt_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_get_gdbindex_symboltable_array
call
failed
with
s
et
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
printf
n
Symbol
table
length
DW_PR_DUu
format
entry
symindex
cuindex
type
name
or
n
list_len
printf
format
entry
name
list
of
cuindex
type
n
for
i
i
list_len
i
Dwarf_Unsigned
symnameoffset
Dwarf_Unsigned
cuvecoffset
res
dwarf_gdbindex_symboltable_entry
gdbindex
i
symt_err
if
res
DW_DLV_OK
struct
esb_s
msg
const
char
et
dw_dlv_string
res
esb_constructor
esb_append_printf_s
ERROR
dwarf_gdbindex_symboltable_entry
call
failed
with
s
et
esb_append_printf_u
on
symtab
index
d
i
esb_append_printf_u
on
of
d
entries
list_len
simple_err_return_action
res
esb_get_string
esb_destructor
return
res
res
print_symtab_entry
dbg
gdbindex
i
symnameoffset
cuvecoffset
culist_len
symt_err
if
res
DW_DLV_OK
return
res
printf
n
return
DW_DLV_OK
int
print_gdb_index
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Gdbindex
gdbindex
Dwarf_Unsigned
version
Dwarf_Unsigned
cu_list_offset
Dwarf_Unsigned
types_cu_list_offset
Dwarf_Unsigned
address_area_offset
Dwarf_Unsigned
symbol_table_offset
Dwarf_Unsigned
constant_pool_offset
Dwarf_Unsigned
section_size
Dwarf_Unsigned
unused
const
char
section_name
unused
Dwarf_Unsigned
culist_len
int
res
glflags
current_section_id
DEBUG_GDB_INDEX
if
glflags
gf_do_print_dwarf
return
DW_DLV_OK
res
dwarf_gdbindex_header
dbg
err
if
res
DW_DLV_NO_ENTRY
Silently
The
section
is
rare
so
lets
say
nothing
return
res
if
res
DW_DLV_ERROR
simple_err_return_msg_either_action
res
ERROR
gdb_index
not
readable
return
res
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
gdb_index
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
printf
Version
DW_PR_XZEROS
DW_PR_DUx
n
version
printf
CU
list
offset
DW_PR_XZEROS
DW_PR_DUx
n
cu_list_offset
printf
Address
area
offset
DW_PR_XZEROS
DW_PR_DUx
n
types_cu_list_offset
printf
Symbol
table
offset
DW_PR_XZEROS
DW_PR_DUx
n
address_area_offset
printf
Constant
pool
offset
DW_PR_XZEROS
DW_PR_DUx
n
constant_pool_offset
printf
section
size
DW_PR_XZEROS
DW_PR_DUx
n
section_size
res
print_culist_array
dbg
gdbindex
err
if
res
DW_DLV_OK
dwarf_gdbindex_free
gdbindex
return
res
res
print_types_culist_array
dbg
gdbindex
err
if
res
DW_DLV_OK
dwarf_gdbindex_free
gdbindex
return
res
res
print_addressarea
dbg
gdbindex
err
if
res
DW_DLV_OK
dwarf_gdbindex_free
gdbindex
return
res
res
print_symboltable
dbg
gdbindex
culist_len
err
dwarf_gdbindex_free
gdbindex
return
res
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
print_frames
h
for
print_location_operations
include
macrocheck
h
include
helpertree
h
include
tag_common
h
Is
this
a
PU
has
been
invalidated
by
the
SN
Systems
linker?
define
IsInvalidCode
low
high
low
max_address
low
high
Most
types
of
CU
can
have
highpc
and
or
lowpc
DW_TAG_type_unit
will
not
static
Dwarf_Bool
cu_tag_type_may_have_lopc_hipc
int
tag
if
tag
DW_TAG_compile_unit
return
TRUE
if
tag
DW_TAG_partial_unit
return
TRUE
if
tag
DW_TAG_skeleton_unit
return
TRUE
return
FALSE
This
updates
values
in
glflags
used
for
reporting
in
error
cases
static
void
update_cu_base_addresses
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Half
attr
Dwarf_Half
tag
LoHiPc
lohipc
Dwarf_Error
err
Update
base
address
for
CU
if
attr
DW_AT_low_pc
if
glflags
need_CU_base_address
cu_tag_type_may_have_lopc_hipc
tag
int
lres
dwarf_formaddr
attrib
CU_base_address
err
DROP_ERROR_INSTANCE
dbg
lres
err
if
lres
DW_DLV_OK
glflags
need_CU_base_address
FALSE
glflags
CU_low_address
glflags
CU_base_address
else
if
glflags
CU_low_address
We
take
the
first
non
zero
address
as
meaningful
Even
if
no
such
in
CU
DIE
int
fres
dwarf_formaddr
attrib
CU_low_address
err
DROP_ERROR_INSTANCE
dbg
fres
err
if
fres
DW_DLV_OK
Stop
looking
for
base
Bogus
but
there
is
none
available
so
stop
glflags
need_CU_base_address
FALSE
Update
high
address
for
CU
if
attr
DW_AT_high_pc
if
glflags
need_CU_high_address
This
is
bogus
in
that
it
accepts
the
first
high
address
in
the
CU
from
any
TAG
if
lohipc
sawhi_flag
LOHIPC_SAWADDR
glflags
need_CU_high_address
FALSE
glflags
CU_high_address
lohipc
hival
else
if
lohipc
havefinal_flag
glflags
CU_high_address
lohipc
hifinal
glflags
need_CU_high_address
FALSE
if
static
void
dumplohipc
LoHiPc
hilopc
char
msg
int
line
printf
LoHiPc
s
line
d
sawlo
d
DW_PR_XZEROS
DW_PR_DUx
n
msg
line
hilopc
sawlo_flag
hilopc
lopc
printf
sawhi
d
DW_PR_XZEROS
DW_PR_DUx
n
hilopc
sawhi_flag
hilopc
hival
printf
havefinal
d
DW_PR_XZEROS
DW_PR_DUx
n
hilopc
havefinal_flag
hilopc
hifinal
endif
ASSERT
attrnum
DW_AT_low_pc
or
DW_AT_high_pc
This
does
not
print
errors
as
those
checks
will
be
redone
by
other
related
code
static
void
get_pc_value
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Half
attrnum
Dwarf_Half
theform
LoHiPc
lohipc
Dwarf_Error
err
int
bres
int
islowaddr
attrnum
DW_AT_low_pc
FALSE
Dwarf_Unsigned
uval
Dwarf_Addr
addr
if
islowaddr
theform
DW_FORM_addr
dwarf_addr_form_is_indexed
theform
New
in
DWARF4
other
forms
of
class
constant
are
not
an
address
but
are
instead
offset
from
pc
bres
dwarf_formudata
attrib
err
if
bres
DW_DLV_OK
if
lohipc
sawhi_flag
lohipc
sawhi_flag
LOHIPC_SAWOFFSET
lohipc
hival
uval
if
lohipc
sawlo_flag
lohipc
havefinal_flag
lohipc
havefinal_flag
TRUE
lohipc
hifinal
lohipc
lopc
uval
else
if
bres
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
bres
err
return
bres
dwarf_formaddr
attrib
err
if
bres
DW_DLV_OK
if
islowaddr
lohipc
lopc
addr
lohipc
sawlo_flag
TRUE
if
lohipc
sawhi_flag
LOHIPC_SAWOFFSET
lohipc
havefinal_flag
lohipc
havefinal_flag
TRUE
lohipc
hifinal
addr
lohipc
hival
else
if
lohipc
sawhi_flag
lohipc
hival
addr
lohipc
sawhi_flag
TRUE
lohipc
hifinal
addr
lohipc
havefinal_flag
TRUE
else
if
bres
DW_DLV_ERROR
DROP_ERROR_INSTANCE
dbg
bres
err
int
print_hipc_lopc_attribute
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Die
die
int
die_indent_level
Dwarf_Unsigned
dieprint_cu_goffset
char
srcfiles
Dwarf_Signed
cnt
Dwarf_Attribute
attrib
Dwarf_Half
attr
Dwarf_Unsigned
max_address
LoHiPc
lohipc
struct
esb_s
valname
Dwarf_Error
err
Dwarf_Half
theform
int
rv
For
DWARF4
the
high_pc
offset
from
the
low_pc
Dwarf_Unsigned
highpcOff
char
highpcstrbuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
highpcstr
esb_constructor_fixed
highpcstrbuf
sizeof
highpcstrbuf
rv
dwarf_whatform
attrib
err
Depending
on
the
form
and
the
attribute
process
the
form
if
rv
DW_DLV_ERROR
print_error_and_continue
dbg
in
print_attribute
dwarf_whatform
cannot
Find
attr
form
rv
err
esb_destructor
return
rv
else
if
rv
DW_DLV_NO_ENTRY
esb_destructor
return
rv
get_pc_value
dbg
attrib
attr
theform
lohipc
err
Determine
if
the
high
pc
is
really
an
offset
set
offset_detected
flag
if
so
if
theform
DW_FORM_addr
dwarf_addr_form_is_indexed
theform
New
in
DWARF4
other
forms
of
class
constant
are
not
an
address
but
are
instead
offset
from
pc
One
could
test
for
DWARF4
here
before
adding
this
string
but
that
seems
unnecessary
as
this
could
not
happen
with
DWARF3
or
earlier
A
normal
consumer
would
have
to
add
this
value
to
DW_AT_low_pc
to
get
a
true
pc
esb_append
offset
from
lowpc
Update
the
high_pc
value
if
we
are
checking
the
ranges
if
glflags
gf_check_ranges
attr
DW_AT_high_pc
Get
the
offset
value
int
show_form_here
int
ares
dd_get_integer_and_name
dbg
attrib
attrname
const
char
NULL
err_string
struct
esb_s
NULL
encoding_type_func
err
show_form_here
if
ares
DW_DLV_OK
if
ares
DW_DLV_NO_ENTRY
print_error_and_continue
dbg
dd_get_integer_and_name
No
Entry
for
DW_AT_high_pc
DW_AT_low_pc
ares
err
else
print_error_and_continue
dbg
dd_get_integer_and_name
Failed
for
DW_AT_high_pc
DW_AT_low_pc
ares
err
esb_destructor
return
ares
rv
get_attr_value
dbg
tag
die
die_indent_level
dieprint_cu_goffset
attrib
srcfiles
cnt
glflags
show_form_used
glflags
verbose
err
if
rv
DW_DLV_ERROR
return
rv
if
lohipc
sawhi_flag
LOHIPC_SAWOFFSET
lohipc
havefinal_flag
esb_append_printf_u
highpc
DW_PR_XZEROS
DW_PR_DUx
lohipc
hifinal
esb_empty_string
valname
esb_append
valname
esb_get_string
esb_destructor
Update
base
and
high
addresses
for
CU
if
glflags
seen_CU
glflags
need_CU_base_address
glflags
need_CU_high_address
updating
glflags
data
for
checking
reporting
later
update_cu_base_addresses
dbg
attrib
attr
tag
lohipc
err
if
glflags
gf_check_decl_file
glflags
gf_check_ranges
glflags
gf_check_locations
if
glflags
seen_PU
glflags
seen_PU_base_address
lohipc
sawlo_flag
glflags
seen_PU_base_address
TRUE
glflags
PU_base_address
lohipc
lopc
if
glflags
seen_PU
glflags
seen_PU_high_address
lohipc
havefinal_flag
glflags
seen_PU_high_address
TRUE
glflags
PU_high_address
lohipc
hifinal
We
have
now
both
low_pc
and
high_pc
values
if
lohipc
havefinal_flag
lohipc
sawlo_flag
We
need
to
decide
if
this
PU
is
valid
as
the
SN
Linker
marks
a
stripped
function
by
setting
lowpc
to
also
for
discarded
comdat
both
lowpc
and
highpc
are
zero
Dwarf_Unsigned
lowaddr
lohipc
lopc
Dwarf_Unsigned
highaddr
lohipc
hifinal
if
glflags
need_PU_valid_code
glflags
need_PU_valid_code
FALSE
To
ignore
a
PU
as
invalid
code
only
consider
the
lowpc
and
highpc
values
associated
with
the
DW_TAG_subprogram
other
instances
of
lowpc
and
highpc
must
be
ignored
lexical
blocks
glflags
in_valid_code
TRUE
if
IsInvalidCode
lowaddr
highaddr
tag
DW_TAG_subprogram
glflags
in_valid_code
FALSE
We
have
a
low_pc
high_pc
pair
check
if
they
are
valid
if
glflags
in_valid_code
DWARF_CHECK_COUNT
ranges_result
if
lowaddr
max_address
lowaddr
highaddr
DWARF_CHECK_ERROR
ranges_result
debug_info
Incorrect
values
for
low_pc
high_pc
if
glflags
gf_check_verbose_mode
PRINTING_UNIQUE
printf
Low
DW_PR_XZEROS
DW_PR_DUx
High
DW_PR_XZEROS
DW_PR_DUx
n
lowaddr
highaddr
if
glflags
gf_check_decl_file
glflags
gf_check_ranges
glflags
gf_check_locations
AddEntryIntoBucketGroup
glflags
pRangesInfo
lowaddr
lowaddr
highaddr
NULL
FALSE
esb_destructor
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
Google
Inc
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
uri
h
include
ctype
h
include
time
h
include
print_sections
h
Print
line
number
information
line
address
new
statement
new
basic
block
filename
define
DW_LINE_VERSION5
static
void
print_source_intro
Dwarf_Debug
dbg
Dwarf_Die
cu_die
int
ores
Dwarf_Off
off
Dwarf_Error
src_err
ores
dwarf_dieoffset
cu_die
if
ores
DW_DLV_OK
int
lres
const
char
sec_name
lres
dwarf_get_die_section_name_b
cu_die
if
lres
DW_DLV_OK
sec_name
strlen
sec_name
sec_name
debug_info
printf
Source
lines
from
CU
DIE
at
s
offset
DW_PR_XZEROS
DW_PR_DUx
n
sec_name
Dwarf_Unsigned
off
DROP_ERROR_INSTANCE
dbg
lres
src_err
else
DROP_ERROR_INSTANCE
dbg
ores
src_err
printf
Source
lines
for
the
CU
DIE
at
unknown
location
n
static
void
record_line_error
const
char
where
Dwarf_Error
line_err
if
glflags
gf_check_lines
checking_this_compiler
struct
esb_s
tmp_buff
char
buftmp
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
buftmp
sizeof
buftmp
esb_append_printf_s
Error
getting
line
details
calling
s
where
esb_append_printf_s
dwarf
error
is
s
dwarf_errmsg
line_err
DWARF_CHECK_ERROR
lines_result
esb_get_string
esb_destructor
static
void
check_last_line_of_table
Dwarf_Addr
pc
Dwarf_Addr
elf_max_address
const
char
sec_name
Ignore
those
PU
that
have
been
stripped
by
the
linker
their
low_pc
values
are
set
to
snc
linker
only
It
is
perfectly
sensible
for
a
compiler
to
leave
a
few
bytes
of
NOP
or
other
stuff
after
the
last
instruction
in
a
subprogram
for
cache
alignment
or
other
purposes
so
a
mismatch
here
is
not
necessarily
an
error
if
glflags
gf_check_lines
checking_this_compiler
DWARF_CHECK_COUNT
lines_result
if
pc
glflags
PU_high_address
glflags
PU_base_address
elf_max_address
char
addr_tmp
struct
esb_s
cm
esb_constructor_fixed
addr_tmp
sizeof
addr_tmp
esb_append_printf_s
s
Address
sanitized
sec_name
esb_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
DW_LNE_end_sequence
address
does
not
exactly
match
pc
esb_append_printf_u
high
function
addr
DW_PR_XZEROS
DW_PR_DUx
glflags
PU_high_address
DWARF_CHECK_ERROR
lines_result
esb_get_string
esb_destructor
static
int
process_line_table
Dwarf_Debug
dbg
const
char
sec_name
Dwarf_Line
linebuf
Dwarf_Signed
linecount
Dwarf_Bool
is_logicals_table
Dwarf_Bool
is_actuals_table
Dwarf_Error
lt_err
char
padding
Dwarf_Signed
i
Dwarf_Addr
pc
Dwarf_Unsigned
lineno
Dwarf_Unsigned
logicalno
Dwarf_Unsigned
column
Dwarf_Unsigned
call_context
char
subprog_name
char
subprog_filename
Dwarf_Unsigned
subprog_line
Dwarf_Bool
newstatement
Dwarf_Bool
lineendsequence
Dwarf_Bool
new_basic_block
int
sres
int
ares
int
lires
int
cores
char
lastsrc_tmp
ESB_FIXED_ALLOC_SIZE
struct
esb_s
lastsrc
Dwarf_Addr
elf_max_address
Dwarf_Bool
SkipRecord
FALSE
esb_constructor_fixed
lastsrc_tmp
sizeof
lastsrc_tmp
glflags
current_section_id
DEBUG_LINE
line_flag
is
TRUE
get_address_size_and_max
dbg
lt_err
Padding
for
a
nice
layout
padding
glflags
gf_line_print_pc
if
glflags
gf_do_print_dwarf
Check
if
print
of
pc
address
is
needed
printf
n
if
is_logicals_table
printf
Logicals
Table
n
printf
sNS
new
statement
PE
prologue
end
EB
epilogue
begin
n
padding
printf
sDI
val
discriminator
value
n
padding
printf
sCC
val
context
SB
val
subprogram
n
padding
else
if
is_actuals_table
printf
Actuals
Table
n
printf
sBB
new
basic
block
ET
end
of
text
sequence
n
sIS
val
ISA
number
n
padding
padding
else
Standard
DWARF
line
table
printf
sNS
new
statement
BB
new
basic
block
ET
end
of
text
sequence
n
padding
printf
sPE
prologue
end
EB
epilogue
begin
n
padding
printf
sIS
val
ISA
number
DI
val
discriminator
value
n
padding
if
is_logicals_table
is_actuals_table
printf
row
if
glflags
gf_line_print_pc
printf
pc
if
is_logicals_table
printf
lno
col
NS
PE
EB
DI
CC
SB
uri
filepath
n
else
if
is_actuals_table
printf
logical
BB
ET
IS
n
else
printf
lno
col
NS
BB
ET
PE
EB
IS
DI
uri
filepath
n
for
i
i
linecount
i
Dwarf_Line
line
linebuf
i
char
lsrc_filename
int
nsres
Dwarf_Bool
found_line_error
FALSE
Dwarf_Bool
has_is_addr_set
FALSE
char
where
NULL
if
glflags
gf_check_decl_file
checking_this_compiler
A
line
record
with
addr
was
detected
if
SkipRecord
Skip
records
that
do
not
have
is_addr_set
ares
dwarf_line_is_addr_set
line
lt_err
if
ares
DW_DLV_OK
has_is_addr_set
SkipRecord
FALSE
else
Keep
ignoring
records
until
we
have
one
with
is_addr_set
continue
if
glflags
gf_check_lines
checking_this_compiler
DWARF_CHECK_COUNT
lines_result
NO
lsrc_filename
is
a
DW_DLA_STRING
do
not
assign
a
static
string
lsrc_filename
unknown
if
is_actuals_table
Dwarf_Error
aterr
sres
dwarf_linesrc
line
if
sres
DW_DLV_ERROR
Do
not
terminate
processing
where
dwarf_linesrc
record_line_error
where
aterr
found_line_error
TRUE
DROP_ERROR_INSTANCE
dbg
sres
aterr
pc
ares
dwarf_lineaddr
line
lt_err
if
ares
DW_DLV_ERROR
Do
not
terminate
processing
where
dwarf_lineaddr
record_line_error
where
lt_err
found_line_error
TRUE
pc
DROP_ERROR_INSTANCE
dbg
ares
lt_err
if
ares
DW_DLV_NO_ENTRY
pc
if
is_actuals_table
lires
dwarf_linelogical
line
lt_err
if
lires
DW_DLV_ERROR
Do
not
terminate
processing
where
dwarf_linelogical
record_line_error
where
lt_err
found_line_error
TRUE
DROP_ERROR_INSTANCE
dbg
lires
lt_err
if
lires
DW_DLV_NO_ENTRY
logicalno
column
else
lires
dwarf_lineno
line
lt_err
if
lires
DW_DLV_ERROR
Do
not
terminate
processing
where
dwarf_lineno
record_line_error
where
lt_err
found_line_error
TRUE
DROP_ERROR_INSTANCE
dbg
lires
lt_err
if
lires
DW_DLV_NO_ENTRY
lineno
cores
dwarf_lineoff_b
line
lt_err
if
cores
DW_DLV_ERROR
Do
not
terminate
processing
where
dwarf_lineoff
record_line_error
where
lt_err
found_line_error
TRUE
DROP_ERROR_INSTANCE
dbg
cores
lt_err
if
cores
DW_DLV_NO_ENTRY
Zero
was
always
the
correct
default
meaning
the
left
edge
DWARF2
spec
sec
column
Process
any
possible
error
condition
though
we
won
t
be
at
the
first
such
error
if
glflags
gf_check_decl_file
checking_this_compiler
DWARF_CHECK_COUNT
decl_file_result
if
found_line_error
DWARF_CHECK_ERROR2
decl_file_result
where
dwarf_errmsg
lt_err
else
if
glflags
gf_do_check_dwarf
Check
the
address
lies
with
a
valid
lowPC
highPC
in
the
text
section
if
IsValidInBucketGroup
glflags
pRangesInfo
pc
Valid
values
do
nothing
else
At
this
point
may
be
we
are
dealing
with
a
linkonce
symbol
The
problem
we
have
here
is
we
have
consumed
the
deug_info
section
and
we
are
dealing
just
with
the
records
from
the
debug_line
so
no
PU_name
is
available
and
no
high_pc
Traverse
the
linkonce
table
if
try
to
match
the
pc
value
with
one
of
those
ranges
if
glflags
gf_check_lines
checking_this_compiler
DWARF_CHECK_COUNT
lines_result
if
FindAddressInBucketGroup
glflags
pLinkonceInfo
pc
Valid
values
do
nothing
else
The
SN
Systems
Linker
generates
line
records
with
addr
when
dealing
with
linkonce
symbols
and
no
stripping
if
pc
if
glflags
gf_check_lines
checking_this_compiler
char
abuf
struct
esb_s
atm
esb_constructor_fixed
abuf
sizeof
abuf
esb_append_printf_s
s
Address
sanitized
sec_name
esb_append_printf_u
DW_PR_XZEROS
DW_PR_DUx
outside
a
valid
text
range
pc
DWARF_CHECK_ERROR
lines_result
esb_get_string
esb_destructor
else
SkipRecord
TRUE
end
not
in
bucket
group
Check
the
last
record
for
the
debug_line
the
one
created
by
DW_LNE_end_sequence
is
the
same
as
the
high_pc
address
for
the
last
known
user
program
unit
PU
There
is
no
real
reason
if
i
linecount
glflags
seen_PU_high_address
is_logicals_table
check_last_line_of_table
pc
elf_max_address
sec_name
end
seen_PU_high_address
Display
the
error
information
if
found_line_error
glflags
gf_record_dwarf_error
if
glflags
gf_check_verbose_mode
PRINTING_UNIQUE
Print
the
record
number
for
better
error
description
printf
Record
DW_PR_DUu
Addr
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
DW_PR_DUu
s
n
i
pc
lineno
column
lsrc_filename?sanitized
lsrc_filename
The
compilation
unit
was
already
printed
if
glflags
gf_check_decl_file
PRINT_CU_INFO
glflags
gf_record_dwarf_error
FALSE
Due
to
a
fatal
error
skip
current
record
if
found_line_error
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
continue
if
glflags
gf_do_print_dwarf
if
is_logicals_table
is_actuals_table
printf
DW_PR_DUu
i
Check
if
print
of
pc
address
is
needed
if
glflags
gf_line_print_pc
printf
DW_PR_XZEROS
DW_PR_DUx
pc
if
is_actuals_table
printf
DW_PR_DUu
logicalno
else
printf
DW_PR_DUu
DW_PR_DUu
lineno
column
if
is_actuals_table
nsres
dwarf_linebeginstatement
line
lt_err
if
nsres
DW_DLV_OK
if
newstatement
glflags
gf_do_print_dwarf
printf
s
NS
else
if
nsres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_linebeginstatement
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
nsres
if
is_logicals_table
nsres
dwarf_lineblock
line
lt_err
if
nsres
DW_DLV_OK
if
new_basic_block
glflags
gf_do_print_dwarf
printf
s
BB
else
if
nsres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_lineblock
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
nsres
nsres
dwarf_lineendsequence
line
lt_err
if
nsres
DW_DLV_OK
if
lineendsequence
glflags
gf_do_print_dwarf
printf
s
ET
else
if
nsres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_lineendsequence
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
nsres
if
glflags
gf_do_print_dwarf
Dwarf_Bool
prologue_end
Dwarf_Bool
epilogue_begin
Dwarf_Unsigned
isa
Dwarf_Unsigned
discriminator
int
disres
dwarf_prologue_end_etc
line
lt_err
if
disres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_prologue_end_etc
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
disres
if
prologue_end
is_actuals_table
printf
PE
if
epilogue_begin
is_actuals_table
printf
EB
if
isa
is_logicals_table
printf
IS
DW_PR_DUx
isa
if
discriminator
is_actuals_table
printf
DI
DW_PR_DUx
discriminator
if
is_logicals_table
call_context
disres
dwarf_linecontext
line
lt_err
if
disres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_linecontext
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
disres
if
call_context
printf
CC
DW_PR_DUu
call_context
subprog_name
disres
dwarf_line_subprog
line
lt_err
if
disres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_line_subprog
failed
on
linebuf
index
u
i
esb_append_printf_u
of
u
line
records
in
the
linebuf
linecount
simple_err_return_action
nsres
esb_get_string
esb_destructor
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
return
disres
if
subprog_name
strlen
subprog_name
We
do
not
print
an
empty
name
Clutters
things
up
printf
SB
s
sanitized
subprog_name
dwarf_dealloc
dbg
subprog_filename
DW_DLA_STRING
subprog_filename
if
is_actuals_table
if
i
glflags
verbose
strcmp
lsrc_filename?lsrc_filename
esb_get_string
struct
esb_s
urs
char
atmp2
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
atmp2
sizeof
atmp2
esb_append
uri
translate_to_uri
lsrc_filename?
lsrc_filename
esb_append
if
glflags
gf_do_print_dwarf
printf
s
esb_get_string
esb_destructor
esb_empty_string
esb_append
lsrc_filename?lsrc_filename
else
Do
not
print
name
it
is
the
same
as
the
last
name
printed
if
glflags
gf_do_print_dwarf
printf
n
dwarf_dealloc
dbg
lsrc_filename
DW_DLA_STRING
lsrc_filename
esb_destructor
return
DW_DLV_OK
Here
we
test
the
interfaces
into
Dwarf_Line_Context
static
int
print_line_context_record
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Line_Context
line_context
Dwarf_Error
err
int
vres
Dwarf_Unsigned
lsecoff
Dwarf_Unsigned
version
Dwarf_Signed
dir_count
Dwarf_Signed
baseindex
Dwarf_Signed
file_count
Dwarf_Signed
endindex
Dwarf_Signed
i
Dwarf_Signed
subprog_count
const
char
name
Dwarf_Small
table_count
struct
esb_s
bufr
int
include_dir_base
DWARF2
int
include_dir_limit
set
below
char
bufr_tmp
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
bufr_tmp
sizeof
bufr_tmp
printf
Line
Context
data
n
vres
dwarf_srclines_table_offset
line_context
err
if
vres
DW_DLV_OK
simple_err_return_action
vres
nERROR
dwarf_srclines_table_offset
failed
Something
broken
return
vres
printf
Line
Section
Offset
DW_PR_XZEROS
DW_PR_DUx
n
lsecoff
vres
dwarf_srclines_version
line_context
err
if
vres
DW_DLV_OK
simple_err_return_action
vres
nERROR
dwarf_srclines_version
failed
Something
broken
return
vres
printf
version
number
DW_PR_DUx
DW_PR_DUu
n
version
version
printf
number
of
line
tables
d
n
table_count
vres
dwarf_srclines_comp_dir
line_context
err
if
vres
DW_DLV_OK
simple_err_return_action
vres
nERROR
dwarf_srclines_comp_dir
failed
Something
broken
return
vres
if
name
printf
Compilation
directory
s
n
name
else
printf
Compilation
directory
unknown
no
DW_AT_comp_dir
n
vres
dwarf_srclines_include_dir_count
line_context
err
if
vres
DW_DLV_OK
simple_err_return_action
vres
nERROR
dwarf_srclines_comp_dir
failed
Something
broken
return
vres
printf
include
directory
count
DW_PR_DUx
DW_PR_DSd
n
Dwarf_Unsigned
dir_count
dir_count
if
version
DW_LINE_VERSION5
include_dir_base
include_dir_limit
dir_count
else
include_dir_base
include_dir_limit
dir_count
for
i
include_dir_base
i
include_dir_limit
i
vres
dwarf_srclines_include_dir_data
line_context
i
err
if
vres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_i
nERROR
Error
accessing
include
directory
d
i
esb_append_printf_i
max
allowed
index
is
d
dir_count
simple_err_return_action
vres
esb_get_string
esb_destructor
return
vres
printf
DW_PR_DSd
s
n
i
name
vres
dwarf_srclines_files_indexes
line_context
err
if
vres
DW_DLV_OK
simple_err_return_action
vres
nERROR
Error
accessing
files
indexes
return
vres
printf
files
count
DW_PR_DUx
DW_PR_DUu
n
file_count
file_count
Set
up
so
just
one
loop
control
needed
for
all
versions
of
line
tables
for
i
baseindex
i
endindex
i
Dwarf_Unsigned
dirindex
Dwarf_Unsigned
modtime
Dwarf_Unsigned
flength
Dwarf_Form_Data16
md5data
vres
dwarf_srclines_files_data_b
line_context
i
err
if
vres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_i
nERROR
Error
accessing
line_context
calling
dwarf_srclines_files_data_b
with
index
d
i
esb_append_printf_i
end
index
is
d
endindex
simple_err_return_action
vres
esb_get_string
esb_destructor
return
vres
esb_empty_string
if
name
esb_empty_string
esb_append
esb_append
name
esb_append
else
esb_append
ERROR
NULL
name
in
files
list
printf
DW_PR_DSd
i
esb_get_string
printf
directory
index
DW_PR_DUu
dirindex
printf
file
length
DW_PR_DUu
flength
if
md5data
char
c
char
md5data
char
end
c
sizeof
md5data
printf
file
md5
value
while
c
end
printf
c
c
printf
if
modtime
time_t
tt3
time_t
modtime
ctime
supplies
newline
printf
file
mod
time
x
s
unsigned
tt3
ctime
else
printf
file
mod
time
n
esb_destructor
vres
dwarf_srclines_subprog_count
line_context
err
if
vres
DW_DLV_OK
simple_err_return_msg_either_action
vres
ERROR
dwarf_srclines_subprog_count
on
a
line_context
fails
return
vres
if
subprog_count
return
DW_DLV_OK
The
following
is
for
the
experimental
table
which
is
only
DWARF4
so
far
so
no
need
for
a
dwarf_srclines_subprog_indexes
function
Yet
printf
subprograms
count
experimental
DW_PR_DUx
DW_PR_DUu
n
subprog_count
subprog_count
for
i
i
subprog_count
i
Dwarf_Unsigned
decl_file
Dwarf_Unsigned
decl_line
vres
dwarf_srclines_subprog_data
line_context
i
err
if
vres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_i
nERROR
Error
accessing
line_context
calling
dwarf_srclines_subprog_data
with
index
d
i
esb_append_printf_i
end
index
is
d
subprog_count
simple_err_return_action
vres
esb_get_string
esb_destructor
return
vres
printf
DW_PR_DSd
s
fileindex
DW_PR_DUu
lineindex
DW_PR_DUu
n
i
name
decl_file
decl_line
return
DW_DLV_OK
int
print_line_numbers_this_cu
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
srcfiles
Dwarf_Signed
srcf_count
Dwarf_Error
err
Dwarf_Unsigned
lineversion
Dwarf_Signed
linecount
Dwarf_Line
linebuf
NULL
Dwarf_Signed
linecount_actuals
Dwarf_Line
linebuf_actuals
NULL
Dwarf_Small
table_count
int
lres
int
line_errs
Dwarf_Line_Context
line_context
const
char
sec_name
Dwarf_Off
cudie_local_offset
Dwarf_Off
dieprint_cu_goffset
int
atres
glflags
current_section_id
DEBUG_LINE
line_flag
is
TRUE
lres
dwarf_get_line_section_name_from_die
cu_die
err
if
lres
DW_DLV_OK
sec_name
strlen
sec_name
sec_name
debug_line
DROP_ERROR_INSTANCE
dbg
lres
err
The
offsets
will
be
zero
if
it
fails
Let
it
pass
atres
dwarf_die_offsets
cu_die
err
DROP_ERROR_INSTANCE
dbg
atres
err
if
glflags
gf_do_print_dwarf
struct
esb_s
truename
char
buf
ESB_FIXED_ALLOC_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_line
FALSE
Ignore
the
COMPRESSED
flags
printf
n
s
line
number
info
for
a
single
cu
n
sanitized
esb_get_string
esb_destructor
else
We
are
checking
not
printing
Dwarf_Half
tag
int
tres
dwarf_tag
cu_die
err
if
tres
DW_DLV_OK
Something
broken
here
struct
esb_s
m
esb_constructor
esb_append
nERROR
Unable
to
get
CU
DIE
dwarf
tag
attempting
to
print
line
numbers
for
a
CU
if
tres
DW_DLV_ERROR
esb_append
dwarf_errmsg
err
simple_err_return_msg_either_action
tres
esb_get_string
esb_destructor
return
tres
else
if
tag
DW_TAG_type_unit
Not
checking
since
type
units
missing
address
or
range
in
CU
header
return
DW_DLV_NO_ENTRY
if
glflags
verbose
int
errcount
Dwarf_Bool
attr_dup
FALSE
int
lresv
print_source_intro
dbg
cu_die
lresv
print_one_die
dbg
cu_die
dieprint_cu_goffset
print_information
indent
level
srcfiles
srcf_count
ignore_die_stack
TRUE
err
if
lresv
DW_DLV_ERROR
return
lresv
DWARF_CHECK_COUNT
lines_result
lresv
dwarf_print_lines
cu_die
err
if
errcount
DWARF_ERROR_COUNT
lines_result
errcount
DWARF_CHECK_COUNT
lines_result
errcount
if
lresv
DW_DLV_ERROR
print_error_and_continue
dbg
Failed
to
print
CU
lines
lresv
err
return
lresv
if
glflags
gf_check_lines
checking_this_compiler
int
lres2
DWARF_CHECK_COUNT
lines_result
lres2
dwarf_check_lineheader_b
cu_die
err
if
lres2
DW_DLV_ERROR
print_error_and_continue
dbg
dwarf_check_lineheader_b
found
a
serious
error
lres2
err
dwarf_dealloc
dbg
err
DW_DLA_ERROR
err
if
line_errs
DWARF_CHECK_ERROR_PRINT_CU
DWARF_ERROR_COUNT
lines_result
line_errs
DWARF_CHECK_COUNT
lines_result
line_errs
The
following
is
complicated
by
a
desire
to
test
various
line
table
interface
functions
Hence
we
test
line_flag_selection
Normal
code
should
pick
an
interface
for
most
the
best
choice
is
what
we
here
call
glflags
gf_line_flag_selection
singledw5
and
use
just
that
interface
set
Sorry
about
the
length
of
the
code
that
results
from
having
so
many
interfaces
if
glflags
gf_line_flag_selection
singledw5
lres
dwarf_srclines_b
cu_die
err
if
lres
DW_DLV_OK
lres
dwarf_srclines_from_linecontext
line_context
err
else
lres
dwarf_srclines_b
cu_die
err
if
lres
DW_DLV_OK
lres
dwarf_srclines_two_level_from_linecontext
line_context
err
if
lres
DW_DLV_ERROR
Do
not
terminate
processing
if
glflags
gf_check_decl_file
DWARF_CHECK_COUNT
decl_file_result
DWARF_CHECK_ERROR2
decl_file_result
dwarf_srclines
dwarf_errmsg
err
Clear
error
condition
glflags
gf_record_dwarf_error
FALSE
else
print_error_and_continue
dbg
dwarf_srclines
lres
err
DROP_ERROR_INSTANCE
dbg
lres
err
return
DW_DLV_OK
else
if
lres
DW_DLV_NO_ENTRY
no
line
information
is
included
else
if
table_count
lres
DW_DLV_OK
if
glflags
gf_do_print_dwarf
if
line_context
glflags
verbose
lres
print_line_context_record
dbg
line_context
err
if
lres
DW_DLV_OK
Should
we
issue
message
about
this
call?
dwarf_srclines_dealloc_b
line_context
return
lres
print_source_intro
dbg
cu_die
if
glflags
verbose
int
dres
Dwarf_Bool
attr_dup
FALSE
FIXME
dres
print_one_die
dbg
cu_die
dieprint_cu_goffset
print_information
TRUE
indent_level
srcfiles
cnt
ignore_die_stack
TRUE
err
if
dres
DW_DLV_ERROR
dwarf_srclines_dealloc_b
line_context
return
dres
if
glflags
gf_line_flag_selection
singledw5
glflags
gf_line_flag_selection
s2l
This
now
all
cases
possible
when
the
table_count
int
ltres
if
table_count
table_count
ASSERT
is_single_table
true
Dwarf_Bool
is_logicals
FALSE
Dwarf_Bool
is_actuals
FALSE
ltres
process_line_table
dbg
sec_name
linebuf
linecount
is_logicals
is_actuals
err
if
ltres
DW_DLV_ERROR
what
if
NO_ENTRY?
dwarf_srclines_dealloc_b
line_context
return
ltres
else
Dwarf_Bool
is_logicals
TRUE
Dwarf_Bool
is_actuals
FALSE
ltres
process_line_table
dbg
sec_name
linebuf
linecount
is_logicals
is_actuals
err
if
ltres
DW_DLV_OK
dwarf_srclines_dealloc_b
line_context
return
ltres
ltres
process_line_table
dbg
sec_name
linebuf_actuals
linecount_actuals
is_logicals
is_actuals
err
if
ltres
DW_DLV_OK
dwarf_srclines_dealloc_b
line_context
return
ltres
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
end
table_count
else
table_count
lres
DW_DLV_OK
table_count
no
lines
in
table
Just
a
line
table
header
if
glflags
gf_do_print_dwarf
int
ores
Dwarf_Unsigned
off
print_source_intro
dbg
cu_die
if
glflags
verbose
int
dpres
Dwarf_Bool
attr_dup
FALSE
FIXME
dpres
print_one_die
dbg
cu_die
dieprint_cu_goffset
print_information
TRUE
indent_level
srcfiles
cnt
ignore_die_stack
TRUE
err
if
dpres
DW_DLV_ERROR
dwarf_srclines_dealloc_b
line_context
return
dpres
if
line_context
if
glflags
verbose
ores
print_line_context_record
dbg
line_context
err
if
ores
DW_DLV_OK
simple_err_return_msg_either_action
ores
ERROR
line
context
record
where
table
count
is
has
a
problem
dwarf_srclines_dealloc_b
line_context
return
ores
ores
dwarf_srclines_table_offset
line_context
err
if
ores
DW_DLV_OK
simple_err_return_msg_either_action
ores
ERROR
line
context
table_offset
where
table
count
is
has
a
problem
dwarf_srclines_dealloc_b
line_context
return
ores
else
printf
Line
table
is
present
offset
DW_PR_XZEROS
DW_PR_DUx
but
no
lines
present
n
off
else
printf
Line
table
is
present
but
no
lines
present
n
if
glflags
gf_line_flag_selection
singledw5
glflags
gf_line_flag_selection
s2l
Now
this
is
all
cases
also
deletes
the
linebuf
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
end
linecounttotal
if
line_context
also
deletes
the
linebuf
dwarf_srclines_dealloc_b
line_context
line_context
linebuf
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
helpertree
h
include
tag_common
h
Prints
locentry
descriptsions
for
DW_LKIND_GNU_exp_list
int
print_llex_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
esbp
Dwarf_Bool
bError
if
debug_addr_unavailable
bError
TRUE
switch
lle_value
case
DW_LLEX_base_address_selection_entry
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLEX_base_address_selection_entry
DW_PR_XZEROS
DW_PR_DUx
debug_addr
not
available
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
index
to
debug_addr
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
new
base
address
DW_PR_XZEROS
DW_PR_DUx
hipc
break
case
DW_LLEX_end_of_list_entry
Nothing
to
do
esb_append
esbp
end
of
list
break
case
DW_LLEX_start_length_entry
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLEX_start_lenth_entry
DW_PR_XZEROS
DW_PR_DUx
debug_addr
not
available
rawlopc
esb_append_printf_u
esbp
length
DW_PR_XZEROS
DW_PR_DUx
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
start
index
to
debug_addr
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
length
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
start
addr
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
endaddr
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLEX_offset_pair_entry
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLEX_offset_pair_entry
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
no
debug_addr
available
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
offset
pair
low
off
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
high
off
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
loaddr
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
hiaddr
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLEX_start_end_entry
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLEX_start_end_entry
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
high
index
DW_PR_XZEROS
DW_PR_DUx
debug_addr
not
available
hipc
else
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLEX_start_end_entry
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
debug_addr
not
available
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
lowaddr
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
highaddr
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
default
struct
esb_s
unexp
esb_constructor
esb_append_printf_u
ERROR
Unexpected
LLEX
code
x
lle_value
print_error_and_continue
dbg
esb_get_string
DW_DLV_OK
esb_destructor
bError
TRUE
break
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
DWARF5
has
the
new
debug_loclists
section
Here
we
print
that
data
The
raw
printing
covers
all
the
content
of
the
section
but
without
relating
it
to
any
compilation
unit
Printing
the
actual
address
means
printing
with
the
actual
DIEs
on
hand
include
config
h
include
globals
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
static
void
print_sec_name
Dwarf_Debug
dbg
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_loclists
TRUE
printf
n
s
n
n
sanitized
esb_get_string
esb_destructor
static
int
print_offset_entry_table
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
offset_entry_count
Dwarf_Error
error
Dwarf_Unsigned
e
unsigned
colmax
unsigned
col
int
res
int
hasnewline
TRUE
for
e
offset_entry_count
e
Dwarf_Unsigned
value
if
e
printf
Location
Offset
Table
n
hasnewline
FALSE
res
dwarf_get_loclist_offset_index_value
dbg
contextnum
e
error
if
res
DW_DLV_OK
return
res
if
col
printf
DW_PR_DUu
e
printf
DW_PR_XZEROS
DW_PR_DUx
value
col
if
col
colmax
printf
n
hasnewline
TRUE
col
if
hasnewline
printf
n
return
DW_DLV_OK
static
void
print_opsbytes
Dwarf_Unsigned
expr_ops_blocklen
Dwarf_Small
expr_ops
Dwarf_Unsigned
i
if
expr_ops_blocklen
return
printf
opsbytes
for
i
expr_ops_blocklen
i
Dwarf_Small
b
expr_ops
i
printf
b
printf
Print
single
raw
lle
static
int
print_single_lle
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Unsigned
contextnum
UNUSEDARG
Dwarf_Unsigned
lineoffset
Dwarf_Unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
Dwarf_Unsigned
expr_ops_blocklen
Dwarf_Unsigned
expr_ops_offset
UNUSEDARG
Dwarf_Small
expr_ops
Dwarf_Unsigned
entrylen
int
res
DW_DLV_OK
const
char
name
struct
esb_s
m
esb_constructor
res
dwarf_get_LLE_name
code
if
res
DW_DLV_OK
ASSERT
res
DW_DLV_NO_ENTRY
see
dwarf_names
c
esb_append_printf_u
ERROR
lle
code
DW_PR_DUx
unknown
code
else
esb_append
name
printf
printf
DW_PR_XZEROS
DW_PR_DUx
lineoffset
esb_get_string
switch
code
case
DW_LLE_end_of_list
printf
printf
break
case
DW_LLE_base_addressx
printf
DW_PR_XZEROS
DW_PR_DUx
v1
printf
break
case
DW_LLE_startx_endx
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_LLE_startx_length
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_LLE_offset_pair
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_LLE_default_location
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_LLE_base_address
printf
DW_PR_XZEROS
DW_PR_DUx
v1
printf
break
case
DW_LLE_start_end
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_LLE_start_length
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
default
printf
ERROR
Unknown
LLE
code
in
debug_loclists
s
n
esb_get_string
simple_err_return_msg_either_action
res
esb_get_string
break
printf
DW_PR_DUu
entrylen
esb_destructor
if
glflags
verbose
expr_ops_blocklen
printf
n
printf
printf
opslen
DW_PR_DUu
expr_ops_blocklen
print_opsbytes
expr_ops_blocklen
expr_ops
printf
n
return
res
Prints
the
raw
content
Exactly
as
in
debug_loclists
static
int
print_entire_loclist
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
offset_of_first_loc
Dwarf_Unsigned
offset_past_last_locentry
Dwarf_Error
error
These
offsets
are
rnglists
section
global
offsets
not
rnglist
context
local
offsets
Dwarf_Unsigned
curoffset
offset_of_first_loc
Dwarf_Unsigned
endoffset
offset_past_last_locentry
int
res
Dwarf_Unsigned
ct
for
curoffset
endoffset
ct
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
Dwarf_Unsigned
expr_ops_blocksize
Dwarf_Unsigned
expr_ops_offset
Dwarf_Small
expr_ops_data
if
ct
printf
Loc
raw
n
printf
Offset
entryname
val1
val2
entrylen
n
This
returns
ops
data
as
in
DWARF
No
application
of
base
addresses
or
anything
res
dwarf_get_loclist_lle
dbg
contextnumber
curoffset
endoffset
error
if
res
DW_DLV_OK
return
res
print_single_lle
dbg
contextnumber
curoffset
code
v1
v2
expr_ops_blocksize
expr_ops_offset
expr_ops_data
entrylen
curoffset
entrylen
if
curoffset
endoffset
struct
esb_s
m
esb_constructor
esb_append_printf_u
DW_DLE_USER_DECLARED_ERROR
final
RLE
in
debug_rnglists
runs
past
end
of
its
area
so
current
offset
DW_PR_DUx
curoffset
esb_append_printf_u
exceeds
context
past
end
offset
of
DW_PR_DUx
endoffset
dwarf_error_creation
dbg
error
esb_get_string
esb_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
int
print_raw_all_loclists
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
Dwarf_Unsigned
count
Dwarf_Unsigned
i
res
dwarf_load_loclists
dbg
error
if
res
DW_DLV_OK
return
res
print_sec_name
dbg
printf
Number
of
loclists
contexts
DW_PR_DUu
n
count
for
i
i
count
i
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_locentry
Dwarf_Unsigned
offset_past_last_locentry
res
dwarf_get_loclist_context_basics
dbg
i
error
if
res
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_u
ERROR
Getting
debug_rnglists
entry
u
we
unexpectedly
stop
early
i
simple_err_return_msg_either_action
res
esb_get_string
esb_destructor
return
res
printf
Context
number
DW_PR_DUu
n
i
printf
Version
n
version
printf
address
size
n
address_size
printf
offset
size
n
offset_size
if
glflags
verbose
printf
extension
size
n
extension_size
printf
segment
selector
size
n
segment_selector_size
printf
offset
entry
count
DW_PR_DUu
n
offset_entry_count
printf
context
size
in
bytes
DW_PR_DUu
n
offset_past_last_locentry
header_offset
if
glflags
verbose
printf
Offset
in
section
DW_PR_XZEROS
DW_PR_DUx
n
header_offset
printf
Offset
of
offsets
DW_PR_XZEROS
DW_PR_DUx
n
offset_of_offset_array
printf
Offsetof
first
loc
DW_PR_XZEROS
DW_PR_DUx
n
offset_of_first_locentry
printf
Offset
past
locations
DW_PR_XZEROS
DW_PR_DUx
n
offset_past_last_locentry
if
offset_entry_count
res
print_offset_entry_table
dbg
i
offset_entry_count
error
if
res
DW_DLV_ERROR
return
res
if
offset_of_first_locentry
offset_past_last_locentry
res
print_entire_loclist
dbg
i
offset_of_first_locentry
offset_past_last_locentry
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
helpertree
h
include
tag_common
h
Prints
locentry
descriptsions
for
DWARF5
DW_LKIND_loclists
int
print_debug_loclists_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
esbp
Dwarf_Bool
bError
if
debug_addr_unavailable
bError
TRUE
switch
lle_value
case
DW_LLE_base_address
debug_addr_unavailable
is
not
applicable
here
esb_append_printf_u
esbp
new
base
address
DW_PR_XZEROS
DW_PR_DUx
lopc
ASSERT
lopc
rawlopc
break
case
DW_LLE_base_addressx
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLE_base_addressx
DW_PR_XZEROS
DW_PR_DUx
no
debug_addr
found
rawlopc
else
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_base_addressx
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
new
base
address
DW_PR_XZEROS
DW_PR_DUx
lopc
break
case
DW_LLE_end_of_list
Nothing
to
do
esb_append
esbp
end
of
list
break
case
DW_LLE_start_length
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_start_length
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLE_startx_length
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLE_startx_length
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
no
debug_addr
found
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_startx_length
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLE_offset_pair
debug_addr_unavailable
does
apply
becase
that
might
cause
base
address
to
be
invalid
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLE_startx_length
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
no
debug_addr
found
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_offset_pair
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLE_start_end
debug_addr_unavailable
does
not
apply
here
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLE_startx_endx
if
debug_addr_unavailable
esb_append_printf_u
esbp
DW_LLE_startx_endx
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
no
debug_addr
found
rawhipc
else
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_startx_endx
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
default
struct
esb_s
unexp
esb_constructor
esb_append_printf_u
ERROR
Unexpected
LLE
code
x
lle_value
print_error_and_continue
dbg
esb_get_string
DW_DLV_OK
esb_destructor
break
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
macrocheck
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
include
print_frames
h
define
TRUE
define
FALSE
struct
macro_counts_s
long
mc_start_file
long
mc_end_file
long
mc_define
long
mc_undef
long
mc_extension
long
mc_code_zero
long
mc_unknown
static
int
print_one_macro_entry_detail
long
i
char
type
struct
Dwarf_Macro_Details_s
mdp
Dwarf_Error
err
UNUSEDARG
DW_MACINFO_
section
offset
file
index
line
string
n
if
glflags
gf_do_print_dwarf
if
mdp
dmd_macro
printf
s
DW_PR_DUu
DW_PR_DSd
DW_PR_DSd
s
n
i
type
Dwarf_Unsigned
mdp
dmd_offset
mdp
dmd_fileindex
mdp
dmd_lineno
sanitized
mdp
dmd_macro
else
printf
s
DW_PR_DUu
DW_PR_DSd
DW_PR_DSd
n
i
type
Dwarf_Unsigned
mdp
dmd_offset
mdp
dmd_fileindex
mdp
dmd_lineno
return
DW_DLV_OK
Nothing
in
here
can
actually
fail
Returns
DW_DLV_OK
static
int
print_one_macro_entry
long
i
struct
Dwarf_Macro_Details_s
mdp
struct
macro_counts_s
counts
char
srcfiles
Dwarf_Signed
srcf_count
Dwarf_Error
error
UNUSEDARG
int
res
switch
mdp
dmd_type
case
counts
mc_code_zero
res
print_one_macro_entry_detail
i
DW_MACINFO_type
code
mdp
error
break
case
DW_MACINFO_start_file
counts
mc_start_file
if
mdp
dmd_fileindex
mdp
dmd_macro
zero
index
no
file
specified
else
if
srcf_count
mdp
dmd_fileindex
srcf_count
mdp
dmd_macro
srcfiles
mdp
dmd_fileindex
else
if
srcf_count
mdp
dmd_macro
invalid
index
no
line
table
file
names
exist
else
mdp
dmd_macro
invalid
index
corrupt
data?
res
print_one_macro_entry_detail
i
DW_MACINFO_start_file
mdp
error
break
case
DW_MACINFO_end_file
counts
mc_end_file
res
print_one_macro_entry_detail
i
DW_MACINFO_end_file
mdp
error
break
case
DW_MACINFO_vendor_ext
counts
mc_extension
res
print_one_macro_entry_detail
i
DW_MACINFO_vendor_ext
mdp
error
break
case
DW_MACINFO_define
counts
mc_define
res
print_one_macro_entry_detail
i
DW_MACINFO_define
mdp
error
break
case
DW_MACINFO_undef
counts
mc_undef
res
print_one_macro_entry_detail
i
DW_MACINFO_undef
mdp
error
break
default
struct
esb_s
typeb
esb_constructor
counts
mc_unknown
esb_append_printf_u
DW_MACINFO_0x
x
of
unknown
type
mdp
dmd_type
print_one_macro_entry_detail
i
esb_get_string
mdp
error
esb_destructor
res
DW_DLV_OK
break
return
res
static
void
mac_dealloc_srcfiles_data
Dwarf_Debug
dbg
char
srcfiles
Dwarf_Signed
srcf_count
Dwarf_Signed
i
if
srcfiles
return
for
i
srcf_count
i
dwarf_dealloc
dbg
srcfiles
i
DW_DLA_STRING
dwarf_dealloc
dbg
srcfiles
DW_DLA_LIST
print
data
in
debug_macinfo
ARGSUSED
int
print_macinfo_by_offset
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Unsigned
offset
Dwarf_Error
error
Dwarf_Unsigned
max
Dwarf_Signed
count
Dwarf_Macro_Details
maclist
NULL
int
lres
long
i
struct
macro_counts_s
counts
Dwarf_Unsigned
totallen
Dwarf_Bool
is_primary
TRUE
char
srcfiles
Dwarf_Signed
srcf_count
glflags
current_section_id
DEBUG_MACINFO
No
real
need
to
get
the
real
section
name
this
section
not
used
much
in
modern
compilers
as
this
definition
of
macro
data
V2
V4
is
obsolete
it
takes
too
much
space
to
be
much
used
lres
dwarf_get_macro_details
dbg
offset
max
error
if
lres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
dwarf_get_macro_details
fails
on
offset
x
from
print_macinfo_by_offset
offset
simple_err_only_return_action
lres
esb_get_string
esb_destructor
return
lres
else
if
lres
DW_DLV_NO_ENTRY
return
lres
lres
dwarf_srcfiles
cu_die
error
if
lres
DW_DLV_ERROR
This
error
will
get
found
other
places
No
need
to
say
anything
here
dwarf_dealloc_error
dbg
error
error
memset
sizeof
counts
if
glflags
gf_do_print_dwarf
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_macinfo
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
printf
n
printf
compilation
unit
debug_macinfo
offset
DW_PR_XZEROS
DW_PR_DUx
n
offset
printf
sec
file
n
printf
num
name
offset
index
line
string
n
for
i
i
count
i
struct
Dwarf_Macro_Details_s
mdp
i
print_one_macro_entry
i
mdp
srcfiles
srcf_count
error
if
counts
mc_start_file
printf
ERROR
DW_MACINFO
file
count
of
zero
is
invalid
DWARF2
n
glflags
gf_count_major_errors
if
counts
mc_start_file
counts
mc_end_file
glflags
gf_count_major_errors
printf
ERROR
Counts
of
DW_MACINFO
start_file
ld
end_file
ld
do
not
match
Incorrect
DWARF2
n
counts
mc_start_file
counts
mc_end_file
if
counts
mc_code_zero
glflags
gf_count_major_errors
printf
ERROR
Count
of
zeros
in
macro
group
should
be
non
zero
preferred
count
is
ld
n
counts
mc_code_zero
next
byte
is
maclist
count
dmd_offset
totallen
maclist
count
dmd_offset
offset
add_macro_import
is_primary
offset
add_macro_area_len
offset
totallen
if
glflags
gf_do_print_dwarf
printf
Macro
counts
start
file
ld
end
file
ld
define
ld
undef
ld
ext
ld
code
zero
ld
unknown
ld
n
counts
mc_start_file
counts
mc_end_file
counts
mc_define
counts
mc_undef
counts
mc_extension
counts
mc_code_zero
counts
mc_unknown
int
type
maclist
count
dmd_type
ASSERT
type
is
zero
mac_dealloc_srcfiles_data
dbg
srcfiles
srcf_count
dwarf_dealloc
dbg
maclist
DW_DLA_STRING
return
DW_DLV_OK
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
ctype
h
include
time
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
include
esb_using_functions
h
include
uri
h
include
makename
h
include
dwarf_tsearch
h
include
print_sections
h
include
macrocheck
h
include
sanitized
h
define
TRUE
define
FALSE
See
the
comments
at
the
beginning
of
macrocheck
c
static
int
strcmp_for_macdef_tdel
const
void
l
const
void
r
const
char
ls
const
char
l
const
char
rs
const
char
r
return
strcmp
ls
rs
Extensible
array
of
pointers
to
file
records
define
MACFILE_ARRAY_START_LEN
unsigned
macfile_array_len
unsigned
macfile_array_next_to_use
Array
of
pointers
to
extended
macfile_entry
records
records
with
the
file
name
string
appended
so
not
all
the
same
length
macfile_entry
macfile_array
static
int
macdef_tree_compare_func
const
void
l
const
void
r
static
void
macdef_tree_insert
char
key
unsigned
opnum
unsigned
operator
Dwarf_Unsigned
line
Dwarf_Unsigned
offset
const
char
string
Dwarf_Unsigned
macro_unit_offset
void
map
static
macdef_entry
macdef_tree_find
char
key
void
map
static
macdef_entry
macdef_tree_create_entry
char
key
unsigned
opnum
unsigned
operator
Dwarf_Unsigned
line
Dwarf_Unsigned
offset
Dwarf_Unsigned
macro_unit_offset
const
char
string
static
void
macfile_array_destroy
void
void
macdef_tree_run_checks
void
static
void
macdef_free_func
void
mx
struct
madef_entry
m
mx
frees
both
strings
and
the
struct
free
m
macfile_entry
macfile_from_array_index
unsigned
index
macfile_entry
m
m
macfile_array
index
return
m
static
void
macdef_tree_destroy_inner
void
tree
dwarf_tdestroy
tree
macdef_free_func
static
void
destroy_macdef_tree
macdef_tree_destroy_inner
macdefundeftree
macdefundeftree
static
void
destroy_macro_globals
void
macfile_array_destroy
destroy_macdef_tree
The
stack
is
static
not
malloc
and
only
has
unsigned
vals
nothing
to
free
macfile_stack_next_to_use
static
int
print_macros_5style_this_cu_inner
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
dwarf_srcfiles
Dwarf_Signed
srcfiles_count
int
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
int
descend_into_inport
TRUE
means
follow
imports
int
by_offset
if
TRUE
is
an
imported
macro
unit
so
the
offset
is
relevant
If
false
is
the
set
for
the
CU
itself
Dwarf_Unsigned
offset
Dwarf_Unsigned
lineno
unsigned
fileno
int
level
Dwarf_Error
err
static
const
char
nonameavail
no
name
available
static
const
char
nofileseenyet
Before
First
DW_MACRO_start_file
static
void
print_stack_crash
void
unsigned
i
printf
MACRONOTE
The
start
file
operation
just
above
exceeds
the
max
allowed
of
d
Possibly
corrupt
dwarf
n
MACFILE_STACK_DEPTH_MAX
glflags
gf_count_macronotes
printf
op
line
filenum
filename
n
for
i
i
macfile_stack_next_to_use
i
macfile_entry
m
macfile_array
macfile_stack
i
printf
u
DW_PR_DUu
DW_PR_DUu
MOFF
DW_PR_DUx
s
n
i
m
ms_operatornum
m
ms_line
m
ms_filenum
m
ms_macro_unit_offset
sanitized
m
ms_filename
Return
if
format
is
bogus
static
unsigned
find_set_keyend
char
str
char
c
char
cp
str
unsigned
int
len
for
cp
cp
c
cp
The
following
two
returns
are
the
norm
for
define
if
c
cp
return
len
else
if
c
cp
return
len
len
continue
This
is
the
normal
return
for
undef
If
an
incoming
define
string
is
empty
or
has
no
spaces
we
get
here
too
return
len
static
int
is_define_op
unsigned
int
operator
switch
operator
case
DW_MACRO_define
case
DW_MACRO_define_strx
case
DW_MACRO_define_sup
case
DW_MACRO_define_strp
return
TRUE
return
FALSE
static
void
add_def_undef
unsigned
opnum
Dwarf_Unsigned
offset
unsigned
int
operator
Dwarf_Unsigned
line_number
const
char
macro_string
Dwarf_Off
macro_unit_offset
struct
esb_s
mtext
Dwarf_Bool
didprintdwarf
unsigned
int
key_length
macfile_entry
m
macdef_entry
meb
char
keystr
int
isdef
FALSE
if
strcmp
esb_get_string
mtext
nonameavail
we
have
no
string
just
the
fake
we
provide
hard
to
check
much
in
this
case
return
keystr
strdup
const
char
macro_string
key_length
find_set_keyend
keystr
if
key_length
if
didprintdwarf
printf
s
sanitized
esb_get_string
mtext
glflags
gf_count_major_errors
printf
ERROR
the
above
define
undef
macro
op
is
missing
its
macro
name
Corrupt
DWARF
n
free
keystr
return
isdef
is_define_op
operator
meb
macdef_tree_find
keystr
if
meb
Unknown
key
macdef_tree_insert
keystr
opnum
operator
line_number
offset
macro_string
macro_unit_offset
meb
macdef_tree_find
keystr
if
meb
printf
ERROR
Unable
to
find
key
s
in
macdef
tree
though
just
created
n
sanitized
keystr
return
if
isdef
meb
md_defined
isdef
meb
md_defcount
else
meb
md_undefined
isdef
meb
md_undefcount
free
keystr
return
A
key
we
have
seen
if
isdef
if
meb
md_defined
if
strcmp
macro_string
meb
md_string
duplicate
def
Legal
C
else
Not
duplicate
def
Bogus
if
didprintdwarf
printf
s
sanitized
esb_get_string
mtext
glflags
gf_count_macronotes
printf
MACRONOTE
Duplicating
the
macro
name
s
but
with
a
different
spelling
seems
to
be
an
error
n
sanitized
keystr
printf
Earlier
spelling
in
operator
u
is
n
meb
md_operatornum
m
macfile_from_array_index
meb
md_file_array_entry
printf
MOFF
DW_PR_XZEROS
DW_PR_DUx
from
line
DW_PR_DUu
file
s
meb
md_macro_unit_offset
meb
md_line
sanitized
m
ms_filename
printf
s
n
sanitized
meb
md_string
printf
new
spelling
with
operator
u
is
n
opnum
m
macfile_from_array_index
macfile_array_next_to_use
printf
MOFF
DW_PR_XZEROS
DW_PR_DUx
from
line
DW_PR_DUu
file
s
macro_unit_offset
line_number
sanitized
m
ms_filename
printf
s
n
sanitized
macro_string
meb
md_defcount
else
Now
defining
something
new
with
this
key
Should
we
print
something?
Warn
or
not?
unsigned
defcount
meb
md_defcount
unsigned
undefcount
meb
md_undefcount
macdef_entry
mee
dwarf_tdelete
keystr
strcmp_for_macdef_tdel
macdef_tree_insert
keystr
opnum
operator
line_number
offset
macro_string
macro_unit_offset
mee
macdef_tree_find
keystr
if
mee
printf
ERROR
Unable
to
find
key
s
in
macdef
tree
though
just
created
n
sanitized
keystr
return
mee
md_defined
TRUE
mee
md_defcount
defcount
mee
md_undefcount
undefcount
free
keystr
free
me
return
We
have
seen
it
and
we
have
an
undef
for
it
now
if
meb
md_defined
Was
def
of
something
with
this
key
now
undefining
with
this
key
unsigned
defcount
meb
md_defcount
unsigned
undefcount
meb
md_undefcount
macdef_entry
mec
dwarf_tdelete
keystr
strcmp_for_macdef_tdel
macdef_tree_insert
keystr
opnum
operator
line_number
offset
macro_string
macro_unit_offset
mec
macdef_tree_find
keystr
if
mec
printf
ERROR
Unable
to
find
key
s
in
macdef
tree
though
just
created
n
sanitized
keystr
return
mec
md_defined
FALSE
mec
md_undefined
TRUE
mec
md_defcount
defcount
mec
md_undefcount
undefcount
free
me
free
keystr
return
if
meb
md_undefined
Simply
a
normal
first
undef
of
a
defined
thing
unsigned
defcount
meb
md_defcount
unsigned
undefcount
meb
md_undefcount
macdef_entry
med
dwarf_tdelete
keystr
strcmp_for_macdef_tdel
macdef_tree_insert
keystr
opnum
operator
line_number
offset
macro_string
macro_unit_offset
med
macdef_tree_find
keystr
if
med
printf
ERROR
Unable
to
find
key
s
in
macdef
tree
though
just
created
n
sanitized
keystr
return
med
md_defined
FALSE
med
md_undefined
TRUE
med
md_defcount
defcount
med
md_undefcount
undefcount
free
me
free
keystr
return
ASSERT
meb
md_undefined
TRUE
In
tree
is
marked
undef
So
undef
again
if
didprintdwarf
printf
s
sanitized
esb_get_string
mtext
if
glflags
gf_do_check_dwarf
free
keystr
return
glflags
gf_count_macronotes
printf
MACRONOTE
Duplicating
the
undefine
of
macro
name
s
could
possibly
be
an
error
n
sanitized
keystr
printf
Earlier
in
operator
u
is
n
meb
md_operatornum
m
macfile_from_array_index
meb
md_file_array_entry
printf
MOFF
DW_PR_XZEROS
DW_PR_DUx
from
line
DW_PR_DUu
file
s
meb
md_macro_unit_offset
meb
md_line
sanitized
m
ms_filename
printf
s
n
sanitized
meb
md_key
printf
new
in
operator
u
is
n
opnum
m
macfile_from_array_index
macfile_array_next_to_use
printf
MOFF
DW_PR_XZEROS
DW_PR_DUx
from
line
DW_PR_DUu
file
s
macro_unit_offset
line_number
sanitized
m
ms_filename
printf
s
n
sanitized
keystr
free
keystr
free
me
return
static
void
expand_array_file_if_required
void
if
macfile_array_next_to_use
macfile_array_len
ASSERT
useme
macfile_array_len
unsigned
oldlen
macfile_array_len
unsigned
newlen
oldlen
macfile_entry
newar
if
newlen
We
have
seen
nothing
make
a
fresh
start
newlen
MACFILE_ARRAY_START_LEN
free
macfile_array
macfile_array
macfile_array_next_to_use
macfile_array_len
newar
macfile_entry
calloc
newlen
sizeof
macfile_entry
if
newar
Out
of
memory
printf
nERROR
out
of
memory
attempting
allocation
of
u
entries
on
macfile_array
Skipping
entry
n
newlen
glflags
gf_count_major_errors
return
if
oldlen
memcpy
newar
macfile_array
oldlen
sizeof
macfile_entry
free
macfile_array
macfile_array
macfile_array_next_to_use
oldlen
macfile_array_len
newlen
macfile_array
newar
static
void
add_array_file_entry
unsigned
k
Dwarf_Unsigned
offset
unsigned
int
operator
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Off
macro_unit_offset
const
char
macro_string
size_t
namelen
strlen
macro_string
unsigned
alloclen
sizeof
macfile_entry
namelen
unsigned
stroff
sizeof
macfile_entry
macfile_entry
m
expand_array_file_if_required
m
macfile_entry
calloc
alloclen
if
m
return
m
ms_operatornum
k
m
ms_operator
operator
m
ms_line
line_number
m
ms_filenum
index
m
ms_offset
offset
m
ms_macro_unit_offset
macro_unit_offset
m
ms_array_number
macfile_array_next_to_use
m
ms_filename
char
m
stroff
strcpy
m
ms_filename
macro_string
macfile_array
macfile_array_next_to_use
m
macfile_stack
macfile_stack_next_to_use
macfile_array_next_to_use
macfile_array_next_to_use
macfile_stack_next_to_use
if
macfile_stack_next_to_use
macfile_stack_max_seen
macfile_stack_max_seen
macfile_stack_next_to_use
static
void
add_to_file_stack
unsigned
k
Dwarf_Unsigned
offset
unsigned
int
operator
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Off
macro_unit_offset
const
char
macro_string
struct
esb_s
mtext
Dwarf_Bool
didprintdwarf
if
operator
DW_MACRO_end_file
unsigned
stack_useme
DW_MACRO_end_file
if
didprintdwarf
glflags
gf_do_check_dwarf
printf
s
sanitized
esb_get_string
mtext
if
glflags
gf_do_check_dwarf
macfile_entry
m
m
macfile_from_array_index
macfile_array_next_to_use
if
macfile_stack_next_to_use
printf
MACRONOTE
End
file
operation
just
above
MOFF
DW_PR_XZEROS
DW_PR_DUx
file
s
has
no
applicable
start
file
Possibly
corrupt
dwarf
n
macro_unit_offset
sanitized
m
ms_filename
glflags
gf_count_macronotes
return
Leave
the
file
array
untouched
stack_useme
macfile_stack_next_to_use
macfile_stack
stack_useme
macfile_stack_next_to_use
stack_useme
return
if
macfile_stack_next_to_use
MACFILE_STACK_DEPTH_MAX
if
didprintdwarf
printf
s
sanitized
esb_get_string
mtext
print_stack_crash
return
add_array_file_entry
k
offset
operator
line_number
index
macro_unit_offset
macro_string
return
static
void
print_source_intro
Dwarf_Die
cu_die
Dwarf_Off
off
int
ores
Dwarf_Error
err
ores
dwarf_dieoffset
cu_die
if
ores
DW_DLV_OK
int
lres
const
char
sec_name
lres
dwarf_get_die_section_name_b
cu_die
if
lres
DW_DLV_OK
sec_name
strlen
sec_name
sec_name
debug_info
printf
Macro
data
from
CU
DIE
at
s
offset
DW_PR_XZEROS
DW_PR_DUx
n
sanitized
sec_name
Dwarf_Unsigned
off
else
printf
Macro
data
for
the
CU
DIE
at
unknown
location
n
static
void
derive_error_message
Dwarf_Debug
dbg
unsigned
k
Dwarf_Half
macro_operator
Dwarf_Unsigned
number_of_ops
int
res
Dwarf_Error
err
const
char
operator_string
const
char
name
struct
esb_s
m
dwarf_get_MACRO_name
macro_operator
esb_constructor
if
res
DW_DLV_ERROR
esb_append
ERROR
from
else
esb_append
ERROR
NO_ENTRY
from
esb_append
operator_string
esb_append_printf_s
for
operand
s
sanitized
name
esb_append_printf_u
operand
u
k
esb_append_printf_u
of
u
operands
number_of_ops
print_error_and_continue
dbg
esb_get_string
res
err
esb_destructor
static
int
print_macro_ops
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
dwarf_srcfiles
Dwarf_Signed
srcfiles_count
Dwarf_Macro_Context
mcontext
Dwarf_Unsigned
number_of_ops
int
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
int
descend_into_import
TRUE
means
follow
imports
int
by_offset
if
TRUE
is
an
imported
macro
unit
Dwarf_Unsigned
macro_unit_offset
of
this
set
Dwarf_Unsigned
macro_unit_length
return
val
int
level
Dwarf_Error
err
unsigned
k
for
k
k
number_of_ops
k
Dwarf_Unsigned
section_offset
Dwarf_Half
macro_operator
Dwarf_Half
forms_count
const
Dwarf_Small
formcode_array
Dwarf_Unsigned
line_number
Dwarf_Unsigned
index
Dwarf_Unsigned
offset
const
char
macro_string
int
lres
static
char
mbuf
struct
esb_s
mtext
esb_constructor_fixed
mbuf
sizeof
mbuf
lres
dwarf_get_macro_op
mcontext
k
err
if
lres
DW_DLV_OK
struct
esb_s
m
dwarf_dealloc_macro_context
mcontext
esb_constructor
if
lres
DW_DLV_ERROR
esb_append
ERROR
from
dwarf_get_macro_op
else
esb_append
ERROR
NO_ENTRY
from
dwarf_get_macro_op
esb_append_printf_u
for
operand
u
k
esb_append_printf_u
of
u
operands
number_of_ops
print_error_and_continue
dbg
esb_get_string
lres
err
esb_destructor
esb_destructor
return
lres
esb_append_printf_i
k
if
by_offset
descend_into_import
esb_append_printf_u
MOFF
DW_PR_XZEROS
DW_PR_DUx
macro_unit_offset
esb_append_printf_u
macro_operator
esb_append_printf_s
macro_operator?
get_MACRO_name
macro_operator
dwarf_names_print_on_error
end
of
macros
if
glflags
gf_show_global_offsets
esb_append_printf_u
GOFF
DW_PR_XZEROS
DW_PR_DUx
section_offset
if
glflags
show_form_used
forms_count
unsigned
l
esb_append_printf_u
n
Forms
count
forms_count
for
l
forms_count
l
Dwarf_Small
form
formcode_array
l
esb_append_printf_u
form
esb_append_printf_s
get_FORM_name
form
dwarf_names_print_on_error
esb_append
n
switch
macro_operator
case
End
of
these
DWARF_MACRO
ops
Dwarf_Unsigned
macro_unit_len
section_offset
macro_unit_offset
esb_append_printf_u
op
offset
DW_PR_XZEROS
DW_PR_DUx
section_offset
esb_append_printf_u
macro
unit
length
DW_PR_DUu
macro_unit_len
esb_append_printf_u
next
byte
offset
DW_PR_XZEROS
DW_PR_DUx
section_offset
macro_unit_length
macro_unit_len
esb_append
n
if
do_print_dwarf
printf
s
sanitized
esb_get_string
break
case
DW_MACRO_end_file
if
do_print_dwarf
esb_append
n
if
do_print_dwarf
printf
s
sanitized
esb_get_string
add_to_file_stack
k
offset
macro_operator
line_number
offset
macro_unit_offset
do_print_dwarf
break
case
DW_MACRO_define
case
DW_MACRO_undef
lres
dwarf_get_macro_defundef
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_defundef
esb_destructor
return
lres
esb_append_printf_u
line
u
line_number
esb_append_printf_s
s
n
macro_string?
sanitized
macro_string
nonameavail
if
do_print_dwarf
printf
s
sanitized
esb_get_string
add_def_undef
k
offset
macro_operator
line_number
macro_string
macro_unit_offset
do_print_dwarf
break
case
DW_MACRO_define_strp
case
DW_MACRO_undef_strp
lres
dwarf_get_macro_defundef
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_defundef
esb_destructor
return
lres
esb_append_printf_u
line
DW_PR_DUu
line_number
esb_append_printf_u
str
offset
DW_PR_XZEROS
DW_PR_DUx
offset
esb_append_printf_s
s
n
macro_string?
sanitized
macro_string
nonameavail
if
do_print_dwarf
printf
s
esb_get_string
add_def_undef
k
offset
macro_operator
line_number
macro_string
macro_unit_offset
do_print_dwarf
break
case
DW_MACRO_define_strx
case
DW_MACRO_undef_strx
lres
dwarf_get_macro_defundef
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_defundef
esb_destructor
return
lres
esb_append_printf_u
line
DW_PR_DUu
line_number
esb_append_printf_u
str
offset
DW_PR_XZEROS
DW_PR_DUx
offset
esb_append_printf_s
s
n
macro_string?
sanitized
macro_string
nonameavail
if
do_print_dwarf
printf
s
sanitized
esb_get_string
add_def_undef
k
offset
macro_operator
line_number
macro_string
macro_unit_offset
do_print_dwarf
break
case
DW_MACRO_define_sup
case
DW_MACRO_undef_sup
The
strings
here
are
from
a
supplementary
object
file
not
this
object
file
Until
we
have
a
way
to
find
the
supplementary
object
file
those
will
show
name
no
name
available
We
do
not
add
these
to
the
MacroCheck
treer
lres
dwarf_get_macro_defundef
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_defundef
esb_destructor
return
lres
esb_append_printf_u
line
DW_PR_DUu
line_number
esb_append_printf_u
str
offset
DW_PR_XZEROS
DW_PR_DUx
offset
esb_append_printf_s
s
n
macro_string?
sanitized
macro_string
nonameavail
if
do_print_dwarf
printf
s
sanitized
esb_get_string
break
case
DW_MACRO_start_file
lres
dwarf_get_macro_startend_file
mcontext
k
err
The
above
call
knows
how
to
reference
its
one
srcfiles
data
and
has
the
debug_macro
version
So
we
do
not
need
to
worry
about
getting
the
file
name
here
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_startend_file
esb_destructor
return
lres
esb_append_printf_u
line
DW_PR_DUu
line_number
esb_append_printf_u
file
number
DW_PR_DUu
index
esb_append
macro_string?
macro_string
no
name
available
esb_append
n
if
do_print_dwarf
printf
s
sanitized
esb_get_string
add_to_file_stack
k
offset
macro_operator
line_number
index
macro_unit_offset
macro_string
do_print_dwarf
break
case
DW_MACRO_import
int
mres
lres
dwarf_get_macro_import
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_import
esb_destructor
return
lres
if
do_print_dwarf
esb_append_printf
offset
DW_PR_XZEROS
DW_PR_DUx
offset
esb_append
n
if
do_print_dwarf
printf
s
sanitized
esb_get_string
if
descend_into_import
macfile_entry
mac_e
mac_e
macfile_from_array_index
macfile_array_next_to_use
mres
macro_import_stack_present
offset
if
mres
DW_DLV_OK
printf
ERROR
While
Printing
DWARF5
macros
we
find
a
recursive
nest
of
imports
noted
with
offset
DW_PR_XZEROS
DW_PR_DUx
so
we
stop
now
n
offset
print_macro_import_stack
glflags
gf_count_major_errors
return
DW_DLV_NO_ENTRY
mres
print_macros_5style_this_cu_inner
dbg
cu_die
dwarf_srcfiles
srcfiles_count
FALSE
turns
off
do_print_dwarf
descend_into_import
TRUE
by
offset
offset
mac_e
ms_line
macfile_array_next_to_use
level
err
if
mres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
ERROR
Printing
DWARF5
macros
at
offset
x
for
the
import
CU
failed
offset
print_error_and_continue
dbg
esb_get_string
mres
err
DROP_ERROR_INSTANCE
dbg
mres
err
esb_destructor
break
case
DW_MACRO_import_sup
lres
dwarf_get_macro_import
mcontext
k
err
if
lres
DW_DLV_OK
derive_error_message
dbg
k
macro_operator
number_of_ops
lres
err
dwarf_get_macro_import
esb_destructor
return
lres
if
add_macro_import_sup
offset
The
supplementary
object
file
is
not
available
So
we
cannot
check
the
import
references
or
know
the
size
As
of
December
endif
if
do_print_dwarf
printf
sup_offset
DW_PR_XZEROS
DW_PR_DUx
n
offset
break
End
switch
macro_operator
esb_destructor
return
DW_DLV_OK
We
follow
imports
if
building_primary_tree
and
in
that
case
following
imports
we
turn
do_print_dwarf
FALSE
static
int
print_macros_5style_this_cu_inner
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
dwarf_srcfiles
Dwarf_Signed
srcfiles_count
int
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
int
descend_into_import
TRUE
means
follow
imports
int
by_offset
if
TRUE
is
an
imported
macro
unit
so
the
offset
is
relevant
If
false
is
the
set
for
the
CU
itself
Dwarf_Unsigned
offset
Dwarf_Unsigned
lineno
unsigned
filenum
int
level
Dwarf_Error
err
int
lres
Dwarf_Unsigned
version
Dwarf_Macro_Context
macro_context
Dwarf_Unsigned
macro_unit_offset
Dwarf_Unsigned
number_of_ops
Dwarf_Unsigned
ops_total_byte_len
Dwarf_Unsigned
context_total_byte_len
Dwarf_Off
dieprint_cu_goffset
Dwarf_Off
cudie_local_offset
int
atres
glflags
current_section_id
DEBUG_MACRO
if
by_offset
lres
dwarf_get_macro_context
cu_die
err
offset
macro_unit_offset
else
lres
dwarf_get_macro_context_by_offset
cu_die
offset
err
macro_unit_offset
offset
if
lres
DW_DLV_NO_ENTRY
return
lres
if
lres
DW_DLV_ERROR
print_error_and_continue
dbg
Unable
to
dwarf_get_macro_context
for
the
DWARF
style
macro
lres
err
return
lres
If
we
fail
to
get
the
offsets
we
won
t
worry
about
it
atres
dwarf_die_offsets
cu_die
err
DROP_ERROR_INSTANCE
dbg
atres
err
lres
dwarf_macro_context_total_length
macro_context
err
if
lres
DW_DLV_OK
return
lres
add_macro_import
level
offset
lineno
filenum
add_macro_area_len
offset
context_total_byte_len
lres
macro_import_stack_push
offset
if
lres
DW_DLV_ERROR
message
printed
Give
up
return
DW_DLV_NO_ENTRY
if
do_print_dwarf
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_macro
TRUE
This
does
not
return
if
by_offset
printf
n
s
Macro
info
for
a
single
cu
at
macro
Offset
DW_PR_XZEROS
DW_PR_DUx
n
sanitized
esb_get_string
macro_unit_offset
print_source_intro
cu_die
else
printf
n
s
Macro
info
for
imported
macro
unit
at
macro
Offset
DW_PR_XZEROS
DW_PR_DUx
n
sanitized
esb_get_string
offset
esb_destructor
else
We
are
checking
not
printing
Dwarf_Half
tag
int
tres
dwarf_tag
cu_die
err
if
tres
DW_DLV_OK
Something
broken
here
dwarf_dealloc_macro_context
macro_context
print_error_and_continue
dbg
Unable
to
get
CU
DIE
tag
though
we
could
see
it
earlier
Something
broken
tres
err
return
tres
else
if
tag
DW_TAG_type_unit
dwarf_dealloc_macro_context
macro_context
Not
checking
since
type
units
missing
address
or
range
in
CU
header
return
DW_DLV_OK
if
do_print_dwarf
glflags
verbose
Dwarf_Bool
attr_dup
FALSE
int
pdres
pdres
print_one_die
dbg
cu_die
dieprint_cu_goffset
print_information
indent
level
dwarf_srcfiles
srcfiles_count
ignore_die_stack
TRUE
err
if
pdres
DW_DLV_ERROR
dwarf_dealloc_macro_context
macro_context
return
pdres
Dwarf_Half
lversion
Dwarf_Unsigned
mac_offset
Dwarf_Unsigned
mac_len
Dwarf_Unsigned
mac_header_len
Dwarf_Unsigned
line_offset
unsigned
mflags
Dwarf_Bool
has_line_offset
FALSE
Dwarf_Bool
has_offset_size_64
FALSE
Dwarf_Bool
has_operands_table
FALSE
Dwarf_Half
opcode_count
Dwarf_Half
offset_size
Dwarf_Unsigned
macro_unit_length
const
char
prefix
if
by_offset
prefix
lres
dwarf_macro_context_head
macro_context
err
if
lres
DW_DLV_NO_ENTRY
dwarf_dealloc_macro_context
macro_context
Impossible
return
lres
if
lres
DW_DLV_ERROR
dwarf_dealloc_macro_context
macro_context
print_error_and_continue
dbg
ERROR
dwarf_macro_context_head
failed
lres
err
return
lres
if
has_offset_size_64
offset_size
If
pure
checking
we
won
t
print
this
header
info
if
glflags
gf_do_check_dwarf
To
understand
imports
we
really
need
the
basic
data
shown
on
all
targeted
macro
offsets
This
is
a
start
allowing
us
to
track
the
imported
tables
Add
verbose
to
see
the
rest
printed
just
below
printf
s
Nested
import
level
d
n
prefix
level
printf
s
Macro
version
d
n
prefix
lversion
printf
s
macro
section
offset
DW_PR_XZEROS
DW_PR_DUx
n
prefix
mac_offset
if
glflags
verbose
glflags
gf_do_check_dwarf
printf
s
flags
x
offsetsize64?
s
lineoffset?
s
operands_table?
s
n
prefix
mflags
has_offset_size_64?
yes
no
has_line_offset
yes
no
has_operands_table?
yes
no
printf
s
offset
size
x
n
prefix
offset_size
printf
s
header
length
DW_PR_XZEROS
DW_PR_DUx
total
length
DW_PR_XZEROS
DW_PR_DUx
n
prefix
mac_header_len
mac_len
if
has_line_offset
printf
debug_line_offset
DW_PR_XZEROS
DW_PR_DUx
n
line_offset
if
has_operands_table
Dwarf_Half
i
for
i
i
opcode_count
i
Dwarf_Half
opcode_num
Dwarf_Half
operand_count
const
Dwarf_Small
operand_array
Dwarf_Half
j
lres
dwarf_macro_operands_table
macro_context
i
err
if
lres
DW_DLV_NO_ENTRY
struct
esb_s
m
dwarf_dealloc_macro_context
macro_context
esb_constructor
esb_append_printf_u
ERROR
dwarf_macro_operands_table
returns
NO_ENTRY
for
index
u
i
esb_append_printf_u
of
u
indexes
opcode_count
print_error_and_continue
dbg
esb_get_string
lres
err
esb_destructor
return
lres
if
lres
DW_DLV_ERROR
struct
esb_s
m
dwarf_dealloc_macro_context
macro_context
esb_constructor
esb_append_printf_u
ERROR
dwarf_macro_operands_table
returns
ERROR
for
index
u
i
esb_append_printf_u
of
u
indexes
opcode_count
print_error_and_continue
dbg
esb_get_string
lres
err
esb_destructor
return
lres
if
opcode_num
printf
s
end
of
macro
operands
prefix
i
Continue
just
in
case
something
is
wrong
and
there
are
more
operands
continue
printf
s
op
operandcount
u
n
prefix
i
opcode_num
get_MACRO_name
opcode_num
dwarf_names_print_on_error
operand_count
for
j
j
operand_count
j
Dwarf_Small
opnd
operand_array
j
printf
s
n
prefix
j
opnd
get_FORM_name
opnd
dwarf_names_print_on_error
if
do_print_dwarf
printf
MacroInformationEntries
count
DW_PR_DUu
bytes
length
DW_PR_DUu
n
number_of_ops
ops_total_byte_len
lres
print_macro_ops
dbg
cu_die
dwarf_srcfiles
srcfiles_count
macro_context
number_of_ops
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
descend_into_import
TRUE
means
follow
imports
by_offset
if
TRUE
is
an
imported
macro
set
macro_unit_offset
level
err
if
lres
DW_DLV_OK
struct
esb_s
m
dwarf_dealloc_macro_context
macro_context
esb_constructor
if
lres
DW_DLV_ERROR
esb_append
ERROR
print_macro_ops
failed
returns
ERROR
else
esb_append
ERROR
print_macro_ops
failed
returns
NO_ENTRY
print_error_and_continue
dbg
esb_get_string
lres
err
esb_destructor
return
lres
macro_unit_offset
for
macro_unit_length
bytes
is
a
real
macro
unit
if
if
check_lines
checking_this_compiler
DWARF_CHECK_COUNT
lines_result
dwarf_check_lineheader
cu_die
if
line_errs
DWARF_CHECK_ERROR_PRINT_CU
DWARF_ERROR_COUNT
lines_result
line_errs
DWARF_CHECK_COUNT
lines_result
line_errs
endif
if
do_print_dwarf
mark_macro_offset_printed
offset
lres
macro_import_stack_pop
if
lres
DW_DLV_OK
return
DW_DLV_NO_ENTRY
dwarf_dealloc_macro_context
macro_context
macro_context
return
DW_DLV_OK
int
print_macros_5style_this_cu
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
dwarf_srcfiles
Dwarf_Signed
srcfiles_count
int
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
int
descend_into_import
TRUE
means
follow
imports
int
by_offset
if
TRUE
is
an
imported
macro
unit
so
the
offset
is
relevant
If
false
is
the
set
for
the
CU
itself
Dwarf_Unsigned
offset
Dwarf_Error
err
int
res
if
macfile_array_next_to_use
macfile_stack_next_to_use
macdefundeftree
macfile_array
printf
ERROR
dwarfdump
internal
files
not
properly
initialized
internal
dwarfdump
bug
No
macro
access
done
Pretending
no
macro
section
present
n
glflags
gf_count_major_errors
return
DW_DLV_NO_ENTRY
add_array_file_entry
DW_MACRO_start_file
nofileseenyet
res
print_macros_5style_this_cu_inner
dbg
cu_die
dwarf_srcfiles
srcfiles_count
do_print_dwarf
descend_into_import
by_offset
offset
err
macdef_tree_run_checks
destroy_macro_globals
Do
NOT
clear
macrocheck
statistics
here
wait
till
all
CUs
processed
before
clearing
return
res
static
int
macdef_tree_compare_func
const
void
l
const
void
r
const
macdef_entry
ml
l
const
macdef_entry
mr
r
int
res
res
strcmp
ml
md_key
mr
md_key
return
res
static
void
macdef_tree_insert
char
key
unsigned
opnum
unsigned
operator
Dwarf_Unsigned
line
Dwarf_Unsigned
offset
const
char
string
Dwarf_Unsigned
macro_unit_offset
void
map
void
retval
macdef_entry
re
macdef_entry
e
e
macdef_tree_create_entry
key
opnum
operator
line
offset
macro_unit_offset
string
e
md_defcount
e
md_undefcount
e
md_undefined
FALSE
e
md_defined
FALSE
tsearch
records
e
s
contents
unless
e
is
already
present
We
must
not
free
it
till
destroy
time
if
it
got
added
to
tree1
retval
dwarf_tsearch
e
map
macdef_tree_compare_func
if
retval
re
macdef_entry
retval
if
re
e
We
returned
an
existing
record
e
not
needed
Increment
refcounts
macdef_free_func
e
else
Record
e
got
added
to
tree1
do
not
free
record
e
static
macdef_entry
macdef_tree_create_entry
char
key
unsigned
opnum
unsigned
operator
Dwarf_Unsigned
line
Dwarf_Unsigned
offset
Dwarf_Unsigned
macro_unit_offset
const
char
string
char
keyspace
unsigned
klen
strlen
key
unsigned
slen
strlen
string
unsigned
finallen
sizeof
macdef_entry
klen
slen
macdef_entry
me
macdef_entry
calloc
finallen
if
me
return
keyspace
sizeof
macdef_entry
char
me
me
md_key
keyspace
strcpy
me
md_key
key
me
md_operatornum
opnum
We
will
set
md_define
md_undefined
and
the
md_defcount
and
md_undefcount
elsewhere
me
md_defined
FALSE
me
md_undefined
FALSE
me
md_operator
operator
me
md_line
line
me
md_offset
offset
me
md_macro_unit_offset
macro_unit_offset
me
md_string
keyspace
klen
me
md_file_array_entry
macfile_array_next_to_use
strcpy
me
md_string
string
return
me
static
macdef_entry
macdef_tree_find
char
key
void
tree
void
retval
macdef_entry
re
macdef_entry
e
e
macdef_tree_create_entry
key
fake
retval
dwarf_tfind
e
tree
macdef_tree_compare_func
if
retval
re
macdef_entry
retval
The
one
we
created
here
must
be
deleted
it
is
dead
We
look
at
the
returned
one
instead
macdef_free_func
e
return
re
static
void
macfile_array_destroy
void
unsigned
i
for
i
macfile_array_next_to_use
i
macfile_entry
m
macfile_array
i
Frees
the
macfile_entry
and
the
filename
string
attached
to
the
end
of
the
struct
free
m
macfile_array
i
free
macfile_array
macfile_array_len
macfile_array_next_to_use
macfile_array
static
Dwarf_Unsigned
walk_reccount
static
void
macro_walk_count_recs
const
void
nodep
UNUSEDARG
const
DW_VISIT
which
const
int
depth
UNUSEDARG
if
which
dwarf_postorder
which
dwarf_endorder
return
walk_reccount
static
Dwarf_Unsigned
macro_count_recs
void
base
walk_reccount
dwarf_twalk
base
macro_walk_count_recs
return
walk_reccount
These
are
file
static
not
local
as
we
need
to
access
in
a
tree
walk
static
macdef_entry
mac_as_array
static
unsigned
mac_as_array_next
static
void
macro_walk_to_array
const
void
nodep
const
DW_VISIT
which
const
int
depth
UNUSEDARG
macdef_entry
re
macdef_entry
nodep
if
which
dwarf_postorder
which
dwarf_endorder
return
mac_as_array
mac_as_array_next
re
mac_as_array_next
static
int
macdef_qsort_compare
const
void
lin
const
void
rin
const
macdef_entry
l
const
macdef_entry
lin
const
macdef_entry
r
const
macdef_entry
rin
int
res
res
strcmp
l
md_key
r
md_key
if
res
return
res
if
l
md_operatornum
r
md_operatornum
return
if
l
md_operatornum
r
md_operatornum
return
No
two
can
have
the
same
md_operatornum
so
this
is
impossible
return
static
void
print_macdef_warn
unsigned
i
macdef_entry
m
unsigned
warncount
if
warncount
printf
macro
defs
undefs
at
end
n
printf
i
m
md_key
printf
m
md_defcount
printf
m
md_undefcount
printf
s
m
md_defined?
defined
undefined
printf
n
Check
the
macdefundef
tree
for
the
unusual
Check
the
macfile_stack
for
leftovers
The
tree
starts
with
and
that
entry
is
a
fake
for
macro
ops
before
a
DW_MACRO_start_file
encountered
void
macdef_tree_run_checks
void
unsigned
i
unsigned
warncount
Dwarf_Unsigned
me_array_count
free
mac_as_array
mac_as_array
mac_as_array_next
if
macfile_stack_next_to_use
printf
MACRONOTE
The
DWARF5
macro
start
file
stack
has
u
entries
left
on
the
stack
Missing
some
end
file
entries?
n
macfile_stack_next_to_use
glflags
gf_count_macronotes
printf
op
line
filenum
filename
n
for
i
i
macfile_stack_next_to_use
i
macfile_entry
m
macfile_array
macfile_stack
i
printf
u
DW_PR_DUu
DW_PR_DUu
s
n
i
m
ms_operatornum
m
ms_line
m
ms_filenum
sanitized
m
ms_filename
Now
check
the
def
undef
tree
left
if
glflags
gf_do_check_dwarf
return
if
macdefundeftree
return
me_array_count
macro_count_recs
if
me_array_count
mac_as_array
macdef_entry
calloc
me_array_count
sizeof
macdef_entry
if
mac_as_array
done
return
warncount
mac_as_array_next
dwarf_twalk
macdefundeftree
macro_walk_to_array
qsort
mac_as_array
me_array_count
sizeof
macdef_entry
macdef_qsort_compare
for
i
i
me_array_count
i
macdef_entry
m
mac_as_array
i
if
m
md_defined
m
md_defcount
m
md_undefcount
totally
normal
continue
if
m
md_defined
m
md_defcount
m
md_undefcount
totally
normal
continue
print_macdef_warn
i
m
warncount
warncount
free
mac_as_array
mac_as_array
mac_as_array_next
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
helpertree
h
include
tag_common
h
Prints
locentry
descriptsions
for
DW_LKIND_loclist
int
print_original_loclist_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
esbp
Dwarf_Bool
bError
UNUSEDARG
switch
lle_value
case
DW_LLE_base_address
esb_append_printf_u
esbp
base
address
DW_PR_XZEROS
DW_PR_DUx
hipc
break
case
DW_LLE_end_of_list
Nothing
to
do
esb_append
esbp
end
of
list
break
case
DW_LLE_offset_pair
if
glflags
verbose
esb_append_printf_u
esbp
DW_LLE_offset_pair
DW_PR_XZEROS
DW_PR_DUx
rawlopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
rawhipc
esb_append_printf_i
esbp
n
llent
esb_append_printf_u
esbp
low
hi
addrs
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
case
DW_LLE_start_end
debug_addr_unavailable
does
not
apply
here
esb_append_printf_u
esbp
start
end
DW_PR_XZEROS
DW_PR_DUx
lopc
esb_append_printf_u
esbp
DW_PR_XZEROS
DW_PR_DUx
hipc
if
checking
debug_addr_unavailable
loc_error_check
tagname
attrname
lopc
rawlopc
hipc
rawhipc
locdesc_offset
base_address
bError
break
default
struct
esb_s
unexp
esb_constructor
esb_append_printf_u
ERROR
Unexpected
LLE
code
x
in
original
loclist
synthesized
code
error
lle_value
print_error_and_continue
dbg
esb_get_string
DW_DLV_OK
esb_destructor
break
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
print_sections
h
include
sanitized
h
This
unifies
the
code
for
some
error
checks
to
avoid
code
duplication
static
void
check_info_offset_sanity
const
char
sec
const
char
field
char
global
Dwarf_Unsigned
offset
Dwarf_Unsigned
maxoff
if
maxoff
Lets
make
a
heuristic
check
if
offset
printf
Warning
section
s
s
s
offset
DW_PR_XZEROS
DW_PR_DUx
exceptionally
large
n
sec
field
global
offset
return
if
offset
maxoff
printf
Warning
section
s
s
s
offset
DW_PR_XZEROS
DW_PR_DUx
larger
than
max
of
DW_PR_DUx
n
sec
field
global
offset
maxoff
Unified
pubnames
style
output
The
error
checking
here
against
maxoff
may
be
useless
in
that
libdwarf
may
return
an
error
if
the
offset
is
bad
and
we
will
not
get
called
here
But
we
leave
it
in
nonetheless
as
it
looks
sensible
In
at
least
one
gigantic
executable
such
offsets
turned
out
wrong
static
int
print_pubname_style_entry
Dwarf_Debug
dbg
const
char
line_title
char
name
Dwarf_Unsigned
die_off
Dwarf_Unsigned
cu_die_off
Dwarf_Unsigned
global_cu_offset
Dwarf_Unsigned
maxoff
Dwarf_Error
err
Dwarf_Die
die
NULL
Dwarf_Off
die_CU_off
int
dres
int
ddres
int
cudres
Dwarf_Bool
is_info
TRUE
get
die
at
die_off
For
this
old
section
in
DWARF
only
debug_info
could
be
appropriate
never
debug_types
Hence
is_info
TRUE
dres
dwarf_offdie_b
dbg
die_off
is_info
err
Some
llvm
version
puts
the
global
die
offset
into
pubnames
with
the
result
that
we
will
get
an
error
here
but
we
just
let
that
create
an
error
papering
it
over
here
by
subtracting
out
the
applicable
debug_info
CU
header
offset
is
problematic
if
dres
DW_DLV_OK
struct
esb_s
details
esb_constructor
esb_append
line_title
esb_append
dwarf_offdie
die
offset
does
not
reference
valid
DIE
esb_append_printf_u
at
offset
DW_PR_DUx
die_off
esb_append
print_error_and_continue
dbg
esb_get_string
dres
err
esb_destructor
return
dres
get
offset
of
die
from
its
cu
header
ddres
dwarf_die_CU_offset
die
err
if
ddres
DW_DLV_OK
struct
esb_s
details
esb_constructor
esb_append
line_title
esb_append
cannot
get
CU
die
offset
print_error_and_continue
dbg
esb_get_string
dres
err
esb_destructor
die_CU_off
dwarf_dealloc
dbg
die
DW_DLA_DIE
return
ddres
Get
die
at
offset
cu_die_off
to
check
its
existence
Dwarf_Die
cu_die
NULL
cudres
dwarf_offdie_b
dbg
cu_die_off
is_info
err
if
cudres
DW_DLV_OK
struct
esb_s
details
dwarf_dealloc
dbg
die
DW_DLA_DIE
esb_constructor
esb_append
line_title
esb_append
dwarf_offdie
cu
die
offset
does
not
reference
valid
CU
DIE
esb_append_printf_u
DW_PR_DUx
cu_die_off
esb_append
does
not
return
print_error_and_continue
dbg
esb_get_string
cudres
err
esb_destructor
return
cudres
else
It
exists
all
is
well
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
Display
offsets
if
glflags
gf_display_offsets
Print
name
at
the
end
for
better
layout
printf
s
die
in
sect
DW_PR_XZEROS
DW_PR_DUx
cu
in
sect
DW_PR_XZEROS
DW_PR_DUx
die
in
cu
DW_PR_XZEROS
DW_PR_DUx
cu
header
in
sect
DW_PR_XZEROS
DW_PR_DUx
line_title
die_off
cu_die_off
Dwarf_Unsigned
die_CU_off
Following
is
absolute
offset
of
the
beginning
of
the
cu
Dwarf_Signed
die_off
die_CU_off
if
die_off
die_CU_off
global_cu_offset
struct
esb_s
details
dwarf_dealloc
dbg
die
DW_DLA_DIE
esb_constructor
esb_append
nERROR
esb_append
line_title
esb_append
has
improper
die
offset
esb_append_printf_u
global
cu
offset
x
global_cu_offset
esb_append_printf_u
does
not
match
die_off
x
die_off
esb_append_printf_u
minus
die_CU_off
x
die_CU_off
esb_append
n
simple_err_return_msg_either_action
DW_DLV_ERROR
esb_get_string
return
DW_DLV_NO_ENTRY
Display
offsets
if
glflags
gf_display_offsets
glflags
verbose
printf
cuhdr
DW_PR_XZEROS
DW_PR_DUx
global_cu_offset
Print
name
at
the
end
for
better
layout
printf
s
n
name
dwarf_dealloc
dbg
die
DW_DLA_DIE
check_info_offset_sanity
line_title
die
offset
name
die_off
maxoff
check_info_offset_sanity
line_title
die
cu
offset
name
die_CU_off
maxoff
check_info_offset_sanity
line_title
cu
offset
name
die_off
die_CU_off
maxoff
return
DW_DLV_OK
static
void
print_globals_header
Dwarf_Off
pub_section_hdr_offset
Dwarf_Unsigned
length_size
from
pubnames
header
Dwarf_Unsigned
length
from
pubnames
header
Dwarf_Unsigned
version
Dwarf_Off
info_header_offset
Dwarf_Unsigned
info_length
printf
Pub
section
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
pub_section_hdr_offset
pub_section_hdr_offset
printf
offset
size
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
length_size
length_size
printf
length
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
length
length
printf
version
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
version
version
printf
info
hdr
offset
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
info_header_offset
info_header_offset
printf
info
hdr
length
DW_PR_XZEROS
DW_PR_DUx
DW_PR_DUu
n
info_length
info_length
Get
all
the
data
in
debug_pubnames
int
print_pubnames
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Global
globbuf
NULL
Dwarf_Signed
count
Offset
to
previous
CU
int
res
Dwarf_Addr
elf_max_address
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
truename
char
sanbuf
ESB_FIXED_ALLOC_SIZE
struct
esb_s
sanitname
glflags
current_section_id
DEBUG_PUBNAMES
res
get_address_size_and_max
dbg
err
if
res
DW_DLV_OK
simple_err_return_msg_either_action
res
print_pubnames
call
to
get
address
size
and
max
address
fails
return
res
if
glflags
verbose
For
best
testing
res
dwarf_return_empty_pubnames
dbg
err
if
res
DW_DLV_OK
simple_err_return_msg_either_action
res
ERROR
Erroneous
libdwarf
call
of
dwarf_return_empty_pubnames
dwarfdump
internal
error
return
res
res
dwarf_get_globals
dbg
err
Do
get_true_section_name
after
loading
section
so
it
reports
on
compressed
data
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_pubnames
TRUE
esb_constructor_fixed
sanbuf
sizeof
sanbuf
Sanitized
cannot
be
safely
reused
there
is
a
static
buffer
so
we
make
a
safe
copy
esb_append
sanitized
esb_get_string
esb_destructor
if
glflags
gf_do_print_dwarf
count
printf
n
s
n
esb_get_string
if
res
DW_DLV_ERROR
simple_err_return_msg_either_action
res
ERROR
dwarf_get_globals
failed
in
print_pubnames
esb_destructor
return
res
fall
through
to
end
if
res
DW_DLV_NO_ENTRY
esb_destructor
return
res
res
print_all_pubnames_style_records
dbg
global
esb_get_string
globbuf
count
err
esb_destructor
dwarf_globals_dealloc
dbg
globbuf
count
dwarf_return_empty_pubnames
dbg
err
return
res
int
print_all_pubnames_style_records
Dwarf_Debug
dbg
const
char
linetitle
const
char
section_true_name
Dwarf_Global
globbuf
Dwarf_Signed
count
Dwarf_Error
err
Dwarf_Unsigned
maxoff
get_info_max_offset
dbg
Dwarf_Unsigned
lastcudieoff
Dwarf_Addr
elf_max_address
Dwarf_Signed
i
int
ares
Dwarf_Bool
is_info
TRUE
ares
get_address_size_and_max
dbg
err
if
ares
DW_DLV_OK
simple_err_return_msg_either_action
ares
ERROR
print_pubnames
style
call
to
get
address
size
and
max
address
fails
return
ares
for
i
i
count
i
int
nres
int
cures3
Dwarf_Off
die_off
Dwarf_Off
cu_die_off
Dwarf_Off
prev_cu_off
elf_max_address
Dwarf_Off
global_cu_off
char
name
Turns
the
cu
local
die_off
in
globbuf
entry
into
a
global
die_off
The
cu_off
returned
is
the
offset
of
the
CU
DIE
not
the
CU
header
nres
dwarf_global_name_offsets
globbuf
i
err
if
nres
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_i
ERROR
dwarf_global_name_offsets
for
globals
index
d
i
esb_append_printf_i
with
globals
count
d
count
simple_err_return_msg_either_action
nres
esb_get_string
esb_destructor
return
nres
if
glflags
verbose
We
know
no
die_off
can
be
zero
except
for
the
fake
global
created
when
the
debug_pubnames
for
a
CU
has
no
actual
entries
we
do
not
need
to
check
for
i
to
detect
this
is
the
initial
global
record
and
we
want
to
print
this
pubnames
section
CU
header
if
lastcudieoff
cu_die_off
Dwarf_Off
pub_section_hdr_offset
Dwarf_Unsigned
pub_offset_size
Dwarf_Unsigned
pub_length
Dwarf_Unsigned
pub_version
Dwarf_Off
info_header_offset
Dwarf_Unsigned
info_length
nres
dwarf_get_globals_header
globbuf
i
err
if
nres
DW_DLV_OK
struct
esb_s
msge
esb_constructor
esb_append
ERROR
Access
dwarf_get_globals_header
esb_append_printf_i
for
index
d
in
i
esb_append
section_true_name
esb_append
simple_err_return_msg_either_action
nres
esb_get_string
esb_destructor
return
nres
if
glflags
gf_do_print_dwarf
print_globals_header
pub_section_hdr_offset
pub_offset_size
pub_length
pub_version
info_header_offset
info_length
lastcudieoff
cu_die_off
if
glflags
verbose
If
verbose
we
can
see
a
zero
die_off
if
die_off
strlen
name
A
different
and
impossible
cu
die
offset
in
case
of
an
empty
pubnames
CU
continue
This
gets
the
CU
header
offset
which
is
the
offset
that
die_off
needs
to
be
added
to
to
calculate
the
DIE
offset
Note
that
dwarf_global_name_offsets
already
did
that
addition
properly
so
this
call
is
just
so
we
can
print
the
CU
header
offset
cures3
dwarf_global_cu_offset
globbuf
i
err
if
cures3
DW_DLV_OK
struct
esb_s
msge
esb_constructor
esb_append
ERROR
Access
dwarf_global_cu_offset
esb_append_printf_i
for
index
d
in
i
esb_append
section_true_name
esb_append
simple_err_return_msg_either_action
cures3
esb_get_string
esb_destructor
return
cures3
if
glflags
gf_check_pubname_attr
Dwarf_Bool
has_attr
int
dres
Dwarf_Die
die
We
are
processing
a
new
set
of
pubnames
for
a
different
CU
get
the
producer
ID
at
cu_off
to
see
if
we
need
to
skip
these
pubnames
if
cu_die_off
prev_cu_off
char
proname
struct
esb_s
producername
Dwarf_Die
lcudie
Record
offset
for
previous
CU
prev_cu_off
cu_die_off
dres
dwarf_offdie_b
dbg
cu_die_off
is_info
err
if
dres
DW_DLV_OK
struct
esb_s
msge
esb_constructor
esb_append
ERROR
Accessing
dwarf_offdie
esb_append_printf_i
for
index
d
in
i
esb_append
section_true_name
esb_append
simple_err_return_msg_either_action
dres
esb_get_string
esb_destructor
return
dres
Get
producer
name
for
this
CU
and
update
compiler
list
esb_constructor_fixed
proname
sizeof
proname
dres
get_producer_name
dbg
lcudie
cu_die_off
err
dwarf_dealloc
dbg
lcudie
DW_DLA_DIE
if
dres
DW_DLV_ERROR
esb_destructor
return
dres
update_compiler_target
esb_get_string
glflags
DIE_CU_overall_offset
cu_die_off
esb_destructor
get
die
at
die_off
dres
dwarf_offdie_b
dbg
die_off
is_info
err
if
dres
DW_DLV_OK
struct
esb_s
msge
esb_constructor
esb_append
ERROR
Accessing
dwarf_offdie
esb_append_printf_i
for
index
d
in
i
esb_append
section_true_name
esb_append_printf_u
with
die
offset
x
die_off
esb_append
simple_err_return_msg_either_action
dres
esb_get_string
esb_destructor
return
dres
ares
dwarf_hasattr
die
DW_AT_external
err
if
ares
DW_DLV_ERROR
struct
esb_s
msgd
esb_constructor
esb_append
ERROR
hasattr
on
DW_AT_external
from
esb_append
section_true_name
esb_append
fails
dwarf_dealloc
dbg
die
DW_DLA_DIE
print_error
does
not
return
simple_err_return_msg_either_action
ares
esb_get_string
esb_destructor
return
ares
DW_DLV_NO_ENTRY
is
odd
Check
that
if
checking
Check
for
specific
compiler
if
checking_this_compiler
DWARF_CHECK_COUNT
pubname_attr_result
if
ares
DW_DLV_OK
has_attr
Should
the
value
of
flag
be
examined?
else
DWARF_CHECK_ERROR2
pubname_attr_result
name
pubname
does
not
have
DW_AT_external
dwarf_dealloc
dbg
die
DW_DLA_DIE
Now
print
name
after
the
test
if
glflags
gf_do_print_dwarf
glflags
gf_record_dwarf_error
glflags
gf_check_verbose_mode
int
res
res
print_pubname_style_entry
dbg
linetitle
name
die_off
cu_die_off
global_cu_off
maxoff
err
if
res
DW_DLV_OK
return
res
glflags
gf_record_dwarf_error
FALSE
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
static
struct
esb_s
esb_string
void
ranges_esb_string_destructor
void
esb_destructor
Because
we
do
not
know
what
DIE
is
involved
if
the
object
being
printed
has
different
address
sizes
in
different
compilation
units
this
will
not
work
properly
anything
could
happen
This
applies
to
debug_ranges
something
only
used
in
DWARF3
and
DWARF4
extern
int
print_ranges
Dwarf_Debug
dbg
Dwarf_Error
err
UNUSEDARG
Dwarf_Unsigned
off
int
group_number
int
wasdense
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
unsigned
loopct
glflags
current_section_id
DEBUG_RANGES
if
glflags
gf_do_print_dwarf
return
DW_DLV_OK
esb_constructor_fixed
buf
sizeof
buf
Turn
off
dense
we
do
not
want
print_ranges_list_to_extra
to
use
dense
form
here
wasdense
glflags
dense
glflags
dense
for
loopct
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
Dwarf_Off
actual_offset
Dwarf_Error
pr_err
int
rres
dwarf_get_ranges_b
dbg
off
No
DIE
available
here
we
will
do
the
best
we
can
if
loopct
get_true_section_name
dbg
debug_ranges
TRUE
printf
n
s
n
sanitized
esb_get_string
if
rres
DW_DLV_OK
char
val
printf
Ranges
group
d
n
group_number
esb_empty_string
print_ranges_list_to_extra
dbg
off
off
rangeset
rangecount
bytecount
dwarf_ranges_dealloc
dbg
rangeset
rangecount
val
esb_get_string
printf
s
sanitized
val
group_number
else
if
rres
DW_DLV_NO_ENTRY
printf
End
of
s
n
sanitized
esb_get_string
break
else
ERROR
which
does
not
quite
mean
a
real
error
as
we
might
just
be
misaligned
reading
things
without
a
DW_AT_ranges
offset
struct
esb_s
m
esb_constructor
esb_append_printf_u
ERROR
at
offset
lx
in
off
esb_append_printf_s
section
s
Stopping
ranges
output
sanitized
esb_get_string
print_error_and_continue
dbg
esb_get_string
rres
pr_err
dwarf_dealloc
dbg
pr_err
DW_DLA_ERROR
pr_err
esb_destructor
break
off
bytecount
glflags
dense
wasdense
esb_destructor
return
DW_DLV_OK
Extracted
this
from
print_range_attribute
to
isolate
the
check
of
the
range
list
static
int
check_ranges_list
Dwarf_Debug
dbg
Dwarf_Off
die_off
UNUSEDARG
Dwarf_Die
cu_die
Dwarf_Unsigned
original_off
Dwarf_Unsigned
finaloff
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
Dwarf_Error
err
Dwarf_Unsigned
off
original_off
Dwarf_Signed
index
Dwarf_Addr
base_address
glflags
CU_base_address
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Bool
bError
FALSE
Dwarf_Half
elf_address_size
Dwarf_Addr
elf_max_address
static
Dwarf_Bool
do_print
TRUE
const
char
sec_name
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_ranges
FALSE
sec_name
esb_get_string
get_address_size_and_max
dbg
err
Ignore
last
entry
is
the
end
of
list
for
index
index
rangecount
index
Dwarf_Ranges
r
rangeset
index
if
r
dwr_addr1
elf_max_address
addr
use
specific
address
current
PU
address
base_address
r
dwr_addr2
else
offset
offset
update
using
CU
address
lopc
r
dwr_addr1
base_address
hipc
r
dwr_addr2
base_address
DWARF_CHECK_COUNT
ranges_result
Check
the
low_pc
and
high_pc
are
within
a
valid
range
in
the
text
section
if
IsValidInBucketGroup
glflags
pRangesInfo
lopc
IsValidInBucketGroup
glflags
pRangesInfo
hipc
Valid
values
do
nothing
else
At
this
point
may
be
we
are
dealing
with
a
linkonce
symbol
if
IsValidInLinkonce
glflags
pLinkonceInfo
glflags
PU_name
lopc
hipc
Valid
values
do
nothing
else
struct
esb_s
errbuf
bError
TRUE
esb_constructor
esb_append_printf_s
s
Address
outside
a
valid
text
range
sanitized
sec_name
DWARF_CHECK_ERROR
ranges_result
esb_get_string
esb_destructor
if
glflags
gf_check_verbose_mode
do_print
Update
DIEs
offset
just
for
printing
int
dioff_res
dwarf_die_offsets
cu_die
DIE_overall_offset
DIE_offset
err
if
dioff_res
DW_DLV_OK
simple_err_return_msg_either_action
dioff_res
Call
to
dwarf_die_offsets
failed
for
the
CU
DIE
in
printing
ranges
return
dioff_res
printf
Offset
DW_PR_XZEROS
DW_PR_DUx
Base
DW_PR_XZEROS
DW_PR_DUx
Low
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
High
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
n
off
base_address
lopc
r
dwr_addr1
hipc
r
dwr_addr2
Each
entry
holds
addresses
offsets
off
elf_address_size
In
the
case
of
errors
we
have
to
print
the
range
records
that
caused
the
error
if
bError
glflags
gf_check_verbose_mode
do_print
struct
esb_s
rangesstr
esb_constructor
printf
n
print_ranges_list_to_extra
dbg
original_off
finaloff
rangeset
rangecount
bytecount
printf
s
n
sanitized
esb_get_string
esb_destructor
In
the
case
of
printing
unique
errors
stop
the
printing
of
any
subsequent
errors
which
have
the
same
text
if
bError
glflags
gf_check_verbose_mode
glflags
gf_print_unique_errors
do_print
FALSE
esb_destructor
return
DW_DLV_OK
Records
information
about
compilers
producers
found
in
the
debug
information
including
the
check
results
for
several
categories
see
k
option
typedef
struct
Dwarf_Off
die_off
Dwarf_Off
range_off
Range_Array_Entry
Array
to
record
the
DW_AT_range
attribute
DIE
to
be
used
at
the
end
of
the
CU
to
check
the
range
values
DWARF4
allows
an
offset
relative
to
the
low_pc
as
the
high_pc
value
Also
LLVM
generates
for
the
CU
the
pair
low_pc
at_ranges
instead
of
the
traditional
low_pc
high_pc
static
Range_Array_Entry
range_array
NULL
static
Dwarf_Unsigned
range_array_size
static
Dwarf_Unsigned
range_array_count
define
RANGE_ARRAY_INITIAL_SIZE
Allocate
space
to
store
information
about
the
ranges
the
values
are
extracted
from
the
DW_AT_ranges
attribute
The
space
is
reused
by
all
CUs
void
allocate_range_array_info
if
range_array
NULL
Allocate
initial
range
array
info
range_array
Range_Array_Entry
calloc
RANGE_ARRAY_INITIAL_SIZE
sizeof
Range_Array_Entry
range_array_size
RANGE_ARRAY_INITIAL_SIZE
void
release_range_array_info
if
range_array
free
range_array
range_array
range_array_size
range_array_count
Clear
out
values
from
previous
CU
static
void
reset_range_array_info
if
range_array
memset
void
range_array
range_array_count
sizeof
Range_Array_Entry
range_array_count
void
record_range_array_info_entry
Dwarf_Off
die_off
Dwarf_Off
range_off
Record
a
new
detected
range
info
if
range_array_count
range_array_size
Resize
range
array
range_array_size
range_array
Range_Array_Entry
realloc
range_array
range_array_size
sizeof
Range_Array_Entry
The
die_off
is
the
Global
Die
Offset
range_array
range_array_count
die_off
die_off
range_array
range_array_count
range_off
range_off
range_array_count
Now
that
we
are
at
the
end
of
the
CU
check
the
range
lists
int
check_range_array_info
Dwarf_Debug
dbg
Dwarf_Die
cu_die_in
Dwarf_Error
err
Dwarf_Bool
is_info
dwarf_get_die_infotypes_flag
cu_die_in
if
range_array
range_array_count
Traverse
the
range
array
and
for
each
entry
Load
the
ranges
Check
for
any
outside
conditions
Dwarf_Off
original_off
Dwarf_Off
finaloffset
Dwarf_Off
die_off
Dwarf_Unsigned
index
Dwarf_Die
cu_die
int
res
In
case
of
errors
the
correct
DIE
offset
should
be
displayed
At
this
point
we
are
at
the
end
of
the
PU
Dwarf_Off
DIE_overall_offset_bak
glflags
DIE_overall_offset
for
index
index
range_array_count
index
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
Get
a
range
info
record
die_off
range_array
index
die_off
original_off
range_array
index
range_off
res
dwarf_offdie_b
dbg
die_off
is_info
err
if
res
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_u
Call
to
dwarf_offdie
failed
getting
the
CU
die
from
offset
DW_PR_XZEROS
DW_PR_DUx
in
checking
ranges
die_off
simple_err_return_msg_either_action
res
esb_get_string
esb_destructor
return
res
res
dwarf_get_ranges_b
dbg
original_off
cu_die
err
if
res
DW_DLV_OK
res
check_ranges_list
dbg
die_off
cu_die
original_off
finaloffset
rangeset
rangecount
bytecount
err
if
res
DW_DLV_OK
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
reset_range_array_info
return
res
dwarf_dealloc
dbg
rangeset
DW_DLA_RANGES
dwarf_dealloc
dbg
cu_die
DW_DLA_DIE
reset_range_array_info
Point
back
to
the
end
of
the
PU
glflags
DIE_overall_offset
DIE_overall_offset_bak
return
DW_DLV_OK
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
DWARF5
has
the
new
debug_rnglists
section
Here
we
print
that
data
The
raw
printing
covers
all
the
content
of
the
section
but
without
relating
it
to
any
compilation
unit
Printing
the
actual
address
means
printing
with
the
actual
DIEs
on
hand
include
config
h
include
globals
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
static
void
print_sec_name
Dwarf_Debug
dbg
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_rnglists
TRUE
printf
n
s
n
n
sanitized
esb_get_string
esb_destructor
static
int
print_offset_entry_table
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnum
Dwarf_Unsigned
offset_entry_count
Dwarf_Error
error
Dwarf_Unsigned
e
unsigned
colmax
unsigned
col
int
res
int
hasnewline
TRUE
for
e
offset_entry_count
e
Dwarf_Unsigned
value
if
e
printf
Location
Offset
Table
n
hasnewline
FALSE
res
dwarf_get_rnglist_offset_index_value
dbg
contextnum
e
error
if
res
DW_DLV_OK
return
res
if
col
printf
DW_PR_DUu
e
printf
DW_PR_XZEROS
DW_PR_DUx
value
col
if
col
colmax
printf
n
hasnewline
TRUE
col
if
hasnewline
printf
n
return
DW_DLV_OK
For
printing
the
raw
rangelist
data
from
debug_rnglists
static
int
print_single_rle
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Unsigned
contextnum
UNUSEDARG
Dwarf_Unsigned
lineoffset
Dwarf_Unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
Dwarf_Unsigned
entrylen
int
res
DW_DLV_OK
const
char
name
struct
esb_s
m
esb_constructor
res
dwarf_get_RLE_name
code
if
res
DW_DLV_OK
ASSERT
res
DW_DLV_NO_ENTRY
see
dwarf_names
c
esb_append_printf_u
ERROR
rle
code
DW_PR_DUx
unknown
code
else
esb_append
name
printf
printf
DW_PR_XZEROS
DW_PR_DUx
lineoffset
esb_get_string
switch
code
case
DW_RLE_end_of_list
printf
printf
break
case
DW_RLE_base_addressx
printf
DW_PR_XZEROS
DW_PR_DUx
v1
printf
break
case
DW_RLE_startx_endx
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_RLE_startx_length
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_RLE_offset_pair
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_RLE_base_address
printf
DW_PR_XZEROS
DW_PR_DUx
v1
printf
break
case
DW_RLE_start_end
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
case
DW_RLE_start_length
printf
DW_PR_XZEROS
DW_PR_DUx
DW_PR_XZEROS
DW_PR_DUx
v1
v2
break
default
printf
ERROR
Unknown
RLE
code
in
debug_rnglists
s
n
esb_get_string
simple_err_return_msg_either_action
res
esb_get_string
break
esb_destructor
if
glflags
verbose
printf
length
DW_PR_DUu
entrylen
printf
n
return
res
For
printing
raw
rangelist
data
as
found
in
debug_rnglists
static
int
print_entire_rangeslist
Dwarf_Debug
dbg
Dwarf_Unsigned
contextnumber
Dwarf_Unsigned
offset_of_first_range
Dwarf_Unsigned
offset_past_last_rangeentry
Dwarf_Error
error
These
offsets
are
rnglists
section
global
offsets
not
rnglist
context
local
offsets
Dwarf_Unsigned
curoffset
offset_of_first_range
Dwarf_Unsigned
endoffset
offset_past_last_rangeentry
int
res
Dwarf_Unsigned
ct
int
title_printed
FALSE
for
curoffset
endoffset
ct
unsigned
entrylen
unsigned
code
Dwarf_Unsigned
v1
Dwarf_Unsigned
v2
if
ct
printf
RangeEntries
raw
n
res
dwarf_get_rnglist_rle
dbg
contextnumber
curoffset
endoffset
error
if
res
DW_DLV_OK
return
res
if
title_printed
title_printed
TRUE
printf
Offset
entryname
val1
val2
entrylen
n
print_single_rle
dbg
contextnumber
curoffset
code
v1
v2
entrylen
curoffset
entrylen
if
curoffset
endoffset
struct
esb_s
m
esb_constructor
esb_append_printf_u
DW_DLE_USER_DECLARED_ERROR
final
RLE
in
debug_rnglists
runs
past
end
of
its
area
so
current
offset
DW_PR_DUx
curoffset
esb_append_printf_u
exceeds
context
past
end
offset
of
DW_PR_DUx
endoffset
dwarf_error_creation
dbg
error
esb_get_string
esb_destructor
return
DW_DLV_ERROR
return
DW_DLV_OK
For
printing
the
raw
rangelist
data
from
debug_rnglists
int
print_raw_all_rnglists
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
Dwarf_Unsigned
count
Dwarf_Unsigned
i
res
dwarf_load_rnglists
dbg
error
if
res
DW_DLV_OK
return
res
print_sec_name
dbg
printf
Number
of
rnglists
contexts
DW_PR_DUu
n
count
for
i
i
count
i
Dwarf_Unsigned
header_offset
Dwarf_Small
offset_size
Dwarf_Small
extension_size
unsigned
version
Dwarf_Small
address_size
Dwarf_Small
segment_selector_size
Dwarf_Unsigned
offset_entry_count
Dwarf_Unsigned
offset_of_offset_array
Dwarf_Unsigned
offset_of_first_rangeentry
Dwarf_Unsigned
offset_past_last_rangeentry
res
dwarf_get_rnglist_context_basics
dbg
i
error
if
res
DW_DLV_OK
struct
esb_s
m
esb_constructor
esb_append_printf_u
ERROR
Getting
debug_rnglists
entry
u
we
unexpectedly
stop
early
i
simple_err_return_msg_either_action
res
esb_get_string
esb_destructor
return
res
printf
Context
number
DW_PR_DUu
n
i
printf
Version
n
version
printf
address
size
n
address_size
printf
offset
size
n
offset_size
if
glflags
verbose
printf
extension
size
n
extension_size
printf
segment
selector
size
n
segment_selector_size
printf
offset
entry
count
DW_PR_DUu
n
offset_entry_count
printf
context
size
in
bytes
DW_PR_DUu
n
offset_past_last_rangeentry
header_offset
if
glflags
verbose
printf
Offset
in
section
DW_PR_XZEROS
DW_PR_DUx
n
header_offset
printf
Offset
of
offsets
DW_PR_XZEROS
DW_PR_DUx
n
offset_of_offset_array
printf
Offsetof
first
range
DW_PR_XZEROS
DW_PR_DUx
n
offset_of_first_rangeentry
printf
Offset
past
ranges
DW_PR_XZEROS
DW_PR_DUx
n
offset_past_last_rangeentry
if
offset_entry_count
res
print_offset_entry_table
dbg
i
offset_entry_count
error
if
res
DW_DLV_ERROR
return
res
if
offset_of_first_rangeentry
offset_past_last_rangeentry
res
print_entire_rangeslist
dbg
i
offset_of_first_rangeentry
offset_past_last_rangeentry
error
if
res
DW_DLV_OK
return
res
return
DW_DLV_OK
Copyright
C
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
sanitized
h
include
naming
h
Two
purposes
here
related
to
COMDAT
A
get
and
print
the
data
on
sections
and
groups
B
reset
certain
global
print
flags
so
printing
a
COMDAT
section
does
not
print
the
major
sections
that
are
from
group
DW_GROUPDATA_BASE
The
functions
are
called
from
dwarfdump
c
and
only
once
So
static
vars
are
safe
static
Dwarf_Unsigned
group_map_entry_count
static
Dwarf_Unsigned
selected_group
static
Dwarf_Unsigned
sec_nums
static
Dwarf_Unsigned
group_nums
static
const
char
sec_names
static
Dwarf_Unsigned
group_count
static
Dwarf_Unsigned
section_count
static
void
freeall_groups_tables
void
free
sec_nums
sec_nums
free
group_nums
group_nums
Cast
prevents
an
ugly
warning
about
the
const
being
stripped
off
free
void
sec_names
sec_names
group_map_entry_count
selected_group
group_count
section_count
define
TRUE
define
FALSE
if
static
struct
glfsetting_s
const
char
secname
Dwarf_Bool
flag
Dwarf_Bool
origset
Dwarf_Bool
origflag
glftab
debug_abbrev
gf_abbrev_flag
FALSE
FALSE
debug_aranges
gf_aranges_flag
FALSE
FALSE
debug_debug_macinfo
gf_macinfo_flag
FALSE
FALSE
debug_debug_macro
gf_macro_flag
FALSE
FALSE
debug_debug_names
gf_debug_names_flag
FALSE
FALSE
debug_eh_frame
gf_eh_frame_flag
FALSE
FALSE
debug_frame
gf_frame_flag
FALSE
FALSE
gdb_index
gf_gdbindex_flag
FALSE
FALSE
debug_info
gf_info_flag
FALSE
FALSE
debug_line
gf_line_flag
FALSE
FALSE
debug_loc
gf_loc_flag
FALSE
FALSE
debug_loclists
gf_loclists_flag
FALSE
FALSE
debug_pubnames
gf_pubnames_flag
FALSE
FALSE
SGI
only
debug_pubtypes
gf_pubtypes_flag
FALSE
FALSE
debug_ranges
gf_ranges_flag
FALSE
FALSE
debug_rnglists
gf_rnglists_flag
FALSE
FALSE
SGI
only
debug_static_func
gf_static_func_flag
FALSE
FALSE
SGI
only
debug_static_var
gf_static_var_flag
FALSE
FALSE
debug_str
gf_string_flag
FALSE
FALSE
debug_types
gf_types_flag
FALSE
FALSE
SGI
only
debug_weaknames
gf_weakname_flag
FALSE
FALSE
endif
If
a
section
is
not
in
group
N
but
is
in
group
then
turn
off
its
flag
Since
sections
are
never
in
both
various
DW_DLE
DUPLICATE
errors
if
libdwarf
tries
to
set
in
both
just
look
in
group
one
See
groups_restore_subsidiary_flags
just
below
FIXME
It
would
be
good
if
for
a
wholly
missing
section
related
to
a
flag
that
the
flag
got
turned
off
if
static
void
turn_off_subsidiary_flags
Dwarf_Debug
dbg
UNUSEDARG
Dwarf_Unsigned
i
for
i
group_map_entry_count
i
if
group_nums
i
unsigned
k
const
char
oursec
sec_names
i
for
glftab
k
secname
k
if
strcmp
oursec
glftab
k
secname
if
glftab
k
origset
glftab
k
origset
TRUE
glftab
k
origflag
glftab
k
flag
glftab
k
flag
FALSE
endif
Restoring
original
condition
in
the
glftab
array
and
in
the
global
flags
it
points
to
So
that
when
processing
an
archive
one
can
restore
the
user
chosen
flags
and
print
subsequent
object
groups
correctly
New
October
void
groups_restore_subsidiary_flags
void
if
unsigned
k
endif
Duplicative
but
harmless
free
freeall_groups_tables
if
for
glftab
k
secname
k
if
glftab
k
origset
glftab
k
flag
glftab
k
origflag
glftab
k
origset
FALSE
glftab
k
origflag
FALSE
endif
NEW
May
Has
a
side
effect
of
using
the
local
table
set
up
by
print_section_groups_data
and
then
frees
the
table
data
For
multi
object
archive
reading
main
calls
groups_restore_subsidiary_flags
at
the
end
of
each
object
file
to
restore
the
original
flags
that
turn_off_subsidiary_flags
changed
void
update_section_flags_per_groups
Dwarf_Debug
dbg
UNUSEDARG
if
sec_names
The
tables
are
absent
Internal
logic
error
here
somewhere
freeall_groups_tables
return
if
selected_group
DW_GROUPNUMBER_BASE
freeall_groups_tables
return
if
selected_group
DW_GROUPNUMBER_DWO
freeall_groups_tables
return
if
turn_off_subsidiary_flags
dbg
endif
freeall_groups_tables
NEW
May
Reports
on
section
groupings
like
DWO
split
dwarf
and
COMDAT
groups
As
a
side
effect
creates
local
table
of
section
and
group
data
int
print_section_groups_data
Dwarf_Debug
dbg
Dwarf_Error
error
int
res
Dwarf_Unsigned
i
res
dwarf_sec_group_sizes
dbg
error
if
res
DW_DLV_OK
simple_err_return_msg_either_action
res
ERROR
dwarf_sec_group_sizes
failed
return
res
if
group_count
selected_group
This
is
the
traditional
DWARF
with
no
split
dwarf
and
no
COMDAT
data
We
don
t
want
to
print
anything
as
we
do
not
want
to
see
differences
from
existing
output
in
this
case
Simplifies
regression
testing
for
now
return
DW_DLV_OK
printf
Section
Groups
data
n
printf
Number
of
Elf
like
sections
DW_PR_DUu
n
section_count
printf
Number
of
groups
DW_PR_DUu
n
group_count
printf
Group
to
print
DW_PR_DUu
n
selected_group
printf
Count
of
map
entries
DW_PR_DUu
n
group_map_entry_count
sec_nums
calloc
group_map_entry_count
sizeof
Dwarf_Unsigned
if
sec_nums
glflags
gf_count_major_errors
printf
ERROR
Unable
to
allocate
DW_PR_DUu
map
section
values
cannot
print
group
map
n
group_map_entry_count
return
DW_DLV_OK
group_nums
calloc
group_map_entry_count
sizeof
Dwarf_Unsigned
if
group_nums
free
group_nums
glflags
gf_count_major_errors
printf
ERROR
Unable
to
allocate
DW_PR_DUu
map
group
values
cannot
print
group
map
n
group_map_entry_count
return
DW_DLV_OK
sec_names
calloc
group_map_entry_count
sizeof
char
if
sec_names
free
group_nums
free
sec_nums
glflags
gf_count_major_errors
printf
ERROR
Unable
to
allocate
DW_PR_DUu
section
name
pointers
cannot
print
group
map
n
group_map_entry_count
return
DW_DLV_OK
res
dwarf_sec_group_map
dbg
group_map_entry_count
group_nums
sec_nums
sec_names
error
if
res
DW_DLV_OK
simple_err_return_msg_either_action
res
ERROR
dwarf_sec_group_map
failed
return
res
for
i
i
group_map_entry_count
i
if
i
printf
index
group
section
n
printf
DW_PR_DUu
DW_PR_DUu
DW_PR_DUu
s
n
i
group_nums
i
sec_nums
i
sanitized
sec_names
i
Do
not
free
our
allocations
Will
do
later
using
freeall_groups_tables
return
DW_DLV_OK
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
print_sections
h
include
print_frames
h
Print
line
number
information
filename
new
basic
block
line
address
new
statement
int
dwarf_names_print_on_error
The
April
dwarf_get_section_max_offsets
in
libdwarf
returns
all
max
offsets
but
we
only
want
one
of
those
offsets
This
function
returns
the
one
we
want
from
that
set
making
functions
needing
this
offset
as
readable
as
possible
avoiding
code
duplication
In
case
of
error
or
missing
section
it
returns
a
zero
size
which
seems
appropriate
Dwarf_Unsigned
get_info_max_offset
Dwarf_Debug
dbg
Dwarf_Unsigned
debug_info_size
int
res
res
dwarf_get_section_max_offsets_d
dbg
if
res
DW_DLV_OK
return
return
debug_info_size
Dumping
a
dwarf
expression
as
a
byte
stream
void
dump_block
char
prefix
char
data
Dwarf_Signed
len
char
end_data
data
len
char
cur
data
int
i
printf
s
prefix
for
cur
end_data
cur
i
if
i
i
printf
printf
cur
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
print_sections
h
include
print_frames
h
include
sanitized
h
Get
all
the
data
in
debug_funcnames
An
SGI
extension
For
a
long
time
erroneously
called
debug_static_funcs
here
On
error
this
allows
some
dwarf
memory
leaks
extern
int
print_static_funcs
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Func
globbuf
NULL
Dwarf_Signed
count
int
gfres
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
truename
struct
esb_s
sanitname
glflags
current_section_id
DEBUG_FUNCNAMES
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_funcnames
TRUE
esb_constructor
Sanitized
cannot
be
safely
reused
there
is
a
static
buffer
so
we
make
a
safe
copy
esb_append
sanitized
esb_get_string
esb_destructor
if
glflags
verbose
For
best
testing
dwarf_return_empty_pubnames
dbg
err
gfres
dwarf_get_funcs
dbg
err
if
gfres
DW_DLV_ERROR
printf
n
s
n
esb_get_string
return
gfres
else
if
gfres
DW_DLV_NO_ENTRY
dwarf_return_empty_pubnames
dbg
err
esb_destructor
return
gfres
else
int
pres
int
printed
FALSE
if
glflags
gf_do_print_dwarf
count
SGI
specific
so
only
mention
if
present
printf
n
s
n
esb_get_string
printed
TRUE
pres
print_all_pubnames_style_records
dbg
static
func
esb_get_string
Dwarf_Global
globbuf
count
err
dwarf_funcs_dealloc
dbg
globbuf
count
if
pres
DW_DLV_ERROR
if
printed
printf
n
s
n
esb_get_string
dwarf_return_empty_pubnames
dbg
err
esb_destructor
return
pres
dwarf_return_empty_pubnames
dbg
err
esb_destructor
return
DW_DLV_OK
print_static_funcs
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
print_sections
h
include
print_frames
h
include
sanitized
h
Get
all
the
data
in
debug_varnames
an
SGI
extension
For
a
long
time
erroneously
called
debug_static_vars
bere
int
print_static_vars
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Var
globbuf
NULL
Dwarf_Signed
count
int
res
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
sanitname
glflags
current_section_id
DEBUG_VARNAMES
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_varnames
TRUE
esb_constructor
Sanitized
cannot
be
safely
reused
there
is
a
static
buffer
so
we
make
a
safe
copy
esb_append
sanitized
esb_get_string
esb_destructor
if
glflags
verbose
For
best
testing
dwarf_return_empty_pubnames
dbg
err
res
dwarf_get_vars
dbg
err
if
res
DW_DLV_ERROR
esb_destructor
dwarf_return_empty_pubnames
dbg
err
return
res
else
if
res
DW_DLV_NO_ENTRY
no
static
vars
esb_destructor
dwarf_return_empty_pubnames
dbg
err
return
res
else
int
pres
int
printed
FALSE
if
glflags
gf_do_print_dwarf
count
SGI
specific
so
only
mention
if
present
printf
n
s
n
esb_get_string
printed
TRUE
pres
print_all_pubnames_style_records
dbg
static
var
esb_get_string
Dwarf_Global
globbuf
count
err
if
pres
DW_DLV_ERROR
if
printed
printf
n
s
n
esb_get_string
esb_destructor
dwarf_return_empty_pubnames
dbg
err
dwarf_vars_dealloc
dbg
globbuf
count
return
pres
dwarf_return_empty_pubnames
dbg
err
esb_destructor
return
DW_DLV_OK
print_static_vars
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
print
data
in
debug_str_offsets
There
is
no
guarantee
this
will
work
because
the
DWARF5
standard
is
silent
about
whether
arbitrary
non
zero
bytes
or
odd
alignments
or
unused
data
spaces
are
allowed
in
the
section
int
print_str_offsets_section
Dwarf_Debug
dbg
Dwarf_Error
err
int
res
Dwarf_Str_Offsets_Table
sot
Dwarf_Unsigned
wasted_byte_count
Dwarf_Unsigned
table_count
Dwarf_Unsigned
tabnum
res
dwarf_open_str_offsets_table_access
dbg
err
if
res
DW_DLV_NO_ENTRY
No
such
table
return
res
if
res
DW_DLV_ERROR
return
res
for
tabnum
Dwarf_Unsigned
unit_length
Dwarf_Unsigned
unit_length_offset
Dwarf_Unsigned
table_start_offset
Dwarf_Half
entry_size
Dwarf_Half
version
Dwarf_Half
padding
Dwarf_Unsigned
table_value_count
Dwarf_Unsigned
i
Dwarf_Unsigned
table_entry_value
unsigned
rowlim
unsigned
count_in_row
res
dwarf_next_str_offsets_table
sot
err
if
res
DW_DLV_NO_ENTRY
We
have
dealt
with
all
tables
break
if
res
DW_DLV_ERROR
dwarf_close_str_offsets_table_access
sot
err
return
res
if
tabnum
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_str_offsets
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
else
printf
n
printf
table
DW_PR_DUu
n
tabnum
printf
tableheader
DW_PR_XZEROS
DW_PR_DUx
n
unit_length_offset
printf
arrayoffset
DW_PR_XZEROS
DW_PR_DUx
n
table_start_offset
printf
unit
length
DW_PR_XZEROS
DW_PR_DUx
n
unit_length
printf
entry
size
u
n
entry_size
printf
version
u
n
version
if
padding
printf
Error
padding
is
non
zero
Something
is
wrong
n
printf
padding
x
n
padding
printf
arraysize
DW_PR_DUu
n
table_value_count
Lets
print
per
row
count_in_row
for
i
i
table_value_count
i
res
dwarf_str_offsets_value_by_index
sot
i
err
if
res
DW_DLV_OK
dwarf_close_str_offsets_table_access
sot
err
return
res
if
count_in_row
printf
Entry
DW_PR_DUu
i
printf
DW_PR_XZEROS
DW_PR_DUx
table_entry_value
count_in_row
if
count_in_row
rowlim
continue
printf
n
count_in_row
if
count_in_row
printf
n
res
dwarf_str_offsets_statistics
sot
err
if
res
DW_DLV_OK
printf
wasted
DW_PR_DUu
bytes
n
wasted_byte_count
if
res
DW_DLV_ERROR
res
dwarf_close_str_offsets_table_access
sot
err
return
res
if
wasted_byte_count
res
dwarf_str_offsets_statistics
sot
err
if
res
DW_DLV_OK
printf
finalwasted
DW_PR_DUu
bytes
n
wasted_byte_count
else
res
dwarf_close_str_offsets_table_access
sot
err
return
res
res
dwarf_close_str_offsets_table_access
sot
err
sot
return
res
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
static
void
print_sec_name
Dwarf_Debug
dbg
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_str
TRUE
printf
n
s
n
sanitized
esb_get_string
esb_destructor
print
data
in
debug_str
int
print_strings
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Signed
length
char
name
Dwarf_Off
offset
int
sres
unsigned
loopct
glflags
current_section_id
DEBUG_STR
for
loopct
sres
dwarf_get_str
dbg
offset
err
DW_DLV_OK
loopct
if
loopct
print_sec_name
dbg
if
glflags
gf_display_offsets
printf
name
at
offset
DW_PR_XZEROS
DW_PR_DUx
length
DW_PR_DSd
is
s
n
Dwarf_Unsigned
offset
length
sanitized
name
else
printf
name
length
DW_PR_DSd
is
s
n
length
sanitized
name
offset
length
if
loopct
print_sec_name
dbg
An
inability
to
find
the
section
is
not
necessarily
a
real
error
so
do
not
report
error
unless
we
ve
seen
a
real
record
if
sres
DW_DLV_ERROR
struct
esb_s
m
esb_constructor
esb_append_printf_u
nERROR
Getting
a
debug_str
section
string
failed
at
string
number
u
loopct
esb_append_printf_u
section
offset
DW_PR_DUx
offset
simple_err_only_return_action
sres
esb_get_string
esb_destructor
return
sres
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
The
address
of
the
Free
Software
Foundation
is
Free
Software
Foundation
Inc
Franklin
St
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
ifdef
HAVE_STDINT_H
include
stdint
h
For
uintptr_t
endif
HAVE_STDINT_H
include
naming
h
include
esb
h
For
flexible
string
buffer
include
esb_using_functions
h
include
sanitized
h
include
print_frames
h
for
print_location_operations
include
macrocheck
h
include
helpertree
h
include
opscounttab
h
include
tag_common
h
include
attr_form
h
static
int
pd_dwarf_names_print_on_error
ifdef
HAVE_USAGE_TAG_ATTR
Record
TAGs
usage
static
unsigned
int
tag_usage
DW_TAG_last
void
record_tag_usage
int
tag
if
tag
DW_TAG_last
tag_usage
tag
endif
HAVE_USAGE_TAG_ATTR
include
dwarfdump
ta
table
h
include
dwarfdump
ta
ext
table
h
int
legal_tag_attr_combination
Dwarf_Half
tag
Dwarf_Half
attr
if
tag
return
FALSE
if
tag
ATTR_TREE_ROW_COUNT
int
index
attr
BITS_PER_WORD
if
index
ATTR_TREE_COLUMN_COUNT
unsigned
bitflag
unsigned
attr
BITS_PER_WORD
int
known
tag_attr_combination_table
tag
index
bitflag
TRUE
FALSE
if
known
ifdef
HAVE_USAGE_TAG_ATTR
Record
usage
of
pair
tag
attr
if
glflags
gf_print_usage_tag_attr
Usage_Tag_Attr
usage_ptr
usage_tag_attr
tag
while
usage_ptr
attr
if
attr
usage_ptr
attr
usage_ptr
count
break
usage_ptr
endif
HAVE_USAGE_TAG_ATTR
return
TRUE
DW_AT_MIPS_fde
used
to
return
TRUE
as
that
was
convenient
for
SGI
MIPS
users
if
glflags
gf_suppress_check_extensions_tables
int
r
for
r
ATTR_TREE_EXT_ROW_COUNT
r
int
c
if
tag
tag_attr_combination_ext_table
r
continue
for
c
ATTR_TREE_EXT_COLUMN_COUNT
c
if
tag_attr_combination_ext_table
r
c
attr
return
TRUE
return
FALSE
include
dwarfdump
tt
table
h
include
dwarfdump
tt
ext
table
h
Look
only
at
valid
table
entries
The
check
here
must
match
the
building
logic
in
tag_tree
c
And
must
match
the
tags
defined
in
dwarf
h
The
tag_tree_combination_table
is
a
table
of
bit
flags
int
legal_tag_tree_combination
Dwarf_Half
tag_parent
Dwarf_Half
tag_child
if
tag_parent
return
FALSE
if
tag_parent
TAG_TREE_ROW_COUNT
int
index
tag_child
BITS_PER_WORD
if
index
TAG_TREE_COLUMN_COUNT
unsigned
bitflag
unsigned
tag_child
BITS_PER_WORD
int
known
tag_tree_combination_table
tag_parent
index
bitflag
TRUE
FALSE
if
known
ifdef
HAVE_USAGE_TAG_ATTR
Record
usage
of
pair
tag_parent
tag_child
if
glflags
gf_print_usage_tag_attr
Usage_Tag_Tree
usage_ptr
usage_tag_tree
tag_parent
while
usage_ptr
tag
if
tag_child
usage_ptr
tag
usage_ptr
count
break
usage_ptr
endif
HAVE_USAGE_TAG_ATTR
return
TRUE
if
glflags
gf_suppress_check_extensions_tables
int
r
for
r
TAG_TREE_EXT_ROW_COUNT
r
int
c
if
tag_parent
tag_tree_combination_ext_table
r
continue
for
c
TAG_TREE_EXT_COLUMN_COUNT
c
if
tag_tree_combination_ext_table
r
c
tag_child
return
TRUE
return
FALSE
Print
a
detailed
tag
and
attributes
usage
int
print_tag_attributes_usage
void
ifdef
HAVE_USAGE_TAG_ATTR
Traverse
the
tag
tree
table
to
print
its
usage
and
then
use
the
DW_TAG
value
as
an
index
into
the
tag_attr
table
to
print
its
associated
usage
all
together
Dwarf_Bool
print_header
TRUE
Rate_Tag_Tree
tag_rate
Rate_Tag_Attr
atr_rate
Usage_Tag_Tree
usage_tag_tree_ptr
Usage_Tag_Attr
usage_tag_attr_ptr
Dwarf_Unsigned
total_tags
Dwarf_Unsigned
total_atrs
Dwarf_Half
total_found_tags
Dwarf_Half
total_found_atrs
Dwarf_Half
total_legal_tags
Dwarf_Half
total_legal_atrs
float
rate_1
float
rate_2
int
tag
printf
n
TAGS
AND
ATTRIBUTES
USAGE
n
for
tag
tag
DW_TAG_last
tag
Print
usage
of
children
TAGs
if
glflags
gf_print_usage_tag_attr_full
tag_usage
tag
usage_tag_tree_ptr
usage_tag_tree
tag
if
usage_tag_tree_ptr
print_header
total_tags
tag_usage
tag
printf
s
n
tag_usage
tag
get_TAG_name
tag
pd_dwarf_names_print_on_error
print_header
FALSE
while
usage_tag_tree_ptr
usage_tag_tree_ptr
tag
if
glflags
gf_print_usage_tag_attr_full
usage_tag_tree_ptr
count
total_tags
usage_tag_tree_ptr
count
printf
s
n
usage_tag_tree_ptr
count
get_TAG_name
usage_tag_tree_ptr
tag
pd_dwarf_names_print_on_error
Record
the
tag
as
found
if
usage_tag_tree_ptr
count
rate_tag_tree
tag
found
usage_tag_tree_ptr
Print
usage
of
attributes
if
glflags
gf_print_usage_tag_attr_full
tag_usage
tag
usage_tag_attr_ptr
usage_tag_attr
tag
if
usage_tag_attr_ptr
print_header
total_tags
tag_usage
tag
printf
s
n
tag_usage
tag
get_TAG_name
tag
pd_dwarf_names_print_on_error
while
usage_tag_attr_ptr
usage_tag_attr_ptr
attr
if
glflags
gf_print_usage_tag_attr_full
usage_tag_attr_ptr
count
total_atrs
usage_tag_attr_ptr
count
printf
s
n
usage_tag_attr_ptr
count
get_AT_name
usage_tag_attr_ptr
attr
pd_dwarf_names_print_on_error
Record
the
attribute
as
found
if
usage_tag_attr_ptr
count
rate_tag_attr
tag
found
usage_tag_attr_ptr
print_header
TRUE
printf
Summary
n
Number
of
standard
tags
DW_PR_XZEROS
DW_PR_DUu
n
TAGs
Number
of
standard
attributes
DW_PR_XZEROS
DW_PR_DUu
n
ATRs
total_tags
total_atrs
total_legal_tags
total_found_tags
total_legal_atrs
total_found_atrs
Print
percentage
of
TAGs
covered
printf
n
STANDARD
TAGS
AND
ATTRIBUTES
USAGE
RATE
n
printf
n
Tags
Attributes
printf
legal
found
rate
legal
found
rate
n
TAG
name
for
tag
tag
DW_TAG_last
tag
tag_rate
tag
atr_rate
tag
if
glflags
gf_print_usage_tag_attr_full
tag_rate
found
atr_rate
found
rate_1
tag_rate
legal
float
tag_rate
found
tag_rate
legal
rate_2
atr_rate
legal
float
atr_rate
found
atr_rate
legal
Skip
not
defined
DW_TAG
values
See
dwarf
h
if
usage_tag_tree
tag
total_legal_tags
tag_rate
legal
total_found_tags
tag_rate
found
total_legal_atrs
atr_rate
legal
total_found_atrs
atr_rate
found
printf
n
get_TAG_name
tag
pd_dwarf_names_print_on_error
tag_rate
legal
tag_rate
found
rate_1
atr_rate
legal
atr_rate
found
rate_2
Print
a
whole
summary
rate_1
total_legal_tags
float
total_found_tags
total_legal_tags
rate_2
total_legal_atrs
float
total_found_atrs
total_legal_atrs
printf
n
Summary
total_legal_tags
total_found_tags
rate_1
total_legal_atrs
total_found_atrs
rate_2
if
glflags
gf_check_tag_attr
glflags
gf_check_attr_encoding
glflags
gf_print_usage_tag_attr
print_attr_form_usage
pd_dwarf_names_print_on_error
endif
HAVE_USAGE_TAG_ATTR
return
DW_DLV_OK
This
is
only
needed
when
processing
archives
There
is
no
data
to
free
but
there
are
counts
to
reset
usage_tag_tree
has
a
count
field
rate_tag_tree
has
a
found
field
Function
created
February
The
usage
info
printed
by
dwarfdump
from
Elf
archives
has
been
wrong
for
a
few
years
due
to
the
lack
of
this
function
void
reset_usage_rate_tag_trees
void
int
i
for
i
i
DW_TAG_last
i
tag_usage
i
for
i
i
DW_TAG_last
i
Usage_Tag_Tree
usage_ptr
usage_tag_tree
i
if
usage_ptr
continue
for
usage_ptr
tag
usage_ptr
usage_ptr
count
for
i
i
DW_TAG_last
i
rate_tag_tree
i
found
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
print_sections
h
include
print_frames
h
include
sanitized
h
Get
all
the
data
in
debug_typenames
or
debug_pubtypes
int
print_types
Dwarf_Debug
dbg
enum
type_type_e
type_type
Dwarf_Error
err
Dwarf_Type
globbuf
Dwarf_Signed
count
char
name
int
gtres
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
struct
esb_s
sanitname
int
get_types
Dwarf_Debug
Dwarf_Type
Dwarf_Signed
Dwarf_Error
void
dealloctype
Dwarf_Debug
Dwarf_Type
Dwarf_Signed
NULL
const
char
linetitle
We
will
now
only
list
either
section
when
there
is
content
if
type_type
DWARF_PUBTYPES
name
debug_pubtypes
get_types
dwarf_get_pubtypes
dealloctype
dwarf_pubtypes_dealloc
linetitle
pubtype
else
SGI_TYPENAME
No
need
to
get
the
real
section
name
this
section
not
used
in
modern
compilers
name
debug_typenames
get_types
dwarf_get_types
dealloctype
dwarf_types_dealloc
linetitle
type
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
name
TRUE
esb_constructor
Sanitized
cannot
be
safely
reused
there
is
a
static
buffer
so
we
make
a
safe
copy
esb_append
sanitized
esb_get_string
esb_destructor
if
glflags
verbose
dwarf_return_empty_pubnames
dbg
err
gtres
get_types
dbg
err
if
gtres
DW_DLV_ERROR
printf
n
s
n
esb_get_string
esb_destructor
return
gtres
else
if
gtres
DW_DLV_NO_ENTRY
no
types
esb_destructor
dwarf_return_empty_pubnames
dbg
err
return
gtres
else
int
wkres
int
printed
FALSE
if
glflags
gf_do_print_dwarf
count
printf
n
s
n
esb_get_string
printed
TRUE
wkres
print_all_pubnames_style_records
dbg
linetitle
esb_get_string
Dwarf_Global
globbuf
count
err
dealloctype
dbg
globbuf
count
if
wkres
DW_DLV_ERROR
if
printed
printf
n
s
n
esb_get_string
dwarf_return_empty_pubnames
dbg
err
esb_destructor
return
wkres
esb_destructor
dwarf_return_empty_pubnames
dbg
err
return
DW_DLV_OK
print_types
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
Sun
Microsystems
Inc
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
naming
h
include
esb
h
include
esb_using_functions
h
include
sanitized
h
include
print_sections
h
Get
all
the
data
in
debug_weaknames
extern
int
print_weaknames
Dwarf_Debug
dbg
Dwarf_Error
err
Dwarf_Weak
globbuf
NULL
Dwarf_Signed
count
int
wkres
struct
esb_s
sanitname
struct
esb_s
truename
char
buf
DWARF_SECNAME_BUFFER_SIZE
glflags
current_section_id
DEBUG_WEAKNAMES
esb_constructor_fixed
buf
sizeof
buf
get_true_section_name
dbg
debug_weaknames
TRUE
esb_constructor
Sanitized
cannot
be
safely
reused
there
is
a
static
buffer
so
we
make
a
safe
copy
esb_append
sanitized
esb_get_string
esb_destructor
if
glflags
verbose
For
best
testing
dwarf_return_empty_pubnames
dbg
err
wkres
dwarf_get_weaks
dbg
err
if
wkres
DW_DLV_ERROR
printf
n
s
n
esb_get_string
esb_destructor
return
wkres
else
if
wkres
DW_DLV_NO_ENTRY
Dwarf_Error
berr
esb_destructor
dwarf_return_empty_pubnames
dbg
no
weaknames
return
wkres
else
int
printed
if
glflags
gf_do_print_dwarf
count
SGI
specific
so
only
mention
if
present
printf
n
s
n
esb_get_string
printed
wkres
print_all_pubnames_style_records
dbg
weakname
esb_get_string
Dwarf_Global
globbuf
count
err
esb_destructor
globbuf
should
be
zero
count
in
case
of
DW_DLV_ERROR
That
s
ok
dwarf_weaks_dealloc
dbg
globbuf
count
dwarf_return_empty_pubnames
dbg
err
if
wkres
DW_DLV_ERROR
if
printed
printf
n
s
n
esb_get_string
return
wkres
esb_destructor
dwarf_return_empty_pubnames
dbg
err
return
DW_DLV_OK
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
Definitions
for
TRUE
FALSE
etc
include
globals
h
include
esb
h
include
glflags
h
include
sanitized
h
This
does
a
uri
style
conversion
of
control
characters
So
SOH
prints
as
for
example
Which
stops
corrupted
or
crafted
strings
from
doing
things
to
the
terminal
the
string
is
routed
to
We
do
not
translate
an
input
to
as
in
real
uri
as
that
would
be
a
bit
confusing
for
most
readers
The
conversion
makes
it
possble
to
print
UTF
strings
reproducibly
sort
of
not
showing
the
real
glyph
Only
call
this
in
a
printf
or
sprintf
and
only
call
it
once
in
any
single
printf
sprintf
Othewise
you
will
get
bogus
results
and
confusion
ASCII
control
codes
We
leave
newline
as
is
NUL
is
end
of
string
the
others
are
translated
NUL
Null
Ctrl
SOH
Start
of
heading
Alt
Ctrl
A
STX
Start
of
text
Alt
Ctrl
B
ETX
End
of
text
Alt
Ctrl
C
EOT
End
of
transmission
Alt
Ctrl
D
ENQ
Enquiry
Alt
Ctrl
E
ACK
Acknowledge
Alt
Ctrl
F
BEL
Bell
Alt
Ctrl
G
BS
Backspace
Alt
Ctrl
H
HT
Horizontal
tab
Alt
Ctrl
I
LF
Line
feed
Alt
Ctrl
J
VT
Vertical
tab
Alt
Ctrl
K
FF
Form
feed
Alt
Ctrl
L
CR
Carriage
return
Alt
Ctrl
M
SO
Shift
out
Alt
Ctrl
N
SI
Shift
in
Alt
Ctrl
O
DLE
Data
line
escape
Alt
Ctrl
P
DC1
Device
control
Alt
Ctrl
Q
DC2
Device
control
Alt
Ctrl
R
DC3
Device
control
Alt
Ctrl
S
DC4
Device
control
Alt
Ctrl
T
NAK
Negative
acknowledge
Alt
Ctrl
U
SYN
Synchronous
idle
Alt
Ctrl
V
ETB
End
transmission
block
Alt
Ctrl
W
CAN
Cancel
Alt
Ctrl
X
EM
End
of
medium
Alt
Ctrl
Y
SU
Substitute
Alt
Ctrl
Z
ES
Escape
Alt
Ctrl
FS
File
separator
Alt
Ctrl
GS
Group
separator
Alt
Ctrl
RS
Record
separator
Alt
Ctrl
US
Unit
separator
Alt
Ctrl
_
In
addition
characters
decimal
appear
to
be
questionable
too
Not
in
iso
nor
in
html
character
entities
list
We
translate
all
strings
with
a
to
do
sanitizing
and
we
change
a
literal
ASCII
char
to
so
readers
know
any
is
a
sanitized
char
We
could
double
up
a
into
on
output
but
switching
to
is
simpler
and
for
readers
and
prevents
ambiguity
Since
we
do
not
handle
utf
properly
nor
detect
it
we
turn
all
non
ASCII
to
xx
below
static
struct
esb_s
localesb
do_sanity_insert
and
no_questionable_chars
absolutely
must
have
the
same
idea
of
questionable
characters
Be
Careful
static
void
do_sanity_insert
const
char
s
struct
esb_s
mesb
const
char
cp
s
for
cp
cp
unsigned
c
cp
if
c
xx
for
this
too
Simple
and
unambiguous
esb_append
mesb
esb_append_printf_u
mesb
c
continue
if
c
c
Usual
case
ASCII
printable
characters
esb_appendn
mesb
cp
continue
ifdef
_WIN32
if
c
esb_appendn
mesb
cp
continue
endif
_WIN32
if
c
esb_append
mesb
esb_append_printf_u
mesb
c
continue
ASSERT
c
ISO
or
UTF
Not
handled
well
yet
esb_append
mesb
esb_append_printf_u
mesb
c
This
routine
improves
overall
dwarfdump
run
times
a
lot
by
separating
strings
that
might
print
badly
from
strings
that
will
print
fine
In
one
large
test
case
it
reduces
run
time
from
seconds
to
seconds
static
int
no_questionable_chars
const
char
s
const
char
cp
s
for
cp
cp
unsigned
c
cp
if
c
Always
sanitize
a
ASCII
char
return
FALSE
if
c
c
Usual
case
ASCII
printable
characters
continue
ifdef
_WIN32
if
c
continue
endif
_WIN32
if
c
c
continue
if
c
return
FALSE
if
c
This
notices
iso
and
UTF
data
as
we
don
t
deal
with
them
properly
in
dwarfdump
return
FALSE
return
TRUE
void
sanitized_string_destructor
void
esb_destructor
const
char
sanitized
const
char
s
const
char
sout
if
glflags
gf_no_sanitize_strings
return
s
if
no_questionable_chars
s
The
original
string
is
safe
as
is
return
s
Using
esb_destructor
is
quite
expensive
in
cpu
time
when
we
build
the
next
sanitized
string
so
we
just
empty
the
localesb
One
reason
it
s
expensive
is
that
we
do
the
appends
in
such
small
batches
in
do_sanity
insert
esb_empty_string
do_sanity_insert
s
sout
esb_get_string
return
sout
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
section_bitmaps
h
and
c
actually
involved
bits
bit
shifting
and
bit
masks
but
now
the
maps
are
simple
byte
arrays
See
reloc_map
and
section_map
in
command_options
c
include
section_bitmaps
h
struct
section_map_s
map_sectnames
DW_HDR_ARRAY_SIZE
DW_SECTNAME_DEBUG_INFO
DW_HDR_DEBUG_INFO
DW_SECTNAME_DEBUG_INFO_DWO
DW_HDR_DEBUG_INFO_DWO
DW_SECTNAME_DEBUG_LINE
DW_HDR_DEBUG_LINE
DW_SECTNAME_DEBUG_LINE_DWO
DW_HDR_DEBUG_LINE_DWO
DW_SECTNAME_DEBUG_PUBNAMES
DW_HDR_DEBUG_PUBNAMES
DW_SECTNAME_DEBUG_ABBREV
DW_HDR_DEBUG_ABBREV
DW_SECTNAME_DEBUG_ABBREV_DWO
DW_HDR_DEBUG_ABBREV_DWO
DW_SECTNAME_DEBUG_ARANGES
DW_HDR_DEBUG_ARANGES
DW_SECTNAME_DEBUG_FRAME
DW_HDR_DEBUG_FRAME
DW_SECTNAME_DEBUG_LOC
DW_HDR_DEBUG_LOC
DW_SECTNAME_DEBUG_LOCLISTS
DW_HDR_DEBUG_LOCLISTS
DW_SECTNAME_DEBUG_LOCLISTS_DWO
DW_HDR_DEBUG_LOCLISTS_DWO
DW_SECTNAME_DEBUG_RANGES
DW_HDR_DEBUG_RANGES
DW_SECTNAME_DEBUG_RNGLISTS
DW_HDR_DEBUG_RNGLISTS
DW_SECTNAME_DEBUG_RNGLISTS_DWO
DW_HDR_DEBUG_RNGLISTS_DWO
DW_SECTNAME_DEBUG_STR
DW_HDR_DEBUG_STR
DW_SECTNAME_DEBUG_STR_DWO
DW_HDR_DEBUG_STR_DWO
DW_SECTNAME_DEBUG_STR_OFFSETS
DW_HDR_DEBUG_STR_OFFSETS
DW_SECTNAME_DEBUG_STR_OFFSETS_DWO
DW_HDR_DEBUG_STR_OFFSETS_DWO
DW_SECTNAME_DEBUG_PUBTYPES
DW_HDR_DEBUG_PUBTYPES
DW_SECTNAME_DEBUG_TYPES
DW_HDR_DEBUG_TYPES
DW_SECTNAME_TEXT
DW_HDR_TEXT
DW_SECTNAME_GDB_INDEX
DW_HDR_GDB_INDEX
DW_SECTNAME_EH_FRAME
DW_HDR_EH_FRAME
DW_SECTNAME_DEBUG_MACINFO
DW_HDR_DEBUG_MACINFO
DW_SECTNAME_DEBUG_MACRO
DW_HDR_DEBUG_MACRO
DW_SECTNAME_DEBUG_MACRO_DWO
DW_HDR_DEBUG_MACRO_DWO
DW_SECTNAME_DEBUG_NAMES
DW_HDR_DEBUG_NAMES
DW_SECTNAME_DEBUG_CU_INDEX
DW_HDR_DEBUG_CU_INDEX
DW_SECTNAME_DEBUG_TU_INDEX
DW_HDR_DEBUG_TU_INDEX
Elf
Header
DW_HDR_HEADER
See
section_bitmaps
c
h
Control
section
header
printing
not
DWARF
printing
static
char
reloc_map
DW_SECTION_REL_ARRAY_SIZE
static
char
section_map
DW_HDR_ARRAY_SIZE
static
Dwarf_Bool
all_sections_on
unsigned
section_bitmap_array_size
void
unsigned
len
sizeof
map_sectnames
sizeof
struct
section_map_s
return
len
Dwarf_Bool
section_name_is_debug_and_wanted
const
char
section_name
unsigned
i
if
all_sections_on
return
TRUE
for
i
DW_HDR_ARRAY_SIZE
i
if
strcmp
section_name
map_sectnames
i
name
section_map
map_sectnames
i
value
return
TRUE
return
FALSE
For
now
defaults
matches
all
but
text
void
set_all_section_defaults
void
unsigned
i
for
i
DW_HDR_ARRAY_SIZE
i
section_map
i
TRUE
void
set_all_sections_on
void
unsigned
i
all_sections_on
TRUE
for
i
DW_HDR_ARRAY_SIZE
i
section_map
i
TRUE
void
set_all_reloc_sections_on
void
unsigned
i
for
i
DW_SECTION_REL_ARRAY_SIZE
i
reloc_map
i
TRUE
Dwarf_Bool
any_section_header_to_print
void
unsigned
i
for
i
DW_HDR_HEADER
i
if
section_map
i
return
TRUE
return
FALSE
TRUE
if
the
section
map
entry
specified
by
the
index
has
been
enabled
Dwarf_Bool
section_map_enabled
unsigned
index
if
index
index
DW_HDR_ARRAY_SIZE
return
FALSE
return
section_map
index
void
enable_section_map_entry
unsigned
index
if
index
index
DW_HDR_ARRAY_SIZE
section_map
index
TRUE
TRUE
if
the
reloc
map
entry
specified
by
the
index
has
been
enabled
Dwarf_Bool
reloc_map_enabled
unsigned
index
if
index
index
DW_SECTION_REL_ARRAY_SIZE
return
FALSE
return
reloc_map
index
void
enable_reloc_map_entry
unsigned
index
if
index
index
DW_SECTION_REL_ARRAY_SIZE
reloc_map
index
TRUE
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
This
tries
to
find
the
string
contained
in
the
string
container
it
returns
true
if
found
else
false
The
comparisons
are
independent
of
case
Regrettably
there
is
no
generally
accepted
version
that
does
this
job
though
GNU
Linux
has
strcasestr
which
does
what
we
need
Our
code
here
do
not
behave
like
strstr
or
strcasestr
in
the
case
of
an
empty
contained
argument
we
return
FALSE
this
case
is
not
interesting
for
dwarfdump
There
is
a
public
domain
stristr
But
given
that
dwarfdump
is
GPL
it
would
seem
IANAL
that
we
cannot
mix
public
domain
code
into
the
release
The
software
here
is
independently
written
and
indeed
trivial
The
POSIX
function
tolower
is
only
properly
defined
on
unsigned
char
hence
the
ugly
casts
strstrnocase
c
include
ctype
h
include
stdio
h
include
globals
h
Dwarf_Bool
is_strstrnocase
const
char
container
const
char
contained
const
unsigned
char
ct
const
unsigned
char
container
for
ct
ct
const
unsigned
char
cntnd
const
unsigned
char
contained
for
cntnd
ct
cntnd
ct
unsigned
char
lct
tolower
ct
unsigned
char
tlc
tolower
cntnd
if
lct
tlc
break
if
cntnd
We
matched
all
the
way
to
end
of
contained
ASSERT
innerwrong
FALSE
return
TRUE
if
ct
Ran
out
of
container
before
contained
so
no
future
match
of
contained
is
possible
return
FALSE
No
match
so
far
See
if
there
is
more
in
container
to
check
return
FALSE
ifdef
TEST
static
void
test
const
char
t1
const
char
t2
int
resexp
Dwarf_Bool
res
is_strstrnocase
t1
t2
if
res
resexp
return
printf
Error
mismatch
s
and
s
Expected
d
got
d
n
t1
t2
resexp
res
int
main
test
aaaaa
a
test
aaaaa
b
test
abaaba
ba
test
abaaxa
x
test
abaabA
Ba
test
a
ab
test
b
c
test
b
test
c
test
test
aaaaa
aaaaaaaa
endif
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
stdio
h
include
stdarg
h
For
va_start
va_arg
va_list
include
errno
h
For
errno
declaration
ifdef
HAVE_UNISTD_H
include
unistd
h
endif
HAVE_UNISTD_
ifdef
HAVE_STDLIB_H
include
stdlib
h
For
exit
declaration
etc
endif
HAVE_STDLIB_H
include
globals
h
include
dwarf
h
include
libdwarf
h
include
common
h
include
esb
h
include
tag_common
h
include
dwgetopt
h
include
libdwarf_version
h
Dwarf_Bool
ellipsis
FALSE
So
we
can
use
dwarf_names
c
Expected
input
format
value
of
a
tag
value
of
a
standard
attribute
that
follows
that
tag
value
of
a
tag
value
of
a
standard
attribute
that
follows
that
tag
The
generated
tag_attr_combination_table
is
used
and
generated
quite
differently
for
standard
than
for
extended
tags
For
standard
tags
the
generated
table
is
indexed
by
tag
number
All
the
columns
are
bit
flags
For
extended
tags
the
generated
table
is
indexed
call
it
j
by
N
and
j
is
the
tag
number
and
the
rest
of
the
columns
N
are
allowed
attribute
numbers
unsigned
int
tag_attr_combination_table
ATTR_TABLE_ROW_MAXIMUM
ATTR_TABLE_COLUMN_MAXIMUM
ifdef
HAVE_USAGE_TAG_ATTR
Working
array
for
a
specific
tag
and
will
contain
its
valid
attributes
static
Dwarf_Half
tag_attr_vector
DW_AT_last
static
Dwarf_Half
tag_parents
DW_TAG_last
static
Dwarf_Half
tag_children
DW_TAG_last
static
Dwarf_Small
tag_attr_legal
DW_TAG_last
endif
HAVE_USAGE_TAG_ATTR
static
const
char
usage
Usage
tag_attr_build
options
i
input
table
path
o
output
table
path
s
Generate
standard
attribute
table
e
Generate
extended
attribute
table
common
extensions
const
char
program_name
char
input_name
char
output_name
int
standard_flag
FALSE
int
extended_flag
FALSE
process
arguments
static
void
process_args
int
argc
char
argv
int
c
Dwarf_Bool
usage_error
FALSE
program_name
argv
while
c
dwgetopt
argc
argv
i
o
se
EOF
switch
c
case
i
input_name
dwoptarg
break
case
o
output_name
dwoptarg
break
case
e
extended_flag
TRUE
break
case
s
standard_flag
TRUE
break
default
usage_error
TRUE
break
if
usage_error
dwoptind
dwoptind
argc
print_usage_message
argv
usage
exit
FAILED
Two
new
naming
routines
May
Instead
of
directly
calling
dwarf_get_
When
bad
tag
attr
numbers
are
presented
we
return
a
warning
string
through
the
pointer
The
thought
is
that
eventually
someone
will
notice
the
error
It
might
of
course
be
better
to
emit
an
error
message
and
stop
static
void
ta_get_AT_name
unsigned
int
attrnum
const
char
nameout
int
res
res
dwarf_get_AT_name
attrnum
nameout
if
res
DW_DLV_OK
return
if
res
DW_DLV_NO_ENTRY
nameout
no
name
known
for
the
attribute
return
nameout
ERROR
so
no
name
known
for
the
attribute
return
static
void
ta_get_TAG_name
unsigned
int
tag
const
char
nameout
int
res
res
dwarf_get_TAG_name
tag
nameout
if
res
DW_DLV_OK
return
if
res
DW_DLV_NO_ENTRY
nameout
no
name
known
for
the
tag
return
nameout
ERROR
so
no
name
known
for
the
tag
return
static
unsigned
maxrowused
static
unsigned
maxcolused
The
argument
sizes
are
declared
in
tag_common
h
so
the
max
usable
is
toprow
and
topcol
static
void
check_unused_combo
unsigned
toprow
unsigned
topcol
if
toprow
maxrowused
printf
Providing
for
u
rows
but
used
u
n
toprow
maxrowused
printf
Giving
up
n
exit
if
topcol
maxcolused
printf
Providing
for
u
cols
but
used
u
n
topcol
maxcolused
printf
Giving
up
n
exit
static
void
validate_row_col
const
char
position
unsigned
crow
unsigned
ccol
unsigned
maxrow
unsigned
maxcol
if
crow
ATTR_TABLE_ROW_MAXIMUM
printf
error
generating
row
in
tag
attr
array
s
current
row
u
size
of
static
array
decl
u
n
position
crow
ATTR_TABLE_ROW_MAXIMUM
exit
if
crow
maxrow
printf
error
generating
row
in
tag
attr
array
s
current
row
u
max
allowed
u
n
position
crow
maxrow
exit
if
ccol
ATTR_TABLE_COLUMN_MAXIMUM
printf
error
generating
column
in
tag
attr
array
s
current
col
u
size
of
static
array
decl
u
n
position
ccol
ATTR_TABLE_COLUMN_MAXIMUM
exit
if
ccol
maxcol
printf
error
generating
column
in
tag
attr
array
s
current
row
u
max
allowed
u
n
position
ccol
maxcol
exit
if
crow
maxrowused
maxrowused
crow
if
ccol
maxcolused
maxcolused
ccol
return
int
main
int
argc
char
argv
unsigned
u
unsigned
int
num
int
input_eof
unsigned
table_rows
unsigned
table_columns
unsigned
current_row
FILE
fileInp
FILE
fileOut
const
char
aname
unsigned
int
index
print_version_details
argv
FALSE
print_args
argc
argv
process_args
argc
argv
if
input_name
fprintf
stderr
Input
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileInp
fopen
input_name
r
if
fileInp
fprintf
stderr
Invalid
input
filename
could
not
open
s
n
input_name
print_usage_message
argv
usage
exit
FAILED
if
output_name
fprintf
stderr
Output
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileOut
fopen
output_name
w
if
fileOut
fprintf
stderr
Invalid
output
filename
could
not
open
s
n
output_name
print_usage_message
argv
usage
exit
FAILED
if
standard_flag
extended_flag
standard_flag
extended_flag
fprintf
stderr
Invalid
table
type
n
fprintf
stderr
Choose
e
or
s
n
print_usage_message
argv
usage
exit
FAILED
if
standard_flag
table_rows
STD_ATTR_TABLE_ROWS
table_columns
STD_ATTR_TABLE_COLUMNS
else
table_rows
EXT_ATTR_TABLE_ROWS
table_columns
EXT_ATTR_TABLE_COLS
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Empty
input
file
if
num
MAGIC_TOKEN_VALUE
bad_line_input
Expected
Generate
main
header
regardless
of
contents
fprintf
fileOut
Generated
code
do
not
edit
n
fprintf
fileOut
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
fileOut
n
BEGIN
FILE
n
n
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
data
type
to
record
the
usage
of
the
pairs
tag
attr
if
standard_flag
fprintf
fileOut
ifndef
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
define
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
endif
HAVE_USAGE_TAG_ATTR
n
n
fprintf
fileOut
ifdef
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
include
dwarf
h
n
fprintf
fileOut
include
libdwarf
h
n
n
fprintf
fileOut
typedef
struct
n
fprintf
fileOut
unsigned
int
count
Attribute
count
n
fprintf
fileOut
Dwarf_Half
attr
Attribute
value
n
fprintf
fileOut
Usage_Tag_Attr
n
n
endif
HAVE_USAGE_TAG_ATTR
while
feof
stdin
unsigned
int
tag
unsigned
int
curcol
unsigned
int
cur_attr
unsigned
int
attr
input_eof
read_value
fileInp
if
IS_EOF
input_eof
Reached
normal
eof
break
if
standard_flag
In
standard
case
the
row
indexed
by
tag
if
tag
table_rows
bad_line_input
tag
u
exceeds
standard
table
size
of
u
rows
tag
table_rows
else
In
extended
case
the
row
indexed
by
N
and
column
zero
has
the
tag
number
if
current_row
table_rows
bad_line_input
too
many
extended
table
rows
Have
u
max
u
current_row
table_rows
validate_row_col
Reading
tag
current_row
table_rows
table_columns
tag_attr_combination_table
current_row
tag
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
curcol
cur_attr
ifdef
HAVE_USAGE_TAG_ATTR
Check
if
we
have
duplicated
tags
if
standard_flag
if
tag_parents
tag
bad_line_input
tag
value
already
defined
tag
tag_parents
tag
tag
Clear
out
the
working
attribute
vector
memset
tag_attr_vector
DW_AT_last
sizeof
Dwarf_Half
endif
HAVE_USAGE_TAG_ATTR
while
num
MAGIC_TOKEN_VALUE
struct
esb_s
msg_buf
esb_constructor
if
standard_flag
unsigned
idx
num
BITS_PER_WORD
unsigned
bit
num
BITS_PER_WORD
if
idx
table_columns
esb_append_printf_i
too
many
attributes
a
table
incomplete
index
d
cols
idx
esb_append_printf_i
d
table_columns
bad_line_input
esb_get_string
validate_row_col
Setting
attr
bit
tag
idx
table_rows
table_columns
tag_attr_combination_table
tag
idx
unsigned
bit
else
if
curcol
table_columns
esb_append_printf_i
too
many
attributes
b
table
incomplete
index
d
curcol
esb_append_printf_i
cols
d
table_columns
bad_line_input
esb_get_string
validate_row_col
Setting
attr
col
current_row
curcol
table_rows
table_columns
tag_attr_combination_table
current_row
curcol
num
curcol
ifdef
HAVE_USAGE_TAG_ATTR
Record
the
usage
only
for
standard
tables
if
standard_flag
Add
attribute
to
current
tag
if
cur_attr
DW_AT_last
esb_empty_string
esb_append_printf_i
too
many
attributes
c
table
incomplete
index
d
cur_attr
esb_append_printf_i
cols
d
DW_AT_last
bad_line_input
esb_get_string
Check
for
duplicated
entries
if
tag_attr_vector
cur_attr
bad_line_input
duplicated
attributes
table
incomplete
tag_attr_vector
cur_attr
num
cur_attr
endif
HAVE_USAGE_TAG_ATTR
esb_destructor
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
tag
attributes
vector
for
current
tag
if
standard_flag
if
tag
DW_TAG_last
bad_line_input
tag
exceeds
standard
table
size
tag
if
tag_children
tag
bad_line_input
tag
already
defined
tag
tag_children
tag
tag
Generate
reference
vector
aname
ta_get_TAG_name
tag
fprintf
fileOut
s
n
tag
aname
fprintf
fileOut
static
Usage_Tag_Attr
tag_attr_
d
n
tag
cur_attr
for
index
index
cur_attr
index
attr
tag_attr_vector
index
ta_get_AT_name
attr
fprintf
fileOut
s
n
attr
aname
fprintf
fileOut
n
n
n
Record
allowed
number
of
attributes
tag_attr_legal
tag
cur_attr
endif
HAVE_USAGE_TAG_ATTR
current_row
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
parent
of
the
individual
vectors
check_unused_combo
table_rows
table_columns
if
standard_flag
unsigned
int
tag
unsigned
int
legal
fprintf
fileOut
static
Usage_Tag_Attr
usage_tag_attr
d
n
DW_TAG_last
for
index
index
DW_TAG_last
index
tag
tag_children
index
if
tag
aname
ta_get_TAG_name
tag
fprintf
fileOut
tag_attr_
s
n
tag
tag
aname
else
fprintf
fileOut
n
fprintf
fileOut
n
n
n
Generate
table
with
allowed
number
of
attributes
fprintf
fileOut
typedef
struct
n
fprintf
fileOut
Dwarf_Small
legal
Legal
attributes
n
fprintf
fileOut
Dwarf_Small
found
Found
attributes
n
fprintf
fileOut
Rate_Tag_Attr
n
n
fprintf
fileOut
static
Rate_Tag_Attr
rate_tag_attr
d
n
DW_TAG_last
for
tag
tag
DW_TAG_last
tag
if
tag_children
tag
legal
tag_attr_legal
tag
aname
ta_get_TAG_name
tag
fprintf
fileOut
s
n
legal
tag
aname
else
fprintf
fileOut
n
fprintf
fileOut
n
n
n
fprintf
fileOut
endif
HAVE_USAGE_TAG_ATTR
n
n
endif
HAVE_USAGE_TAG_ATTR
if
standard_flag
fprintf
fileOut
define
ATTR_TREE_ROW_COUNT
d
n
n
table_rows
fprintf
fileOut
define
ATTR_TREE_COLUMN_COUNT
d
n
n
table_columns
fprintf
fileOut
static
unsigned
int
tag_attr_combination_table
n
fprintf
fileOut
ATTR_TREE_ROW_COUNT
ATTR_TREE_COLUMN_COUNT
n
else
fprintf
fileOut
Common
extensions
n
fprintf
fileOut
define
ATTR_TREE_EXT_ROW_COUNT
d
n
n
table_rows
fprintf
fileOut
define
ATTR_TREE_EXT_COLUMN_COUNT
d
n
n
table_columns
fprintf
fileOut
static
unsigned
int
tag_attr_combination_ext_table
n
fprintf
fileOut
ATTR_TREE_EXT_ROW_COUNT
ATTR_TREE_EXT_COLUMN_COUNT
n
for
u
u
table_rows
u
unsigned
j
const
char
name
if
standard_flag
ta_get_TAG_name
u
fprintf
fileOut
n
u
name
else
unsigned
k
tag_attr_combination_table
u
ta_get_TAG_name
k
fprintf
fileOut
n
k
name
fprintf
fileOut
for
j
j
table_columns
j
if
j
j
fprintf
fileOut
n
fprintf
fileOut
tag_attr_combination_table
u
j
fprintf
fileOut
n
fprintf
fileOut
n
fprintf
fileOut
n
END
FILE
n
fclose
fileInp
fclose
fileOut
return
A
fake
so
we
can
use
dwarf_names
c
void
print_error
Dwarf_Debug
dbg
UNUSEDARG
const
char
msg
UNUSEDARG
int
res
UNUSEDARG
Dwarf_Error
localerr
UNUSEDARG
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
dwarf
h
include
stdio
h
include
stdarg
h
For
va_start
va_arg
va_list
include
stdlib
h
For
exit
declaration
etc
include
errno
h
For
errno
declaration
include
ctype
h
For
isspace
declaration
include
globals
h
include
naming
h
include
tag_common
h
static
int
linecount
static
char
line_in
MAX_LINE_SIZE
void
bad_line_input
char
format
va_list
ap
va_start
ap
format
fprintf
stderr
tag_
tree
attr
form
table
build
failed
line
d
s
linecount
line_in
vfprintf
stderr
format
ap
The
object
ap
may
be
passed
as
an
argument
to
another
function
if
that
function
invokes
the
va_arg
macro
with
parameter
ap
the
value
of
ap
in
the
calling
function
is
unspecified
and
shall
be
passed
to
the
va_end
macro
prior
to
any
further
reference
to
ap
Single
Unix
Specification
va_end
ap
fprintf
stderr
n
exit
FAILED
void
trim_newline
char
line
int
max
char
end
line
max
for
line
line
end
line
if
line
n
Found
newline
drop
it
line
return
return
Detect
empty
lines
and
other
lines
we
do
not
want
to
read
static
Dwarf_Bool
is_skippable_line
char
pLine
Dwarf_Bool
empty
TRUE
if
pLine
Preprocessor
lines
are
of
no
interest
return
TRUE
for
pLine
empty
pLine
empty
isspace
pLine
return
empty
Reads
a
value
from
the
text
table
Exits
with
non
zero
status
if
the
table
is
erroneous
in
some
way
This
array
must
match
exactly
the
order
of
the
enum
entries
in
Dwarf_Form_Class
in
libdwarf
h
in
static
char
enumvals
DW_FORM_CLASS_UNKNOWN
DW_FORM_CLASS_ADDRESS
DW_FORM_CLASS_BLOCK
DW_FORM_CLASS_CONSTANT
DW_FORM_CLASS_EXPRLOC
DW_FORM_CLASS_FLAG
DW_FORM_CLASS_LINEPTR
DW_FORM_CLASS_LOCLISTPTR
DWARF2
only
DW_FORM_CLASS_MACPTR
DWARF2
only
DW_FORM_CLASS_RANGELISTPTR
DWARF2
only
DW_FORM_CLASS_REFERENCE
DW_FORM_CLASS_STRING
DW_FORM_CLASS_FRAMEPTR
MIPS
IRIX
DWARF2
only
DW_FORM_CLASS_MACROPTR
DWARF5
DW_FORM_CLASS_ADDRPTR
DWARF5
DW_FORM_CLASS_LOCLIST
DWARF5
DW_FORM_CLASS_LOCLISTSPTR
DWARF5
DW_FORM_CLASS_RNGLIST
DWARF5
DW_FORM_CLASS_RNGLISTSPTR
DWARF5
DW_FORM_CLASS_STROFFSETSPTR
DWARF5
static
int
lookup_enum_val
char
lin
const
char
s
enumvals
char
lp
lin
int
inputlen
int
enumindex
int
i
for
i
lp
lp
i
if
lp
lp
n
break
inputlen
if
inputlen
bad_line_input
bad
DW_FORM_CLASS_
input
if
strncmp
lin
DW_FORM_CLASS_
bad_line_input
bad
DW_FORM_CLASS_
input
for
i
s
i
s
enumvals
i
int
len
inputlen
int
arslen
strlen
s
if
arslen
len
len
arslen
if
strncmp
s
lin
len
enumindex
i
return
enumindex
break
if
enumindex
bad_line_input
DW_FORM_CLASS
not
matched
return
int
read_value
unsigned
int
outval
FILE
file
char
res
unsigned
long
lval
char
strout
Dwarf_Bool
bBlankLine
TRUE
linecount
outval
while
bBlankLine
res
fgets
line_in
sizeof
line_in
file
if
res
if
ferror
file
fprintf
stderr
attr_form
Error
reading
table
d
lines
read
n
linecount
exit
FAILED
if
feof
file
return
IS_EOF
Impossible
fprintf
stderr
attr_form
Impossible
error
reading
table
d
lines
read
n
linecount
exit
FAILED
bBlankLine
is_skippable_line
line_in
trim_newline
line_in
sizeof
line_in
errno
lval
strtoul
line_in
if
strout
line_in
int
enumindex
We
have
outlen
so
look
up
an
enum
value
enumindex
lookup_enum_val
line_in
if
enumindex
bad_line_input
Cannot
find
enum
value
outval
enumindex
return
NOT_EOF
if
errno
int
myerr
errno
fprintf
stderr
attr_form
errno
d
n
myerr
bad_line_input
invalid
number
on
line
outval
int
lval
return
NOT_EOF
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
Portions
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
errno
h
For
errno
declaration
ifdef
HAVE_UNISTD_H
include
unistd
h
endif
include
common
h
include
tag_common
h
include
dwgetopt
h
include
libdwarf_version
h
for
DW_VERSION_DATE_STR
unsigned
int
tag_tree_combination_table
TAG_TABLE_ROW_MAXIMUM
TAG_TABLE_COLUMN_MAXIMUM
ifdef
HAVE_USAGE_TAG_ATTR
Working
array
for
a
specific
tag
and
its
valid
tags
static
Dwarf_Half
tag_tree_vector
DW_TAG_last
static
Dwarf_Half
tag_parents
DW_TAG_last
static
Dwarf_Half
tag_children
DW_TAG_last
static
Dwarf_Small
tag_tree_legal
DW_TAG_last
endif
HAVE_USAGE_TAG_ATTR
const
char
program_name
Dwarf_Bool
ellipsis
FALSE
So
we
can
use
dwarf_names
c
Expected
input
format
value
of
a
tag
value
of
a
standard
tag
that
may
be
a
child
ofthat
tag
value
of
a
tag
value
of
a
standard
tag
that
may
be
a
child
ofthat
tag
No
commentary
allowed
no
symbols
just
numbers
Blank
lines
are
allowed
and
are
dropped
static
const
char
usage
Usage
tag_tree_build
options
options
t
t
tGenerate
Tags
table
i
Input
file
path
o
Output
table
path
e
Want
Extended
table
common
extensions
s
Want
Standard
table
static
char
input_name
static
char
output_name
int
extended_flag
FALSE
int
standard_flag
FALSE
static
void
process_args
int
argc
char
argv
int
c
Dwarf_Bool
usage_error
FALSE
program_name
argv
while
c
dwgetopt
argc
argv
i
o
es
EOF
switch
c
case
i
input_name
char
strdup
dwoptarg
break
case
o
output_name
char
strdup
dwoptarg
break
case
e
extended_flag
TRUE
break
case
s
standard_flag
TRUE
break
default
usage_error
TRUE
break
if
usage_error
dwoptind
dwoptind
argc
print_usage_message
argv
usage
exit
FAILED
New
naming
routine
May
Instead
of
directly
calling
dwarf_get_
When
bad
tag
attr
numbers
are
presented
we
return
a
warning
string
through
the
pointer
The
thought
is
that
eventually
someone
will
notice
the
error
It
might
of
course
be
better
to
emit
an
error
message
and
stop
static
void
ta_get_TAG_name
unsigned
int
tagnum
const
char
nameout
int
res
res
dwarf_get_TAG_name
tagnum
nameout
if
res
DW_DLV_OK
return
if
res
DW_DLV_NO_ENTRY
nameout
no
name
known
for
the
TAG
return
nameout
ERROR
so
no
name
known
for
the
TAG
return
these
are
used
in
assignments
static
unsigned
maxrowused
static
unsigned
maxcolused
The
argument
sizes
are
declared
in
tag_common
h
so
the
max
usable
is
toprow
and
topcol
static
void
check_unused_combo
unsigned
toprow
unsigned
topcol
if
toprow
maxrowused
printf
Providing
for
u
rows
but
used
u
n
toprow
maxrowused
printf
Giving
up
n
exit
if
topcol
maxcolused
printf
Providing
for
u
cols
but
used
u
n
topcol
maxcolused
printf
Giving
up
n
exit
static
void
validate_row_col
const
char
position
unsigned
crow
unsigned
ccol
unsigned
maxrow
unsigned
maxcol
if
crow
TAG_TABLE_ROW_MAXIMUM
printf
error
generating
row
in
tag
attr
array
s
current
row
u
size
of
static
array
decl
u
n
position
crow
TAG_TABLE_ROW_MAXIMUM
exit
if
crow
maxrow
printf
error
generating
row
in
tree
tag
array
s
current
row
u
max
allowed
u
n
position
crow
maxrow
exit
if
ccol
TAG_TABLE_COLUMN_MAXIMUM
printf
error
generating
column
in
tag
attr
array
s
current
col
u
size
of
static
array
decl
u
n
position
ccol
TAG_TABLE_COLUMN_MAXIMUM
exit
if
ccol
maxcol
printf
error
generating
column
in
tree
tag
array
s
current
row
u
max
allowed
u
n
position
ccol
maxcol
exit
if
crow
maxrowused
maxrowused
crow
if
ccol
maxcolused
maxcolused
ccol
return
int
main
int
argc
char
argv
unsigned
u
unsigned
int
num
int
input_eof
unsigned
table_rows
unsigned
table_columns
unsigned
current_row
FILE
fileInp
FILE
fileOut
const
char
aname
unsigned
int
index
print_version_details
argv
FALSE
print_args
argc
argv
process_args
argc
argv
if
input_name
fprintf
stderr
Input
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileInp
fopen
input_name
r
if
fileInp
fprintf
stderr
Invalid
input
filename
could
not
open
s
n
input_name
print_usage_message
argv
usage
exit
FAILED
if
output_name
fprintf
stderr
Output
name
required
not
supplied
n
print_usage_message
argv
usage
exit
FAILED
fileOut
fopen
output_name
w
if
fileOut
fprintf
stderr
Invalid
output
filename
could
not
open
s
n
output_name
print_usage_message
argv
usage
exit
FAILED
if
standard_flag
extended_flag
standard_flag
extended_flag
fprintf
stderr
Invalid
table
type
n
fprintf
stderr
Choose
e
or
s
n
print_usage_message
argv
usage
exit
FAILED
if
standard_flag
table_rows
STD_TAG_TABLE_ROWS
table_columns
STD_TAG_TABLE_COLUMNS
else
table_rows
EXT_TAG_TABLE_ROWS
table_columns
EXT_TAG_TABLE_COLS
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Empty
input
file
if
num
MAGIC_TOKEN_VALUE
bad_line_input
Expected
Generate
main
header
regardless
of
contents
fprintf
fileOut
Generated
code
do
not
edit
n
fprintf
fileOut
Generated
sourcedate
s
n
DW_VERSION_DATE_STR
fprintf
fileOut
n
BEGIN
FILE
n
n
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
data
type
to
record
the
usage
of
the
pairs
tag
tag
if
standard_flag
fprintf
fileOut
ifndef
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
define
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
endif
HAVE_USAGE_TAG_ATTR
n
n
fprintf
fileOut
ifdef
HAVE_USAGE_TAG_ATTR
n
fprintf
fileOut
include
dwarf
h
n
fprintf
fileOut
include
libdwarf
h
n
n
fprintf
fileOut
typedef
struct
n
fprintf
fileOut
unsigned
int
count
Tag
count
n
fprintf
fileOut
Dwarf_Half
tag
Tag
value
n
fprintf
fileOut
Usage_Tag_Tree
n
n
endif
HAVE_USAGE_TAG_ATTR
while
feof
stdin
unsigned
int
tag
unsigned
nTagLoc
unsigned
int
cur_tag
unsigned
int
child_tag
input_eof
read_value
fileInp
if
IS_EOF
input_eof
Reached
normal
eof
break
if
standard_flag
if
current_row
table_rows
bad_line_input
tag
value
exceeds
standard
table
size
else
if
current_row
table_rows
bad_line_input
too
many
extended
table
rows
validate_row_col
Reading
tag
current_row
table_rows
table_columns
tag_tree_combination_table
current_row
tag
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
nTagLoc
cur_tag
ifdef
HAVE_USAGE_TAG_ATTR
Check
if
we
have
duplicated
tags
if
standard_flag
if
tag_parents
tag
bad_line_input
tag
already
defined
tag
tag_parents
tag
tag
Clear
out
the
working
attribute
vector
memset
tag_tree_vector
DW_TAG_last
sizeof
Dwarf_Half
endif
HAVE_USAGE_TAG_ATTR
while
num
MAGIC_TOKEN_VALUE
if
standard_flag
unsigned
idx
num
BITS_PER_WORD
unsigned
bit
num
BITS_PER_WORD
if
idx
table_columns
fprintf
stderr
Want
column
d
have
only
d
n
idx
table_columns
bad_line_input
too
many
TAGs
table
incomplete
validate_row_col
Update
columns
bit
tag
idx
table_rows
table_columns
tag_tree_combination_table
tag
idx
unsigned
bit
else
if
nTagLoc
table_columns
printf
Attempting
to
use
column
d
max
is
d
n
nTagLoc
table_columns
bad_line_input
too
many
subTAGs
table
incomplete
validate_row_col
Update
tagloc
current_row
nTagLoc
table_rows
table_columns
tag_tree_combination_table
current_row
nTagLoc
num
nTagLoc
ifdef
HAVE_USAGE_TAG_ATTR
Record
the
usage
only
for
standard
tables
if
standard_flag
Add
child
tag
to
current
tag
if
cur_tag
DW_TAG_last
bad_line_input
too
many
TAGs
table
incomplete
Check
for
duplicated
entries
if
tag_tree_vector
cur_tag
bad_line_input
duplicated
tag
table
incomplete
tag_tree_vector
cur_tag
num
cur_tag
endif
HAVE_USAGE_TAG_ATTR
input_eof
read_value
fileInp
if
IS_EOF
input_eof
bad_line_input
Not
terminated
correctly
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
tag
tree
vector
for
current
tag
if
standard_flag
if
tag
DW_TAG_last
bad_line_input
tag
value
exceeds
standard
table
size
if
tag_children
tag
bad_line_input
subtag
already
defined
tag
tag_children
tag
tag
Generate
reference
vector
aname
ta_get_TAG_name
tag
fprintf
fileOut
s
n
tag
aname
fprintf
fileOut
static
Usage_Tag_Tree
tag_tree_
d
n
tag
cur_tag
for
index
index
cur_tag
index
child_tag
tag_tree_vector
index
ta_get_TAG_name
child_tag
fprintf
fileOut
s
n
child_tag
aname
fprintf
fileOut
n
n
n
Record
allowed
number
of
attributes
tag_tree_legal
tag
cur_tag
endif
HAVE_USAGE_TAG_ATTR
current_row
for
extended
table
ifdef
HAVE_USAGE_TAG_ATTR
Generate
the
parent
of
the
individual
vectors
if
standard_flag
unsigned
int
tag
unsigned
int
legal
fprintf
fileOut
static
Usage_Tag_Tree
usage_tag_tree
n
DW_TAG_last
for
index
index
DW_TAG_last
index
tag
tag_children
index
if
tag
aname
ta_get_TAG_name
tag
fprintf
fileOut
tag_tree_
s
n
tag
tag
aname
else
fprintf
fileOut
n
fprintf
fileOut
n
n
n
Generate
table
with
allowed
number
of
tags
fprintf
fileOut
typedef
struct
n
fprintf
fileOut
Dwarf_Small
legal
Legal
tags
n
fprintf
fileOut
Dwarf_Small
found
Found
tags
n
fprintf
fileOut
Rate_Tag_Tree
n
n
fprintf
fileOut
static
Rate_Tag_Tree
rate_tag_tree
n
DW_TAG_last
for
tag
tag
DW_TAG_last
tag
if
tag_children
tag
legal
tag_tree_legal
tag
aname
ta_get_TAG_name
tag
fprintf
fileOut
s
n
legal
tag
aname
else
fprintf
fileOut
n
fprintf
fileOut
n
n
n
fprintf
fileOut
endif
HAVE_USAGE_TAG_ATTR
n
n
endif
HAVE_USAGE_TAG_ATTR
check_unused_combo
table_rows
table_columns
if
standard_flag
fprintf
fileOut
define
TAG_TREE_COLUMN_COUNT
d
n
n
table_columns
fprintf
fileOut
define
TAG_TREE_ROW_COUNT
d
n
n
table_rows
fprintf
fileOut
static
unsigned
int
tag_tree_combination_table
n
fprintf
fileOut
TAG_TREE_ROW_COUNT
TAG_TREE_COLUMN_COUNT
n
else
fprintf
fileOut
define
TAG_TREE_EXT_COLUMN_COUNT
d
n
n
table_columns
fprintf
fileOut
define
TAG_TREE_EXT_ROW_COUNT
d
n
n
table_rows
fprintf
fileOut
Common
extensions
n
fprintf
fileOut
static
unsigned
int
tag_tree_combination_ext_table
n
fprintf
fileOut
TAG_TREE_EXT_ROW_COUNT
TAG_TREE_EXT_COLUMN_COUNT
n
for
u
u
table_rows
u
unsigned
j
const
char
name
if
standard_flag
ta_get_TAG_name
u
fprintf
fileOut
n
u
name
else
unsigned
k
tag_tree_combination_table
u
ta_get_TAG_name
k
fprintf
fileOut
n
k
name
fprintf
fileOut
for
j
j
table_columns
j
fprintf
fileOut
tag_tree_combination_table
u
j
fprintf
fileOut
n
fprintf
fileOut
n
fprintf
fileOut
n
END
FILE
n
fclose
fileInp
fclose
fileOut
return
A
fake
so
we
can
use
dwarf_names
c
void
print_error
Dwarf_Debug
dbg
UNUSEDARG
const
char
msg
UNUSEDARG
int
res
UNUSEDARG
Dwarf_Error
localerr
UNUSEDARG
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
SGI
has
moved
from
the
Crittenden
Lane
address
include
globals
h
include
esb
h
include
esb_using_functions
h
void
get_true_section_name
Dwarf_Debug
dbg
const
char
standard_name
struct
esb_s
name_out
Dwarf_Bool
add_compr
Dwarf_Small
marked_compressed
Dwarf_Small
marked_zlib_compressed
Dwarf_Small
marked_shf_compressed
Dwarf_Unsigned
compressed_length
Dwarf_Unsigned
uncompressed_length
const
char
stdname
standard_name
const
char
actualname
int
cres
Dwarf_Error
tnameerr
cres
dwarf_get_real_section_name
dbg
stdname
if
cres
DW_DLV_OK
esb_append
name_out
actualname
if
add_compr
Dwarf_Bool
compr
FALSE
if
marked_compressed
esb_append
name_out
zdebug
compr
TRUE
if
marked_zlib_compressed
esb_append
name_out
ZLIB
initial
bytes
compr
TRUE
if
marked_shf_compressed
esb_append
name_out
SHF_COMPRESSED
compr
TRUE
if
compr
char
floatbuf
double
comprfactor
if
compressed_length
comprfactor
double
uncompressed_length
double
compressed_length
esb_append_printf_u
name_out
CompLen
DW_PR_DUu
compressed_length
esb_append_printf_u
name_out
Uncomp
DW_PR_DUu
uncompressed_length
sprintf
floatbuf
compression
comprfactor
esb_append
name_out
floatbuf
return
else
if
cres
DW_DLV_NO_ENTRY
esb_append
name_out
stdname
return
DW_DLV_ERROR
esb_append
name_out
stdname
avoid
error
leak
dwarf_dealloc
dbg
tnameerr
DW_DLA_ERROR
tnameerr
esb_append
name_out
Error
accessing
section
name
return
Copyright
David
Anderson
All
rights
reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
globals
h
include
esb
h
include
uri
h
include
stdio
h
include
ctype
h
dwarfdump_ctype
table
See
uritablebuild
c
static
char
dwarfdump_ctype_table
NUL
control
control
control
control
control
control
control
control
whitespace
whitespace
whitespace
whitespace
whitespace
control
control
control
control
control
control
control
control
control
control
control
control
control
control
control
control
control
control
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
_
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
DEL
other
other
Translate
dangerous
and
some
other
characters
to
safe
xx
form
void
translate_to_uri
const
char
filename
struct
esb_s
out
const
char
cp
for
cp
filename
cp
cp
char
v
int
c
unsigned
char
cp
if
dwarfdump_ctype_table
c
v
c
v
esb_append
out
v
else
esb_append
out
esb_append_printf_u
out
c&0xff
This
is
not
very
efficient
but
it
is
seldom
called
static
char
hexdig
char
c
char
ochar
if
c
c
ochar
c
return
ochar
if
c
a
c
f
ochar
c
a
return
ochar
if
c
A
c
F
ochar
c
A
return
ochar
We
have
an
input
botch
here
fprintf
stderr
Translating
from
uri
A
supposed
hexadecimal
input
character
is
not
or
a
f
or
A
F
it
is
shown
as
hex
here
x
n
c
return
ochar
static
char
tohex
char
c1
char
c2
char
out
hexdig
c1
hexdig
c2
return
out
static
int
hexpairtochar
const
char
cp
char
myochar
char
ochar
int
olen
char
c
cp
if
c
char
c2
cp
if
c2
ochar
tohex
c
c2
olen
else
fprintf
stderr
Translating
from
uri
A
supposed
hexadecimal
input
character
pair
runs
off
the
end
of
the
input
after
hex
digit
n
botched
input
ochar
c
olen
else
botched
input
fprintf
stderr
Translating
from
uri
A
supposed
hexadecimal
input
character
pair
runs
off
the
end
of
the
input
n
ochar
olen
myochar
ochar
return
olen
void
translate_from_uri
const
char
input
struct
esb_s
out
const
char
cp
input
char
tempstr
for
cp
cp
char
c
cp
if
c
int
increment
char
c2
cp
hexpairtochar
deals
with
c2
being
NUL
if
c2
tempstr
c
tempstr
esb_append
out
tempstr
cp
continue
increment
hexpairtochar
cp
tempstr
c
tempstr
esb_append
out
tempstr
cp
increment
continue
tempstr
c
tempstr
esb_append
out
tempstr
ifdef
TEST
unsigned
int
errcnt
static
void
mytestfrom
const
char
in
const
char
expected
int
testnum
struct
esb_s
out
esb_constructor
translate_from_uri
in
if
strcmp
expected
esb_get_string
printf
Fail
test
d
expected
s
got
s
n
testnum
expected
esb_get_string
errcnt
esb_destructor
static
void
mytest
char
in
char
expected
int
testnum
struct
esb_s
out
esb_constructor
translate_to_uri
in
if
strcmp
expected
esb_get_string
printf
Fail
test
d
expected
s
got
s
n
testnum
expected
esb_get_string
errcnt
esb_destructor
int
main
We
no
longer
translate
space
to
that
turns
out
not
to
help
all
that
much
mytest
aaa
aaa
mytest
bc
bc
mytest
bc
mytest
bc
n
bc
mytest
bc
n
mytest
bc
r
bc
mytest
bc
r
mytest
x01
mytest
x01
mytestfrom
abc
abc
mytestfrom
a
a
bc
mytestfrom
a
a
mytestfrom
a
a
bc
mytestfrom
a
a
mytestfrom
a
a
The
following
is
mistaken
input
mytestfrom
a
a2
mytestfrom
a
a
mytest
bc
if
errcnt
printf
uri
errcount
errcnt
return
errcnt?
endif
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
include
stdio
h
include
ctype
h
Generates
a
table
which
identifies
a
few
dangerous
characters
Ones
one
does
not
want
to
appear
in
output
It
s
a
bit
arbitrary
in
that
we
allow
lots
of
shell
interpreted
characters
through
and
most
characters
generally
But
not
control
characters
or
single
or
double
quotes
The
quotes
would
be
particularly
problematic
for
post
processing
dwarfdump
output
sensibly
This
was
used
once
to
create
the
table
in
uri
c
and
not
is
unlikely
to
be
used
again
static
void
print_entry
int
c
char
v
v
c
v
if
c
printf
NUL
n
c
return
if
isalnum
c
c
We
let
the
space
character
print
as
space
since
lots
of
files
are
named
that
way
in
Mac
and
Windows
printf
s
n
v
c
return
if
c
c
c
We
let
the
space
character
print
as
space
since
lots
of
files
are
named
that
way
in
Mac
and
Windows
printf
s
n
v
c
return
if
isspace
c
Other
white
space
translated
printf
whitespace
n
c
return
if
c
printf
DEL
n
c
return
if
c
c
ASCII
control
characters
printf
control
n
c
return
if
c
c
c
c
printf
s
n
v
c
return
if
c
c
ASCII
printf
s
n
v
c
return
if
c
c
printf
other
n
c
return
if
c
c
ASCII
printf
s
n
v
c
return
if
c
c
ASCII
printf
s
n
v
c
return
if
c
c
ASCII
printf
s
n
v
c
return
if
c
c
ASCII
printf
s
n
v
c
return
if
c
ASCII
printf
s
n
v
c
return
We
are
allowing
other
iso
characters
through
unchanged
printf
n
c
int
main
int
i
printf
dwarfdump_ctype
table
n
printf
char
dwarfdump_ctype_table
n
for
i
i
i
print_entry
i
printf
n
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
ADDRMAP_H
define
ADDRMAP_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
struct
Addr_Map_Entry
Dwarf_Unsigned
mp_key
char
mp_name
struct
Addr_Map_Entry
addr_map_insert
Dwarf_Unsigned
addr
char
name
void
map
struct
Addr_Map_Entry
addr_map_find
Dwarf_Unsigned
addr
void
map
void
addr_map_destroy
void
map
ifdef
__cplusplus
endif
__cplusplus
endif
ADDRMAP_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
ATTR_FORM_H
define
ATTR_FORM_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
define
AF_STD
define
AF_EXTEN
struct
Three_Key_Entry_s
Dwarf_Half
key1
usually
AT
number
Dwarf_Half
key2
usually
FORM_CLASS
number
Dwarf_Half
key3
usually
actual
DW_FORM
number
but
for
a
record
from
the
preset
table
this
is
zero
as
there
the
actual
FORM
is
unknown
Dwarf_Small
std_or_exten
std
extension
Dwarf_Small
from_tables
if
found
in
preset
table
else
meaning
found
only
in
the
DWARF
Dwarf_Unsigned
count
The
number
actually
encountered
typedef
struct
Three_Key_Entry_s
Three_Key_Entry
Returns
DW_DLV_ERROR
if
out
of
memory
else
DW_DLV_OK
int
make_3key
Dwarf_Half
k1
Dwarf_Half
k2
Dwarf_Half
k3
Dwarf_Small
std_or_exten
Dwarf_Small
from_preset
Dwarf_Unsigned
count
Three_Key_Entry
out
Dwarf_Unsigned
three_key_entry_count
void
base
void
free_func_3key_entry
void
keystructptr
int
std_compare_3key_entry
const
void
l
const
void
r
int
build_attr_form_base_tree
int
errnum
void
destroy_attr_form_trees
void
void
record_attr_form_use
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Half
attr
Dwarf_Half
fclass
Dwarf_Half
form
int
pd_dwarf_names_print_on_error
int
die_stack_indent_level
The
standard
main
tree
for
attr_form
data
Starting
out
as
simple
global
variables
extern
void
threekey_attr_form_base
for
attr
form
combos
void
print_attr_form_usage
int
poe
ifdef
__cplusplus
endif
__cplusplus
endif
ATTR_FORM_H
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
CHECKUTIL_H
define
CHECKUTIL_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Map
information
Depending
on
the
specific
functions
used
various
fields
here
are
either
used
or
ignored
typedef
struct
Dwarf_Bool
bFlag
General
flag
const
char
name
Generic
name
Dwarf_Addr
key
Used
for
binary
search
the
key
is
either
a
pc
address
or
a
DIE
offset
depending
on
which
bucket
table
is
in
use
Dwarf_Addr
base
Used
for
base
address
Dwarf_Addr
low
Used
for
Low
PC
Dwarf_Addr
high
Used
for
High
PC
Bucket_Data
This
groups
Bucket_Data
records
into
a
bucket
so
that
a
single
malloc
creates
BUCKET_SIZE
entries
The
intent
is
to
reduce
overhead
as
compared
to
having
next
previous
pointers
in
each
Bucket_Data
and
mallocing
each
Bucket_Data
individually
define
BUCKET_SIZE
typedef
struct
bucket
int
nEntries
Bucket_Data
Entries
BUCKET_SIZE
struct
bucket
pNext
Bucket
This
Forms
the
head
record
of
a
list
of
Buckets
typedef
struct
int
kind
Kind
of
bucket
Dwarf_Addr
lower
Lower
value
for
data
Dwarf_Addr
upper
Upper
value
for
data
Bucket_Data
pFirst
First
sentinel
Bucket_Data
pLast
Last
sentinel
Bucket
pHead
First
bucket
in
set
Bucket
pTail
Last
bucket
in
set
Bucket_Group
Bucket_Group
AllocateBucketGroup
int
kind
void
ReleaseBucketGroup
Bucket_Group
pBucketGroup
void
ResetBucketGroup
Bucket_Group
pBucketGroup
void
ResetSentinelBucketGroup
Bucket_Group
pBucketGroup
void
PrintBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Bool
bFull
void
AddEntryIntoBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
Dwarf_Addr
base
Dwarf_Addr
low
Dwarf_Addr
high
const
char
name
Dwarf_Bool
bFlag
Dwarf_Bool
DeleteKeyInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
Dwarf_Bool
FindAddressInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
address
Bucket_Data
FindDataInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
Bucket_Data
FindKeyInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
key
Bucket_Data
FindNameInBucketGroup
Bucket_Group
pBucketGroup
char
name
Dwarf_Bool
IsValidInBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
pc
void
ResetLimitsBucketSet
Bucket_Group
pBucketGroup
void
SetLimitsBucketGroup
Bucket_Group
pBucketGroup
Dwarf_Addr
lower
Dwarf_Addr
upper
Dwarf_Bool
IsValidInLinkonce
Bucket_Group
pLo
const
char
name
Dwarf_Addr
lopc
Dwarf_Addr
hipc
ifdef
__cplusplus
endif
__cplusplus
endif
CHECKUTIL_H
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
COMMAND_OPTIONS_H
define
COMMAND_OPTIONS_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
const
char
process_args
int
argc
char
argv
const
char
do_uri_translation
const
char
s
const
char
context
void
uri_data_constructor
void
void
uri_data_destructor
void
ifdef
__cplusplus
endif
__cplusplus
endif
COMMAND_OPTIONS_H
Copyright
C
SN
Systems
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
COMMON_INCLUDED_H
define
COMMON_INCLUDED_H
void
print_args
int
argc
char
argv
void
print_version_details
const
char
name
int
alwaysprint
void
print_usage_message
const
char
program_name
const
char
text
endif
COMMON_INCLUDED_H
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
COMPILER_INFO_H
define
COMPILER_INFO_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
define
COMPILER_TABLE_MAX
typedef
struct
anc
struct
anc
next
char
item
a_name_chain
typedef
struct
int
checks
int
errors
Dwarf_Check_Result
Records
information
about
compilers
producers
found
in
the
debug
information
including
the
check
results
for
several
categories
see
k
option
typedef
struct
const
char
name
Dwarf_Bool
verified
a_name_chain
cu_list
a_name_chain
cu_last
Dwarf_Check_Result
results
LAST_CATEGORY
Compiler
Compiler
statistics
extern
void
update_compiler_target
const
char
producer_name
extern
void
add_cu_name_compiler_target
char
name
extern
void
clean_up_compilers_detected
void
extern
Dwarf_Bool
checking_this_compiler
void
extern
void
reset_compiler_entry
Compiler
compiler
extern
void
print_checks_results
void
extern
void
DWARF_CHECK_COUNT
Dwarf_Check_Categories
category
int
inc
extern
void
DWARF_ERROR_COUNT
Dwarf_Check_Categories
category
int
inc
extern
Dwarf_Bool
record_producer
char
name
ifdef
__cplusplus
endif
__cplusplus
endif
COMPILER_INFO_H
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DEFINED_TYPES_H
define
DEFINED_TYPES_H
ifndef
FALSE
define
FALSE
endif
ifndef
TRUE
define
TRUE
endif
ifndef
FAILED
define
FAILED
endif
define
OKAY
ifdef
__cplusplus
endif
__cplusplus
endif
DEFINED_TYPES_H
Generated
routines
do
not
edit
Generated
sourcedate
BEGIN
FILE
ifndef
DWARF_NAMES_H
define
DWARF_NAMES_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
extern
int
dwarf_get_TAG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_children_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FORM_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_AT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_OP_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DEFAULTED_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_IDX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LLEX_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LLE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_RLE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIVIS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_GNUIKIND_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_UT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_SECT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_END_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ATCF_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ACCESS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_VIRTUALITY_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LANG_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ID_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_INL_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ORD_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_DSC_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNCT_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNS_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_LNE_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ISA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACRO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_MACINFO_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CFA_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_EH_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_FRAME_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_CHILDREN_name
unsigned
int
val_in
const
char
s_out
extern
int
dwarf_get_ADDR_name
unsigned
int
val_in
const
char
s_out
ifdef
__cplusplus
endif
__cplusplus
endif
DWARF_NAMES_H
END
FILE
ifndef
DWARF_TSEARCH_H
define
DWARF_TSEARCH_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
The
following
interfaces
follow
tsearch
See
the
Single
Unix
Specification
but
the
implementation
is
written
without
reference
to
the
source
code
of
any
version
of
tsearch
Only
uses
of
tsearch
were
examined
not
tsearch
source
code
See
https
www
prevanders
net
tsearch
html
and
https
www
prevanders
net
dwarf
html
tsearch
for
information
about
tsearch
We
are
matching
the
standard
functional
interface
here
but
to
avoid
interfering
with
libc
implementations
or
code
using
libc
implementations
we
change
all
the
names
The
hashfunc
return
is
now
easily
changed
with
cc
DDW_TSHASHTYPE
unsigned
long
The
quotes
required
here
as
the
example
type
has
a
space
character
ifndef
DW_TSHASHTYPE
define
DW_TSHASHTYPE
uintptr_t
endif
The
DW_VISIT
values
passed
back
to
you
through
the
callback
function
in
dwarf_twalk
typedef
enum
dwarf_preorder
Before
visit
children
dwarf_postorder
After
first
children
visit
before
last
dwarf_endorder
After
visit
of
children
last
visit
dwarf_leaf
DW_VISIT
void
return
values
are
actually
void
key
so
you
must
dereference
these
once
to
get
a
key
you
passed
in
Hence
the
void
and
rootp
name
void
dwarf_tsearch
const
void
key
void
rootp
int
compar
const
void
const
void
void
dwarf_tfind
const
void
key
void
const
rootp
int
compar
const
void
const
void
dwarf_tdelete
returns
NULL
if
it
cannot
delete
anything
or
if
the
tree
is
now
empty
if
empty
rootp
is
set
NULL
by
dwarf_tdelete
If
the
delete
succeeds
and
the
tree
is
non
empty
returns
a
pointer
to
the
parent
node
of
the
deleted
item
unless
the
deleted
item
was
at
the
root
in
which
case
the
returned
pointer
relates
to
the
new
root
void
dwarf_tdelete
const
void
key
void
rootp
int
compar
const
void
const
void
Here
the
argument
is
really
void
theroot
void
dwarf_twalk
const
void
root
void
action
const
void
nodep
const
DW_VISIT
which
const
int
depth
dwarf_tdestroy
cannot
set
the
root
pointer
NULL
you
must
do
so
on
return
from
dwarf_tdestroy
void
dwarf_tdestroy
void
root
void
free_node
void
nodep
Prints
a
simple
tree
representation
to
stdout
For
debugging
void
dwarf_tdump
const
void
root
char
keyprint
const
void
const
char
msg
Returns
NULL
and
does
nothing
unless
the
implemenation
used
uses
a
hash
tree
void
dwarf_initialize_search_hash
void
treeptr
DW_TSHASHTYPE
hashfunc
const
void
key
unsigned
long
size_estimate
endif
DWARF_TSEARCH_H
Generated
table
do
not
edit
Generated
sourcedate
ifndef
DWARFDUMP_AF_TABLE_H
define
DWARFDUMP_AF_TABLE_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
struct
af_table_s
Dwarf_Half
attr
Dwarf_Half
formclass
unsigned
char
section
attr_formclass_table
DW_AT_abstract_origin
DW_FORM_CLASS_REFERENCE
Std
DW_AT_accessibility
DW_FORM_CLASS_CONSTANT
Std
DW_AT_addr_base
DW_FORM_CLASS_ADDRPTR
Std
DW_AT_address_class
DW_FORM_CLASS_CONSTANT
Std
DW_AT_alignment
DW_FORM_CLASS_CONSTANT
Std
DW_AT_allocated
DW_FORM_CLASS_CONSTANT
Std
DW_AT_allocated
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_allocated
DW_FORM_CLASS_REFERENCE
Std
DW_AT_artificial
DW_FORM_CLASS_FLAG
Std
DW_AT_associated
DW_FORM_CLASS_CONSTANT
Std
DW_AT_associated
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_associated
DW_FORM_CLASS_REFERENCE
Std
DW_AT_base_types
DW_FORM_CLASS_REFERENCE
Std
DW_AT_binary_scale
DW_FORM_CLASS_CONSTANT
Std
DW_AT_bit_offset
DW_FORM_CLASS_CONSTANT
Std
DW_AT_bit_offset
DW_FORM_CLASS_BLOCK
Std
DW_AT_bit_offset
DW_FORM_CLASS_REFERENCE
Std
DW_AT_bit_size
DW_FORM_CLASS_CONSTANT
Std
DW_AT_bit_size
DW_FORM_CLASS_BLOCK
Std
DW_AT_bit_size
DW_FORM_CLASS_REFERENCE
Std
DW_AT_bit_stride
DW_FORM_CLASS_CONSTANT
Std
DW_AT_bit_stride
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_bit_stride
DW_FORM_CLASS_REFERENCE
Std
DW_AT_byte_size
DW_FORM_CLASS_CONSTANT
Std
DW_AT_byte_size
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_byte_size
DW_FORM_CLASS_REFERENCE
Std
DW_AT_byte_stride
DW_FORM_CLASS_CONSTANT
Std
DW_AT_byte_stride
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_byte_stride
DW_FORM_CLASS_REFERENCE
Std
DW_AT_call_all_calls
DW_FORM_CLASS_FLAG
Std
DW_AT_call_all_source_calls
DW_FORM_CLASS_FLAG
Std
DW_AT_call_all_tail_calls
DW_FORM_CLASS_FLAG
Std
DW_AT_call_column
DW_FORM_CLASS_CONSTANT
Std
DW_AT_call_data_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_call_data_value
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_call_file
DW_FORM_CLASS_CONSTANT
Std
DW_AT_calling_convention
DW_FORM_CLASS_CONSTANT
Std
DW_AT_call_line
DW_FORM_CLASS_CONSTANT
Std
DW_AT_call_origin
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_call_origin
DW_FORM_CLASS_REFERENCE
Std
DW_AT_call_parameter
DW_FORM_CLASS_REFERENCE
Std
DW_AT_call_pc
DW_FORM_CLASS_ADDRESS
Std
DW_AT_call_return_pc
DW_FORM_CLASS_ADDRESS
Std
DW_AT_call_tail_call
DW_FORM_CLASS_FLAG
Std
DW_AT_call_target
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_call_target_clobbered
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_call_value
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_common_reference
DW_FORM_CLASS_REFERENCE
Std
DW_AT_comp_dir
DW_FORM_CLASS_STRING
Std
DW_AT_const_expr
DW_FORM_CLASS_FLAG
Std
DW_AT_const_value
DW_FORM_CLASS_CONSTANT
Std
DW_AT_const_value
DW_FORM_CLASS_BLOCK
Std
DW_AT_const_value
DW_FORM_CLASS_STRING
Std
DW_AT_containing_type
DW_FORM_CLASS_REFERENCE
Std
DW_AT_count
DW_FORM_CLASS_CONSTANT
Std
DW_AT_count
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_count
DW_FORM_CLASS_REFERENCE
Std
DW_AT_data_bit_offset
DW_FORM_CLASS_CONSTANT
Std
DW_AT_data_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_data_member_location
DW_FORM_CLASS_CONSTANT
Std
DW_AT_data_member_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_data_member_location
DW_FORM_CLASS_LOCLIST
Std
DW_AT_decimal_scale
DW_FORM_CLASS_CONSTANT
Std
DW_AT_decimal_sign
DW_FORM_CLASS_CONSTANT
Std
DW_AT_declaration
DW_FORM_CLASS_FLAG
Std
DW_AT_decl_column
DW_FORM_CLASS_CONSTANT
Std
DW_AT_decl_file
DW_FORM_CLASS_CONSTANT
Std
DW_AT_decl_line
DW_FORM_CLASS_CONSTANT
Std
DW_AT_defaulted
DW_FORM_CLASS_CONSTANT
Std
DW_AT_deleted
DW_FORM_CLASS_FLAG
Std
DW_AT_description
DW_FORM_CLASS_STRING
Std
DW_AT_digit_count
DW_FORM_CLASS_CONSTANT
Std
DW_AT_discr
DW_FORM_CLASS_REFERENCE
Std
DW_AT_discr_list
DW_FORM_CLASS_BLOCK
Std
DW_AT_discr_value
DW_FORM_CLASS_CONSTANT
Std
DW_AT_dwo_id
DW_FORM_CLASS_REFERENCE
Std
DW_AT_dwo_name
DW_FORM_CLASS_STRING
Std
DW_AT_elemental
DW_FORM_CLASS_FLAG
Std
DW_AT_encoding
DW_FORM_CLASS_CONSTANT
Std
DW_AT_endianity
DW_FORM_CLASS_CONSTANT
Std
DW_AT_entry_pc
DW_FORM_CLASS_ADDRESS
Std
DW_AT_entry_pc
DW_FORM_CLASS_CONSTANT
Std
DW_AT_enum_class
DW_FORM_CLASS_FLAG
Std
DW_AT_explicit
DW_FORM_CLASS_FLAG
Std
DW_AT_export_symbols
DW_FORM_CLASS_FLAG
Std
DW_AT_extension
DW_FORM_CLASS_REFERENCE
Std
DW_AT_external
DW_FORM_CLASS_FLAG
Std
DW_AT_frame_base
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_frame_base
DW_FORM_CLASS_LOCLIST
Std
DW_AT_friend
DW_FORM_CLASS_REFERENCE
Std
DW_AT_high_pc
DW_FORM_CLASS_CONSTANT
Std
DW_AT_high_pc
DW_FORM_CLASS_ADDRESS
Std
DW_AT_identifier_case
DW_FORM_CLASS_CONSTANT
Std
DW_AT_import
DW_FORM_CLASS_REFERENCE
Std
DW_AT_inline
DW_FORM_CLASS_CONSTANT
Std
DW_AT_is_optional
DW_FORM_CLASS_FLAG
Std
DW_AT_language
DW_FORM_CLASS_CONSTANT
Std
DW_AT_linkage_name
DW_FORM_CLASS_STRING
Std
DW_AT_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_location
DW_FORM_CLASS_LOCLIST
Std
DW_AT_location
DW_FORM_CLASS_LOCLISTPTR
Std
DW_AT_loclists_base
DW_FORM_CLASS_LOCLISTSPTR
Std
DW_AT_lower_bound
DW_FORM_CLASS_CONSTANT
Std
DW_AT_lower_bound
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_lower_bound
DW_FORM_CLASS_REFERENCE
Std
DW_AT_low_pc
DW_FORM_CLASS_ADDRESS
Std
DW_AT_macro_info
DW_FORM_CLASS_MACPTR
Std
DW_AT_macros
DW_FORM_CLASS_MAXCROPTR
Std
DW_AT_main_subprogram
DW_FORM_CLASS_STRING
Std
DW_AT_mutable
DW_FORM_CLASS_FLAG
Std
DW_AT_name
DW_FORM_CLASS_STRING
Std
DW_AT_namelist_item
DW_FORM_CLASS_REFERENCE
Std
DW_AT_noreturn
DW_FORM_CLASS_FLAG
Std
DW_AT_object_pointer
DW_FORM_CLASS_REFERENCE
Std
DW_AT_ordering
DW_FORM_CLASS_CONSTANT
Std
DW_AT_picture_string
DW_FORM_CLASS_STRING
Std
DW_AT_priority
DW_FORM_CLASS_REFERENCE
Std
DW_AT_producer
DW_FORM_CLASS_STRING
Std
DW_AT_prototyped
DW_FORM_CLASS_FLAG
Std
DW_AT_pure
DW_FORM_CLASS_FLAG
Std
DW_AT_ranges
DW_FORM_CLASS_RNGLIST
Std
DW_AT_ranges
DW_FORM_CLASS_RANGELISTPTR
Std
DW_AT_ranges
DW_FORM_CLASS_RNGLISTSPTR
Std
DW_AT_rank
DW_FORM_CLASS_CONSTANT
Std
DW_AT_rank
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_recursive
DW_FORM_CLASS_FLAG
Std
DW_AT_reference
DW_FORM_CLASS_FLAG
Std
DW_AT_return_addr
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_return_addr
DW_FORM_CLASS_LOCLIST
Std
DW_AT_rnglists_base
DW_FORM_CLASS_RNGLISTSPTR
Std
DW_AT_rvalue_reference
DW_FORM_CLASS_FLAG
Std
DW_AT_segment
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_segment
DW_FORM_CLASS_LOCLIST
Std
DW_AT_sibling
DW_FORM_CLASS_REFERENCE
Std
DW_AT_signature
DW_FORM_CLASS_REFERENCE
Std
DW_AT_small
DW_FORM_CLASS_REFERENCE
Std
DW_AT_specification
DW_FORM_CLASS_REFERENCE
Std
DW_AT_start_scope
DW_FORM_CLASS_CONSTANT
Std
DW_AT_start_scope
DW_FORM_CLASS_RNGLIST
Std
DW_AT_static_link
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_static_link
DW_FORM_CLASS_LOCLIST
Std
DW_AT_stmt_list
DW_FORM_CLASS_LINEPTR
Std
DW_AT_string_length
DW_FORM_CLASS_BLOCK
Std
DW_AT_string_length
DW_FORM_CLASS_LOCLISTPTR
Std
DW_AT_string_length_bit_size
DW_FORM_CLASS_CONSTANT
Std
DW_AT_string_length_byte_size
DW_FORM_CLASS_CONSTANT
Std
DW_AT_str_offsets_base
DW_FORM_CLASS_STROFFSETSPTR
Std
DW_AT_threads_scaled
DW_FORM_CLASS_FLAG
Std
DW_AT_trampoline
DW_FORM_CLASS_REFERENCE
Std
DW_AT_trampoline
DW_FORM_CLASS_ADDRESS
Std
DW_AT_trampoline
DW_FORM_CLASS_FLAG
Std
DW_AT_trampoline
DW_FORM_CLASS_STRING
Std
DW_AT_type
DW_FORM_CLASS_REFERENCE
Std
DW_AT_upper_bound
DW_FORM_CLASS_CONSTANT
Std
DW_AT_upper_bound
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_upper_bound
DW_FORM_CLASS_REFERENCE
Std
DW_AT_use_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_use_location
DW_FORM_CLASS_LOCLIST
Std
DW_AT_use_UTF8
DW_FORM_CLASS_FLAG
Std
DW_AT_variable_parameter
DW_FORM_CLASS_FLAG
Std
DW_AT_virtuality
DW_FORM_CLASS_CONSTANT
Std
DW_AT_visibility
DW_FORM_CLASS_CONSTANT
Std
DW_AT_vtable_elem_location
DW_FORM_CLASS_EXPRLOC
Std
DW_AT_vtable_elem_location
DW_FORM_CLASS_LOCLIST
Std
end
af_table
standard
DW_AT_GNU_addr_base
DW_FORM_CLASS_ADDRPTR
Ext
DW_AT_GNU_all_call_sites
DW_FORM_CLASS_FLAG
Ext
DW_AT_GNU_all_tail_call_sites
DW_FORM_CLASS_FLAG
Ext
DW_AT_GNU_call_site_data_value
DW_FORM_CLASS_EXPRLOC
Ext
DW_AT_GNU_call_site_target
DW_FORM_CLASS_EXPRLOC
Ext
DW_AT_GNU_call_site_value
DW_FORM_CLASS_EXPRLOC
Ext
DW_AT_GNU_denominator
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_discriminator
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_dwo_id
DW_FORM_CLASS_REFERENCE
Ext
DW_AT_GNU_dwo_id
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_dwo_name
DW_FORM_CLASS_STRING
Ext
DW_AT_GNU_macros
DW_FORM_CLASS_MAXCROPTR
Ext
DW_AT_GNU_numerator
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_odr_signature
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_odr_signature
DW_FORM_CLASS_REFERENCE
Ext
DW_AT_GNU_pubnames
DW_FORM_CLASS_REFERENCE
Ext
DW_AT_GNU_pubnames
DW_FORM_CLASS_FLAG
Ext
DW_AT_GNU_pubnames
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_pubtypes
DW_FORM_CLASS_REFERENCE
Ext
DW_AT_GNU_pubtypes
DW_FORM_CLASS_FLAG
Ext
DW_AT_GNU_pubtypes
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_GNU_ranges_base
DW_FORM_CLASS_RNGLISTSPTR
Ext
DW_AT_GNU_tail_call
DW_FORM_CLASS_FLAG
Ext
DW_AT_MIPS_abstract_name
DW_FORM_CLASS_STRING
Ext
DW_AT_MIPS_fde
DW_FORM_CLASS_FRAMEPTR
Ext
DW_AT_MIPS_has_inlines
DW_FORM_CLASS_FLAG
Ext
DW_AT_MIPS_linkage_name
DW_FORM_CLASS_STRING
Ext
DW_AT_SUN_link_name
DW_FORM_CLASS_STRING
Ext
DW_AT_SUN_part_link_name
DW_FORM_CLASS_STRING
Ext
DW_AT_ghs_rsm
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_ghs_frsm
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_ghs_frames
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_ghs_rso
DW_FORM_CLASS_CONSTANT
Ext
DW_AT_ghs_subcpu
DW_FORM_CLASS_CONSTANT
Ext
end
af_table
extended
ifdef
__cplusplus
extern
C
endif
__cplusplus
endif
DWARFDUMP_AF_TABLE_H
Generated
code
do
not
edit
Generated
sourcedate
BEGIN
FILE
Common
extensions
define
ATTR_TREE_EXT_ROW_COUNT
define
ATTR_TREE_EXT_COLUMN_COUNT
static
unsigned
int
tag_attr_combination_ext_table
ATTR_TREE_EXT_ROW_COUNT
ATTR_TREE_EXT_COLUMN_COUNT
DW_TAG_structure_type
DW_TAG_compile_unit
DW_TAG_skeleton_unit
DW_TAG_partial_unit
DW_TAG_member
DW_TAG_enumeration_type
DW_TAG_array_type
DW_TAG_subprogram
DW_TAG_type_unit
DW_TAG_variable
DW_TAG_GNU_template_template_parameter
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_formal_parameter_pack
DW_TAG_GNU_call_site
DW_TAG_GNU_call_site_parameter
DW_TAG_constant
DW_TAG_subrange_type
DW_TAG_inlined_subroutine
DW_TAG_lexical_block
END
FILE
Generated
code
do
not
edit
Generated
sourcedate
BEGIN
FILE
ifndef
HAVE_USAGE_TAG_ATTR
define
HAVE_USAGE_TAG_ATTR
endif
HAVE_USAGE_TAG_ATTR
ifdef
HAVE_USAGE_TAG_ATTR
include
dwarf
h
include
libdwarf
h
typedef
struct
unsigned
int
count
Attribute
count
Dwarf_Half
attr
Attribute
value
Usage_Tag_Attr
DW_TAG_access_declaration
static
Usage_Tag_Attr
tag_attr_23
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_TAG_array_type
static
Usage_Tag_Attr
tag_attr_01
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_bit_stride
DW_AT_byte_size
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_ordering
DW_AT_rank
DW_AT_sibling
DW_AT_specification
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_atomic_type
static
Usage_Tag_Attr
tag_attr_47
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_sibling
DW_AT_type
DW_TAG_base_type
static
Usage_Tag_Attr
tag_attr_24
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_binary_scale
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_byte_size
DW_AT_bit_size
DW_AT_data_bit_offset
DW_AT_data_location
DW_AT_decimal_scale
DW_AT_decimal_sign
DW_AT_description
DW_AT_digit_count
DW_AT_encoding
DW_AT_endianity
DW_AT_name
DW_AT_picture_string
DW_AT_sibling
DW_AT_small
DW_TAG_call_site
static
Usage_Tag_Attr
tag_attr_48
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_call_origin
DW_AT_call_pc
DW_AT_call_return_pc
DW_AT_call_tail_call
DW_AT_call_target
DW_AT_call_target_clobbered
DW_AT_sibling
DW_AT_type
DW_TAG_call_site_parameter
static
Usage_Tag_Attr
tag_attr_49
DW_AT_call_data_location
DW_AT_call_data_value
DW_AT_call_parameter
DW_AT_call_value
DW_AT_location
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_catch_block
static
Usage_Tag_Attr
tag_attr_25
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_low_pc
DW_AT_ranges
DW_AT_segment
DW_AT_sibling
DW_TAG_class_type
static
Usage_Tag_Attr
tag_attr_02
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_calling_convention
DW_AT_containing_type
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_specification
DW_AT_start_scope
DW_AT_visibility
DW_TAG_coarray_type
static
Usage_Tag_Attr
tag_attr_44
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_bit_size
DW_AT_byte_size
DW_AT_sibling
DW_AT_type
DW_TAG_common_block
static
Usage_Tag_Attr
tag_attr_1a
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_declaration
DW_AT_description
DW_AT_linkage_name
DW_AT_location
DW_AT_name
DW_AT_segment
DW_AT_sibling
DW_AT_visibility
DW_TAG_common_inclusion
static
Usage_Tag_Attr
tag_attr_1b
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_common_reference
DW_AT_declaration
DW_AT_sibling
DW_AT_visibility
DW_TAG_compile_unit
static
Usage_Tag_Attr
tag_attr_11
DW_AT_addr_base
DW_AT_base_types
DW_AT_comp_dir
DW_AT_dwo_id
DW_AT_dwo_name
DW_AT_entry_pc
DW_AT_identifier_case
DW_AT_high_pc
DW_AT_language
DW_AT_loclists_base
DW_AT_low_pc
DW_AT_macro_info
DW_AT_macros
DW_AT_main_subprogram
DW_AT_name
DW_AT_producer
DW_AT_ranges
DW_AT_rnglists_base
DW_AT_segment
DW_AT_stmt_list
DW_AT_str_offsets_base
DW_AT_use_UTF8
DW_TAG_condition
static
Usage_Tag_Attr
tag_attr_3f
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_name
DW_AT_sibling
DW_TAG_const_type
static
Usage_Tag_Attr
tag_attr_26
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_constant
static
Usage_Tag_Attr
tag_attr_27
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_const_value
DW_AT_declaration
DW_AT_description
DW_AT_endianity
DW_AT_external
DW_AT_linkage_name
DW_AT_name
DW_AT_sibling
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_dwarf_procedure
static
Usage_Tag_Attr
tag_attr_36
DW_AT_location
DW_TAG_dynamic_type
static
Usage_Tag_Attr
tag_attr_46
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_description
DW_AT_name
DW_AT_type
DW_AT_sibling
DW_TAG_entry_point
static
Usage_Tag_Attr
tag_attr_03
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_address_class
DW_AT_description
DW_AT_frame_base
DW_AT_linkage_name
DW_AT_low_pc
DW_AT_name
DW_AT_return_addr
DW_AT_segment
DW_AT_sibling
DW_AT_static_link
DW_AT_type
DW_TAG_enumeration_type
static
Usage_Tag_Attr
tag_attr_04
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_bit_stride
DW_AT_byte_size
DW_AT_byte_stride
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_enum_class
DW_AT_linkage_name
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_specification
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_enumerator
static
Usage_Tag_Attr
tag_attr_28
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_const_value
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_TAG_file_type
static
Usage_Tag_Attr
tag_attr_29
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_data_location
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_formal_parameter
static
Usage_Tag_Attr
tag_attr_05
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_artificial
DW_AT_const_value
DW_AT_default_value
DW_AT_description
DW_AT_endianity
DW_AT_is_optional
DW_AT_location
DW_AT_name
DW_AT_segment
DW_AT_sibling
DW_AT_type
DW_AT_variable_parameter
DW_TAG_friend
static
Usage_Tag_Attr
tag_attr_2a
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_friend
DW_AT_sibling
DW_TAG_generic_subrange
static
Usage_Tag_Attr
tag_attr_45
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_bit_stride
DW_AT_byte_size
DW_AT_byte_stride
DW_AT_count
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_lower_bound
DW_AT_name
DW_AT_sibling
DW_AT_threads_scaled
DW_AT_type
DW_AT_upper_bound
DW_AT_visibility
DW_TAG_imported_declaration
static
Usage_Tag_Attr
tag_attr_08
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_description
DW_AT_import
DW_AT_name
DW_AT_sibling
DW_AT_start_scope
DW_TAG_immutable_type
static
Usage_Tag_Attr
tag_attr_4b
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_type
DW_TAG_imported_module
static
Usage_Tag_Attr
tag_attr_3a
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_import
DW_AT_sibling
DW_AT_start_scope
DW_TAG_imported_unit
static
Usage_Tag_Attr
tag_attr_3d
DW_AT_import
DW_TAG_inheritance
static
Usage_Tag_Attr
tag_attr_1c
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_data_member_location
DW_AT_sibling
DW_AT_type
DW_AT_virtuality
DW_TAG_inlined_subroutine
static
Usage_Tag_Attr
tag_attr_1d
DW_AT_abstract_origin
DW_AT_call_column
DW_AT_call_file
DW_AT_call_line
DW_AT_const_expr
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_low_pc
DW_AT_ranges
DW_AT_return_addr
DW_AT_segment
DW_AT_sibling
DW_AT_start_scope
DW_AT_trampoline
DW_TAG_interface_type
static
Usage_Tag_Attr
tag_attr_38
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_alignment
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_start_scope
DW_TAG_label
static
Usage_Tag_Attr
tag_attr_0a
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_description
DW_AT_low_pc
DW_AT_name
DW_AT_segment
DW_AT_sibling
DW_AT_start_scope
DW_TAG_lexical_block
static
Usage_Tag_Attr
tag_attr_0b
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_description
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_low_pc
DW_AT_name
DW_AT_ranges
DW_AT_segment
DW_AT_sibling
DW_TAG_member
static
Usage_Tag_Attr
tag_attr_0d
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_alignment
DW_AT_artificial
DW_AT_bit_offset
DW_AT_bit_size
DW_AT_byte_size
DW_AT_bit_size
DW_AT_const_value
DW_AT_data_bit_offset
DW_AT_data_member_location
DW_AT_declaration
DW_AT_description
DW_AT_external
DW_AT_mutable
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_AT_visibility
DW_TAG_module
static
Usage_Tag_Attr
tag_attr_1e
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_declaration
DW_AT_description
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_low_pc
DW_AT_name
DW_AT_priority
DW_AT_ranges
DW_AT_segment
DW_AT_sibling
DW_AT_specification
DW_AT_visibility
DW_TAG_namelist
static
Usage_Tag_Attr
tag_attr_2b
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_declaration
DW_AT_name
DW_AT_sibling
DW_AT_visibility
DW_TAG_namelist_item
static
Usage_Tag_Attr
tag_attr_2c
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_namelist_item
DW_AT_sibling
DW_TAG_namespace
static
Usage_Tag_Attr
tag_attr_39
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_declaration
DW_AT_description
DW_AT_export_symbols
DW_AT_extension
DW_AT_export_symbols
DW_AT_name
DW_AT_sibling
DW_AT_start_scope
DW_TAG_packed_type
static
Usage_Tag_Attr
tag_attr_2d
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_partial_unit
static
Usage_Tag_Attr
tag_attr_3c
DW_AT_addr_base
DW_AT_base_types
DW_AT_comp_dir
DW_AT_description
DW_AT_dwo_name
DW_AT_entry_pc
DW_AT_identifier_case
DW_AT_high_pc
DW_AT_language
DW_AT_low_pc
DW_AT_macro_info
DW_AT_macros
DW_AT_main_subprogram
DW_AT_name
DW_AT_noreturn
DW_AT_producer
DW_AT_ranges
DW_AT_rnglists_base
DW_AT_segment
DW_AT_stmt_list
DW_AT_str_offsets_base
DW_AT_use_UTF8
DW_TAG_pointer_type
static
Usage_Tag_Attr
tag_attr_0f
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_address_class
DW_AT_alignment
DW_AT_bit_size
DW_AT_byte_size
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_ptr_to_member_type
static
Usage_Tag_Attr
tag_attr_1f
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_abstract_origin
DW_AT_address_class
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_containing_type
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_AT_use_location
DW_AT_visibility
DW_TAG_reference_type
static
Usage_Tag_Attr
tag_attr_10
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_address_class
DW_AT_alignment
DW_AT_bit_size
DW_AT_byte_size
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_restrict_type
static
Usage_Tag_Attr
tag_attr_37
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_sibling
DW_AT_type
DW_TAG_rvalue_reference_type
static
Usage_Tag_Attr
tag_attr_42
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_address_class
DW_AT_byte_size
DW_AT_name
DW_AT_type
DW_TAG_set_type
static
Usage_Tag_Attr
tag_attr_20
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_start_scope
DW_AT_sibling
DW_AT_type
DW_AT_visibility
DW_TAG_shared_type
static
Usage_Tag_Attr
tag_attr_40
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_alignment
DW_AT_count
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_skeleton_unit
static
Usage_Tag_Attr
tag_attr_4a
DW_AT_addr_base
DW_AT_comp_dir
DW_AT_dwo_name
DW_AT_high_pc
DW_AT_low_pc
DW_AT_stmt_list
DW_AT_ranges
DW_AT_rnglists_base
DW_AT_stmt_list
DW_AT_str_offsets_base
DW_AT_use_UTF8
DW_TAG_string_type
static
Usage_Tag_Attr
tag_attr_12
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_segment
DW_AT_sibling
DW_AT_start_scope
DW_AT_string_length
DW_AT_string_length_bit_size
DW_AT_string_length_byte_size
DW_AT_visibility
DW_TAG_structure_type
static
Usage_Tag_Attr
tag_attr_13
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_calling_convention
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_export_symbols
DW_AT_linkage_name
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_specification
DW_AT_start_scope
DW_AT_visibility
DW_TAG_subprogram
static
Usage_Tag_Attr
tag_attr_2e
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_address_class
DW_AT_alignment
DW_AT_artificial
DW_AT_call_all_calls
DW_AT_call_all_tail_calls
DW_AT_call_all_source_calls
DW_AT_calling_convention
DW_AT_containing_type
DW_AT_declaration
DW_AT_defaulted
DW_AT_deleted
DW_AT_description
DW_AT_elemental
DW_AT_entry_pc
DW_AT_explicit
DW_AT_external
DW_AT_frame_base
DW_AT_high_pc
DW_AT_inline
DW_AT_linkage_name
DW_AT_low_pc
DW_AT_main_subprogram
DW_AT_name
DW_AT_noreturn
DW_AT_object_pointer
DW_AT_prototyped
DW_AT_pure
DW_AT_ranges
DW_AT_recursive
DW_AT_reference
DW_AT_return_addr
DW_AT_rvalue_reference
DW_AT_segment
DW_AT_sibling
DW_AT_specification
DW_AT_start_scope
DW_AT_static_link
DW_AT_trampoline
DW_AT_type
DW_AT_visibility
DW_AT_virtuality
DW_AT_vtable_elem_location
DW_TAG_subrange_type
static
Usage_Tag_Attr
tag_attr_21
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_allocated
DW_AT_associated
DW_AT_bit_stride
DW_AT_byte_size
DW_AT_bit_size
DW_AT_byte_stride
DW_AT_count
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_lower_bound
DW_AT_name
DW_AT_sibling
DW_AT_threads_scaled
DW_AT_type
DW_AT_upper_bound
DW_AT_visibility
DW_TAG_subroutine_type
static
Usage_Tag_Attr
tag_attr_15
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_address_class
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_object_pointer
DW_AT_prototyped
DW_AT_rvalue_reference
DW_AT_sibling
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_template_alias
static
Usage_Tag_Attr
tag_attr_43
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_template_type_parameter
static
Usage_Tag_Attr
tag_attr_2f
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_default_value
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_template_value_parameter
static
Usage_Tag_Attr
tag_attr_30
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_const_value
DW_AT_default_value
DW_AT_description
DW_AT_location
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_thrown_type
static
Usage_Tag_Attr
tag_attr_31
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_try_block
static
Usage_Tag_Attr
tag_attr_32
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_low_pc
DW_AT_ranges
DW_AT_segment
DW_AT_sibling
DW_TAG_typedef
static
Usage_Tag_Attr
tag_attr_16
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_name
DW_AT_sibling
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_type_unit
static
Usage_Tag_Attr
tag_attr_41
DW_AT_comp_dir
DW_AT_language
DW_AT_stmt_list
DW_AT_str_offsets_base
DW_AT_use_UTF8
DW_TAG_union_type
static
Usage_Tag_Attr
tag_attr_17
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_allocated
DW_AT_associated
DW_AT_bit_size
DW_AT_byte_size
DW_AT_calling_convention
DW_AT_data_location
DW_AT_declaration
DW_AT_description
DW_AT_export_symbols
DW_AT_linkage_name
DW_AT_name
DW_AT_sibling
DW_AT_signature
DW_AT_specification
DW_AT_start_scope
DW_AT_visibility
DW_TAG_unspecified_parameters
static
Usage_Tag_Attr
tag_attr_18
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_artificial
DW_AT_sibling
DW_TAG_unspecified_type
static
Usage_Tag_Attr
tag_attr_3b
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_description
DW_AT_name
DW_TAG_variable
static
Usage_Tag_Attr
tag_attr_34
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_alignment
DW_AT_artificial
DW_AT_byte_size
DW_AT_bit_size
DW_AT_const_expr
DW_AT_const_value
DW_AT_declaration
DW_AT_description
DW_AT_endianity
DW_AT_external
DW_AT_linkage_name
DW_AT_location
DW_AT_name
DW_AT_segment
DW_AT_sibling
DW_AT_specification
DW_AT_start_scope
DW_AT_type
DW_AT_visibility
DW_TAG_variant
static
Usage_Tag_Attr
tag_attr_19
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_accessibility
DW_AT_abstract_origin
DW_AT_declaration
DW_AT_discr_list
DW_AT_discr_value
DW_AT_sibling
DW_TAG_variant_part
static
Usage_Tag_Attr
tag_attr_33
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_abstract_origin
DW_AT_accessibility
DW_AT_declaration
DW_AT_discr
DW_AT_sibling
DW_AT_type
DW_TAG_volatile_type
static
Usage_Tag_Attr
tag_attr_35
DW_AT_decl_column
DW_AT_decl_file
DW_AT_decl_line
DW_AT_name
DW_AT_sibling
DW_AT_type
DW_TAG_with_stmt
static
Usage_Tag_Attr
tag_attr_22
DW_AT_accessibility
DW_AT_address_class
DW_AT_declaration
DW_AT_entry_pc
DW_AT_high_pc
DW_AT_location
DW_AT_low_pc
DW_AT_ranges
DW_AT_segment
DW_AT_sibling
DW_AT_type
DW_AT_visibility
static
Usage_Tag_Attr
usage_tag_attr
tag_attr_01
DW_TAG_array_type
tag_attr_02
DW_TAG_class_type
tag_attr_03
DW_TAG_entry_point
tag_attr_04
DW_TAG_enumeration_type
tag_attr_05
DW_TAG_formal_parameter
tag_attr_08
DW_TAG_imported_declaration
tag_attr_0a
DW_TAG_label
tag_attr_0b
DW_TAG_lexical_block
tag_attr_0d
DW_TAG_member
tag_attr_0f
DW_TAG_pointer_type
tag_attr_10
DW_TAG_reference_type
tag_attr_11
DW_TAG_compile_unit
tag_attr_12
DW_TAG_string_type
tag_attr_13
DW_TAG_structure_type
tag_attr_15
DW_TAG_subroutine_type
tag_attr_16
DW_TAG_typedef
tag_attr_17
DW_TAG_union_type
tag_attr_18
DW_TAG_unspecified_parameters
tag_attr_19
DW_TAG_variant
tag_attr_1a
DW_TAG_common_block
tag_attr_1b
DW_TAG_common_inclusion
tag_attr_1c
DW_TAG_inheritance
tag_attr_1d
DW_TAG_inlined_subroutine
tag_attr_1e
DW_TAG_module
tag_attr_1f
DW_TAG_ptr_to_member_type
tag_attr_20
DW_TAG_set_type
tag_attr_21
DW_TAG_subrange_type
tag_attr_22
DW_TAG_with_stmt
tag_attr_23
DW_TAG_access_declaration
tag_attr_24
DW_TAG_base_type
tag_attr_25
DW_TAG_catch_block
tag_attr_26
DW_TAG_const_type
tag_attr_27
DW_TAG_constant
tag_attr_28
DW_TAG_enumerator
tag_attr_29
DW_TAG_file_type
tag_attr_2a
DW_TAG_friend
tag_attr_2b
DW_TAG_namelist
tag_attr_2c
DW_TAG_namelist_item
tag_attr_2d
DW_TAG_packed_type
tag_attr_2e
DW_TAG_subprogram
tag_attr_2f
DW_TAG_template_type_parameter
tag_attr_30
DW_TAG_template_value_parameter
tag_attr_31
DW_TAG_thrown_type
tag_attr_32
DW_TAG_try_block
tag_attr_33
DW_TAG_variant_part
tag_attr_34
DW_TAG_variable
tag_attr_35
DW_TAG_volatile_type
tag_attr_36
DW_TAG_dwarf_procedure
tag_attr_37
DW_TAG_restrict_type
tag_attr_38
DW_TAG_interface_type
tag_attr_39
DW_TAG_namespace
tag_attr_3a
DW_TAG_imported_module
tag_attr_3b
DW_TAG_unspecified_type
tag_attr_3c
DW_TAG_partial_unit
tag_attr_3d
DW_TAG_imported_unit
tag_attr_3f
DW_TAG_condition
tag_attr_40
DW_TAG_shared_type
tag_attr_41
DW_TAG_type_unit
tag_attr_42
DW_TAG_rvalue_reference_type
tag_attr_43
DW_TAG_template_alias
tag_attr_44
DW_TAG_coarray_type
tag_attr_45
DW_TAG_generic_subrange
tag_attr_46
DW_TAG_dynamic_type
tag_attr_47
DW_TAG_atomic_type
tag_attr_48
DW_TAG_call_site
tag_attr_49
DW_TAG_call_site_parameter
tag_attr_4a
DW_TAG_skeleton_unit
tag_attr_4b
DW_TAG_immutable_type
typedef
struct
Dwarf_Small
legal
Legal
attributes
Dwarf_Small
found
Found
attributes
Rate_Tag_Attr
static
Rate_Tag_Attr
rate_tag_attr
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_imported_declaration
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
DW_TAG_immutable_type
endif
HAVE_USAGE_TAG_ATTR
define
ATTR_TREE_ROW_COUNT
define
ATTR_TREE_COLUMN_COUNT
static
unsigned
int
tag_attr_combination_table
ATTR_TREE_ROW_COUNT
ATTR_TREE_COLUMN_COUNT
no
name
known
for
the
tag
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
no
name
known
for
the
tag
no
name
known
for
the
tag
DW_TAG_imported_declaration
no
name
known
for
the
tag
DW_TAG_label
DW_TAG_lexical_block
no
name
known
for
the
tag
DW_TAG_member
no
name
known
for
the
tag
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
no
name
known
for
the
tag
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_mutable_type
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
DW_TAG_immutable_type
END
FILE
Generated
code
do
not
edit
Generated
sourcedate
BEGIN
FILE
define
TAG_TREE_EXT_COLUMN_COUNT
define
TAG_TREE_EXT_ROW_COUNT
Common
extensions
static
unsigned
int
tag_tree_combination_ext_table
TAG_TREE_EXT_ROW_COUNT
TAG_TREE_EXT_COLUMN_COUNT
DW_TAG_structure_type
DW_TAG_class_type
DW_TAG_lexical_block
DW_TAG_subprogram
DW_TAG_union_type
DW_TAG_inlined_subroutine
DW_TAG_GNU_call_site
DW_TAG_GNU_template_parameter_pack
DW_TAG_GNU_formal_parameter_pack
END
FILE
Generated
code
do
not
edit
Generated
sourcedate
BEGIN
FILE
ifndef
HAVE_USAGE_TAG_ATTR
define
HAVE_USAGE_TAG_ATTR
endif
HAVE_USAGE_TAG_ATTR
ifdef
HAVE_USAGE_TAG_ATTR
include
dwarf
h
include
libdwarf
h
typedef
struct
unsigned
int
count
Tag
count
Dwarf_Half
tag
Tag
value
Usage_Tag_Tree
DW_TAG_access_declaration
static
Usage_Tag_Tree
tag_tree_23
DW_TAG_array_type
static
Usage_Tag_Tree
tag_tree_01
DW_TAG_subrange_type
DW_TAG_dynamic_type
DW_TAG_generic_subrange
DW_TAG_enumeration_type
DW_TAG_base_type
static
Usage_Tag_Tree
tag_tree_24
DW_TAG_call_site
static
Usage_Tag_Tree
tag_tree_48
DW_TAG_call_site_parameter
DW_TAG_call_site_parameter
static
Usage_Tag_Tree
tag_tree_49
DW_TAG_catch_block
static
Usage_Tag_Tree
tag_tree_25
DW_TAG_formal_parameter
DW_TAG_unspecified_parameters
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_enumeration_type
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_base_type
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_atomic_type
DW_TAG_constant
DW_TAG_file_type
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_class_type
static
Usage_Tag_Tree
tag_tree_02
DW_TAG_member
DW_TAG_inheritance
DW_TAG_access_declaration
DW_TAG_friend
DW_TAG_ptr_to_member_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_typedef
DW_TAG_base_type
DW_TAG_pointer_type
DW_TAG_union_type
DW_TAG_coarray_type
DW_TAG_dynamic_type
DW_TAG_const_type
DW_TAG_atomic_type
DW_TAG_class_type
DW_TAG_structure_type
DW_TAG_enumeration_type
DW_TAG_imported_declaration
DW_TAG_template_alias
DW_TAG_coarray_type
static
Usage_Tag_Tree
tag_tree_44
DW_TAG_subrange_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_array_type
DW_TAG_base_type
DW_TAG_common_block
static
Usage_Tag_Tree
tag_tree_1a
DW_TAG_variable
DW_TAG_common_inclusion
static
Usage_Tag_Tree
tag_tree_1b
DW_TAG_skeleton_unit
static
Usage_Tag_Tree
tag_tree_4a
DW_TAG_structure_type
DW_TAG_union_type
DW_TAG_class_type
DW_TAG_enumeration_type
DW_TAG_compile_unit
static
Usage_Tag_Tree
tag_tree_11
DW_TAG_array_type
DW_TAG_dynamic_type
DW_TAG_class_type
DW_TAG_dwarf_procedure
DW_TAG_enumeration_type
DW_TAG_imported_declaration
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_rvalue_reference_type
DW_TAG_restrict_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_common_block
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_generic_subrange
DW_TAG_base_type
DW_TAG_coarray_type
DW_TAG_const_type
DW_TAG_atomic_type
DW_TAG_constant
DW_TAG_file_type
DW_TAG_namelist
DW_TAG_namespace
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_imported_module
DW_TAG_template_alias
DW_TAG_unspecified_type
DW_TAG_type_unit
static
Usage_Tag_Tree
tag_tree_41
DW_TAG_array_type
DW_TAG_dynamic_type
DW_TAG_class_type
DW_TAG_enumeration_type
DW_TAG_imported_declaration
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_common_block
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_generic_subrange
DW_TAG_base_type
DW_TAG_coarray_type
DW_TAG_const_type
DW_TAG_atomic_type
DW_TAG_constant
DW_TAG_file_type
DW_TAG_namelist
DW_TAG_namespace
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_imported_module
DW_TAG_template_alias
DW_TAG_condition
static
Usage_Tag_Tree
tag_tree_3f
DW_TAG_constant
DW_TAG_subrange_type
DW_TAG_atomic_type
static
Usage_Tag_Tree
tag_tree_47
DW_TAG_const_type
static
Usage_Tag_Tree
tag_tree_26
DW_TAG_constant
static
Usage_Tag_Tree
tag_tree_27
DW_TAG_dwarf_procedure
static
Usage_Tag_Tree
tag_tree_36
DW_TAG_entry_point
static
Usage_Tag_Tree
tag_tree_03
DW_TAG_formal_parameter
DW_TAG_unspecified_parameters
DW_TAG_common_inclusion
DW_TAG_enumeration_type
static
Usage_Tag_Tree
tag_tree_04
DW_TAG_enumerator
DW_TAG_enumerator
static
Usage_Tag_Tree
tag_tree_28
DW_TAG_file_type
static
Usage_Tag_Tree
tag_tree_29
DW_TAG_formal_parameter
static
Usage_Tag_Tree
tag_tree_05
DW_TAG_friend
static
Usage_Tag_Tree
tag_tree_2a
DW_TAG_imported_declaration
static
Usage_Tag_Tree
tag_tree_08
DW_TAG_imported_module
static
Usage_Tag_Tree
tag_tree_3a
DW_TAG_imported_unit
static
Usage_Tag_Tree
tag_tree_3d
DW_TAG_inheritance
static
Usage_Tag_Tree
tag_tree_1c
DW_TAG_inlined_subroutine
static
Usage_Tag_Tree
tag_tree_1d
DW_TAG_array_type
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_call_site
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_constant
DW_TAG_const_type
DW_TAG_dynamic_type
DW_TAG_enumeration_type
DW_TAG_file_type
DW_TAG_formal_parameter
DW_TAG_generic_subrange
DW_TAG_inlined_subroutine
DW_TAG_lexical_block
DW_TAG_namelist
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_reference_type
DW_TAG_set_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_subrange_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_interface_type
static
Usage_Tag_Tree
tag_tree_38
DW_TAG_member
DW_TAG_subprogram
DW_TAG_label
static
Usage_Tag_Tree
tag_tree_0a
DW_TAG_lexical_block
static
Usage_Tag_Tree
tag_tree_0b
DW_TAG_array_type
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_call_site
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_constant
DW_TAG_const_type
DW_TAG_dynamic_type
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_generic_subrange
DW_TAG_imported_declaration
DW_TAG_imported_module
DW_TAG_inlined_subroutine
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_module
DW_TAG_namelist
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_reference_type
DW_TAG_set_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_subrange_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_member
static
Usage_Tag_Tree
tag_tree_0d
DW_TAG_module
static
Usage_Tag_Tree
tag_tree_1e
DW_TAG_namelist
static
Usage_Tag_Tree
tag_tree_2b
DW_TAG_namelist_item
DW_TAG_namelist_item
static
Usage_Tag_Tree
tag_tree_2c
DW_TAG_namespace
static
Usage_Tag_Tree
tag_tree_39
DW_TAG_array_type
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_common_block
DW_TAG_constant
DW_TAG_const_type
DW_TAG_dynamic_type
DW_TAG_enumeration_type
DW_TAG_generic_subrange
DW_TAG_imported_declaration
DW_TAG_imported_module
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_namelist
DW_TAG_namespace
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_reference_type
DW_TAG_set_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_subrange_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_packed_type
static
Usage_Tag_Tree
tag_tree_2d
DW_TAG_partial_unit
static
Usage_Tag_Tree
tag_tree_3c
DW_TAG_array_type
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_common_block
DW_TAG_constant
DW_TAG_const_type
DW_TAG_dynamic_type
DW_TAG_enumeration_type
DW_TAG_file_type
DW_TAG_generic_subrange
DW_TAG_imported_declaration
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_namelist
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_reference_type
DW_TAG_set_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_subrange_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_pointer_type
static
Usage_Tag_Tree
tag_tree_0f
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_packed_type
DW_TAG_reference_type
DW_TAG_restrict_type
DW_TAG_rvalue_reference_type
DW_TAG_shared_type
DW_TAG_volatile_type
DW_TAG_ptr_to_member_type
static
Usage_Tag_Tree
tag_tree_1f
DW_TAG_reference_type
static
Usage_Tag_Tree
tag_tree_10
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_restrict_type
DW_TAG_rvalue_reference_type
DW_TAG_shared_type
DW_TAG_volatile_type
DW_TAG_rvalue_reference_type
static
Usage_Tag_Tree
tag_tree_42
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_restrict_type
DW_TAG_shared_type
DW_TAG_volatile_type
DW_TAG_restrict_type
static
Usage_Tag_Tree
tag_tree_37
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_rvalue_reference_type
DW_TAG_shared_type
DW_TAG_volatile_type
DW_TAG_set_type
static
Usage_Tag_Tree
tag_tree_20
DW_TAG_shared_type
static
Usage_Tag_Tree
tag_tree_40
DW_TAG_atomic_type
DW_TAG_const_type
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_restrict_type
DW_TAG_rvalue_reference_type
DW_TAG_shared_type
DW_TAG_volatile_type
DW_TAG_string_type
static
Usage_Tag_Tree
tag_tree_12
DW_TAG_structure_type
static
Usage_Tag_Tree
tag_tree_13
DW_TAG_access_declaration
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_const_type
DW_TAG_enumeration_type
DW_TAG_friend
DW_TAG_imported_declaration
DW_TAG_inheritance
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_template_alias
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_variant_part
DW_TAG_volatile_type
DW_TAG_subprogram
static
Usage_Tag_Tree
tag_tree_2e
DW_TAG_array_type
DW_TAG_atomic_type
DW_TAG_base_type
DW_TAG_call_site
DW_TAG_class_type
DW_TAG_coarray_type
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_constant
DW_TAG_const_type
DW_TAG_enumeration_type
DW_TAG_file_type
DW_TAG_formal_parameter
DW_TAG_generic_subrange
DW_TAG_imported_declaration
DW_TAG_imported_module
DW_TAG_inlined_subroutine
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_namelist
DW_TAG_packed_type
DW_TAG_pointer_type
DW_TAG_ptr_to_member_type
DW_TAG_reference_type
DW_TAG_set_type
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_subrange_type
DW_TAG_subroutine_type
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_subrange_type
static
Usage_Tag_Tree
tag_tree_21
DW_TAG_generic_subrange
static
Usage_Tag_Tree
tag_tree_45
DW_TAG_subroutine_type
static
Usage_Tag_Tree
tag_tree_15
DW_TAG_formal_parameter
DW_TAG_typedef
DW_TAG_unspecified_parameters
DW_TAG_template_type_parameter
static
Usage_Tag_Tree
tag_tree_2f
DW_TAG_template_value_parameter
static
Usage_Tag_Tree
tag_tree_30
DW_TAG_thrown_type
static
Usage_Tag_Tree
tag_tree_31
DW_TAG_try_block
static
Usage_Tag_Tree
tag_tree_32
DW_TAG_typedef
static
Usage_Tag_Tree
tag_tree_16
DW_TAG_union_type
static
Usage_Tag_Tree
tag_tree_17
DW_TAG_class_type
DW_TAG_enumeration_type
DW_TAG_friend
DW_TAG_member
DW_TAG_structure_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_template_alias
static
Usage_Tag_Tree
tag_tree_43
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_unspecified_parameters
static
Usage_Tag_Tree
tag_tree_18
DW_TAG_unspecified_type
static
Usage_Tag_Tree
tag_tree_3b
DW_TAG_variable
static
Usage_Tag_Tree
tag_tree_34
DW_TAG_variant
static
Usage_Tag_Tree
tag_tree_19
DW_TAG_variant_part
DW_TAG_variant_part
static
Usage_Tag_Tree
tag_tree_33
DW_TAG_volatile_type
static
Usage_Tag_Tree
tag_tree_35
DW_TAG_with_stmt
static
Usage_Tag_Tree
tag_tree_22
static
Usage_Tag_Tree
usage_tag_tree
tag_tree_01
DW_TAG_array_type
tag_tree_02
DW_TAG_class_type
tag_tree_03
DW_TAG_entry_point
tag_tree_04
DW_TAG_enumeration_type
tag_tree_05
DW_TAG_formal_parameter
tag_tree_08
DW_TAG_imported_declaration
tag_tree_0a
DW_TAG_label
tag_tree_0b
DW_TAG_lexical_block
tag_tree_0d
DW_TAG_member
tag_tree_0f
DW_TAG_pointer_type
tag_tree_10
DW_TAG_reference_type
tag_tree_11
DW_TAG_compile_unit
tag_tree_12
DW_TAG_string_type
tag_tree_13
DW_TAG_structure_type
tag_tree_15
DW_TAG_subroutine_type
tag_tree_16
DW_TAG_typedef
tag_tree_17
DW_TAG_union_type
tag_tree_18
DW_TAG_unspecified_parameters
tag_tree_19
DW_TAG_variant
tag_tree_1a
DW_TAG_common_block
tag_tree_1b
DW_TAG_common_inclusion
tag_tree_1c
DW_TAG_inheritance
tag_tree_1d
DW_TAG_inlined_subroutine
tag_tree_1e
DW_TAG_module
tag_tree_1f
DW_TAG_ptr_to_member_type
tag_tree_20
DW_TAG_set_type
tag_tree_21
DW_TAG_subrange_type
tag_tree_22
DW_TAG_with_stmt
tag_tree_23
DW_TAG_access_declaration
tag_tree_24
DW_TAG_base_type
tag_tree_25
DW_TAG_catch_block
tag_tree_26
DW_TAG_const_type
tag_tree_27
DW_TAG_constant
tag_tree_28
DW_TAG_enumerator
tag_tree_29
DW_TAG_file_type
tag_tree_2a
DW_TAG_friend
tag_tree_2b
DW_TAG_namelist
tag_tree_2c
DW_TAG_namelist_item
tag_tree_2d
DW_TAG_packed_type
tag_tree_2e
DW_TAG_subprogram
tag_tree_2f
DW_TAG_template_type_parameter
tag_tree_30
DW_TAG_template_value_parameter
tag_tree_31
DW_TAG_thrown_type
tag_tree_32
DW_TAG_try_block
tag_tree_33
DW_TAG_variant_part
tag_tree_34
DW_TAG_variable
tag_tree_35
DW_TAG_volatile_type
tag_tree_36
DW_TAG_dwarf_procedure
tag_tree_37
DW_TAG_restrict_type
tag_tree_38
DW_TAG_interface_type
tag_tree_39
DW_TAG_namespace
tag_tree_3a
DW_TAG_imported_module
tag_tree_3b
DW_TAG_unspecified_type
tag_tree_3c
DW_TAG_partial_unit
tag_tree_3d
DW_TAG_imported_unit
tag_tree_3f
DW_TAG_condition
tag_tree_40
DW_TAG_shared_type
tag_tree_41
DW_TAG_type_unit
tag_tree_42
DW_TAG_rvalue_reference_type
tag_tree_43
DW_TAG_template_alias
tag_tree_44
DW_TAG_coarray_type
tag_tree_45
DW_TAG_generic_subrange
tag_tree_47
DW_TAG_atomic_type
tag_tree_48
DW_TAG_call_site
tag_tree_49
DW_TAG_call_site_parameter
tag_tree_4a
DW_TAG_skeleton_unit
typedef
struct
Dwarf_Small
legal
Legal
tags
Dwarf_Small
found
Found
tags
Rate_Tag_Tree
static
Rate_Tag_Tree
rate_tag_tree
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
DW_TAG_imported_declaration
DW_TAG_label
DW_TAG_lexical_block
DW_TAG_member
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
endif
HAVE_USAGE_TAG_ATTR
define
TAG_TREE_COLUMN_COUNT
define
TAG_TREE_ROW_COUNT
static
unsigned
int
tag_tree_combination_table
TAG_TREE_ROW_COUNT
TAG_TREE_COLUMN_COUNT
no
name
known
for
the
TAG
DW_TAG_array_type
DW_TAG_class_type
DW_TAG_entry_point
DW_TAG_enumeration_type
DW_TAG_formal_parameter
no
name
known
for
the
TAG
no
name
known
for
the
TAG
DW_TAG_imported_declaration
no
name
known
for
the
TAG
DW_TAG_label
DW_TAG_lexical_block
no
name
known
for
the
TAG
DW_TAG_member
no
name
known
for
the
TAG
DW_TAG_pointer_type
DW_TAG_reference_type
DW_TAG_compile_unit
DW_TAG_string_type
DW_TAG_structure_type
no
name
known
for
the
TAG
DW_TAG_subroutine_type
DW_TAG_typedef
DW_TAG_union_type
DW_TAG_unspecified_parameters
DW_TAG_variant
DW_TAG_common_block
DW_TAG_common_inclusion
DW_TAG_inheritance
DW_TAG_inlined_subroutine
DW_TAG_module
DW_TAG_ptr_to_member_type
DW_TAG_set_type
DW_TAG_subrange_type
DW_TAG_with_stmt
DW_TAG_access_declaration
DW_TAG_base_type
DW_TAG_catch_block
DW_TAG_const_type
DW_TAG_constant
DW_TAG_enumerator
DW_TAG_file_type
DW_TAG_friend
DW_TAG_namelist
DW_TAG_namelist_item
DW_TAG_packed_type
DW_TAG_subprogram
DW_TAG_template_type_parameter
DW_TAG_template_value_parameter
DW_TAG_thrown_type
DW_TAG_try_block
DW_TAG_variant_part
DW_TAG_variable
DW_TAG_volatile_type
DW_TAG_dwarf_procedure
DW_TAG_restrict_type
DW_TAG_interface_type
DW_TAG_namespace
DW_TAG_imported_module
DW_TAG_unspecified_type
DW_TAG_partial_unit
DW_TAG_imported_unit
DW_TAG_mutable_type
DW_TAG_condition
DW_TAG_shared_type
DW_TAG_type_unit
DW_TAG_rvalue_reference_type
DW_TAG_template_alias
DW_TAG_coarray_type
DW_TAG_generic_subrange
DW_TAG_dynamic_type
DW_TAG_atomic_type
DW_TAG_call_site
DW_TAG_call_site_parameter
DW_TAG_skeleton_unit
END
FILE
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWCONFIG_H
define
DWCONFIG_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
define
FOUND_ABI_START
define
FOUND_OPTION
define
FOUND_ERROR
define
FOUND_DONE
Declarations
helping
configure
the
frame
reader
We
are
not
allowing
negative
register
numbers
Which
could
be
allowed
if
necessary
with
a
little
work
struct
dwconf_s
char
cf_config_file_path
char
cf_abi_name
The
interface_number
is
now
only
so
never
tested
It
used
to
allow
to
test
old
and
now
deleted
libdwarf
API
functions
int
cf_interface_number
The
number
of
table
rules
aka
columns
For
MIPS
IRIX
is
unsigned
long
cf_table_entry_count
Array
of
cf_table_entry_count
reg
names
Names
not
filled
in
from
dwarfdump
conf
have
NULL
pointer
value
cf_named_regs_table_size
must
match
size
of
cf_regs
array
Set
cf_regs_malloced
if
table
was
malloced
Set
if
static
char
cf_regs
unsigned
long
cf_named_regs_table_size
unsigned
cf_regs_malloced
The
default
initial
value
when
intializing
a
table
for
MIPS
is
DW_FRAME_SAME_VAL
For
other
ISA
ABIs
may
be
DW_FRAME_UNDEFINED_VAL
unsigned
cf_initial_rule_value
unsigned
cf_same_val
unsigned
cf_undefined_val
The
number
of
the
cfa
register
For
cf_interface_number
of
MIPS
this
is
For
other
architectures
and
anytime
using
cf_interface_number
this
should
be
outside
the
table
a
special
value
such
as
not
a
table
column
at
all
unsigned
cf_cfa_reg
If
non
zero
it
is
the
number
of
bytes
in
an
address
for
the
frame
data
Normally
it
will
be
zero
because
there
are
usually
other
sources
for
the
correct
address
size
However
with
DWARF2
frame
data
there
is
no
explicit
address
size
in
the
frame
data
and
the
object
file
might
not
have
other
debug_
sections
to
work
with
If
zero
no
address
size
was
supplied
and
that
is
normal
and
the
already
set
or
defaulted
address
size
is
to
be
used
Only
an
exceptional
frame
configure
will
specify
address
size
here
This
won
t
work
at
all
if
the
object
needing
this
setting
has
different
address
size
in
different
CUs
unsigned
cf_address_size
Returns
DW_DLV_OK
if
works
Returns
DW_DLV_ERROR
if
cannot
do
what
is
asked
int
find_conf_file_and_read_config
const
char
named_file
const
char
named_abi
char
defaults
struct
dwconf_s
conf_out
void
init_conf_file_data
struct
dwconf_s
config_file_data
void
print_reg_from_config_data
Dwarf_Unsigned
reg
struct
dwconf_s
config_data
void
free_all_dwconf
struct
dwconf_s
config_data
void
init_generic_config_1200_regs
struct
dwconf_s
conf
ifdef
__cplusplus
endif
__cplusplus
endif
DWCONFIG_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
DWCONF_USING_FUNCTIONS_H
define
DWCONF_USING_FUNCTIONS_H
ifdef
__cplusplus
extern
C
endif
int
print_frames
Dwarf_Debug
dbg
int
want_eh
struct
dwconf_s
Dwarf_Die
void
void
Dwarf_Error
void
printreg
Dwarf_Unsigned
reg
struct
dwconf_s
config_data
ifdef
__cplusplus
endif
endif
DWCONF_USING_FUNCTIONS_H
getopt
c
v
joerg
Exp
Modified
by
David
Anderson
to
work
with
GNU
Linux
and
freebsd
Added
for
clarity
Switched
to
standard
dwarfdump
formatting
Treatment
of
modified
so
that
gets
dwoptarg
NULL
if
space
follows
the
letter
the
dwoptarg
is
set
to
null
Copyright
c
The
Regents
of
the
University
of
California
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
Neither
the
name
of
the
University
nor
the
names
of
its
contributors
may
be
used
to
endorse
or
promote
products
derived
from
this
software
without
specific
prior
written
permission
THIS
SOFTWARE
IS
PROVIDED
BY
THE
REGENTS
AND
CONTRIBUTORS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
REGENTS
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifdef
__cplusplus
extern
C
endif
__cplusplus
extern
int
dwopterr
extern
int
dwoptind
extern
int
dwoptopt
extern
int
dwoptreset
extern
char
dwoptarg
int
dwgetopt
int
nargc
char
const
nargv
const
char
ostr
As
of
October
it
seems
advisable
to
allow
long
option
names
So
based
on
a
reading
of
man
getopt
we
reimplement
a
portion
of
GNU
getopt_long
It
s
a
wonderfully
sensible
design
and
all
the
credit
should
go
to
the
original
designers
We
are
not
implementing
all
the
features
of
GNU
Linux
getopt_long
just
the
features
we
wish
to
use
Specifically
we
require
val
be
and
flag
be
NULL
and
ignore
those
fields
We
do
not
implement
GNU
digit_optind
at
all
Within
these
restrictions
the
interface
behaves
the
same
as
GNU
getopt_long
or
so
it
appears
from
the
getopt
documentation
release
of
the
Linux
man
pages
project
GETOPT
http
www
kernel
org
doc
man
pages
struct
dwoption
const
char
name
int
has_arg
int
flag
int
val
define
dwno_argument
define
dwrequired_argument
define
dwoptional_argument
int
dwgetopt_long
int
nargc
char
const
nargv
const
char
ostr
const
struct
dwoption
longopts
int
longindex
ifdef
__cplusplus
endif
__cplusplus
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
esb
h
Extensible
string
buffer
A
simple
vaguely
object
oriented
extensible
string
buffer
The
struct
could
be
opaque
here
but
it
seems
ok
to
expose
the
contents
simplifies
debugging
ifndef
ESB_H
define
ESB_H
include
config
h
include
stdio
h
include
stdarg
h
For
va_start
va_arg
va_list
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
exit
C89
malloc
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STRING_H
include
string
h
for
strchr
etc
endif
HAVE_STRING_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
If
esb_allocated_size
then
esb_string
points
to
esb_allocated_size
bytes
and
esb_used
bytes
esb_allocated_size
All
operations
that
insert
or
return
strings
ensure
first
that
esb_allocated_size
is
non
zero
and
the
requirements
here
are
met
In
esb_constructor
esb_allocated_size
and
esb_used_bytes
and
esb_string
are
set
No
malloc
done
Default
init
alloc
sets
esb_allocated_size
alloc_size
and
mallocs
alloc_size
bytes
and
esb_used_bytes
and
esb_string
NUL
struct
esb_s
char
esb_string
pointer
to
the
data
itself
or
NULL
size_t
esb_allocated_size
Size
of
allocated
data
or
The
allocated
size
must
include
the
trailing
NUL
as
we
do
insert
a
NUL
size_t
esb_used_bytes
Amount
of
space
used
or
which
does
not
include
the
trailing
NUL
Matches
what
strlen
esb_string
would
return
rigid
means
never
do
malloc
fixed
means
the
size
is
a
user
buffer
but
if
we
run
out
of
room
feel
free
to
malloc
space
and
then
unset
esb_fixed
An
esb
can
be
fixed
and
rigid
fixed
and
not
rigid
or
not
fixed
and
not
rigid
char
esb_fixed
char
esb_rigid
Mirroring
the
broken
code
in
libdwarf
h
in
typedef
long
long
esb_int
typedef
unsigned
long
long
esb_unsigned
Open
close
the
null
device
used
during
formatting
printing
FILE
esb_open_null_device
void
void
esb_close_null_device
void
string
length
taken
from
string
itself
void
esb_append
struct
esb_s
data
const
char
in_string
The
len
is
believed
Do
not
pass
in
strings
len
bytes
long
void
esb_appendn
struct
esb_s
data
const
char
in_string
size_t
len
Always
returns
an
empty
string
or
a
non
empty
string
Never
char
esb_get_string
struct
esb_s
data
Sets
esb_used_bytes
to
zero
The
string
is
not
freed
and
esb_allocated_size
is
unchanged
void
esb_empty_string
struct
esb_s
data
Return
esb_used_bytes
size_t
esb_string_len
struct
esb_s
data
The
following
are
for
testing
esb
not
use
by
dwarfdump
data
is
presumed
to
contain
garbage
not
values
and
is
properly
initialized
void
esb_constructor
struct
esb_s
data
void
esb_constructor_rigid
struct
esb_s
data
char
buf
size_t
buflen
void
esb_constructor_fixed
struct
esb_s
data
char
buf
size_t
buflen
void
esb_force_allocation
struct
esb_s
data
size_t
minlen
The
string
is
freed
contents
of
data
set
to
zeroes
void
esb_destructor
struct
esb_s
data
To
get
all
paths
in
the
code
tested
this
sets
the
allocation
reallocation
to
the
given
value
which
can
be
quite
small
but
must
not
be
zero
void
esb_alloc_size
size_t
size
size_t
esb_get_allocated_size
struct
esb_s
data
Append
a
formatted
string
void
esb_append_printf
struct
esb_s
data
const
char
format
void
esb_append_printf_s
struct
esb_s
data
const
char
format
const
char
s
void
esb_append_printf_i
struct
esb_s
data
const
char
format
esb_int
void
esb_append_printf_u
struct
esb_s
data
const
char
format
esb_unsigned
Get
a
copy
of
the
internal
data
buffer
char
esb_get_copy
struct
esb_s
data
ifdef
__cplusplus
endif
__cplusplus
endif
ESB_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
ESB_USING_FUNCTIONS_H
define
ESB_USING_FUNCTIONS_H
ifdef
__cplusplus
extern
C
endif
Always
returns
DW_DLV_OK
int
print_ranges_list_to_extra
Dwarf_Debug
dbg
Dwarf_Unsigned
originaloff
Dwarf_Unsigned
finaloff
Dwarf_Ranges
rangeset
Dwarf_Signed
rangecount
Dwarf_Unsigned
bytecount
struct
esb_s
stringbuf
int
get_producer_name
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Off
dieprint_cu_offset
struct
esb_s
producername
Dwarf_Error
err
int
get_attr_value
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Die
die
int
die_indent_level
Dwarf_Off
die_cu_offset
Dwarf_Attribute
attrib
char
srcfiles
Dwarf_Signed
cnt
struct
esb_s
esbp
int
show_form
int
local_verbose
Dwarf_Error
err
void
format_sig8_string
Dwarf_Sig8
data
struct
esb_s
out
int
dwarfdump_print_location_operations
Dwarf_Debug
dbg
Dwarf_Die
die
int
die_indent_level
Dwarf_Locdesc_c
locs
interface
Dwarf_Unsigned
llent
Which
locdesc
is
this
Dwarf_Unsigned
entrycount
count
of
DW_OP
operators
Dwarf_Small
lkind
int
no_ending_newlines
Dwarf_Addr
baseaddr
struct
esb_s
string_out
Dwarf_Error
err
void
get_true_section_name
Dwarf_Debug
dbg
const
char
standard_name
struct
esb_s
name_out
Dwarf_Bool
add_compr
ifdef
__cplusplus
endif
endif
ESi_USING_FUNCTIONS_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
GLFLAGS_H
define
GLFLAGS_H
All
the
dwarfdump
flags
are
gathered
into
a
single
global
struct
as
it
has
been
hard
to
know
how
many
there
were
or
what
they
were
all
for
struct
esb_s
struct
dwconf_s
enum
line_flag_type_e
singledw5
Meaning
choose
single
table
DWARF5
new
interfaces
s2l
Meaning
choose
two
level
DWARF5
new
interfaces
orig
Meaning
choose
DWARF2
single
level
interface
orig2l
Meaning
choose
DWARF
two
level
interface
Check
categories
corresponding
to
the
k
option
typedef
enum
Dwarf_Check_Categories
abbrev_code_result
pubname_attr_result
reloc_offset_result
attr_tag_result
tag_tree_result
type_offset_result
decl_file_result
ranges_result
lines_result
aranges_result
Harmless
errors
are
errors
detected
inside
libdwarf
but
not
reported
via
DW_DLE_ERROR
returns
because
the
errors
won
t
really
affect
client
code
The
harmless
errors
are
reported
and
otherwise
ignored
It
is
difficult
to
report
the
error
when
the
error
is
noticed
by
libdwarf
the
error
is
reported
at
a
later
time
The
other
errors
dwarfdump
reports
are
also
generally
harmless
but
are
detected
by
dwarfdump
so
it
s
possble
to
report
the
error
as
soon
as
the
error
is
discovered
harmless_result
fde_duplication
frames_result
locations_result
names_result
abbreviations_result
dwarf_constants_result
di_gaps_result
forward_decl_result
self_references_result
attr_encoding_result
duplicated_attributes_result
total_check_result
attr_formclass_result
LAST_CATEGORY
Must
be
last
Dwarf_Check_Categories
struct
section_high_offsets_s
Dwarf_Unsigned
debug_info_size
Dwarf_Unsigned
debug_abbrev_size
Dwarf_Unsigned
debug_line_size
Dwarf_Unsigned
debug_loc_size
Dwarf_Unsigned
debug_aranges_size
Dwarf_Unsigned
debug_macinfo_size
Dwarf_Unsigned
debug_pubnames_size
Dwarf_Unsigned
debug_str_size
Dwarf_Unsigned
debug_frame_size
Dwarf_Unsigned
debug_ranges_size
Dwarf_Unsigned
debug_pubtypes_size
Dwarf_Unsigned
debug_types_size
Dwarf_Unsigned
debug_macro_size
Dwarf_Unsigned
debug_str_offsets_size
Dwarf_Unsigned
debug_sup_size
Dwarf_Unsigned
debug_cu_index_size
Dwarf_Unsigned
debug_tu_index_size
Dwarf_Unsigned
debug_names_size
Dwarf_Unsigned
debug_loclists_size
Dwarf_Unsigned
debug_rnglists_size
Options
to
enable
debug
tracing
define
MAX_TRACE_LEVEL
struct
glflags_s
This
so
both
dwarf_loclist_n
and
dwarf_get_loclist_c
and
the
dwarf_loclist_from_expr
variations
can
be
tested
Defaults
to
new
dwarf_get_loclist_c
See
g
option
original
IRIX
dwarf_loclist
no
longer
tested
as
of
October
Dwarf_Bool
gf_use_old_dwarf_loclist
enum
line_flag_type_e
gf_line_flag_selection
Dwarf_Bool
gf_abbrev_flag
Dwarf_Bool
gf_aranges_flag
debug_aranges
section
Dwarf_Bool
gf_debug_names_flag
debug_names
section
Dwarf_Bool
gf_eh_frame_flag
GNU
eh_frame
section
Dwarf_Bool
gf_frame_flag
debug_frame
section
Dwarf_Bool
gf_gdbindex_flag
gdbindex
section
Dwarf_Bool
gf_gnu_debuglink_flag
gnu_debuglink
section
Dwarf_Bool
gf_debug_gnu_flag
debug_gnu_pubtypes
pubnames
Dwarf_Bool
gf_debug_sup_flag
debug_sup
Dwarf_Bool
gf_info_flag
debug_info
Dwarf_Bool
gf_line_flag
Dwarf_Bool
gf_no_follow_debuglink
Dwarf_Bool
gf_line_print_pc
Dwarf_Bool
gf_line_skeleton_flag
Dwarf_Bool
gf_loc_flag
Dwarf_Bool
gf_macinfo_flag
DWARF2
Old
macro
section
Dwarf_Bool
gf_macro_flag
DWARF5
Dwarf_Bool
gf_pubnames_flag
Dwarf_Bool
gf_ranges_flag
debug_ranges
section
Dwarf_Bool
gf_reloc_flag
Elf
relocations
not
DWARF
Dwarf_Bool
gf_static_func_flag
SGI
only
Dwarf_Bool
gf_static_var_flag
SGI
only
Dwarf_Bool
gf_string_flag
Dwarf_Bool
gf_pubtypes_flag
SGI
only
Dwarf_Bool
gf_types_flag
debug_types
not
all
CU
types
Dwarf_Bool
gf_weakname_flag
SGI
only
Dwarf_Bool
gf_header_flag
Control
printing
of
Elf
header
Dwarf_Bool
gf_section_groups_flag
Print
list
of
CUs
per
compiler
Dwarf_Bool
gf_producer_children_flag
Dwarf_Bool
gf_check_abbrev_code
Dwarf_Bool
gf_check_pubname_attr
Dwarf_Bool
gf_check_reloc_offset
Dwarf_Bool
gf_check_tag_attr
Dwarf_Bool
gf_check_tag_tree
Dwarf_Bool
gf_check_type_offset
Dwarf_Bool
gf_check_decl_file
Dwarf_Bool
gf_check_macros
Dwarf_Bool
gf_check_lines
Dwarf_Bool
gf_check_fdes
Dwarf_Bool
gf_check_ranges
Dwarf_Bool
gf_check_aranges
Dwarf_Bool
gf_check_harmless
Dwarf_Bool
gf_check_abbreviations
Dwarf_Bool
gf_check_dwarf_constants
Dwarf_Bool
gf_check_di_gaps
Dwarf_Bool
gf_check_forward_decl
Dwarf_Bool
gf_check_self_references
Dwarf_Bool
gf_check_attr_encoding
Attributes
encoding
Dwarf_Bool
gf_generic_1200_regs
Dwarf_Bool
gf_suppress_check_extensions_tables
Dwarf_Bool
gf_check_duplicated_attributes
lots
of
checks
make
no
sense
on
a
dwp
debugfission
object
Dwarf_Bool
gf_suppress_checking_on_dwp
suppress_nested_name_search
is
a
band
aid
A
workaround
A
real
fix
for
N
behavior
is
needed
Dwarf_Bool
gf_suppress_nested_name_search
Dwarf_Bool
gf_uri_options_translation
Dwarf_Bool
gf_do_print_uri_in_input
Print
global
unique
error
messages
Dwarf_Bool
gf_print_unique_errors
Dwarf_Bool
gf_found_error_message
Dwarf_Bool
gf_check_names
During
k
mode
display
errors
Dwarf_Bool
gf_check_verbose_mode
Dwarf_Bool
gf_check_frames
Dwarf_Bool
gf_check_frames_extended
Extensive
frames
check
Dwarf_Bool
gf_check_locations
Location
list
check
Dwarf_Bool
gf_print_usage_tag_attr
Print
basic
usage
Dwarf_Bool
gf_print_usage_tag_attr_full
Print
full
usage
Dwarf_Bool
gf_check_all_compilers
Dwarf_Bool
gf_check_snc_compiler
Check
SNC
compiler
Dwarf_Bool
gf_check_gcc_compiler
Dwarf_Bool
gf_print_summary_all
Dwarf_Bool
gf_file_use_no_libelf
The
check
and
print
flags
here
make
it
easy
to
allow
check
only
or
print
only
We
no
longer
support
check
and
print
in
a
single
run
Dwarf_Bool
gf_do_check_dwarf
Dwarf_Bool
gf_do_print_dwarf
Dwarf_Bool
gf_check_show_results
Display
checks
results
Dwarf_Bool
gf_record_dwarf_error
A
test
has
failed
this
is
normally
set
FALSE
shortly
after
being
set
TRUE
it
is
a
short
range
hint
we
should
print
something
we
might
not
otherwise
print
under
the
circumstances
Dwarf_Bool
gf_check_debug_names
Dwarf_Bool
gf_no_sanitize_strings
Display
parent
children
when
in
wide
format?
Dwarf_Bool
gf_display_parent_tree
Dwarf_Bool
gf_display_children_tree
int
gf_stop_indent_level
Searching
for
function
name
printing
frame
data
split
dwarf
lookup
by
address
or
die
if
non
zero
then
debug_addr
is
needed
but
missing
Tells
dwarfdump
to
only
search
by
address
locally
char
gf_debug_addr_missing
Other
error
in
lookup
by
address
or
by_die
int
gf_error_code_search_by_address
Avoid
some
unneccesary
work
lookup
by
address
char
gf_all_cus_seen_search_by_address
Die
indents
this
prefix
an
indent
count
instead
of
actual
spaces
int
gf_max_space_indent
End
searching
for
function
name
Print
search
results
in
wide
format?
Dwarf_Bool
gf_search_wide_format
S
option
strings
for
any
and
match
Dwarf_Bool
gf_search_is_on
Dwarf_Bool
gf_search_print_results
Dwarf_Bool
gf_cu_name_flag
Dwarf_Bool
gf_show_global_offsets
Dwarf_Bool
gf_display_offsets
Dwarf_Bool
gf_print_str_offsets
Dwarf_Bool
gf_expr_ops_joined
Dwarf_Bool
gf_print_raw_rnglists
Dwarf_Bool
gf_print_raw_loclists
unsigned
long
gf_count_major_errors
unsigned
long
gf_count_macronotes
char
gf_global_debuglink_paths
unsigned
gf_global_debuglink_count
Base
address
has
a
special
meaning
in
DWARF4
relative
to
address
ranges
Dwarf_Bool
seen_PU
Detected
a
PU
Dwarf_Bool
seen_CU
Detected
a
CU
Dwarf_Bool
need_CU_name
Need
CU
name
Dwarf_Bool
need_CU_base_address
Need
CU
Base
address
Dwarf_Bool
need_CU_high_address
Need
CU
High
address
Dwarf_Bool
need_PU_valid_code
Need
PU
valid
code
Dwarf_Bool
in_valid_code
set
reset
in
subprogram
and
compile
unit
DIES
Dwarf_Bool
seen_PU_base_address
Detected
a
Base
address
for
PU
Dwarf_Bool
seen_PU_high_address
Detected
a
High
address
for
PU
Dwarf_Addr
PU_base_address
PU
Base
address
Dwarf_Addr
PU_high_address
PU
High
address
Dwarf_Off
DIE_offset
DIE
offset
in
compile
unit
Dwarf_Off
DIE_overall_offset
DIE
offset
in
debug_info
These
globals
enable
better
error
reporting
Dwarf_Off
DIE_CU_offset
CU
DIE
offset
in
compile
unit
CU
DIE
offset
in
debug_info
Dwarf_Off
DIE_CU_overall_offset
int
current_section_id
Section
being
process
Base
Address
is
needed
for
range
lists
and
must
come
from
a
CU
Low
address
is
for
information
and
can
come
from
a
function
or
something
in
the
CU
Dwarf_Addr
CU_base_address
CU
Base
address
Dwarf_Addr
CU_low_address
CU
low
address
Dwarf_Addr
CU_high_address
CU
High
address
Dwarf_Off
fde_offset_for_cu_low
Dwarf_Off
fde_offset_for_cu_high
const
char
program_name
const
char
program_fullname
const
char
search_any_text
const
char
search_match_text
const
char
search_regex_text
int
search_occurrences
S
option
the
compiled_regex
ifdef
HAVE_REGEX
regex_t
search_re
endif
Start
verbose
at
zero
verbose
can
be
incremented
with
v
but
not
decremented
int
verbose
int
gf_show_dwarfdump_conf
Incremented
with
show
dwarfdump
conf
never
decremented
Dwarf_Bool
dense
Dwarf_Bool
ellipsis
Dwarf_Bool
show_form_used
break_after_n_units
is
mainly
for
testing
It
enables
easy
limiting
of
output
size
running
time
when
one
wants
the
output
limited
For
example
H
limits
the
i
output
to
compilation
units
and
the
f
or
F
output
to
FDEs
and
CIEs
int
break_after_n_units
struct
section_high_offsets_s
section_high_offsets_global
pRangesInfo
records
the
DW_AT_high_pc
and
DW_AT_low_pc
and
is
used
to
check
that
line
range
info
falls
inside
the
known
valid
ranges
The
data
is
per
CU
and
is
reset
per
CU
in
tag_specific_checks_setup
Bucket_Group
pRangesInfo
pLinkonceInfo
records
data
about
the
link
once
sections
If
a
line
range
is
not
valid
in
the
current
CU
it
might
be
valid
in
a
linkonce
section
this
data
records
the
linkonce
sections
So
it
is
filled
in
when
an
object
file
is
read
and
remains
unchanged
for
an
entire
object
file
Bucket_Group
pLinkonceInfo
pVisitedInfo
records
a
recursive
traversal
of
DIE
attributes
DW_AT_specification
DW_AT_abstract_origin
DW_AT_type
that
let
DWARF
refer
as
in
a
general
graph
to
arbitrary
other
DIEs
These
traversals
use
pVisitedInfo
to
detect
any
compiler
errors
that
introduce
circular
references
Printing
of
the
traversals
is
also
done
on
request
Entries
are
added
and
deleted
as
they
are
visited
in
a
depth
first
traversal
Bucket_Group
pVisitedInfo
Compilation
Unit
information
for
improved
error
messages
If
the
strings
are
too
short
we
just
truncate
so
fixed
length
here
is
fine
define
COMPILE_UNIT_NAME_LEN
char
PU_name
COMPILE_UNIT_NAME_LEN
PU
Name
char
CU_name
COMPILE_UNIT_NAME_LEN
CU
Name
char
CU_producer
COMPILE_UNIT_NAME_LEN
CU
Producer
Name
Options
to
enable
debug
tracing
int
nTrace
MAX_TRACE_LEVEL
Output
filename
const
char
output_file
int
group_number
Global
esb
buffers
struct
esb_s
newprogname
struct
esb_s
cu_name
struct
esb_s
config_file_path
struct
esb_s
config_file_tiedpath
struct
dwconf_s
config_file_data
Check
errors
int
check_error
int
gf_print_alloc_sums
extern
struct
glflags_s
glflags
void
init_global_flags
void
void
reset_global_flags
void
void
set_checks_off
void
void
reset_overall_CU_error_data
void
Dwarf_Bool
cu_data_is_set
void
Shortcuts
for
additional
trace
options
define
DUMP_OPTIONS
Dump
options
define
DUMP_RANGES_INFO
Dump
RangesInfo
Table
Dump
Location
debug_loc
Info
define
DUMP_LOCATION_SECTION_INFO
Dump
Ranges
debug_ranges
Info
define
DUMP_RANGES_SECTION_INFO
define
DUMP_LINKONCE_INFO
Dump
Linkonce
Table
define
DUMP_VISITED_INFO
Dump
Visited
Info
define
dump_options
glflags
nTrace
DUMP_OPTIONS
define
dump_ranges_info
glflags
nTrace
DUMP_RANGES_INFO
define
dump_location_section_info
glflags
nTrace
DUMP_LOCATION_SECTION_INFO
define
dump_ranges_section_info
glflags
nTrace
DUMP_RANGES_SECTION_INFO
define
dump_linkonce_info
glflags
nTrace
DUMP_LINKONCE_INFO
define
dump_visited_info
glflags
nTrace
DUMP_VISITED_INFO
Section
IDs
See
also
libdwarfp
pro_opaque
h
DEBUG_INFO
etc
as
we
arbitrarily
use
the
same
numbering
here
In
pro_opaque
the
numbering
matters
Here
it
helps
us
record
where
we
are
at
any
instant
It
s
not
necessary
they
match
but
seems
good
to
do
Here
we
have
some
extra
sections
not
related
to
relocations
so
we
just
add
those
beginning
with
define
DEBUG_INFO
define
DEBUG_LINE
define
DEBUG_ABBREV
define
DEBUG_FRAME
define
DEBUG_ARANGES
define
DEBUG_PUBNAMES
define
DEBUG_FUNCNAMES
define
DEBUG_TYPENAMES
define
DEBUG_VARNAMES
define
DEBUG_WEAKNAMES
define
DEBUG_MACINFO
DWARF
only
define
DEBUG_LOC
define
DEBUG_RANGES
define
DEBUG_TYPES
define
DEBUG_PUBTYPES
define
DEBUG_NAMES
DWARF5
aka
dnames
define
DEBUG_STR
define
DEBUG_LINE_STR
define
DEBUG_MACRO
DWARF
define
DEBUG_LOCLISTS
DWARF
define
DEBUG_RNGLISTS
DWARF
define
DEBUG_SUP
DWARF
define
DEBUG_GDB_INDEX
define
DEBUG_FRAME_EH_GNU
define
DEBUG_GNU_PUBNAMES
define
DEBUG_GNU_PUBTYPES
Print
the
information
only
if
unique
errors
is
set
and
it
is
first
time
define
PRINTING_UNIQUE
glflags
gf_found_error_message
endif
GLFLAGS_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
Portions
Copyright
SN
Systems
Ltd
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
globals_INCLUDED
define
globals_INCLUDED
ifdef
__cplusplus
extern
C
endif
include
config
h
define
DWARF_SECNAME_BUFFER_SIZE
define
ESB_FIXED_ALLOC_SIZE
include
stdio
h
ifdef
HAVE_STDLIB_H
include
stdlib
h
for
exit
C89
malloc
endif
HAVE_STDLIB_H
ifdef
HAVE_MALLOC_H
Useful
include
for
some
Windows
compilers
include
malloc
h
endif
HAVE_MALLOC_H
ifdef
HAVE_STRING_H
include
string
h
for
strchr
etc
endif
HAVE_STRING_H
Windows
specific
header
files
if
defined
_WIN32
defined
HAVE_STDAFX_H
include
stdafx
h
endif
HAVE_STDAFX_H
include
dwarf
h
include
libdwarf
h
include
libdwarf_private
h
ifdef
HAVE_REGEX
include
regex
h
endif
include
checkutil
h
include
defined_types
h
include
glflags
h
Used
to
avoid
leakage
when
we
hide
errors
Use
carefully
doing
err
when
you
mean
err
will
not
be
caught
by
the
compiler
and
will
not
do
what
one
wants
Using
err
when
err
is
correct
will
be
caught
by
the
compiler
You
are
warned
define
DROP_ERROR_INSTANCE
d
r
e
if
r
DW_DLV_ERROR
if
e
dwarf_dealloc_error
d
e
e
else
if
r
DW_DLV_OK
r
DW_DLV_NO_ENTRY
report_caller_error_drop_error
r
__LINE__
__FILE__
Version
returns
DW_AT_decl_file
differently
than
earlier
versions
define
DWVERSION4
define
DWVERSION5
FALSE
for
the
flags
means
off
define
LOHIPC_SAWADDR
define
LOHIPC_SAWOFFSET
struct
LoHiPc_s
Dwarf_Unsigned
lopc
hival
is
either
an
address
if
sawhi
LOHIPC_SAWADDR
or
an
offset
if
sawhi_flag
LOWHIPC_SAWOFFSET
or
zero
sawhi_flag
FALSE
Dwarf_Unsigned
hival
The
result
of
adding
lopc
to
hival
Dwarf_Unsigned
hifinal
non
zero
if
DW_AT_lowpc
seen
Dwarf_Small
sawlo_flag
non
zero
if
DW_AT_high_pc
seen
defaults
FALSE
otherwise
is
LOHIPC_SAWADDR
or
LOHIPC_SAWOFFSET
Dwarf_Small
sawhi_flag
If
non
zero
hifinal
is
set
to
the
hipc
address
Defaults
to
FALSE
Dwarf_Small
havefinal_flag
typedef
struct
LoHiPc_s
LoHiPc
Calculate
wasted
space
extern
void
calculate_attributes_usage
Dwarf_Half
attr
Dwarf_Half
theform
Dwarf_Unsigned
value
extern
Dwarf_Bool
is_strstrnocase
const
char
data
const
char
pattern
Process
TAGs
for
checking
mode
and
reset
pRangesInfo
table
if
appropriate
extern
void
tag_specific_globals_setup
Dwarf_Debug
dbg
Dwarf_Half
val
int
die_indent_level
extern
int
simple_err_return_msg_either_action
int
res
const
char
msg
extern
int
simple_err_return_action
int
res
const
char
msg
extern
int
simple_err_only_return_action
int
res
const
char
msg
extern
void
print_error_and_continue
Dwarf_Debug
dbg
const
char
msg
int
res
Dwarf_Error
err
extern
void
print_error
Dwarf_Debug
dbg
const
char
msg
int
res
Dwarf_Error
err
extern
int
print_line_numbers_this_cu
Dwarf_Debug
dbg
Dwarf_Die
in_die
char
srcfiles
Dwarf_Signed
cnt
Dwarf_Error
err
extern
int
print_frames
Dwarf_Debug
dbg
int
want_eh
struct
dwconf_s
Dwarf_Die
cu_die_for_current_frame
void
void
Dwarf_Error
extern
void
printreg
Dwarf_Unsigned
reg
struct
dwconf_s
config_data
extern
int
print_ranges
Dwarf_Debug
dbg
Dwarf_Error
err
extern
int
print_raw_all_rnglists
Dwarf_Debug
dbg
Dwarf_Error
err
extern
int
print_raw_all_loclists
Dwarf_Debug
dbg
Dwarf_Error
err
extern
int
print_pubnames
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_infos
Dwarf_Debug
dbg
Dwarf_Bool
is_info
Dwarf_Error
extern
int
print_abbrevs
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_strings
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_aranges
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_static_funcs
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_static_vars
Dwarf_Debug
dbg
Dwarf_Error
enum
type_type_e
SGI_TYPENAME
DWARF_PUBTYPES
extern
int
print_types
Dwarf_Debug
dbg
enum
type_type_e
type_type
Dwarf_Error
extern
int
print_weaknames
Dwarf_Debug
dbg
Dwarf_Error
extern
int
print_debug_names
Dwarf_Debug
dbg
Dwarf_Error
int
print_debug_sup
Dwarf_Debug
dbg
Dwarf_Error
error
int
print_all_abbrevs_for_cu
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Dwarf_Unsigned
abbrev_num_in
Dwarf_Unsigned
length_out
Dwarf_Unsigned
abbrev_num_out
Dwarf_Error
error
int
print_all_pubnames_style_records
Dwarf_Debug
dbg
const
char
linetitle
const
char
section_true_name
Dwarf_Global
globbuf
Dwarf_Signed
count
Dwarf_Error
err
Space
used
to
record
range
information
extern
void
allocate_range_array_info
void
extern
void
release_range_array_info
void
extern
void
record_range_array_info_entry
Dwarf_Off
die_off
Dwarf_Off
range_off
extern
int
check_range_array_info
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Error
int
should_skip_this_cu
Dwarf_Debug
dbg
Dwarf_Bool
Dwarf_Die
cu_die
int
get_address_size_and_max
Dwarf_Debug
dbg
Dwarf_Half
size
Dwarf_Addr
max
Dwarf_Error
err
Returns
the
producer
of
the
CU
int
get_cu_name
Dwarf_Debug
dbg
Dwarf_Die
cu_die
Dwarf_Off
dieprint_cu_offset
char
short_name
char
long_name
Dwarf_Error
err
Get
number
of
abbreviations
for
a
CU
extern
void
get_abbrev_array_info
Dwarf_Debug
dbg
Dwarf_Unsigned
offset
Validate
an
abbreviation
extern
void
validate_abbrev_code
Dwarf_Debug
dbg
Dwarf_Unsigned
abbrev_code
extern
int
print_one_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Off
dieprint_cu_offset
Dwarf_Bool
print_information
int
die_indent_level
char
srcfiles
Dwarf_Signed
cnt
Dwarf_Bool
an_attr_duplicated
Dwarf_Bool
ignore_die_stack
Dwarf_Error
err
Check
for
specific
compiler
extern
Dwarf_Bool
checking_this_compiler
void
extern
void
update_compiler_target
const
char
producer_name
extern
void
add_cu_name_compiler_target
char
name
General
error
reporting
routines
These
were
macros
for
a
short
time
and
when
changed
into
functions
they
kept
for
now
their
capitalization
The
capitalization
will
likely
change
extern
void
PRINT_CU_INFO
void
extern
void
DWARF_CHECK_COUNT
Dwarf_Check_Categories
category
int
inc
extern
void
DWARF_ERROR_COUNT
Dwarf_Check_Categories
category
int
inc
extern
void
DWARF_CHECK_ERROR_PRINT_CU
void
define
DWARF_CHECK_ERROR
c
d
DWARF_CHECK_ERROR3
c
d
define
DWARF_CHECK_ERROR2
c
d
e
DWARF_CHECK_ERROR3
c
d
e
extern
void
DWARF_CHECK_ERROR3
Dwarf_Check_Categories
category
const
char
str1
const
char
str2
const
char
strexpl
extern
int
print_macinfo_by_offset
Dwarf_Debug
dbg
Dwarf_Die
cudie
Dwarf_Unsigned
offset
Dwarf_Error
void
ranges_esb_string_destructor
void
void
destruct_abbrev_array
void
int
get_proc_name_by_die
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Addr
low_pc
struct
esb_s
proc_name
Dwarf_Die
cu_die_for_print_frames
void
pcMap
Dwarf_Error
err
extern
void
dump_block
char
prefix
char
data
Dwarf_Signed
len
extern
int
print_gdb_index
Dwarf_Debug
dbg
Dwarf_Error
err
extern
int
print_debugfission_index
Dwarf_Debug
dbg
const
char
type
Dwarf_Error
void
clean_up_die_esb
void
void
safe_strcpy
char
out
long
outlen
const
char
in
long
inlen
int
print_macros_5style_this_cu
Dwarf_Debug
dbg
Dwarf_Die
cu_die
char
srcfiles
Dwarf_Signed
cnt
int
do_print_dwarf
not
relying
on
gf_do_print_dwarf
here
int
descend_into_imports
TRUE
means
follow
imports
Dwarf_Bool
in_import_list
helps
make
print
readable
Dwarf_Unsigned
offset
Dwarf_Error
Detailed
attributes
encoding
space
int
print_attributes_encoding
Dwarf_Debug
dbg
Dwarf_Error
Detailed
tag
and
attributes
usage
int
print_tag_attributes_usage
void
void
record_tag_usage
int
tag
void
reset_usage_rate_tag_trees
void
int
print_section_groups_data
Dwarf_Debug
dbg
Dwarf_Error
void
update_section_flags_per_groups
Dwarf_Debug
dbg
void
groups_restore_subsidiary_flags
void
int
legal_tag_attr_combination
Dwarf_Half
tag
Dwarf_Half
attr
int
legal_tag_tree_combination
Dwarf_Half
parent_tag
Dwarf_Half
child_tag
int
print_str_offsets_section
Dwarf_Debug
dbg
Dwarf_Error
void
print_any_harmless_errors
Dwarf_Debug
dbg
void
print_secname
Dwarf_Debug
dbg
const
char
secname
void
report_caller_error_drop_error
int
dwdlv
int
line
char
filename
encoding_type_func
used
in
print_die
c
and
print_lopc_hipc_attr
c
typedef
const
char
encoding_type_func
unsigned
int
doprintingonerr
int
dd_get_integer_and_name
Dwarf_Debug
dbg
Dwarf_Attribute
attrib
Dwarf_Unsigned
uval_out
const
char
attr_name
struct
esb_s
string_out
encoding_type_func
val_as_string
Dwarf_Error
err
int
show_form
int
print_original_loclist_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
ebsp
Dwarf_Bool
bError
int
print_llex_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
ebsp
Dwarf_Bool
bError
int
print_debug_loclists_linecodes
Dwarf_Debug
dbg
Dwarf_Bool
checking
const
char
tagname
const
char
attrname
unsigned
int
llent
Dwarf_Small
lle_value
Dwarf_Addr
base_address
Dwarf_Addr
rawlopc
Dwarf_Addr
rawhipc
Dwarf_Bool
debug_addr_unavailable
Dwarf_Addr
lopc
Dwarf_Addr
hipc
Dwarf_Unsigned
locdesc_offset
struct
esb_s
ebsp
Dwarf_Bool
bError
void
loc_error_check
const
char
tagname
const
char
attrname
Dwarf_Addr
lopcfinal
Dwarf_Addr
rawlopc
Dwarf_Addr
hipcfinal
Dwarf_Addr
rawhipc
Dwarf_Unsigned
offset
Dwarf_Addr
base_address
Dwarf_Bool
bError
int
print_hipc_lopc_attribute
Dwarf_Debug
dbg
Dwarf_Half
tag
Dwarf_Die
die
int
die_indent_level
Dwarf_Unsigned
dieprint_cu_goffset
char
srcfiles
Dwarf_Signed
cnt
Dwarf_Attribute
attrib
Dwarf_Half
attr
Dwarf_Unsigned
max_address
LoHiPc
lohipc
struct
esb_s
valname
Dwarf_Error
err
ifdef
__cplusplus
endif
endif
globals_INCLUDED
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
HELPERTREE_H
define
HELPERTREE_H
This
is
a
tsearch
tree
interface
we
may
use
in
various
ways
where
each
different
sort
of
use
is
a
different
Helpertree_Base_s
instance
We
create
Helpertree_Base_s
so
we
can
use
type
checked
calls
not
showing
the
tsearch
void
outside
of
helpertree
c
struct
Helpertree_Base_s
void
hb_base
For
debug_info
extern
struct
Helpertree_Base_s
helpertree_offsets_base_info
For
debug_types
extern
struct
Helpertree_Base_s
helpertree_offsets_base_types
struct
Helpertree_Map_Entry_s
Key
is
offset
It
will
be
a
section
global
offset
so
applicable
across
an
entire
executable
object
section
Dwarf_Unsigned
hm_key
val
is
something
defined
differently
in
different
uses
for
integer
type
it
is
means
unknown
known
signed
known
unsigned
int
hm_val
Add
fields
here
as
needed
Add
entry
or
set
to
known
signed
or
known
unsigned
struct
Helpertree_Map_Entry_s
helpertree_add_entry
Dwarf_Unsigned
offset
int
val
struct
Helpertree_Base_s
helper
Look
for
entry
Use
hm_val
if
non
null
return
to
determine
signedness
struct
Helpertree_Map_Entry_s
helpertree_find
Dwarf_Unsigned
offset
struct
Helpertree_Base_s
helper
void
helpertree_clear_statistics
struct
Helpertree_Base_s
helper
endif
HELPERTREE_H
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
MACROCHECK_H
define
MACROCHECK_H
tsearch
trees
used
in
macro
checking
extern
void
macro_check_tree
DWARF5
macros
extern
void
macinfo_check_tree
DWARF2
macros
extern
void
macdefundeftree
DWARF5
style
macros
struct
Macrocheck_Map_Entry_s
Dwarf_Unsigned
mp_key
Key
is
offset
Dwarf_Unsigned
mp_len
len
in
bytes
off
this
macro
set
We
count
number
of
uses
More
than
primary
is
an
error
Both
primary
and
secondary
is
ok
or
error?
Dwarf_Unsigned
mp_refcount_primary
Dwarf_Unsigned
mp_refcount_secondary
Dwarf_Unsigned
mp_import_linenum
unsigned
mp_import_from_filenum
So
we
go
through
each
one
just
once
Dwarf_Bool
mp_printed
for
def
undef
checking
struct
macdef_entry_s
char
md_key
Tacked
on
this
record
Do
not
free
unsigned
md_operatornum
unsigned
int
md_defined
unsigned
int
md_undefined
unsigned
int
md_defcount
unsigned
int
md_undefcount
unsigned
md_operator
Dwarf_Unsigned
md_line
Dwarf_Unsigned
md_offset
Dwarf_Unsigned
md_macro_unit_offset
char
md_string
see
create
entry
Do
not
free
unsigned
md_file_array_entry
typedef
struct
macdef_entry_s
macdef_entry
for
start
file
end
file
checking
struct
macfile_entry_s
unsigned
ms_operatornum
unsigned
ms_operator
Dwarf_Unsigned
ms_line
Dwarf_Unsigned
ms_filenum
Dwarf_Unsigned
ms_offset
Dwarf_Unsigned
ms_macro_unit_offset
unsigned
ms_array_number
position
in
macfile_array
char
ms_filename
typedef
struct
macfile_entry_s
macfile_entry
define
MACFILE_STACK_DEPTH_MAX
Arbitrary
Make
bigger?
extern
unsigned
macfile_stack_next_to_use
extern
unsigned
macfile_stack
MACFILE_STACK_DEPTH_MAX
extern
unsigned
macfile_stack_max_seen
define
MACRO_IMPORT_STACK_DEPTH
Arbitrary
Make
bigger?
extern
Dwarf_Unsigned
macro_import_stack
MACRO_IMPORT_STACK_DEPTH
extern
unsigned
macro_import_stack_next_to_use
extern
unsigned
macro_import_stack_max_seen
Returns
DW_DLV_ERROR
if
the
push
could
not
done
which
would
be
because
full
Else
returns
DW_DLV_OK
int
macro_import_stack_push
Dwarf_Unsigned
offset
Returns
DW_DLV_ERROR
if
the
pop
could
not
done
else
returns
DW_DLV_OK
int
macro_import_stack_pop
void
Returns
DW_DLV_OK
if
offset
is
in
the
stack
or
DW_DLV_NO_ENTRY
if
it
is
not
in
the
stack
int
macro_import_stack_present
Dwarf_Unsigned
offset
void
macro_import_stack_cleanout
void
void
print_macro_import_stack
void
struct
Macrocheck_Map_Entry_s
macrocheck_map_find
Dwarf_Unsigned
offset
void
map
void
add_macro_import
void
base
Dwarf_Bool
is_primary
Dwarf_Unsigned
offset
Dwarf_Unsigned
linenum
unsigned
mafile_file_number
void
add_macro_import_sup
void
base
Dwarf_Unsigned
offset
void
add_macro_area_len
void
base
Dwarf_Unsigned
offset
Dwarf_Unsigned
len
int
get_next_unprinted_macro_offset
void
base
Dwarf_Unsigned
off
void
mark_macro_offset_printed
void
base
Dwarf_Unsigned
offset
int
print_macrocheck_statistics
const
char
name
void
basep
int
isdwarf5
Dwarf_Unsigned
section_size
Dwarf_Error
err
void
clear_macrocheck_statistics
void
basep
macfile_entry
macfile_from_array_index
unsigned
index
endif
MACROCHECK_H
ifndef
names_h
define
names_h
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
makename
h
This
is
for
putting
strings
into
stable
storage
Effectively
an
strdup
wrapper
Rarely
called
It
leaks
memory
the
memory
is
never
freed
but
that
seems
unimportant
since
use
of
this
is
very
rare
ifdef
__cplusplus
extern
C
endif
__cplusplus
char
makename
const
char
Makes
a
copy
of
the
string
in
a
malloc
area
Can
never
return
Destroy
all
makename
data
Do
just
before
exit
void
makename_destructor
void
ifdef
__cplusplus
endif
__cplusplus
endif
MAKENAME_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
naming
h
ifndef
NAMING_H_INCLUDED
define
NAMING_H_INCLUDED
ifdef
__cplusplus
extern
C
endif
extern
const
char
get_FORM_CLASS_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_TAG_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_children_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_FORM_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_AT_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_OP_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ATE_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_DS_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_END_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ATCF_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ACCESS_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_VIS_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_VIRTUALITY_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_LANG_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ID_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_CC_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_INL_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ORD_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_DSC_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_LNS_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_LNE_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_MACINFO_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_MACRO_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_CFA_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_EH_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_FRAME_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_CHILDREN_name
unsigned
int
val_in
int
printonerr
extern
const
char
get_ADDR_name
unsigned
int
val_in
int
printonerr
ifdef
__cplusplus
endif
endif
NAMING_H_INCLUDED
Copyright
c
David
Anderson
All
rights
reserved
This
software
file
is
hereby
placed
in
the
public
domain
For
use
by
anyone
for
any
purpose
opscounttab
h
struct
dwarf_opscounttab_s
signed
char
oc_opcount
define
DWOPS_ARRAY_SIZE
extern
struct
dwarf_opscounttab_s
dwarf_opscounttab
DWOPS_ARRAY_SIZE
Copyright
C
David
Anderson
All
Rights
Reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
To
print
debug_gnu_pubnames
debug_gnu_typenames
int
print_debug_gnu
Dwarf_Debug
dbg
Dwarf_Error
error
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
PRINT_FRAMES_H
define
PRINT_FRAMES_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
int
print_one_cie
Dwarf_Debug
dbg
Dwarf_Die
die
Dwarf_Cie
cie
Dwarf_Unsigned
cie_index
Dwarf_Half
address_size
struct
dwconf_s
config_data
Dwarf_Error
err
int
print_location_operations
Dwarf_Debug
dbg
Dwarf_Die
die
int
die_indent_level
Dwarf_Ptr
bytes_in
Dwarf_Unsigned
block_len
Dwarf_Half
addr_size
Dwarf_Half
offset_size
Dwarf_Half
version
struct
esb_s
out_string
Dwarf_Error
err
ifdef
__cplusplus
endif
__cplusplus
endif
PRINT_FRAMES_H
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
PRINT_SECTIONS_H
define
PRINT_SECTIONS_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
extern
int
dwarf_names_print_on_error
Dwarf_Unsigned
get_info_max_offset
Dwarf_Debug
dbg
ifdef
__cplusplus
endif
__cplusplus
endif
PRINT_SECTIONS_H
Copyright
c
David
Anderson
All
rights
reserved
Redistribution
and
use
in
source
and
binary
forms
with
or
without
modification
are
permitted
provided
that
the
following
conditions
are
met
Redistributions
of
source
code
must
retain
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
Redistributions
in
binary
form
must
reproduce
the
above
copyright
notice
this
list
of
conditions
and
the
following
disclaimer
in
the
documentation
and
or
other
materials
provided
with
the
distribution
THIS
SOFTWARE
IS
PROVIDED
BY
THE
COPYRIGHT
HOLDERS
AND
CONTRIBUTORS
AS
IS
AND
ANY
EXPRESS
OR
IMPLIED
WARRANTIES
INCLUDING
BUT
NOT
LIMITED
TO
THE
IMPLIED
WARRANTIES
OF
MERCHANTABILITY
AND
FITNESS
FOR
A
PARTICULAR
PURPOSE
ARE
DISCLAIMED
IN
NO
EVENT
SHALL
THE
COPYRIGHT
HOLDER
OR
CONTRIBUTORS
BE
LIABLE
FOR
ANY
DIRECT
INDIRECT
INCIDENTAL
SPECIAL
EXEMPLARY
OR
CONSEQUENTIAL
DAMAGES
INCLUDING
BUT
NOT
LIMITED
TO
PROCUREMENT
OF
SUBSTITUTE
GOODS
OR
SERVICES
LOSS
OF
USE
DATA
OR
PROFITS
OR
BUSINESS
INTERRUPTION
HOWEVER
CAUSED
AND
ON
ANY
THEORY
OF
LIABILITY
WHETHER
IN
CONTRACT
STRICT
LIABILITY
OR
TORT
INCLUDING
NEGLIGENCE
OR
OTHERWISE
ARISING
IN
ANY
WAY
OUT
OF
THE
USE
OF
THIS
SOFTWARE
EVEN
IF
ADVISED
OF
THE
POSSIBILITY
OF
SUCH
DAMAGE
ifndef
SANITIZED_H
define
SANITIZED_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
Eliminate
control
characters
from
the
input
leaving
the
input
unchanged
Return
pointer
to
an
ephemeral
location
only
callfor
printf
and
only
once
per
printf
const
char
sanitized
const
char
s
void
sanitized_string_destructor
void
ifdef
__cplusplus
endif
__cplusplus
endif
SANITIZED_H
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
SECTION_BITMAPS_H_INCLUDED
define
SECTION_BITMAPS_H_INCLUDED
section_bitmaps
h
and
c
actually
involved
bits
bit
shifting
and
bit
masks
but
now
the
maps
are
simple
byte
arrays
See
reloc_map
and
section_map
in
dwarfdump
c
Value
is
one
of
the
DW_HDR_DEBUG_
names
struct
section_map_s
const
char
name
unsigned
value
extern
struct
section_map_s
map_sectnames
define
DW_HDR_DEBUG_INFO
define
DW_HDR_DEBUG_INFO_DWO
define
DW_HDR_DEBUG_LINE
define
DW_HDR_DEBUG_LINE_DWO
define
DW_HDR_DEBUG_PUBNAMES
define
DW_HDR_DEBUG_ABBREV
define
DW_HDR_DEBUG_ABBREV_DWO
define
DW_HDR_DEBUG_ARANGES
define
DW_HDR_DEBUG_FRAME
define
DW_HDR_DEBUG_LOC
define
DW_HDR_DEBUG_LOCLISTS
define
DW_HDR_DEBUG_LOCLISTS_DWO
define
DW_HDR_DEBUG_RANGES
define
DW_HDR_DEBUG_RNGLISTS
define
DW_HDR_DEBUG_RNGLISTS_DWO
define
DW_HDR_DEBUG_STR
define
DW_HDR_DEBUG_STR_DWO
define
DW_HDR_DEBUG_STR_OFFSETS
define
DW_HDR_DEBUG_STR_OFFSETS_DWO
define
DW_HDR_DEBUG_PUBTYPES
define
DW_HDR_DEBUG_TYPES
define
DW_HDR_TEXT
define
DW_HDR_GDB_INDEX
define
DW_HDR_EH_FRAME
define
DW_HDR_DEBUG_MACINFO
define
DW_HDR_DEBUG_MACRO
define
DW_HDR_DEBUG_MACRO_DWO
define
DW_HDR_DEBUG_NAMES
define
DW_HDR_DEBUG_CU_INDEX
define
DW_HDR_DEBUG_TU_INDEX
define
DW_HDR_HEADER
define
DW_HDR_ARRAY_SIZE
Debug
section
names
to
be
included
in
printing
define
DW_SECTNAME_DEBUG_INFO
debug_info
define
DW_SECTNAME_DEBUG_INFO_DWO
debug_info
dwo
define
DW_SECTNAME_DEBUG_LINE
debug_line
define
DW_SECTNAME_DEBUG_LINE_DWO
debug_line
dwo
define
DW_SECTNAME_DEBUG_PUBNAMES
debug_pubnames
define
DW_SECTNAME_DEBUG_ABBREV
debug_abbrev
define
DW_SECTNAME_DEBUG_ABBREV_DWO
debug_abbrev
dwo
define
DW_SECTNAME_DEBUG_ARANGES
debug_aranges
define
DW_SECTNAME_DEBUG_FRAME
debug_frame
define
DW_SECTNAME_DEBUG_LOC
debug_loc
define
DW_SECTNAME_DEBUG_LOCLISTS
debug_loclists
define
DW_SECTNAME_DEBUG_LOCLISTS_DWO
debug_loclists
dwo
define
DW_SECTNAME_DEBUG_RANGES
debug_ranges
define
DW_SECTNAME_DEBUG_RNGLISTS
debug_rnglists
define
DW_SECTNAME_DEBUG_RNGLISTS_DWO
debug_rnglists
dwo
define
DW_SECTNAME_DEBUG_STR
debug_str
define
DW_SECTNAME_DEBUG_STR_DWO
debug_str
dwo
define
DW_SECTNAME_DEBUG_STR_OFFSETS
debug_str_offsets
define
DW_SECTNAME_DEBUG_STR_OFFSETS_DWO
debug_str_offsets
dwo
obsolete
SGI
only
section
was
debug_typenames
define
DW_SECTNAME_DEBUG_PUBTYPES
debug_pubtypes
define
DW_SECTNAME_DEBUG_TYPES
debug_types
define
DW_SECTNAME_TEXT
text
define
DW_SECTNAME_GDB_INDEX
gdb_index
define
DW_SECTNAME_EH_FRAME
eh_frame
define
DW_SECTNAME_DEBUG_SUP
debug_sup
define
DW_SECTNAME_DEBUG_MACINFO
debug_macinfo
define
DW_SECTNAME_DEBUG_MACRO
debug_macro
define
DW_SECTNAME_DEBUG_MACRO_DWO
debug_macro
dwo
define
DW_SECTNAME_DEBUG_NAMES
debug_names
define
DW_SECTNAME_DEBUG_CU_INDEX
debug_cu_index
define
DW_SECTNAME_DEBUG_TU_INDEX
debug_tu_index
Definitions
for
printing
relocations
define
DW_SECTION_REL_DEBUG_INFO
define
DW_SECTION_REL_DEBUG_LINE
define
DW_SECTION_REL_DEBUG_PUBNAMES
define
DW_SECTION_REL_DEBUG_ABBREV
define
DW_SECTION_REL_DEBUG_ARANGES
define
DW_SECTION_REL_DEBUG_FRAME
define
DW_SECTION_REL_DEBUG_LOC
define
DW_SECTION_REL_DEBUG_LOCLISTS
define
DW_SECTION_REL_DEBUG_RANGES
define
DW_SECTION_REL_DEBUG_RNGLISTS
define
DW_SECTION_REL_DEBUG_TYPES
define
DW_SECTION_REL_DEBUG_STR_OFFSETS
define
DW_SECTION_REL_DEBUG_PUBTYPES
define
DW_SECTION_REL_GDB_INDEX
define
DW_SECTION_REL_EH_FRAME
define
DW_SECTION_REL_DEBUG_SUP
define
DW_SECTION_REL_DEBUG_MACINFO
define
DW_SECTION_REL_DEBUG_MACRO
define
DW_SECTION_REL_DEBUG_NAMES
define
DW_SECTION_REL_ARRAY_SIZE
define
DW_SECTNAME_RELA_DEBUG_INFO
rela
debug_info
define
DW_SECTNAME_RELA_DEBUG_LINE
rela
debug_line
define
DW_SECTNAME_RELA_DEBUG_PUBNAMES
rela
debug_pubnames
define
DW_SECTNAME_RELA_DEBUG_ABBREV
rela
debug_abbrev
define
DW_SECTNAME_RELA_DEBUG_ARANGES
rela
debug_aranges
define
DW_SECTNAME_RELA_DEBUG_FRAME
rela
debug_frame
define
DW_SECTNAME_RELA_DEBUG_LOC
rela
debug_loc
define
DW_SECTNAME_RELA_DEBUG_LOCLISTS
rela
debug_loclists
define
DW_SECTNAME_RELA_DEBUG_RANGES
rela
debug_ranges
define
DW_SECTNAME_RELA_DEBUG_RNGLISTS
rela
debug_rnglists
define
DW_SECTNAME_RELA_DEBUG_TYPES
rela
debug_types
define
DW_SECTNAME_RELA_DEBUG_STR_OFFSETS
rela
debug_str_offsets
define
DW_SECTNAME_RELA_DEBUG_PUBTYPES
rela
debug_pubtypes
define
DW_SECTNAME_RELA_GDB_INDEX
rela
debug_gdb_index
define
DW_SECTNAME_RELA_EH_FRAME
rela
eh_frame
define
DW_SECTNAME_RELA_DEBUG_SUP
rela
debug_sup
define
DW_SECTNAME_RELA_DEBUG_MACINFO
rela
debug_macinfo
define
DW_SECTNAME_RELA_DEBUG_MACRO
rela
debug_macro
define
DW_SECTNAME_RELA_DEBUG_NAMES
rela
debug_names
define
DW_SECTNAME_REL_DEBUG_INFO
rel
debug_info
define
DW_SECTNAME_REL_DEBUG_LINE
rel
debug_line
define
DW_SECTNAME_REL_DEBUG_PUBNAMES
rel
debug_pubnames
define
DW_SECTNAME_REL_DEBUG_ABBREV
rel
debug_abbrev
define
DW_SECTNAME_REL_DEBUG_ARANGES
rel
debug_aranges
define
DW_SECTNAME_REL_DEBUG_FRAME
rel
debug_frame
define
DW_SECTNAME_REL_DEBUG_LOC
rel
debug_loc
define
DW_SECTNAME_REL_DEBUG_LOCLISTS
rel
debug_loclists
define
DW_SECTNAME_REL_DEBUG_RANGES
rel
debug_ranges
define
DW_SECTNAME_REL_DEBUG_RNGLISTS
rel
debug_rnglists
define
DW_SECTNAME_REL_DEBUG_TYPES
rel
debug_types
define
DW_SECTNAME_REL_DEBUG_STR_OFFSETS
rel
debug_str_offsets
define
DW_SECTNAME_REL_DEBUG_PUBTYPES
rel
debug_pubtypes
define
DW_SECTNAME_REL_GDB_INDEX
rel
debug_gdb_index
define
DW_SECTNAME_REL_EH_FRAME
rel
eh_frame
define
DW_SECTNAME_REL_DEBUG_SUP
rel
debug_sup
define
DW_SECTNAME_REL_DEBUG_MACINFO
rel
debug_macinfo
define
DW_SECTNAME_REL_DEBUG_MACRO
rel
debug_macro
define
DW_SECTNAME_REL_DEBUG_NAMES
rel
debug_names
Dwarf_Bool
section_name_is_debug_and_wanted
const
char
section_name
unsigned
section_bitmap_array_size
void
void
set_all_section_defaults
void
Dwarf_Bool
any_section_header_to_print
void
void
enable_section_map_entry
unsigned
index
Dwarf_Bool
section_map_enabled
unsigned
index
void
set_all_sections_on
void
void
enable_reloc_map_entry
unsigned
index
Dwarf_Bool
reloc_map_enabled
unsigned
index
void
set_all_reloc_sections_on
void
endif
SECTION_BITMAPS_H_INCLUDED
Copyright
C
Silicon
Graphics
Inc
All
Rights
Reserved
Portions
Copyright
C
SN
Systems
Ltd
All
Rights
Reserved
Portions
Copyright
C
David
Anderson
All
Rights
Reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
tag_common_INCLUDED
define
tag_common_INCLUDED
The
following
is
the
magic
token
used
to
distinguish
real
tags
attrs
from
group
delimiters
Blank
lines
have
been
eliminated
by
an
awk
script
define
MAGIC_TOKEN_VALUE
These
next
two
should
match
the
last
DW_TAG
and
last
DW_AT
in
the
standard
set
from
dwarf
h
define
DW_TAG_last
define
DW_AT_last
TAG_TREE
LIST
Expected
input
format
value
of
a
tag
value
of
a
standard
tag
that
may
be
a
child
of
that
tag
value
of
a
tag
value
of
a
standard
tag
that
may
be
a
child
of
that
tag
No
blank
lines
or
commentary
allowed
no
symbols
just
numbers
TAG_ATTR
LIST
Expected
input
format
value
of
a
tag
value
of
a
standard
attribute
that
follows
that
tag
value
of
a
tag
value
of
a
standard
attribute
that
follows
that
tag
No
blank
lines
or
commentary
allowed
no
symbols
just
numbers
We
don
t
need
really
long
lines
the
input
file
is
simple
define
MAX_LINE_SIZE
more
than
the
highest
number
in
the
DW_TAG
defines
this
is
for
standard
TAGs
Number
of
rows
define
STD_TAG_TABLE_ROWS
Enough
entries
to
have
a
bit
for
each
standard
legal
tag
define
STD_TAG_TABLE_COLUMNS
TAG
tree
common
extension
maximums
define
EXT_TAG_TABLE_ROWS
define
EXT_TAG_TABLE_COLS
The
following
used
in
tag_tree
c
only
They
must
be
large
enough
but
they
are
only
used
declaring
array
during
build
not
compiled
into
dwarfdump
so
if
a
bit
too
large
there
is
no
side
effect
on
anything
define
TAG_TABLE_ROW_MAXIMUM
define
TAG_TABLE_COLUMN_MAXIMUM
Number
of
attributes
columns
per
tag
The
array
is
bit
fields
BITS_PER_WORD
fields
per
word
Dense
and
quick
to
inspect
define
COUNT_ATTRIBUTE_STD
define
STD_ATTR_TABLE_ROWS
define
STD_ATTR_TABLE_COLUMNS
tag
attr
tree
common
extension
maximums
define
EXT_ATTR_TABLE_ROWS
define
EXT_ATTR_TABLE_COLS
The
following
used
in
tag_attr
c
only
They
must
be
large
enough
but
they
are
only
used
declaring
an
array
during
build
not
compiled
into
dwarfdump
so
if
a
bit
too
large
there
is
no
side
effect
on
anything
define
ATTR_TABLE_ROW_MAXIMUM
define
ATTR_TABLE_COLUMN_MAXIMUM
Bits
per
int
to
mark
legal
attrs
define
BITS_PER_WORD
define
IS_EOF
define
NOT_EOF
extern
void
bad_line_input
char
format
extern
void
trim_newline
char
line
int
max
extern
Dwarf_Bool
is_blank_line
char
pLine
extern
int
read_value
unsigned
int
outval
FILE
f
Define
to
to
support
the
generation
of
tag
attr
usage
define
HAVE_USAGE_TAG_ATTR
Define
to
to
support
the
generation
of
attr
formclass
usage
define
HAVE_USAGE_ATTR_FORMCLASS
endif
tag_common_INCLUDED
Copyright
David
Anderson
All
rights
reserved
This
program
is
free
software
you
can
redistribute
it
and
or
modify
it
under
the
terms
of
version
of
the
GNU
General
Public
License
as
published
by
the
Free
Software
Foundation
This
program
is
distributed
in
the
hope
that
it
would
be
useful
but
WITHOUT
ANY
WARRANTY
without
even
the
implied
warranty
of
MERCHANTABILITY
or
FITNESS
FOR
A
PARTICULAR
PURPOSE
Further
this
software
is
distributed
without
any
warranty
that
it
is
free
of
the
rightful
claim
of
any
third
person
regarding
infringement
or
the
like
Any
license
provided
herein
whether
implied
or
otherwise
applies
only
to
this
software
file
Patent
licenses
if
any
provided
herein
do
not
apply
to
combinations
of
this
program
with
other
software
or
any
other
product
whatsoever
You
should
have
received
a
copy
of
the
GNU
General
Public
License
along
with
this
program
if
not
write
the
Free
Software
Foundation
Inc
Franklin
Street
Fifth
Floor
Boston
MA
USA
ifndef
URI_H
define
URI_H
ifdef
__cplusplus
extern
C
endif
__cplusplus
void
translate_to_uri
const
char
filename
struct
esb_s
out
void
translate_from_uri
const
char
input
struct
esb_s
out
ifdef
__cplusplus
endif
__cplusplus
endif
URI_H
